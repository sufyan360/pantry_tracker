"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/analytics/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalytics: () => (/* binding */ getAnalytics),\n/* harmony export */   getGoogleAnalyticsClientId: () => (/* binding */ getGoogleAnalyticsClientId),\n/* harmony export */   initializeAnalytics: () => (/* binding */ initializeAnalytics),\n/* harmony export */   isSupported: () => (/* binding */ isSupported),\n/* harmony export */   logEvent: () => (/* binding */ logEvent),\n/* harmony export */   setAnalyticsCollectionEnabled: () => (/* binding */ setAnalyticsCollectionEnabled),\n/* harmony export */   setConsent: () => (/* binding */ setConsent),\n/* harmony export */   setCurrentScreen: () => (/* binding */ setCurrentScreen),\n/* harmony export */   setDefaultEventParameters: () => (/* binding */ setDefaultEventParameters),\n/* harmony export */   setUserId: () => (/* binding */ setUserId),\n/* harmony export */   setUserProperties: () => (/* binding */ setUserProperties),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var safevalues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! safevalues */ \"(ssr)/./node_modules/safevalues/dist/mjs/index.js\");\n/* harmony import */ var safevalues_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! safevalues/dom */ \"(ssr)/./node_modules/safevalues/dist/mjs/dom/index.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_installations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @firebase/installations */ \"(ssr)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Analytics.\r\n */\r\nconst ANALYTICS_TYPE = 'analytics';\r\n// Key to attach FID to in gtag params.\r\nconst GA_FID_KEY = 'firebase_id';\r\nconst ORIGIN_KEY = 'origin';\r\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\r\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\r\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/analytics');\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\r\nfunction promiseAllSettled(promises) {\r\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\r\n}\r\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction insertScriptTag(dataLayerName, measurementId) {\r\n    const script = document.createElement('script');\r\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\r\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\r\n    //\r\n    // We also have to ensure the template string before the first expression constitutes a valid URL\r\n    // start, as this is what the initial validation focuses on. If the template literal begins\r\n    // directly with an expression (e.g. `${GTAG_SCRIPT_URL}`), the validation fails due to an\r\n    // empty initial string.\r\n    const url = (0,safevalues__WEBPACK_IMPORTED_MODULE_2__.trustedResourceUrl) `https://www.googletagmanager.com/gtag/js?l=${dataLayerName}&id=${measurementId}`;\r\n    safevalues_dom__WEBPACK_IMPORTED_MODULE_3__.safeScriptEl.setSrc(script, url);\r\n    script.async = true;\r\n    document.head.appendChild(script);\r\n}\r\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction getOrCreateDataLayer(dataLayerName) {\r\n    // Check for existing dataLayer and create if needed.\r\n    let dataLayer = [];\r\n    if (Array.isArray(window[dataLayerName])) {\r\n        dataLayer = window[dataLayerName];\r\n    }\r\n    else {\r\n        window[dataLayerName] = dataLayer;\r\n    }\r\n    return dataLayer;\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\r\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\r\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\r\n    /// are waiting for, and wait only on that one.\r\n    const correspondingAppId = measurementIdToAppId[measurementId];\r\n    try {\r\n        if (correspondingAppId) {\r\n            await initializationPromisesMap[correspondingAppId];\r\n        }\r\n        else {\r\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\r\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\r\n            // that appId's initialization promise. If there is none, promise resolves and gtag\r\n            // call goes through.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\r\n            if (foundConfig) {\r\n                await initializationPromisesMap[foundConfig.appId];\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, measurementId, gtagParams);\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\r\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\r\n    try {\r\n        let initializationPromisesToWaitFor = [];\r\n        // If there's a 'send_to' param, check if any ID specified matches\r\n        // an initializeIds() promise we are waiting for.\r\n        if (gtagParams && gtagParams['send_to']) {\r\n            let gaSendToList = gtagParams['send_to'];\r\n            // Make it an array if is isn't, so it can be dealt with the same way.\r\n            if (!Array.isArray(gaSendToList)) {\r\n                gaSendToList = [gaSendToList];\r\n            }\r\n            // Checking 'send_to' fields requires having all measurement ID results back from\r\n            // the dynamic config fetch.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            for (const sendToId of gaSendToList) {\r\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\r\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\r\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\r\n                if (initializationPromise) {\r\n                    initializationPromisesToWaitFor.push(initializationPromise);\r\n                }\r\n                else {\r\n                    // Found an item in 'send_to' that is not associated\r\n                    // directly with an FID, possibly a group.  Empty this array,\r\n                    // exit the loop early, and let it get populated below.\r\n                    initializationPromisesToWaitFor = [];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // This will be unpopulated if there was no 'send_to' field , or\r\n        // if not all entries in the 'send_to' field could be mapped to\r\n        // a FID. In these cases, wait on all pending initialization promises.\r\n        if (initializationPromisesToWaitFor.length === 0) {\r\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\r\n        }\r\n        // Run core gtag function with args after all relevant initialization\r\n        // promises have been resolved.\r\n        await Promise.all(initializationPromisesToWaitFor);\r\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\r\n        gtagCore(\"event\" /* GtagCommand.EVENT */, measurementId, gtagParams || {});\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n}\r\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\r\nfunction wrapGtag(gtagCore, \r\n/**\r\n * Allows wrapped gtag calls to wait on whichever intialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\r\ninitializationPromisesMap, \r\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\r\ndynamicConfigPromisesList, \r\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\r\nmeasurementIdToAppId) {\r\n    /**\r\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n     * @param command Gtag command type.\r\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n     * @param gtagParams Params if event is EVENT/CONFIG.\r\n     */\r\n    async function gtagWrapper(command, ...args) {\r\n        try {\r\n            // If event, check that relevant initialization promises have completed.\r\n            if (command === \"event\" /* GtagCommand.EVENT */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If EVENT, second arg must be measurementId.\r\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"config\" /* GtagCommand.CONFIG */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If CONFIG, second arg must be measurementId.\r\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"consent\" /* GtagCommand.CONSENT */) {\r\n                const [consentAction, gtagParams] = args;\r\n                // consentAction can be one of 'default' or 'update'.\r\n                gtagCore(\"consent\" /* GtagCommand.CONSENT */, consentAction, gtagParams);\r\n            }\r\n            else if (command === \"get\" /* GtagCommand.GET */) {\r\n                const [measurementId, fieldName, callback] = args;\r\n                gtagCore(\"get\" /* GtagCommand.GET */, measurementId, fieldName, callback);\r\n            }\r\n            else if (command === \"set\" /* GtagCommand.SET */) {\r\n                const [customParams] = args;\r\n                // If SET, second arg must be params.\r\n                gtagCore(\"set\" /* GtagCommand.SET */, customParams);\r\n            }\r\n            else {\r\n                gtagCore(command, ...args);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n    return gtagWrapper;\r\n}\r\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\r\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\r\n    // Create a basic core gtag function\r\n    let gtagCore = function (..._args) {\r\n        // Must push IArguments object, not an array.\r\n        window[dataLayerName].push(arguments);\r\n    };\r\n    // Replace it with existing one if found\r\n    if (window[gtagFunctionName] &&\r\n        typeof window[gtagFunctionName] === 'function') {\r\n        // @ts-ignore\r\n        gtagCore = window[gtagFunctionName];\r\n    }\r\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\r\n    return {\r\n        gtagCore,\r\n        wrappedGtag: window[gtagFunctionName]\r\n    };\r\n}\r\n/**\r\n * Returns the script tag in the DOM matching both the gtag url pattern\r\n * and the provided data layer name.\r\n */\r\nfunction findGtagScriptOnPage(dataLayerName) {\r\n    const scriptTags = window.document.getElementsByTagName('script');\r\n    for (const tag of Object.values(scriptTags)) {\r\n        if (tag.src &&\r\n            tag.src.includes(GTAG_URL) &&\r\n            tag.src.includes(dataLayerName)) {\r\n            return tag;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\r\n        ' already exists. ' +\r\n        'Only one Firebase Analytics instance can be created for each appId.',\r\n    [\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\r\n        'it was initially called with. It can be called again with the same options to ' +\r\n        'return the existing instance, or getAnalytics() can be used ' +\r\n        'to get a reference to the already-intialized instance.',\r\n    [\"already-initialized-settings\" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\r\n        'settings() must be called before initializing any Analytics instance' +\r\n        'or it will have no effect.',\r\n    [\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\r\n    [\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    [\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\r\n    [\"no-api-key\" /* AnalyticsError.NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid API key.',\r\n    [\"no-app-id\" /* AnalyticsError.NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid app ID.',\r\n    [\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */]: 'The \"client_id\" field is empty.',\r\n    [\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */]: 'Trusted Types detected an invalid gtag resource: {$gtagURL}.'\r\n};\r\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_4__.ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\r\nconst LONG_RETRY_FACTOR = 30;\r\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\r\nconst BASE_INTERVAL_MILLIS = 1000;\r\n/**\r\n * Stubbable retry data storage class.\r\n */\r\nclass RetryData {\r\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\r\n        this.throttleMetadata = throttleMetadata;\r\n        this.intervalMillis = intervalMillis;\r\n    }\r\n    getThrottleMetadata(appId) {\r\n        return this.throttleMetadata[appId];\r\n    }\r\n    setThrottleMetadata(appId, metadata) {\r\n        this.throttleMetadata[appId] = metadata;\r\n    }\r\n    deleteThrottleMetadata(appId) {\r\n        delete this.throttleMetadata[appId];\r\n    }\r\n}\r\nconst defaultRetryData = new RetryData();\r\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\r\nfunction getHeaders(apiKey) {\r\n    return new Headers({\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfig(appFields) {\r\n    var _a;\r\n    const { appId, apiKey } = appFields;\r\n    const request = {\r\n        method: 'GET',\r\n        headers: getHeaders(apiKey)\r\n    };\r\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\r\n    const response = await fetch(appUrl, request);\r\n    if (response.status !== 200 && response.status !== 304) {\r\n        let errorMessage = '';\r\n        try {\r\n            // Try to get any error message text from server response.\r\n            const jsonResponse = (await response.json());\r\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\r\n                errorMessage = jsonResponse.error.message;\r\n            }\r\n        }\r\n        catch (_ignored) { }\r\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */, {\r\n            httpStatus: response.status,\r\n            responseMessage: errorMessage\r\n        });\r\n    }\r\n    return response.json();\r\n}\r\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfigWithRetry(app, \r\n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\r\nretryData = defaultRetryData, timeoutMillis) {\r\n    const { appId, apiKey, measurementId } = app.options;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!apiKey) {\r\n        if (measurementId) {\r\n            return {\r\n                measurementId,\r\n                appId\r\n            };\r\n        }\r\n        throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n    }\r\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\r\n        backoffCount: 0,\r\n        throttleEndTimeMillis: Date.now()\r\n    };\r\n    const signal = new AnalyticsAbortSignal();\r\n    setTimeout(async () => {\r\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n        signal.abort();\r\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\r\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\r\n}\r\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\r\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\r\n) {\r\n    var _a;\r\n    const { appId, measurementId } = appFields;\r\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n    // Ensures the throttle end time is honored if the last attempt timed out.\r\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n    try {\r\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\r\n    }\r\n    catch (e) {\r\n        if (measurementId) {\r\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\r\n                ` Falling back to the measurement ID ${measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);\r\n            return { appId, measurementId };\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        const response = await fetchDynamicConfig(appFields);\r\n        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n        retryData.deleteThrottleMetadata(appId);\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        const error = e;\r\n        if (!isRetriableError(error)) {\r\n            retryData.deleteThrottleMetadata(appId);\r\n            if (measurementId) {\r\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\r\n                    ` Falling back to the measurement ID ${measurementId}` +\r\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\r\n                return { appId, measurementId };\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503\r\n            ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.calculateBackoffMillis)(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\r\n            : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.calculateBackoffMillis)(backoffCount, retryData.intervalMillis);\r\n        // Increments backoff state.\r\n        const throttleMetadata = {\r\n            throttleEndTimeMillis: Date.now() + backoffMillis,\r\n            backoffCount: backoffCount + 1\r\n        };\r\n        // Persists state.\r\n        retryData.setThrottleMetadata(appId, throttleMetadata);\r\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\r\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\r\n    }\r\n}\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise((resolve, reject) => {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        const timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(() => {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError) || !e.customData) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    const httpStatus = Number(e.customData['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nclass AnalyticsAbortSignal {\r\n    constructor() {\r\n        this.listeners = [];\r\n    }\r\n    addEventListener(listener) {\r\n        this.listeners.push(listener);\r\n    }\r\n    abort() {\r\n        this.listeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\r\nlet defaultEventParametersForInit;\r\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\r\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, eventParams);\r\n        return;\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, params);\r\n    }\r\n}\r\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\r\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'screen_name': screenName });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'screen_name': screenName\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\r\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'user_id': id });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_id': id\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\r\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\r\n    if (options && options.global) {\r\n        const flatProperties = {};\r\n        for (const key of Object.keys(properties)) {\r\n            // use dot notation for merge behavior in gtag.js\r\n            flatProperties[`user_properties.${key}`] = properties[key];\r\n        }\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, flatProperties);\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_properties': properties\r\n        });\r\n    }\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n */\r\nasync function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {\r\n    const measurementId = await initializationPromise;\r\n    return new Promise((resolve, reject) => {\r\n        gtagFunction(\"get\" /* GtagCommand.GET */, measurementId, 'client_id', (clientId) => {\r\n            if (!clientId) {\r\n                reject(ERROR_FACTORY.create(\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */));\r\n            }\r\n            resolve(clientId);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\r\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\r\n    const measurementId = await initializationPromise;\r\n    window[`ga-disable-${measurementId}`] = !enabled;\r\n}\r\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\r\nlet defaultConsentSettingsForInit;\r\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction _setConsentDefaultForInit(consentSettings) {\r\n    defaultConsentSettingsForInit = consentSettings;\r\n}\r\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\r\nfunction _setDefaultEventParametersForInit(customParams) {\r\n    defaultEventParametersForInit = customParams;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function validateIndexedDB() {\r\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\r\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n            errorInfo: 'IndexedDB is not available in this environment.'\r\n        }).message);\r\n        return false;\r\n    }\r\n    else {\r\n        try {\r\n            await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.validateIndexedDBOpenable)();\r\n        }\r\n        catch (e) {\r\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n                errorInfo: e === null || e === void 0 ? void 0 : e.toString()\r\n            }).message);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\r\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\r\n    var _a;\r\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\r\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\r\n    dynamicConfigPromise\r\n        .then(config => {\r\n        measurementIdToAppId[config.measurementId] = config.appId;\r\n        if (app.options.measurementId &&\r\n            config.measurementId !== app.options.measurementId) {\r\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\r\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\r\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\r\n                ` update the` +\r\n                ` measurement ID field in the local config or remove it from the local config.`);\r\n        }\r\n    })\r\n        .catch(e => logger.error(e));\r\n    // Add to list to track state of all dynamic config promises.\r\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\r\n    const fidPromise = validateIndexedDB().then(envIsValid => {\r\n        if (envIsValid) {\r\n            return installations.getId();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    });\r\n    const [dynamicConfig, fid] = await Promise.all([\r\n        dynamicConfigPromise,\r\n        fidPromise\r\n    ]);\r\n    // Detect if user has already put the gtag <script> tag on this page with the passed in\r\n    // data layer name.\r\n    if (!findGtagScriptOnPage(dataLayerName)) {\r\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\r\n    }\r\n    // Detects if there are consent settings that need to be configured.\r\n    if (defaultConsentSettingsForInit) {\r\n        gtagCore(\"consent\" /* GtagCommand.CONSENT */, 'default', defaultConsentSettingsForInit);\r\n        _setConsentDefaultForInit(undefined);\r\n    }\r\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\r\n    // but since it is idempotent, we can call it multiple times.\r\n    // We keep it together with other initialization logic for better code structure.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    gtagCore('js', new Date());\r\n    // User config added first. We don't want users to accidentally overwrite\r\n    // base Firebase config properties.\r\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\r\n    // guard against developers accidentally setting properties with prefix `firebase_`\r\n    configProperties[ORIGIN_KEY] = 'firebase';\r\n    configProperties.update = true;\r\n    if (fid != null) {\r\n        configProperties[GA_FID_KEY] = fid;\r\n    }\r\n    // It should be the first config command called on this GA-ID\r\n    // Initialize this GA-ID and set FID on it using the gtag config API.\r\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\r\n    // `configProperties`.\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, dynamicConfig.measurementId, configProperties);\r\n    // Detects if there is data that will be set on every event logged from the SDK.\r\n    if (defaultEventParametersForInit) {\r\n        gtagCore(\"set\" /* GtagCommand.SET */, defaultEventParametersForInit);\r\n        _setDefaultEventParametersForInit(undefined);\r\n    }\r\n    return dynamicConfig.measurementId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Analytics Service class.\r\n */\r\nclass AnalyticsService {\r\n    constructor(app) {\r\n        this.app = app;\r\n    }\r\n    _delete() {\r\n        delete initializationPromisesMap[this.app.options.appId];\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\r\nlet initializationPromisesMap = {};\r\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\r\nlet dynamicConfigPromisesList = [];\r\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\r\nconst measurementIdToAppId = {};\r\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\r\nlet dataLayerName = 'dataLayer';\r\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\r\nlet gtagName = 'gtag';\r\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\r\nlet gtagCoreFunction;\r\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\r\nlet wrappedGtagFunction;\r\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\r\nlet globalInitDone = false;\r\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\r\nfunction settings(options) {\r\n    if (globalInitDone) {\r\n        throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n    }\r\n    if (options.dataLayerName) {\r\n        dataLayerName = options.dataLayerName;\r\n    }\r\n    if (options.gtagName) {\r\n        gtagName = options.gtagName;\r\n    }\r\n}\r\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\r\nfunction warnOnBrowserContextMismatch() {\r\n    const mismatchedEnvMessages = [];\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isBrowserExtension)()) {\r\n        mismatchedEnvMessages.push('This is a browser extension environment.');\r\n    }\r\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.areCookiesEnabled)()) {\r\n        mismatchedEnvMessages.push('Cookies are not available.');\r\n    }\r\n    if (mismatchedEnvMessages.length > 0) {\r\n        const details = mismatchedEnvMessages\r\n            .map((message, index) => `(${index + 1}) ${message}`)\r\n            .join(' ');\r\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */, {\r\n            errorInfo: details\r\n        });\r\n        logger.warn(err.message);\r\n    }\r\n}\r\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\r\nfunction factory(app, installations, options) {\r\n    warnOnBrowserContextMismatch();\r\n    const appId = app.options.appId;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!app.options.apiKey) {\r\n        if (app.options.measurementId) {\r\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\r\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n        }\r\n    }\r\n    if (initializationPromisesMap[appId] != null) {\r\n        throw ERROR_FACTORY.create(\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */, {\r\n            id: appId\r\n        });\r\n    }\r\n    if (!globalInitDone) {\r\n        // Steps here should only be done once per page: creation or wrapping\r\n        // of dataLayer and global gtag function.\r\n        getOrCreateDataLayer(dataLayerName);\r\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\r\n        wrappedGtagFunction = wrappedGtag;\r\n        gtagCoreFunction = gtagCore;\r\n        globalInitDone = true;\r\n    }\r\n    // Async but non-blocking.\r\n    // This map reflects the completion state of all promises for each appId.\r\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\r\n    const analyticsInstance = new AnalyticsService(app);\r\n    return analyticsInstance;\r\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction getAnalytics(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\r\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(app);\r\n    // Dependencies\r\n    const analyticsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        return analyticsProvider.getImmediate();\r\n    }\r\n    return initializeAnalytics(app);\r\n}\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction initializeAnalytics(app, options = {}) {\r\n    // Dependencies\r\n    const analyticsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        const existingInstance = analyticsProvider.getImmediate();\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(options, analyticsProvider.getOptions())) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const analyticsInstance = analyticsProvider.initialize({ options });\r\n    return analyticsInstance;\r\n}\r\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\r\nasync function isSupported() {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isBrowserExtension)()) {\r\n        return false;\r\n    }\r\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.areCookiesEnabled)()) {\r\n        return false;\r\n    }\r\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\r\n        return false;\r\n    }\r\n    try {\r\n        const isDBOpenable = await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.validateIndexedDBOpenable)();\r\n        return isDBOpenable;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\r\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\r\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(analyticsInstance);\r\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nasync function getGoogleAnalyticsClientId(analyticsInstance) {\r\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(analyticsInstance);\r\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\r\n}\r\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\r\nfunction setUserId(analyticsInstance, id, options) {\r\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(analyticsInstance);\r\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\r\nfunction setUserProperties(analyticsInstance, properties, options) {\r\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(analyticsInstance);\r\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\r\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\r\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(analyticsInstance);\r\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\r\nfunction setDefaultEventParameters(customParams) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"set\" /* GtagCommand.SET */, customParams);\r\n    }\r\n    else {\r\n        _setDefaultEventParametersForInit(customParams);\r\n    }\r\n}\r\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\r\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\r\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(analyticsInstance);\r\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction setConsent(consentSettings) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"consent\" /* GtagCommand.CONSENT */, 'update', consentSettings);\r\n    }\r\n    else {\r\n        _setConsentDefaultForInit(consentSettings);\r\n    }\r\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.6\";\n\n/**\r\n * The Firebase Analytics Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction registerAnalytics() {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_5__.Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const installations = container\r\n            .getProvider('installations-internal')\r\n            .getImmediate();\r\n        return factory(app, installations, analyticsOptions);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_5__.Component('analytics-internal', internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\r\n    function internalFactory(container) {\r\n        try {\r\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\r\n            return {\r\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */, {\r\n                reason: e\r\n            });\r\n        }\r\n    }\r\n}\r\nregisterAnalytics();\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FuYWx5dGljcy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEY7QUFDaEQ7QUFDTTtBQUNGO0FBQzhKO0FBQzVKO0FBQ2Y7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixPQUFPO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0EsZ0JBQWdCLDhEQUFrQiwrQ0FBK0MsY0FBYyxNQUFNLGNBQWM7QUFDbkgsSUFBSSwrREFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsS0FBSztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0osUUFBUTtBQUM5SjtBQUNBO0FBQ0EsMEVBQTBFLFdBQVc7QUFDckY7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0EsOEVBQThFLHVCQUF1QjtBQUNyRyxzR0FBc0csWUFBWSxHQUFHLGlCQUFpQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILFNBQVM7QUFDdEk7QUFDQSwwQkFBMEIsd0RBQVk7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHFDQUFxQztBQUNwRztBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckUseUZBQXlGLGdEQUFnRDtBQUN6SSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekUsNkZBQTZGLDREQUE0RDtBQUN6Six5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzRUFBc0I7QUFDcEMsY0FBYyxzRUFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQSx1QkFBdUIseURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLDBCQUEwQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFFBQVEsaUZBQWlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwyQkFBMkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEdBQThHO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFvQjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlFQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsMEJBQTBCO0FBQ3RHLCtFQUErRSxxQkFBcUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFrQjtBQUMxQjtBQUNBO0FBQ0EsU0FBUyxpRUFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVSxJQUFJLFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQSw0QkFBNEIscURBQU07QUFDbEMsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQSw4QkFBOEIsMkRBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLDhCQUE4QiwyREFBWTtBQUMxQztBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBa0I7QUFDMUI7QUFDQTtBQUNBLFNBQVMsaUVBQWlCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTLG9FQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUVBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFFBQVEsaUZBQWlGO0FBQ3pGO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4R0FBOEc7QUFDdEg7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWtCLEtBQUssMERBQVMsK0JBQStCLDJCQUEyQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxpRUFBa0IsS0FBSywwREFBUztBQUNwQyxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFZ087QUFDaE8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZlbnRvcnlfbWFuYWdtZW50Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hbmFseXRpY3MvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz9kMzI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyB0cnVzdGVkUmVzb3VyY2VVcmwgfSBmcm9tICdzYWZldmFsdWVzJztcbmltcG9ydCB7IHNhZmVTY3JpcHRFbCB9IGZyb20gJ3NhZmV2YWx1ZXMvZG9tJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgY2FsY3VsYXRlQmFja29mZk1pbGxpcywgRmlyZWJhc2VFcnJvciwgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUsIGlzQnJvd3NlckV4dGVuc2lvbiwgYXJlQ29va2llc0VuYWJsZWQsIGdldE1vZHVsYXJJbnN0YW5jZSwgZGVlcEVxdWFsIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9pbnN0YWxsYXRpb25zJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFR5cGUgY29uc3RhbnQgZm9yIEZpcmViYXNlIEFuYWx5dGljcy5cclxuICovXHJcbmNvbnN0IEFOQUxZVElDU19UWVBFID0gJ2FuYWx5dGljcyc7XHJcbi8vIEtleSB0byBhdHRhY2ggRklEIHRvIGluIGd0YWcgcGFyYW1zLlxyXG5jb25zdCBHQV9GSURfS0VZID0gJ2ZpcmViYXNlX2lkJztcclxuY29uc3QgT1JJR0lOX0tFWSA9ICdvcmlnaW4nO1xyXG5jb25zdCBGRVRDSF9USU1FT1VUX01JTExJUyA9IDYwICogMTAwMDtcclxuY29uc3QgRFlOQU1JQ19DT05GSUdfVVJMID0gJ2h0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlYXBpcy5jb20vdjFhbHBoYS9wcm9qZWN0cy8tL2FwcHMve2FwcC1pZH0vd2ViQ29uZmlnJztcclxuY29uc3QgR1RBR19VUkwgPSAnaHR0cHM6Ly93d3cuZ29vZ2xldGFnbWFuYWdlci5jb20vZ3RhZy9qcyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hbmFseXRpY3MnKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE1ha2VzaGlmdCBwb2x5ZmlsbCBmb3IgUHJvbWlzZS5hbGxTZXR0bGVkKCkuIFJlc29sdmVzIHdoZW4gYWxsIHByb21pc2VzXHJcbiAqIGhhdmUgZWl0aGVyIHJlc29sdmVkIG9yIHJlamVjdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvbWlzZXMgQXJyYXkgb2YgcHJvbWlzZXMgdG8gd2FpdCBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9taXNlQWxsU2V0dGxlZChwcm9taXNlcykge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzLm1hcChwcm9taXNlID0+IHByb21pc2UuY2F0Y2goZSA9PiBlKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBJbnNlcnRzIGd0YWcgc2NyaXB0IHRhZyBpbnRvIHRoZSBwYWdlIHRvIGFzeW5jaHJvbm91c2x5IGRvd25sb2FkIGd0YWcuXHJcbiAqIEBwYXJhbSBkYXRhTGF5ZXJOYW1lIE5hbWUgb2YgZGF0YWxheWVyIChtb3N0IG9mdGVuIHRoZSBkZWZhdWx0LCBcIl9kYXRhTGF5ZXJcIikuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnNlcnRTY3JpcHRUYWcoZGF0YUxheWVyTmFtZSwgbWVhc3VyZW1lbnRJZCkge1xyXG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAvLyBXZSBhcmUgbm90IHByb3ZpZGluZyBhbiBhbmFseXRpY3NJZCBpbiB0aGUgVVJMIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBhIGBwYWdlX3ZpZXdgXHJcbiAgICAvLyB3aXRob3V0IGZpZC4gV2Ugd2lsbCBpbml0aWFsaXplIGdhLWlkIHVzaW5nIGd0YWcgKGNvbmZpZykgY29tbWFuZCB0b2dldGhlciB3aXRoIGZpZC5cclxuICAgIC8vXHJcbiAgICAvLyBXZSBhbHNvIGhhdmUgdG8gZW5zdXJlIHRoZSB0ZW1wbGF0ZSBzdHJpbmcgYmVmb3JlIHRoZSBmaXJzdCBleHByZXNzaW9uIGNvbnN0aXR1dGVzIGEgdmFsaWQgVVJMXHJcbiAgICAvLyBzdGFydCwgYXMgdGhpcyBpcyB3aGF0IHRoZSBpbml0aWFsIHZhbGlkYXRpb24gZm9jdXNlcyBvbi4gSWYgdGhlIHRlbXBsYXRlIGxpdGVyYWwgYmVnaW5zXHJcbiAgICAvLyBkaXJlY3RseSB3aXRoIGFuIGV4cHJlc3Npb24gKGUuZy4gYCR7R1RBR19TQ1JJUFRfVVJMfWApLCB0aGUgdmFsaWRhdGlvbiBmYWlscyBkdWUgdG8gYW5cclxuICAgIC8vIGVtcHR5IGluaXRpYWwgc3RyaW5nLlxyXG4gICAgY29uc3QgdXJsID0gdHJ1c3RlZFJlc291cmNlVXJsIGBodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbS9ndGFnL2pzP2w9JHtkYXRhTGF5ZXJOYW1lfSZpZD0ke21lYXN1cmVtZW50SWR9YDtcclxuICAgIHNhZmVTY3JpcHRFbC5zZXRTcmMoc2NyaXB0LCB1cmwpO1xyXG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxufVxyXG4vKipcclxuICogR2V0IHJlZmVyZW5jZSB0bywgb3IgY3JlYXRlLCBnbG9iYWwgZGF0YWxheWVyLlxyXG4gKiBAcGFyYW0gZGF0YUxheWVyTmFtZSBOYW1lIG9mIGRhdGFsYXllciAobW9zdCBvZnRlbiB0aGUgZGVmYXVsdCwgXCJfZGF0YUxheWVyXCIpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVEYXRhTGF5ZXIoZGF0YUxheWVyTmFtZSkge1xyXG4gICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGRhdGFMYXllciBhbmQgY3JlYXRlIGlmIG5lZWRlZC5cclxuICAgIGxldCBkYXRhTGF5ZXIgPSBbXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHdpbmRvd1tkYXRhTGF5ZXJOYW1lXSkpIHtcclxuICAgICAgICBkYXRhTGF5ZXIgPSB3aW5kb3dbZGF0YUxheWVyTmFtZV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3dbZGF0YUxheWVyTmFtZV0gPSBkYXRhTGF5ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YUxheWVyO1xyXG59XHJcbi8qKlxyXG4gKiBXcmFwcGVkIGd0YWcgbG9naWMgd2hlbiBndGFnIGlzIGNhbGxlZCB3aXRoICdjb25maWcnIGNvbW1hbmQuXHJcbiAqXHJcbiAqIEBwYXJhbSBndGFnQ29yZSBCYXNpYyBndGFnIGZ1bmN0aW9uIHRoYXQganVzdCBhcHBlbmRzIHRvIGRhdGFMYXllci5cclxuICogQHBhcmFtIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAgTWFwIG9mIGFwcElkcyB0byB0aGVpciBpbml0aWFsaXphdGlvbiBwcm9taXNlcy5cclxuICogQHBhcmFtIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgQXJyYXkgb2YgZHluYW1pYyBjb25maWcgZmV0Y2ggcHJvbWlzZXMuXHJcbiAqIEBwYXJhbSBtZWFzdXJlbWVudElkVG9BcHBJZCBNYXAgb2YgR0EgbWVhc3VyZW1lbnRJRHMgdG8gY29ycmVzcG9uZGluZyBGaXJlYmFzZSBhcHBJZC5cclxuICogQHBhcmFtIG1lYXN1cmVtZW50SWQgR0EgTWVhc3VyZW1lbnQgSUQgdG8gc2V0IGNvbmZpZyBmb3IuXHJcbiAqIEBwYXJhbSBndGFnUGFyYW1zIEd0YWcgY29uZmlnIHBhcmFtcyB0byBzZXQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBndGFnT25Db25maWcoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWRUb0FwcElkLCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zKSB7XHJcbiAgICAvLyBJZiBjb25maWcgaXMgYWxyZWFkeSBmZXRjaGVkLCB3ZSBrbm93IHRoZSBhcHBJZCBhbmQgY2FuIHVzZSBpdCB0byBsb29rIHVwIHdoYXQgRklEIHByb21pc2Ugd2VcclxuICAgIC8vLyBhcmUgd2FpdGluZyBmb3IsIGFuZCB3YWl0IG9ubHkgb24gdGhhdCBvbmUuXHJcbiAgICBjb25zdCBjb3JyZXNwb25kaW5nQXBwSWQgPSBtZWFzdXJlbWVudElkVG9BcHBJZFttZWFzdXJlbWVudElkXTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGNvcnJlc3BvbmRpbmdBcHBJZCkge1xyXG4gICAgICAgICAgICBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2NvcnJlc3BvbmRpbmdBcHBJZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBjb25maWcgaXMgbm90IGZldGNoZWQgeWV0LCB3YWl0IGZvciBhbGwgY29uZmlncyAod2UgZG9uJ3Qga25vdyB3aGljaCBvbmUgd2UgbmVlZCkgYW5kXHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGFwcElkIChpZiBhbnkpIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZWFzdXJlbWVudElkLiBJZiB0aGVyZSBpcyBvbmUsIHdhaXQgb25cclxuICAgICAgICAgICAgLy8gdGhhdCBhcHBJZCdzIGluaXRpYWxpemF0aW9uIHByb21pc2UuIElmIHRoZXJlIGlzIG5vbmUsIHByb21pc2UgcmVzb2x2ZXMgYW5kIGd0YWdcclxuICAgICAgICAgICAgLy8gY2FsbCBnb2VzIHRocm91Z2guXHJcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNDb25maWdSZXN1bHRzID0gYXdhaXQgcHJvbWlzZUFsbFNldHRsZWQoZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kQ29uZmlnID0gZHluYW1pY0NvbmZpZ1Jlc3VsdHMuZmluZChjb25maWcgPT4gY29uZmlnLm1lYXN1cmVtZW50SWQgPT09IG1lYXN1cmVtZW50SWQpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbZm91bmRDb25maWcuYXBwSWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgICBndGFnQ29yZShcImNvbmZpZ1wiIC8qIEd0YWdDb21tYW5kLkNPTkZJRyAqLywgbWVhc3VyZW1lbnRJZCwgZ3RhZ1BhcmFtcyk7XHJcbn1cclxuLyoqXHJcbiAqIFdyYXBwZWQgZ3RhZyBsb2dpYyB3aGVuIGd0YWcgaXMgY2FsbGVkIHdpdGggJ2V2ZW50JyBjb21tYW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ3RhZ0NvcmUgQmFzaWMgZ3RhZyBmdW5jdGlvbiB0aGF0IGp1c3QgYXBwZW5kcyB0byBkYXRhTGF5ZXIuXHJcbiAqIEBwYXJhbSBpbml0aWFsaXphdGlvblByb21pc2VzTWFwIE1hcCBvZiBhcHBJZHMgdG8gdGhlaXIgaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMuXHJcbiAqIEBwYXJhbSBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0IEFycmF5IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLlxyXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZCBHQSBNZWFzdXJlbWVudCBJRCB0byBsb2cgZXZlbnQgdG8uXHJcbiAqIEBwYXJhbSBndGFnUGFyYW1zIFBhcmFtcyB0byBsb2cgd2l0aCB0aGlzIGV2ZW50LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ3RhZ09uRXZlbnQoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IgPSBbXTtcclxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgJ3NlbmRfdG8nIHBhcmFtLCBjaGVjayBpZiBhbnkgSUQgc3BlY2lmaWVkIG1hdGNoZXNcclxuICAgICAgICAvLyBhbiBpbml0aWFsaXplSWRzKCkgcHJvbWlzZSB3ZSBhcmUgd2FpdGluZyBmb3IuXHJcbiAgICAgICAgaWYgKGd0YWdQYXJhbXMgJiYgZ3RhZ1BhcmFtc1snc2VuZF90byddKSB7XHJcbiAgICAgICAgICAgIGxldCBnYVNlbmRUb0xpc3QgPSBndGFnUGFyYW1zWydzZW5kX3RvJ107XHJcbiAgICAgICAgICAgIC8vIE1ha2UgaXQgYW4gYXJyYXkgaWYgaXMgaXNuJ3QsIHNvIGl0IGNhbiBiZSBkZWFsdCB3aXRoIHRoZSBzYW1lIHdheS5cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGdhU2VuZFRvTGlzdCkpIHtcclxuICAgICAgICAgICAgICAgIGdhU2VuZFRvTGlzdCA9IFtnYVNlbmRUb0xpc3RdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNraW5nICdzZW5kX3RvJyBmaWVsZHMgcmVxdWlyZXMgaGF2aW5nIGFsbCBtZWFzdXJlbWVudCBJRCByZXN1bHRzIGJhY2sgZnJvbVxyXG4gICAgICAgICAgICAvLyB0aGUgZHluYW1pYyBjb25maWcgZmV0Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNDb25maWdSZXN1bHRzID0gYXdhaXQgcHJvbWlzZUFsbFNldHRsZWQoZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VuZFRvSWQgb2YgZ2FTZW5kVG9MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbnkgZmV0Y2hlZCBkeW5hbWljIG1lYXN1cmVtZW50IElEIHRoYXQgbWF0Y2hlcyB0aGlzICdzZW5kX3RvJyBJRFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRDb25maWcgPSBkeW5hbWljQ29uZmlnUmVzdWx0cy5maW5kKGNvbmZpZyA9PiBjb25maWcubWVhc3VyZW1lbnRJZCA9PT0gc2VuZFRvSWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gZm91bmRDb25maWcgJiYgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFtmb3VuZENvbmZpZy5hcHBJZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlc1RvV2FpdEZvci5wdXNoKGluaXRpYWxpemF0aW9uUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhbiBpdGVtIGluICdzZW5kX3RvJyB0aGF0IGlzIG5vdCBhc3NvY2lhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgd2l0aCBhbiBGSUQsIHBvc3NpYmx5IGEgZ3JvdXAuICBFbXB0eSB0aGlzIGFycmF5LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4aXQgdGhlIGxvb3AgZWFybHksIGFuZCBsZXQgaXQgZ2V0IHBvcHVsYXRlZCBiZWxvdy5cclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblByb21pc2VzVG9XYWl0Rm9yID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHVucG9wdWxhdGVkIGlmIHRoZXJlIHdhcyBubyAnc2VuZF90bycgZmllbGQgLCBvclxyXG4gICAgICAgIC8vIGlmIG5vdCBhbGwgZW50cmllcyBpbiB0aGUgJ3NlbmRfdG8nIGZpZWxkIGNvdWxkIGJlIG1hcHBlZCB0b1xyXG4gICAgICAgIC8vIGEgRklELiBJbiB0aGVzZSBjYXNlcywgd2FpdCBvbiBhbGwgcGVuZGluZyBpbml0aWFsaXphdGlvbiBwcm9taXNlcy5cclxuICAgICAgICBpZiAoaW5pdGlhbGl6YXRpb25Qcm9taXNlc1RvV2FpdEZvci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlc1RvV2FpdEZvciA9IE9iamVjdC52YWx1ZXMoaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJ1biBjb3JlIGd0YWcgZnVuY3Rpb24gd2l0aCBhcmdzIGFmdGVyIGFsbCByZWxldmFudCBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIC8vIHByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZC5cclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbml0aWFsaXphdGlvblByb21pc2VzVG9XYWl0Rm9yKTtcclxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vYi8xNDEzNzA0NDkgLSB0aGlyZCBhcmd1bWVudCBjYW5ub3QgYmUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGd0YWdDb3JlKFwiZXZlbnRcIiAvKiBHdGFnQ29tbWFuZC5FVkVOVCAqLywgbWVhc3VyZW1lbnRJZCwgZ3RhZ1BhcmFtcyB8fCB7fSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxvZ2dlci5lcnJvcihlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogV3JhcHMgYSBzdGFuZGFyZCBndGFnIGZ1bmN0aW9uIHdpdGggZXh0cmEgY29kZSB0byB3YWl0IGZvciBjb21wbGV0aW9uIG9mXHJcbiAqIHJlbGV2YW50IGluaXRpYWxpemF0aW9uIHByb21pc2VzIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ3RhZ0NvcmUgQmFzaWMgZ3RhZyBmdW5jdGlvbiB0aGF0IGp1c3QgYXBwZW5kcyB0byBkYXRhTGF5ZXIuXHJcbiAqIEBwYXJhbSBpbml0aWFsaXphdGlvblByb21pc2VzTWFwIE1hcCBvZiBhcHBJZHMgdG8gdGhlaXIgaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMuXHJcbiAqIEBwYXJhbSBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0IEFycmF5IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLlxyXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZFRvQXBwSWQgTWFwIG9mIEdBIG1lYXN1cmVtZW50SURzIHRvIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2UgYXBwSWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwR3RhZyhndGFnQ29yZSwgXHJcbi8qKlxyXG4gKiBBbGxvd3Mgd3JhcHBlZCBndGFnIGNhbGxzIHRvIHdhaXQgb24gd2hpY2hldmVyIGludGlhbGl6YXRpb24gcHJvbWlzZXMgYXJlIHJlcXVpcmVkLFxyXG4gKiBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBndGFnIHBhcmFtcycgYHNlbmRfdG9gIGZpZWxkLCBpZiBhbnkuXHJcbiAqL1xyXG5pbml0aWFsaXphdGlvblByb21pc2VzTWFwLCBcclxuLyoqXHJcbiAqIFdyYXBwZWQgZ3RhZyBjYWxscyBzb21ldGltZXMgcmVxdWlyZSBhbGwgZHluYW1pYyBjb25maWcgZmV0Y2hlcyB0byBoYXZlIHJldHVybmVkXHJcbiAqIGJlZm9yZSBkZXRlcm1pbmluZyB3aGF0IGluaXRpYWxpemF0aW9uIHByb21pc2VzICh3aGljaCBpbmNsdWRlIEZJRHMpIHRvIHdhaXQgZm9yLlxyXG4gKi9cclxuZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgXHJcbi8qKlxyXG4gKiBXcmFwcGVkIGd0YWcgY29uZmlnIGNhbGxzIGNhbiBuYXJyb3cgZG93biB3aGljaCBpbml0aWFsaXphdGlvbiBwcm9taXNlICh3aXRoIEZJRClcclxuICogdG8gd2FpdCBmb3IgaWYgdGhlIG1lYXN1cmVtZW50SWQgaXMgYWxyZWFkeSBmZXRjaGVkLCBieSBnZXR0aW5nIHRoZSBjb3JyZXNwb25kaW5nIGFwcElkLFxyXG4gKiB3aGljaCBpcyB0aGUga2V5IGZvciB0aGUgaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMgbWFwLlxyXG4gKi9cclxubWVhc3VyZW1lbnRJZFRvQXBwSWQpIHtcclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlciBhcm91bmQgZ3RhZyB0aGF0IGVuc3VyZXMgRklEIGlzIHNlbnQgd2l0aCBndGFnIGNhbGxzLlxyXG4gICAgICogQHBhcmFtIGNvbW1hbmQgR3RhZyBjb21tYW5kIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gaWRPck5hbWVPclBhcmFtcyBNZWFzdXJlbWVudCBJRCBpZiBjb21tYW5kIGlzIEVWRU5UL0NPTkZJRywgcGFyYW1zIGlmIGNvbW1hbmQgaXMgU0VULlxyXG4gICAgICogQHBhcmFtIGd0YWdQYXJhbXMgUGFyYW1zIGlmIGV2ZW50IGlzIEVWRU5UL0NPTkZJRy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZnVuY3Rpb24gZ3RhZ1dyYXBwZXIoY29tbWFuZCwgLi4uYXJncykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIElmIGV2ZW50LCBjaGVjayB0aGF0IHJlbGV2YW50IGluaXRpYWxpemF0aW9uIHByb21pc2VzIGhhdmUgY29tcGxldGVkLlxyXG4gICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gXCJldmVudFwiIC8qIEd0YWdDb21tYW5kLkVWRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbbWVhc3VyZW1lbnRJZCwgZ3RhZ1BhcmFtc10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgRVZFTlQsIHNlY29uZCBhcmcgbXVzdCBiZSBtZWFzdXJlbWVudElkLlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgZ3RhZ09uRXZlbnQoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbbWVhc3VyZW1lbnRJZCwgZ3RhZ1BhcmFtc10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgQ09ORklHLCBzZWNvbmQgYXJnIG11c3QgYmUgbWVhc3VyZW1lbnRJZC5cclxuICAgICAgICAgICAgICAgIGF3YWl0IGd0YWdPbkNvbmZpZyhndGFnQ29yZSwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiY29uc2VudFwiIC8qIEd0YWdDb21tYW5kLkNPTlNFTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtjb25zZW50QWN0aW9uLCBndGFnUGFyYW1zXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zZW50QWN0aW9uIGNhbiBiZSBvbmUgb2YgJ2RlZmF1bHQnIG9yICd1cGRhdGUnLlxyXG4gICAgICAgICAgICAgICAgZ3RhZ0NvcmUoXCJjb25zZW50XCIgLyogR3RhZ0NvbW1hbmQuQ09OU0VOVCAqLywgY29uc2VudEFjdGlvbiwgZ3RhZ1BhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJnZXRcIiAvKiBHdGFnQ29tbWFuZC5HRVQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFttZWFzdXJlbWVudElkLCBmaWVsZE5hbWUsIGNhbGxiYWNrXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICBndGFnQ29yZShcImdldFwiIC8qIEd0YWdDb21tYW5kLkdFVCAqLywgbWVhc3VyZW1lbnRJZCwgZmllbGROYW1lLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXN0b21QYXJhbXNdID0gYXJncztcclxuICAgICAgICAgICAgICAgIC8vIElmIFNFVCwgc2Vjb25kIGFyZyBtdXN0IGJlIHBhcmFtcy5cclxuICAgICAgICAgICAgICAgIGd0YWdDb3JlKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCBjdXN0b21QYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ3RhZ0NvcmUoY29tbWFuZCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBndGFnV3JhcHBlcjtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBnbG9iYWwgZ3RhZyBmdW5jdGlvbiBvciB3cmFwcyBleGlzdGluZyBvbmUgaWYgZm91bmQuXHJcbiAqIFRoaXMgd3JhcHBlZCBmdW5jdGlvbiBhdHRhY2hlcyBGaXJlYmFzZSBpbnN0YW5jZSBJRCAoRklEKSB0byBndGFnICdjb25maWcnIGFuZFxyXG4gKiAnZXZlbnQnIGNhbGxzIHRoYXQgYmVsb25nIHRvIHRoZSBHQUlEIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZpcmViYXNlIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCBNYXAgb2YgYXBwSWRzIHRvIHRoZWlyIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxyXG4gKiBAcGFyYW0gZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCBBcnJheSBvZiBkeW5hbWljIGNvbmZpZyBmZXRjaCBwcm9taXNlcy5cclxuICogQHBhcmFtIG1lYXN1cmVtZW50SWRUb0FwcElkIE1hcCBvZiBHQSBtZWFzdXJlbWVudElEcyB0byBjb3JyZXNwb25kaW5nIEZpcmViYXNlIGFwcElkLlxyXG4gKiBAcGFyYW0gZGF0YUxheWVyTmFtZSBOYW1lIG9mIGdsb2JhbCBHQSBkYXRhbGF5ZXIgYXJyYXkuXHJcbiAqIEBwYXJhbSBndGFnRnVuY3Rpb25OYW1lIE5hbWUgb2YgZ2xvYmFsIGd0YWcgZnVuY3Rpb24gKFwiZ3RhZ1wiIGlmIG5vdCB1c2VyLXNwZWNpZmllZCkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwT3JDcmVhdGVHdGFnKGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWRUb0FwcElkLCBkYXRhTGF5ZXJOYW1lLCBndGFnRnVuY3Rpb25OYW1lKSB7XHJcbiAgICAvLyBDcmVhdGUgYSBiYXNpYyBjb3JlIGd0YWcgZnVuY3Rpb25cclxuICAgIGxldCBndGFnQ29yZSA9IGZ1bmN0aW9uICguLi5fYXJncykge1xyXG4gICAgICAgIC8vIE11c3QgcHVzaCBJQXJndW1lbnRzIG9iamVjdCwgbm90IGFuIGFycmF5LlxyXG4gICAgICAgIHdpbmRvd1tkYXRhTGF5ZXJOYW1lXS5wdXNoKGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVwbGFjZSBpdCB3aXRoIGV4aXN0aW5nIG9uZSBpZiBmb3VuZFxyXG4gICAgaWYgKHdpbmRvd1tndGFnRnVuY3Rpb25OYW1lXSAmJlxyXG4gICAgICAgIHR5cGVvZiB3aW5kb3dbZ3RhZ0Z1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgZ3RhZ0NvcmUgPSB3aW5kb3dbZ3RhZ0Z1bmN0aW9uTmFtZV07XHJcbiAgICB9XHJcbiAgICB3aW5kb3dbZ3RhZ0Z1bmN0aW9uTmFtZV0gPSB3cmFwR3RhZyhndGFnQ29yZSwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBndGFnQ29yZSxcclxuICAgICAgICB3cmFwcGVkR3RhZzogd2luZG93W2d0YWdGdW5jdGlvbk5hbWVdXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY3JpcHQgdGFnIGluIHRoZSBET00gbWF0Y2hpbmcgYm90aCB0aGUgZ3RhZyB1cmwgcGF0dGVyblxyXG4gKiBhbmQgdGhlIHByb3ZpZGVkIGRhdGEgbGF5ZXIgbmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmRHdGFnU2NyaXB0T25QYWdlKGRhdGFMYXllck5hbWUpIHtcclxuICAgIGNvbnN0IHNjcmlwdFRhZ3MgPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xyXG4gICAgZm9yIChjb25zdCB0YWcgb2YgT2JqZWN0LnZhbHVlcyhzY3JpcHRUYWdzKSkge1xyXG4gICAgICAgIGlmICh0YWcuc3JjICYmXHJcbiAgICAgICAgICAgIHRhZy5zcmMuaW5jbHVkZXMoR1RBR19VUkwpICYmXHJcbiAgICAgICAgICAgIHRhZy5zcmMuaW5jbHVkZXMoZGF0YUxheWVyTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBFUlJPUlMgPSB7XHJcbiAgICBbXCJhbHJlYWR5LWV4aXN0c1wiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfRVhJU1RTICovXTogJ0EgRmlyZWJhc2UgQW5hbHl0aWNzIGluc3RhbmNlIHdpdGggdGhlIGFwcElkIHskaWR9ICcgK1xyXG4gICAgICAgICcgYWxyZWFkeSBleGlzdHMuICcgK1xyXG4gICAgICAgICdPbmx5IG9uZSBGaXJlYmFzZSBBbmFseXRpY3MgaW5zdGFuY2UgY2FuIGJlIGNyZWF0ZWQgZm9yIGVhY2ggYXBwSWQuJyxcclxuICAgIFtcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBbmFseXRpY3NFcnJvci5BTFJFQURZX0lOSVRJQUxJWkVEICovXTogJ2luaXRpYWxpemVBbmFseXRpY3MoKSBjYW5ub3QgYmUgY2FsbGVkIGFnYWluIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgdGhhbiB0aG9zZSAnICtcclxuICAgICAgICAnaXQgd2FzIGluaXRpYWxseSBjYWxsZWQgd2l0aC4gSXQgY2FuIGJlIGNhbGxlZCBhZ2FpbiB3aXRoIHRoZSBzYW1lIG9wdGlvbnMgdG8gJyArXHJcbiAgICAgICAgJ3JldHVybiB0aGUgZXhpc3RpbmcgaW5zdGFuY2UsIG9yIGdldEFuYWx5dGljcygpIGNhbiBiZSB1c2VkICcgK1xyXG4gICAgICAgICd0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGFscmVhZHktaW50aWFsaXplZCBpbnN0YW5jZS4nLFxyXG4gICAgW1wiYWxyZWFkeS1pbml0aWFsaXplZC1zZXR0aW5nc1wiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfSU5JVElBTElaRURfU0VUVElOR1MgKi9dOiAnRmlyZWJhc2UgQW5hbHl0aWNzIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuJyArXHJcbiAgICAgICAgJ3NldHRpbmdzKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyBhbnkgQW5hbHl0aWNzIGluc3RhbmNlJyArXHJcbiAgICAgICAgJ29yIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuJyxcclxuICAgIFtcImludGVyb3AtY29tcG9uZW50LXJlZy1mYWlsZWRcIiAvKiBBbmFseXRpY3NFcnJvci5JTlRFUk9QX0NPTVBPTkVOVF9SRUdfRkFJTEVEICovXTogJ0ZpcmViYXNlIEFuYWx5dGljcyBJbnRlcm9wIENvbXBvbmVudCBmYWlsZWQgdG8gaW5zdGFudGlhdGU6IHskcmVhc29ufScsXHJcbiAgICBbXCJpbnZhbGlkLWFuYWx5dGljcy1jb250ZXh0XCIgLyogQW5hbHl0aWNzRXJyb3IuSU5WQUxJRF9BTkFMWVRJQ1NfQ09OVEVYVCAqL106ICdGaXJlYmFzZSBBbmFseXRpY3MgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LiAnICtcclxuICAgICAgICAnV3JhcCBpbml0aWFsaXphdGlvbiBvZiBhbmFseXRpY3MgaW4gYW5hbHl0aWNzLmlzU3VwcG9ydGVkKCkgJyArXHJcbiAgICAgICAgJ3RvIHByZXZlbnQgaW5pdGlhbGl6YXRpb24gaW4gdW5zdXBwb3J0ZWQgZW52aXJvbm1lbnRzLiBEZXRhaWxzOiB7JGVycm9ySW5mb30nLFxyXG4gICAgW1wiaW5kZXhlZGRiLXVuYXZhaWxhYmxlXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5ERVhFRERCX1VOQVZBSUxBQkxFICovXTogJ0luZGV4ZWREQiB1bmF2YWlsYWJsZSBvciByZXN0cmljdGVkIGluIHRoaXMgZW52aXJvbm1lbnQuICcgK1xyXG4gICAgICAgICdXcmFwIGluaXRpYWxpemF0aW9uIG9mIGFuYWx5dGljcyBpbiBhbmFseXRpY3MuaXNTdXBwb3J0ZWQoKSAnICtcclxuICAgICAgICAndG8gcHJldmVudCBpbml0aWFsaXphdGlvbiBpbiB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudHMuIERldGFpbHM6IHskZXJyb3JJbmZvfScsXHJcbiAgICBbXCJmZXRjaC10aHJvdHRsZVwiIC8qIEFuYWx5dGljc0Vycm9yLkZFVENIX1RIUk9UVExFICovXTogJ1RoZSBjb25maWcgZmV0Y2ggcmVxdWVzdCB0aW1lZCBvdXQgd2hpbGUgaW4gYW4gZXhwb25lbnRpYWwgYmFja29mZiBzdGF0ZS4nICtcclxuICAgICAgICAnIFVuaXggdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyB3aGVuIGZldGNoIHJlcXVlc3QgdGhyb3R0bGluZyBlbmRzOiB7JHRocm90dGxlRW5kVGltZU1pbGxpc30uJyxcclxuICAgIFtcImNvbmZpZy1mZXRjaC1mYWlsZWRcIiAvKiBBbmFseXRpY3NFcnJvci5DT05GSUdfRkVUQ0hfRkFJTEVEICovXTogJ0R5bmFtaWMgY29uZmlnIGZldGNoIGZhaWxlZDogW3skaHR0cFN0YXR1c31dIHskcmVzcG9uc2VNZXNzYWdlfScsXHJcbiAgICBbXCJuby1hcGkta2V5XCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBJX0tFWSAqL106ICdUaGUgXCJhcGlLZXlcIiBmaWVsZCBpcyBlbXB0eSBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBGaXJlYmFzZSBBbmFseXRpY3MgcmVxdWlyZXMgdGhpcyBmaWVsZCB0bycgK1xyXG4gICAgICAgICdjb250YWluIGEgdmFsaWQgQVBJIGtleS4nLFxyXG4gICAgW1wibm8tYXBwLWlkXCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBQX0lEICovXTogJ1RoZSBcImFwcElkXCIgZmllbGQgaXMgZW1wdHkgaW4gdGhlIGxvY2FsIEZpcmViYXNlIGNvbmZpZy4gRmlyZWJhc2UgQW5hbHl0aWNzIHJlcXVpcmVzIHRoaXMgZmllbGQgdG8nICtcclxuICAgICAgICAnY29udGFpbiBhIHZhbGlkIGFwcCBJRC4nLFxyXG4gICAgW1wibm8tY2xpZW50LWlkXCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQ0xJRU5UX0lEICovXTogJ1RoZSBcImNsaWVudF9pZFwiIGZpZWxkIGlzIGVtcHR5LicsXHJcbiAgICBbXCJpbnZhbGlkLWd0YWctcmVzb3VyY2VcIiAvKiBBbmFseXRpY3NFcnJvci5JTlZBTElEX0dUQUdfUkVTT1VSQ0UgKi9dOiAnVHJ1c3RlZCBUeXBlcyBkZXRlY3RlZCBhbiBpbnZhbGlkIGd0YWcgcmVzb3VyY2U6IHskZ3RhZ1VSTH0uJ1xyXG59O1xyXG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYW5hbHl0aWNzJywgJ0FuYWx5dGljcycsIEVSUk9SUyk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBCYWNrb2ZmIGZhY3RvciBmb3IgNTAzIGVycm9ycywgd2hpY2ggd2Ugd2FudCB0byBiZSBjb25zZXJ2YXRpdmUgYWJvdXRcclxuICogdG8gYXZvaWQgb3ZlcmxvYWRpbmcgc2VydmVycy4gRWFjaCByZXRyeSBpbnRlcnZhbCB3aWxsIGJlXHJcbiAqIEJBU0VfSU5URVJWQUxfTUlMTElTICogTE9OR19SRVRSWV9GQUNUT1IgXiByZXRyeUNvdW50LCBzbyB0aGUgc2Vjb25kIG9uZVxyXG4gKiB3aWxsIGJlIH4zMCBzZWNvbmRzICh3aXRoIGZ1enppbmcpLlxyXG4gKi9cclxuY29uc3QgTE9OR19SRVRSWV9GQUNUT1IgPSAzMDtcclxuLyoqXHJcbiAqIEJhc2Ugd2FpdCBpbnRlcnZhbCB0byBtdWx0aXBsaWVkIGJ5IGJhY2tvZmZGYWN0b3JeYmFja29mZkNvdW50LlxyXG4gKi9cclxuY29uc3QgQkFTRV9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xyXG4vKipcclxuICogU3R1YmJhYmxlIHJldHJ5IGRhdGEgc3RvcmFnZSBjbGFzcy5cclxuICovXHJcbmNsYXNzIFJldHJ5RGF0YSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aHJvdHRsZU1ldGFkYXRhID0ge30sIGludGVydmFsTWlsbGlzID0gQkFTRV9JTlRFUlZBTF9NSUxMSVMpIHtcclxuICAgICAgICB0aGlzLnRocm90dGxlTWV0YWRhdGEgPSB0aHJvdHRsZU1ldGFkYXRhO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxNaWxsaXMgPSBpbnRlcnZhbE1pbGxpcztcclxuICAgIH1cclxuICAgIGdldFRocm90dGxlTWV0YWRhdGEoYXBwSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aHJvdHRsZU1ldGFkYXRhW2FwcElkXTtcclxuICAgIH1cclxuICAgIHNldFRocm90dGxlTWV0YWRhdGEoYXBwSWQsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy50aHJvdHRsZU1ldGFkYXRhW2FwcElkXSA9IG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlVGhyb3R0bGVNZXRhZGF0YShhcHBJZCkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRocm90dGxlTWV0YWRhdGFbYXBwSWRdO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGRlZmF1bHRSZXRyeURhdGEgPSBuZXcgUmV0cnlEYXRhKCk7XHJcbi8qKlxyXG4gKiBTZXQgR0VUIHJlcXVlc3QgaGVhZGVycy5cclxuICogQHBhcmFtIGFwaUtleSBBcHAgQVBJIGtleS5cclxuICovXHJcbmZ1bmN0aW9uIGdldEhlYWRlcnMoYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gbmV3IEhlYWRlcnMoe1xyXG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICd4LWdvb2ctYXBpLWtleSc6IGFwaUtleVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEZldGNoZXMgZHluYW1pYyBjb25maWcgZnJvbSBiYWNrZW5kLlxyXG4gKiBAcGFyYW0gYXBwIEZpcmViYXNlIGFwcCB0byBmZXRjaCBjb25maWcgZm9yLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEeW5hbWljQ29uZmlnKGFwcEZpZWxkcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgeyBhcHBJZCwgYXBpS2V5IH0gPSBhcHBGaWVsZHM7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVycyhhcGlLZXkpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgYXBwVXJsID0gRFlOQU1JQ19DT05GSUdfVVJMLnJlcGxhY2UoJ3thcHAtaWR9JywgYXBwSWQpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcHBVcmwsIHJlcXVlc3QpO1xyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gMzA0KSB7XHJcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBnZXQgYW55IGVycm9yIG1lc3NhZ2UgdGV4dCBmcm9tIHNlcnZlciByZXNwb25zZS5cclxuICAgICAgICAgICAgY29uc3QganNvblJlc3BvbnNlID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XHJcbiAgICAgICAgICAgIGlmICgoX2EgPSBqc29uUmVzcG9uc2UuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBqc29uUmVzcG9uc2UuZXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2lnbm9yZWQpIHsgfVxyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiY29uZmlnLWZldGNoLWZhaWxlZFwiIC8qIEFuYWx5dGljc0Vycm9yLkNPTkZJR19GRVRDSF9GQUlMRUQgKi8sIHtcclxuICAgICAgICAgICAgaHR0cFN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICByZXNwb25zZU1lc3NhZ2U6IGVycm9yTWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxufVxyXG4vKipcclxuICogRmV0Y2hlcyBkeW5hbWljIGNvbmZpZyBmcm9tIGJhY2tlbmQsIHJldHJ5aW5nIGlmIGZhaWxlZC5cclxuICogQHBhcmFtIGFwcCBGaXJlYmFzZSBhcHAgdG8gZmV0Y2ggY29uZmlnIGZvci5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoRHluYW1pY0NvbmZpZ1dpdGhSZXRyeShhcHAsIFxyXG4vLyByZXRyeURhdGEgYW5kIHRpbWVvdXRNaWxsaXMgYXJlIHBhcmFtZXRlcml6ZWQgdG8gYWxsb3cgcGFzc2luZyBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgdGVzdGluZy5cclxucmV0cnlEYXRhID0gZGVmYXVsdFJldHJ5RGF0YSwgdGltZW91dE1pbGxpcykge1xyXG4gICAgY29uc3QgeyBhcHBJZCwgYXBpS2V5LCBtZWFzdXJlbWVudElkIH0gPSBhcHAub3B0aW9ucztcclxuICAgIGlmICghYXBwSWQpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcC1pZFwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0FQUF9JRCAqLyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwaUtleSkge1xyXG4gICAgICAgIGlmIChtZWFzdXJlbWVudElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlbWVudElkLFxyXG4gICAgICAgICAgICAgICAgYXBwSWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcGkta2V5XCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBJX0tFWSAqLyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0aHJvdHRsZU1ldGFkYXRhID0gcmV0cnlEYXRhLmdldFRocm90dGxlTWV0YWRhdGEoYXBwSWQpIHx8IHtcclxuICAgICAgICBiYWNrb2ZmQ291bnQ6IDAsXHJcbiAgICAgICAgdGhyb3R0bGVFbmRUaW1lTWlsbGlzOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2lnbmFsID0gbmV3IEFuYWx5dGljc0Fib3J0U2lnbmFsKCk7XHJcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyBOb3RlIGEgdmVyeSBsb3cgZGVsYXksIGVnIDwgMTBtcywgY2FuIGVsYXBzZSBiZWZvcmUgbGlzdGVuZXJzIGFyZSBpbml0aWFsaXplZC5cclxuICAgICAgICBzaWduYWwuYWJvcnQoKTtcclxuICAgIH0sIHRpbWVvdXRNaWxsaXMgIT09IHVuZGVmaW5lZCA/IHRpbWVvdXRNaWxsaXMgOiBGRVRDSF9USU1FT1VUX01JTExJUyk7XHJcbiAgICByZXR1cm4gYXR0ZW1wdEZldGNoRHluYW1pY0NvbmZpZ1dpdGhSZXRyeSh7IGFwcElkLCBhcGlLZXksIG1lYXN1cmVtZW50SWQgfSwgdGhyb3R0bGVNZXRhZGF0YSwgc2lnbmFsLCByZXRyeURhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBSdW5zIG9uZSByZXRyeSBhdHRlbXB0LlxyXG4gKiBAcGFyYW0gYXBwRmllbGRzIE5lY2Vzc2FyeSBhcHAgY29uZmlnIGZpZWxkcy5cclxuICogQHBhcmFtIHRocm90dGxlTWV0YWRhdGEgT25nb2luZyBtZXRhZGF0YSB0byBkZXRlcm1pbmUgdGhyb3R0bGluZyB0aW1lcy5cclxuICogQHBhcmFtIHNpZ25hbCBBYm9ydCBzaWduYWwuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBhdHRlbXB0RmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5KGFwcEZpZWxkcywgeyB0aHJvdHRsZUVuZFRpbWVNaWxsaXMsIGJhY2tvZmZDb3VudCB9LCBzaWduYWwsIHJldHJ5RGF0YSA9IGRlZmF1bHRSZXRyeURhdGEgLy8gZm9yIHRlc3RpbmdcclxuKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB7IGFwcElkLCBtZWFzdXJlbWVudElkIH0gPSBhcHBGaWVsZHM7XHJcbiAgICAvLyBTdGFydHMgd2l0aCBhIChwb3RlbnRpYWxseSB6ZXJvKSB0aW1lb3V0IHRvIHN1cHBvcnQgcmVzdW1wdGlvbiBmcm9tIHN0b3JlZCBzdGF0ZS5cclxuICAgIC8vIEVuc3VyZXMgdGhlIHRocm90dGxlIGVuZCB0aW1lIGlzIGhvbm9yZWQgaWYgdGhlIGxhc3QgYXR0ZW1wdCB0aW1lZCBvdXQuXHJcbiAgICAvLyBOb3RlIHRoZSBTREsgd2lsbCBuZXZlciBtYWtlIGEgcmVxdWVzdCBpZiB0aGUgZmV0Y2ggdGltZW91dCBleHBpcmVzIGF0IHRoaXMgcG9pbnQuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHNldEFib3J0YWJsZVRpbWVvdXQoc2lnbmFsLCB0aHJvdHRsZUVuZFRpbWVNaWxsaXMpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAobWVhc3VyZW1lbnRJZCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgVGltZWQgb3V0IGZldGNoaW5nIHRoaXMgRmlyZWJhc2UgYXBwJ3MgbWVhc3VyZW1lbnQgSUQgZnJvbSB0aGUgc2VydmVyLmAgK1xyXG4gICAgICAgICAgICAgICAgYCBGYWxsaW5nIGJhY2sgdG8gdGhlIG1lYXN1cmVtZW50IElEICR7bWVhc3VyZW1lbnRJZH1gICtcclxuICAgICAgICAgICAgICAgIGAgcHJvdmlkZWQgaW4gdGhlIFwibWVhc3VyZW1lbnRJZFwiIGZpZWxkIGluIHRoZSBsb2NhbCBGaXJlYmFzZSBjb25maWcuIFske2UgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlfV1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgYXBwSWQsIG1lYXN1cmVtZW50SWQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaER5bmFtaWNDb25maWcoYXBwRmllbGRzKTtcclxuICAgICAgICAvLyBOb3RlIHRoZSBTREsgb25seSBjbGVhcnMgdGhyb3R0bGUgc3RhdGUgaWYgcmVzcG9uc2UgaXMgc3VjY2VzcyBvciBub24tcmV0cmlhYmxlLlxyXG4gICAgICAgIHJldHJ5RGF0YS5kZWxldGVUaHJvdHRsZU1ldGFkYXRhKGFwcElkKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZTtcclxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlRXJyb3IoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgIHJldHJ5RGF0YS5kZWxldGVUaHJvdHRsZU1ldGFkYXRhKGFwcElkKTtcclxuICAgICAgICAgICAgaWYgKG1lYXN1cmVtZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBGYWlsZWQgdG8gZmV0Y2ggdGhpcyBGaXJlYmFzZSBhcHAncyBtZWFzdXJlbWVudCBJRCBmcm9tIHRoZSBzZXJ2ZXIuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCBGYWxsaW5nIGJhY2sgdG8gdGhlIG1lYXN1cmVtZW50IElEICR7bWVhc3VyZW1lbnRJZH1gICtcclxuICAgICAgICAgICAgICAgICAgICBgIHByb3ZpZGVkIGluIHRoZSBcIm1lYXN1cmVtZW50SWRcIiBmaWVsZCBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBbJHtlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZX1dYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBhcHBJZCwgbWVhc3VyZW1lbnRJZCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiYWNrb2ZmTWlsbGlzID0gTnVtYmVyKChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jdXN0b21EYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cFN0YXR1cykgPT09IDUwM1xyXG4gICAgICAgICAgICA/IGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCByZXRyeURhdGEuaW50ZXJ2YWxNaWxsaXMsIExPTkdfUkVUUllfRkFDVE9SKVxyXG4gICAgICAgICAgICA6IGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCByZXRyeURhdGEuaW50ZXJ2YWxNaWxsaXMpO1xyXG4gICAgICAgIC8vIEluY3JlbWVudHMgYmFja29mZiBzdGF0ZS5cclxuICAgICAgICBjb25zdCB0aHJvdHRsZU1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICB0aHJvdHRsZUVuZFRpbWVNaWxsaXM6IERhdGUubm93KCkgKyBiYWNrb2ZmTWlsbGlzLFxyXG4gICAgICAgICAgICBiYWNrb2ZmQ291bnQ6IGJhY2tvZmZDb3VudCArIDFcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFBlcnNpc3RzIHN0YXRlLlxyXG4gICAgICAgIHJldHJ5RGF0YS5zZXRUaHJvdHRsZU1ldGFkYXRhKGFwcElkLCB0aHJvdHRsZU1ldGFkYXRhKTtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENhbGxpbmcgYXR0ZW1wdEZldGNoIGFnYWluIGluICR7YmFja29mZk1pbGxpc30gbWlsbGlzYCk7XHJcbiAgICAgICAgcmV0dXJuIGF0dGVtcHRGZXRjaER5bmFtaWNDb25maWdXaXRoUmV0cnkoYXBwRmllbGRzLCB0aHJvdHRsZU1ldGFkYXRhLCBzaWduYWwsIHJldHJ5RGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFN1cHBvcnRzIHdhaXRpbmcgb24gYSBiYWNrb2ZmIGJ5OlxyXG4gKlxyXG4gKiA8dWw+XHJcbiAqICAgPGxpPlByb21pc2lmeWluZyBzZXRUaW1lb3V0LCBzbyB3ZSBjYW4gc2V0IGEgdGltZW91dCBpbiBvdXIgUHJvbWlzZSBjaGFpbjwvbGk+XHJcbiAqICAgPGxpPkxpc3RlbmluZyBvbiBhIHNpZ25hbCBidXMgZm9yIGFib3J0IGV2ZW50cywganVzdCBsaWtlIHRoZSBGZXRjaCBBUEk8L2xpPlxyXG4gKiAgIDxsaT5GYWlsaW5nIGluIHRoZSBzYW1lIHdheSB0aGUgRmV0Y2ggQVBJIGZhaWxzLCBzbyB0aW1pbmcgb3V0IGEgbGl2ZSByZXF1ZXN0IGFuZCBhIHRocm90dGxlZFxyXG4gKiAgICAgICByZXF1ZXN0IGFwcGVhciB0aGUgc2FtZS48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0QWJvcnRhYmxlVGltZW91dChzaWduYWwsIHRocm90dGxlRW5kVGltZU1pbGxpcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvLyBEZXJpdmVzIGJhY2tvZmYgZnJvbSBnaXZlbiBlbmQgdGltZSwgbm9ybWFsaXppbmcgbmVnYXRpdmUgbnVtYmVycyB0byB6ZXJvLlxyXG4gICAgICAgIGNvbnN0IGJhY2tvZmZNaWxsaXMgPSBNYXRoLm1heCh0aHJvdHRsZUVuZFRpbWVNaWxsaXMgLSBEYXRlLm5vdygpLCAwKTtcclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmTWlsbGlzKTtcclxuICAgICAgICAvLyBBZGRzIGxpc3RlbmVyLCByYXRoZXIgdGhhbiBzZXRzIG9uYWJvcnQsIGJlY2F1c2Ugc2lnbmFsIGlzIGEgc2hhcmVkIG9iamVjdC5cclxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgY29tcGxldGVzIGJlZm9yZSB0aGlzIHRpbWVvdXQsIHRoZSByZWplY3Rpb24gaGFzIG5vIGVmZmVjdC5cclxuICAgICAgICAgICAgcmVqZWN0KEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZmV0Y2gtdGhyb3R0bGVcIiAvKiBBbmFseXRpY3NFcnJvci5GRVRDSF9USFJPVFRMRSAqLywge1xyXG4gICAgICAgICAgICAgICAgdGhyb3R0bGVFbmRUaW1lTWlsbGlzXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHtAbGluayBFcnJvcn0gaW5kaWNhdGVzIGEgZmV0Y2ggcmVxdWVzdCBtYXkgc3VjY2VlZCBsYXRlci5cclxuICovXHJcbmZ1bmN0aW9uIGlzUmV0cmlhYmxlRXJyb3IoZSkge1xyXG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHx8ICFlLmN1c3RvbURhdGEpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBVc2VzIHN0cmluZyBpbmRleCBkZWZpbmVkIGJ5IEVycm9yRGF0YSwgd2hpY2ggRmlyZWJhc2VFcnJvciBpbXBsZW1lbnRzLlxyXG4gICAgY29uc3QgaHR0cFN0YXR1cyA9IE51bWJlcihlLmN1c3RvbURhdGFbJ2h0dHBTdGF0dXMnXSk7XHJcbiAgICByZXR1cm4gKGh0dHBTdGF0dXMgPT09IDQyOSB8fFxyXG4gICAgICAgIGh0dHBTdGF0dXMgPT09IDUwMCB8fFxyXG4gICAgICAgIGh0dHBTdGF0dXMgPT09IDUwMyB8fFxyXG4gICAgICAgIGh0dHBTdGF0dXMgPT09IDUwNCk7XHJcbn1cclxuLyoqXHJcbiAqIFNoaW1zIGEgbWluaW1hbCBBYm9ydFNpZ25hbCAoY29waWVkIGZyb20gUmVtb3RlIENvbmZpZykuXHJcbiAqXHJcbiAqIDxwPkFib3J0Q29udHJvbGxlcidzIEFib3J0U2lnbmFsIGNvbnZlbmllbnRseSBkZWNvdXBsZXMgZmV0Y2ggdGltZW91dCBsb2dpYyBmcm9tIG90aGVyIGFzcGVjdHNcclxuICogb2YgbmV0d29ya2luZywgc3VjaCBhcyByZXRyaWVzLiBGaXJlYmFzZSBkb2Vzbid0IHVzZSBBYm9ydENvbnRyb2xsZXIgZW5vdWdoIHRvIGp1c3RpZnkgYVxyXG4gKiBwb2x5ZmlsbCByZWNvbW1lbmRhdGlvbiwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBGZXRjaCBBUEksIGJ1dCB0aGlzIG1pbmltYWwgc2hpbSBjYW4gZWFzaWx5IGJlXHJcbiAqIHN3YXBwZWQgb3V0IGlmL3doZW4gd2UgZG8uXHJcbiAqL1xyXG5jbGFzcyBBbmFseXRpY3NBYm9ydFNpZ25hbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgYWJvcnQoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXZlbnQgcGFyYW1ldGVycyB0byBzZXQgb24gJ2d0YWcnIGR1cmluZyBpbml0aWFsaXphdGlvbi5cclxuICovXHJcbmxldCBkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdDtcclxuLyoqXHJcbiAqIExvZ3MgYW4gYW5hbHl0aWNzIGV2ZW50IHRocm91Z2ggdGhlIEZpcmViYXNlIFNESy5cclxuICpcclxuICogQHBhcmFtIGd0YWdGdW5jdGlvbiBXcmFwcGVkIGd0YWcgZnVuY3Rpb24gdGhhdCB3YWl0cyBmb3IgZmlkIHRvIGJlIHNldCBiZWZvcmUgc2VuZGluZyBhbiBldmVudFxyXG4gKiBAcGFyYW0gZXZlbnROYW1lIEdvb2dsZSBBbmFseXRpY3MgZXZlbnQgbmFtZSwgY2hvb3NlIGZyb20gc3RhbmRhcmQgbGlzdCBvciB1c2UgYSBjdXN0b20gc3RyaW5nLlxyXG4gKiBAcGFyYW0gZXZlbnRQYXJhbXMgQW5hbHl0aWNzIGV2ZW50IHBhcmFtZXRlcnMuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2dFdmVudCQxKGd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCkge1xyXG4gICAgICAgIGd0YWdGdW5jdGlvbihcImV2ZW50XCIgLyogR3RhZ0NvbW1hbmQuRVZFTlQgKi8sIGV2ZW50TmFtZSwgZXZlbnRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFBhcmFtcyksIHsgJ3NlbmRfdG8nOiBtZWFzdXJlbWVudElkIH0pO1xyXG4gICAgICAgIGd0YWdGdW5jdGlvbihcImV2ZW50XCIgLyogR3RhZ0NvbW1hbmQuRVZFTlQgKi8sIGV2ZW50TmFtZSwgcGFyYW1zKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2V0IHNjcmVlbl9uYW1lIHBhcmFtZXRlciBmb3IgdGhpcyBHb29nbGUgQW5hbHl0aWNzIElELlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGxvZ0V2ZW50fSB3aXRoIGBldmVudE5hbWVgIGFzICdzY3JlZW5fdmlldycgYW5kIGFkZCByZWxldmFudCBgZXZlbnRQYXJhbXNgLlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2FuYWx5dGljcy9zY3JlZW52aWV3cyB8IFRyYWNrIFNjcmVlbnZpZXdzfS5cclxuICpcclxuICogQHBhcmFtIGd0YWdGdW5jdGlvbiBXcmFwcGVkIGd0YWcgZnVuY3Rpb24gdGhhdCB3YWl0cyBmb3IgZmlkIHRvIGJlIHNldCBiZWZvcmUgc2VuZGluZyBhbiBldmVudFxyXG4gKiBAcGFyYW0gc2NyZWVuTmFtZSBTY3JlZW4gbmFtZSBzdHJpbmcgdG8gc2V0LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2V0Q3VycmVudFNjcmVlbiQxKGd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlLCBzY3JlZW5OYW1lLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCkge1xyXG4gICAgICAgIGd0YWdGdW5jdGlvbihcInNldFwiIC8qIEd0YWdDb21tYW5kLlNFVCAqLywgeyAnc2NyZWVuX25hbWUnOiBzY3JlZW5OYW1lIH0pO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBtZWFzdXJlbWVudElkLCB7XHJcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgJ3NjcmVlbl9uYW1lJzogc2NyZWVuTmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZXQgdXNlcl9pZCBwYXJhbWV0ZXIgZm9yIHRoaXMgR29vZ2xlIEFuYWx5dGljcyBJRC5cclxuICpcclxuICogQHBhcmFtIGd0YWdGdW5jdGlvbiBXcmFwcGVkIGd0YWcgZnVuY3Rpb24gdGhhdCB3YWl0cyBmb3IgZmlkIHRvIGJlIHNldCBiZWZvcmUgc2VuZGluZyBhbiBldmVudFxyXG4gKiBAcGFyYW0gaWQgVXNlciBJRCBzdHJpbmcgdG8gc2V0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzZXRVc2VySWQkMShndGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZSwgaWQsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2xvYmFsKSB7XHJcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCB7ICd1c2VyX2lkJzogaWQgfSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJZCA9IGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZTtcclxuICAgICAgICBndGFnRnVuY3Rpb24oXCJjb25maWdcIiAvKiBHdGFnQ29tbWFuZC5DT05GSUcgKi8sIG1lYXN1cmVtZW50SWQsIHtcclxuICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAndXNlcl9pZCc6IGlkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNldCBhbGwgb3RoZXIgdXNlciBwcm9wZXJ0aWVzIG90aGVyIHRoYW4gdXNlcl9pZCBhbmQgc2NyZWVuX25hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBndGFnRnVuY3Rpb24gV3JhcHBlZCBndGFnIGZ1bmN0aW9uIHRoYXQgd2FpdHMgZm9yIGZpZCB0byBiZSBzZXQgYmVmb3JlIHNlbmRpbmcgYW4gZXZlbnRcclxuICogQHBhcmFtIHByb3BlcnRpZXMgTWFwIG9mIHVzZXIgcHJvcGVydGllcyB0byBzZXRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNldFVzZXJQcm9wZXJ0aWVzJDEoZ3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2UsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2xvYmFsKSB7XHJcbiAgICAgICAgY29uc3QgZmxhdFByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgICAgICAvLyB1c2UgZG90IG5vdGF0aW9uIGZvciBtZXJnZSBiZWhhdmlvciBpbiBndGFnLmpzXHJcbiAgICAgICAgICAgIGZsYXRQcm9wZXJ0aWVzW2B1c2VyX3Byb3BlcnRpZXMuJHtrZXl9YF0gPSBwcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGd0YWdGdW5jdGlvbihcInNldFwiIC8qIEd0YWdDb21tYW5kLlNFVCAqLywgZmxhdFByb3BlcnRpZXMpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBtZWFzdXJlbWVudElkLCB7XHJcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgJ3VzZXJfcHJvcGVydGllcyc6IHByb3BlcnRpZXNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEgdW5pcXVlIEdvb2dsZSBBbmFseXRpY3MgaWRlbnRpZmllciBmb3IgdGhlIHdlYiBjbGllbnQuXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5hbHl0aWNzL2Rldmd1aWRlcy9jb2xsZWN0aW9uL2dhNC9yZWZlcmVuY2UvY29uZmlnI2NsaWVudF9pZCB8IGNsaWVudF9pZH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBndGFnRnVuY3Rpb24gV3JhcHBlZCBndGFnIGZ1bmN0aW9uIHRoYXQgd2FpdHMgZm9yIGZpZCB0byBiZSBzZXQgYmVmb3JlIHNlbmRpbmcgYW4gZXZlbnRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGludGVybmFsR2V0R29vZ2xlQW5hbHl0aWNzQ2xpZW50SWQoZ3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2UpIHtcclxuICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGd0YWdGdW5jdGlvbihcImdldFwiIC8qIEd0YWdDb21tYW5kLkdFVCAqLywgbWVhc3VyZW1lbnRJZCwgJ2NsaWVudF9pZCcsIChjbGllbnRJZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWNsaWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1jbGllbnQtaWRcIiAvKiBBbmFseXRpY3NFcnJvci5OT19DTElFTlRfSUQgKi8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKGNsaWVudElkKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBTZXQgd2hldGhlciBjb2xsZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoaXMgSUQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbmFibGVkIElmIHRydWUsIGNvbGxlY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhpcyBJRC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNldEFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkJDEoaW5pdGlhbGl6YXRpb25Qcm9taXNlLCBlbmFibGVkKSB7XHJcbiAgICBjb25zdCBtZWFzdXJlbWVudElkID0gYXdhaXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xyXG4gICAgd2luZG93W2BnYS1kaXNhYmxlLSR7bWVhc3VyZW1lbnRJZH1gXSA9ICFlbmFibGVkO1xyXG59XHJcbi8qKlxyXG4gKiBDb25zZW50IHBhcmFtZXRlcnMgdG8gZGVmYXVsdCB0byBkdXJpbmcgJ2d0YWcnIGluaXRpYWxpemF0aW9uLlxyXG4gKi9cclxubGV0IGRlZmF1bHRDb25zZW50U2V0dGluZ3NGb3JJbml0O1xyXG4vKipcclxuICogU2V0cyB0aGUgdmFyaWFibGUge0BsaW5rIGRlZmF1bHRDb25zZW50U2V0dGluZ3NGb3JJbml0fSBmb3IgdXNlIGluIHRoZSBpbml0aWFsaXphdGlvbiBvZlxyXG4gKiBhbmFseXRpY3MuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb25zZW50U2V0dGluZ3MgTWFwcyB0aGUgYXBwbGljYWJsZSBlbmQgdXNlciBjb25zZW50IHN0YXRlIGZvciBndGFnLmpzLlxyXG4gKi9cclxuZnVuY3Rpb24gX3NldENvbnNlbnREZWZhdWx0Rm9ySW5pdChjb25zZW50U2V0dGluZ3MpIHtcclxuICAgIGRlZmF1bHRDb25zZW50U2V0dGluZ3NGb3JJbml0ID0gY29uc2VudFNldHRpbmdzO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSB2YXJpYWJsZSBgZGVmYXVsdEV2ZW50UGFyYW1ldGVyc0ZvckluaXRgIGZvciB1c2UgaW4gdGhlIGluaXRpYWxpemF0aW9uIG9mXHJcbiAqIGFuYWx5dGljcy5cclxuICpcclxuICogQHBhcmFtIGN1c3RvbVBhcmFtcyBBbnkgY3VzdG9tIHBhcmFtcyB0aGUgdXNlciBtYXkgcGFzcyB0byBndGFnLmpzLlxyXG4gKi9cclxuZnVuY3Rpb24gX3NldERlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KGN1c3RvbVBhcmFtcykge1xyXG4gICAgZGVmYXVsdEV2ZW50UGFyYW1ldGVyc0ZvckluaXQgPSBjdXN0b21QYXJhbXM7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREIoKSB7XHJcbiAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICBsb2dnZXIud2FybihFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImluZGV4ZWRkYi11bmF2YWlsYWJsZVwiIC8qIEFuYWx5dGljc0Vycm9yLklOREVYRUREQl9VTkFWQUlMQUJMRSAqLywge1xyXG4gICAgICAgICAgICBlcnJvckluZm86ICdJbmRleGVkREIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LidcclxuICAgICAgICB9KS5tZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5kZXhlZGRiLXVuYXZhaWxhYmxlXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5ERVhFRERCX1VOQVZBSUxBQkxFICovLCB7XHJcbiAgICAgICAgICAgICAgICBlcnJvckluZm86IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50b1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIGFuYWx5dGljcyBpbnN0YW5jZSBpbiBndGFnLmpzIGJ5IGNhbGxpbmcgY29uZmlnIGNvbW1hbmQgd2l0aCBmaWQuXHJcbiAqXHJcbiAqIE5PVEU6IFdlIGNvbWJpbmUgYW5hbHl0aWNzIGluaXRpYWxpemF0aW9uIGFuZCBzZXR0aW5nIGZpZCB0b2dldGhlciBiZWNhdXNlIHdlIHdhbnQgZmlkIHRvIGJlXHJcbiAqIHBhcnQgb2YgdGhlIGBwYWdlX3ZpZXdgIGV2ZW50IHRoYXQncyBzZW50IGR1cmluZyB0aGUgaW5pdGlhbGl6YXRpb25cclxuICogQHBhcmFtIGFwcCBGaXJlYmFzZSBhcHBcclxuICogQHBhcmFtIGd0YWdDb3JlIFRoZSBndGFnIGZ1bmN0aW9uIHRoYXQncyBub3Qgd3JhcHBlZC5cclxuICogQHBhcmFtIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgQXJyYXkgb2YgYWxsIGR5bmFtaWMgY29uZmlnIHByb21pc2VzLlxyXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZFRvQXBwSWQgTWFwcyBtZWFzdXJlbWVudElEIHRvIGFwcElELlxyXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyBfRmlyZWJhc2VJbnN0YWxsYXRpb25zSW50ZXJuYWwgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZXR1cm5zIE1lYXN1cmVtZW50IElELlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVBbmFseXRpY3MoYXBwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkVG9BcHBJZCwgaW5zdGFsbGF0aW9ucywgZ3RhZ0NvcmUsIGRhdGFMYXllck5hbWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGR5bmFtaWNDb25maWdQcm9taXNlID0gZmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5KGFwcCk7XHJcbiAgICAvLyBPbmNlIGZldGNoZWQsIG1hcCBtZWFzdXJlbWVudElkcyB0byBhcHBJZCwgZm9yIGVhc2Ugb2YgbG9va3VwIGluIHdyYXBwZWQgZ3RhZyBmdW5jdGlvbi5cclxuICAgIGR5bmFtaWNDb25maWdQcm9taXNlXHJcbiAgICAgICAgLnRoZW4oY29uZmlnID0+IHtcclxuICAgICAgICBtZWFzdXJlbWVudElkVG9BcHBJZFtjb25maWcubWVhc3VyZW1lbnRJZF0gPSBjb25maWcuYXBwSWQ7XHJcbiAgICAgICAgaWYgKGFwcC5vcHRpb25zLm1lYXN1cmVtZW50SWQgJiZcclxuICAgICAgICAgICAgY29uZmlnLm1lYXN1cmVtZW50SWQgIT09IGFwcC5vcHRpb25zLm1lYXN1cmVtZW50SWQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBtZWFzdXJlbWVudCBJRCBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnICgke2FwcC5vcHRpb25zLm1lYXN1cmVtZW50SWR9KWAgK1xyXG4gICAgICAgICAgICAgICAgYCBkb2VzIG5vdCBtYXRjaCB0aGUgbWVhc3VyZW1lbnQgSUQgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIgKCR7Y29uZmlnLm1lYXN1cmVtZW50SWR9KS5gICtcclxuICAgICAgICAgICAgICAgIGAgVG8gZW5zdXJlIGFuYWx5dGljcyBldmVudHMgYXJlIGFsd2F5cyBzZW50IHRvIHRoZSBjb3JyZWN0IEFuYWx5dGljcyBwcm9wZXJ0eSxgICtcclxuICAgICAgICAgICAgICAgIGAgdXBkYXRlIHRoZWAgK1xyXG4gICAgICAgICAgICAgICAgYCBtZWFzdXJlbWVudCBJRCBmaWVsZCBpbiB0aGUgbG9jYWwgY29uZmlnIG9yIHJlbW92ZSBpdCBmcm9tIHRoZSBsb2NhbCBjb25maWcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgICAgICAuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoZSkpO1xyXG4gICAgLy8gQWRkIHRvIGxpc3QgdG8gdHJhY2sgc3RhdGUgb2YgYWxsIGR5bmFtaWMgY29uZmlnIHByb21pc2VzLlxyXG4gICAgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdC5wdXNoKGR5bmFtaWNDb25maWdQcm9taXNlKTtcclxuICAgIGNvbnN0IGZpZFByb21pc2UgPSB2YWxpZGF0ZUluZGV4ZWREQigpLnRoZW4oZW52SXNWYWxpZCA9PiB7XHJcbiAgICAgICAgaWYgKGVudklzVmFsaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbGxhdGlvbnMuZ2V0SWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbZHluYW1pY0NvbmZpZywgZmlkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICBkeW5hbWljQ29uZmlnUHJvbWlzZSxcclxuICAgICAgICBmaWRQcm9taXNlXHJcbiAgICBdKTtcclxuICAgIC8vIERldGVjdCBpZiB1c2VyIGhhcyBhbHJlYWR5IHB1dCB0aGUgZ3RhZyA8c2NyaXB0PiB0YWcgb24gdGhpcyBwYWdlIHdpdGggdGhlIHBhc3NlZCBpblxyXG4gICAgLy8gZGF0YSBsYXllciBuYW1lLlxyXG4gICAgaWYgKCFmaW5kR3RhZ1NjcmlwdE9uUGFnZShkYXRhTGF5ZXJOYW1lKSkge1xyXG4gICAgICAgIGluc2VydFNjcmlwdFRhZyhkYXRhTGF5ZXJOYW1lLCBkeW5hbWljQ29uZmlnLm1lYXN1cmVtZW50SWQpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0cyBpZiB0aGVyZSBhcmUgY29uc2VudCBzZXR0aW5ncyB0aGF0IG5lZWQgdG8gYmUgY29uZmlndXJlZC5cclxuICAgIGlmIChkZWZhdWx0Q29uc2VudFNldHRpbmdzRm9ySW5pdCkge1xyXG4gICAgICAgIGd0YWdDb3JlKFwiY29uc2VudFwiIC8qIEd0YWdDb21tYW5kLkNPTlNFTlQgKi8sICdkZWZhdWx0JywgZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXQpO1xyXG4gICAgICAgIF9zZXRDb25zZW50RGVmYXVsdEZvckluaXQodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgY29tbWFuZCBpbml0aWFsaXplcyBndGFnLmpzIGFuZCBvbmx5IG5lZWRzIHRvIGJlIGNhbGxlZCBvbmNlIGZvciB0aGUgZW50aXJlIHdlYiBhcHAsXHJcbiAgICAvLyBidXQgc2luY2UgaXQgaXMgaWRlbXBvdGVudCwgd2UgY2FuIGNhbGwgaXQgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAvLyBXZSBrZWVwIGl0IHRvZ2V0aGVyIHdpdGggb3RoZXIgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGJldHRlciBjb2RlIHN0cnVjdHVyZS5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBndGFnQ29yZSgnanMnLCBuZXcgRGF0ZSgpKTtcclxuICAgIC8vIFVzZXIgY29uZmlnIGFkZGVkIGZpcnN0LiBXZSBkb24ndCB3YW50IHVzZXJzIHRvIGFjY2lkZW50YWxseSBvdmVyd3JpdGVcclxuICAgIC8vIGJhc2UgRmlyZWJhc2UgY29uZmlnIHByb3BlcnRpZXMuXHJcbiAgICBjb25zdCBjb25maWdQcm9wZXJ0aWVzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbmZpZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbiAgICAvLyBndWFyZCBhZ2FpbnN0IGRldmVsb3BlcnMgYWNjaWRlbnRhbGx5IHNldHRpbmcgcHJvcGVydGllcyB3aXRoIHByZWZpeCBgZmlyZWJhc2VfYFxyXG4gICAgY29uZmlnUHJvcGVydGllc1tPUklHSU5fS0VZXSA9ICdmaXJlYmFzZSc7XHJcbiAgICBjb25maWdQcm9wZXJ0aWVzLnVwZGF0ZSA9IHRydWU7XHJcbiAgICBpZiAoZmlkICE9IG51bGwpIHtcclxuICAgICAgICBjb25maWdQcm9wZXJ0aWVzW0dBX0ZJRF9LRVldID0gZmlkO1xyXG4gICAgfVxyXG4gICAgLy8gSXQgc2hvdWxkIGJlIHRoZSBmaXJzdCBjb25maWcgY29tbWFuZCBjYWxsZWQgb24gdGhpcyBHQS1JRFxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGlzIEdBLUlEIGFuZCBzZXQgRklEIG9uIGl0IHVzaW5nIHRoZSBndGFnIGNvbmZpZyBBUEkuXHJcbiAgICAvLyBOb3RlOiBUaGlzIHdpbGwgdHJpZ2dlciBhIHBhZ2VfdmlldyBldmVudCB1bmxlc3MgJ3NlbmRfcGFnZV92aWV3JyBpcyBzZXQgdG8gZmFsc2UgaW5cclxuICAgIC8vIGBjb25maWdQcm9wZXJ0aWVzYC5cclxuICAgIGd0YWdDb3JlKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBkeW5hbWljQ29uZmlnLm1lYXN1cmVtZW50SWQsIGNvbmZpZ1Byb3BlcnRpZXMpO1xyXG4gICAgLy8gRGV0ZWN0cyBpZiB0aGVyZSBpcyBkYXRhIHRoYXQgd2lsbCBiZSBzZXQgb24gZXZlcnkgZXZlbnQgbG9nZ2VkIGZyb20gdGhlIFNESy5cclxuICAgIGlmIChkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdCkge1xyXG4gICAgICAgIGd0YWdDb3JlKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCBkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdCk7XHJcbiAgICAgICAgX3NldERlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHluYW1pY0NvbmZpZy5tZWFzdXJlbWVudElkO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbmFseXRpY3MgU2VydmljZSBjbGFzcy5cclxuICovXHJcbmNsYXNzIEFuYWx5dGljc1NlcnZpY2Uge1xyXG4gICAgY29uc3RydWN0b3IoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGRlbGV0ZSBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW3RoaXMuYXBwLm9wdGlvbnMuYXBwSWRdO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFwcyBhcHBJZCB0byBmdWxsIGluaXRpYWxpemF0aW9uIHByb21pc2UuIFdyYXBwZWQgZ3RhZyBjYWxscyBtdXN0IHdhaXQgb25cclxuICogYWxsIG9yIHNvbWUgb2YgdGhlc2UsIGRlcGVuZGluZyBvbiB0aGUgY2FsbCdzIGBzZW5kX3RvYCBwYXJhbSBhbmQgdGhlIHN0YXR1c1xyXG4gKiBvZiB0aGUgZHluYW1pYyBjb25maWcgZmV0Y2hlcyAoc2VlIGJlbG93KS5cclxuICovXHJcbmxldCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwID0ge307XHJcbi8qKlxyXG4gKiBMaXN0IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLiBJbiBjZXJ0YWluIGNhc2VzLCB3cmFwcGVkIGd0YWcgY2FsbHNcclxuICogd2FpdCBvbiBhbGwgdGhlc2UgdG8gYmUgY29tcGxldGUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIGl0IGNhbiBzZWxlY3RpdmVseVxyXG4gKiB3YWl0IGZvciBvbmx5IGNlcnRhaW4gaW5pdGlhbGl6YXRpb24gKEZJRCkgcHJvbWlzZXMgb3IgaWYgaXQgbXVzdCB3YWl0IGZvciBhbGwuXHJcbiAqL1xyXG5sZXQgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCA9IFtdO1xyXG4vKipcclxuICogTWFwcyBmZXRjaGVkIG1lYXN1cmVtZW50SWRzIHRvIGFwcElkLiBQb3B1bGF0ZWQgd2hlbiB0aGUgYXBwJ3MgZHluYW1pYyBjb25maWdcclxuICogZmV0Y2ggY29tcGxldGVzLiBJZiBhbHJlYWR5IHBvcHVsYXRlZCwgZ3RhZyBjb25maWcgY2FsbHMgY2FuIHVzZSB0aGlzIHRvXHJcbiAqIHNlbGVjdGl2ZWx5IHdhaXQgZm9yIG9ubHkgdGhpcyBhcHAncyBpbml0aWFsaXphdGlvbiBwcm9taXNlIChGSUQpIGluc3RlYWQgb2YgYWxsXHJcbiAqIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxyXG4gKi9cclxuY29uc3QgbWVhc3VyZW1lbnRJZFRvQXBwSWQgPSB7fTtcclxuLyoqXHJcbiAqIE5hbWUgZm9yIHdpbmRvdyBnbG9iYWwgZGF0YSBsYXllciBhcnJheSB1c2VkIGJ5IEdBOiBkZWZhdWx0cyB0byAnZGF0YUxheWVyJy5cclxuICovXHJcbmxldCBkYXRhTGF5ZXJOYW1lID0gJ2RhdGFMYXllcic7XHJcbi8qKlxyXG4gKiBOYW1lIGZvciB3aW5kb3cgZ2xvYmFsIGd0YWcgZnVuY3Rpb24gdXNlZCBieSBHQTogZGVmYXVsdHMgdG8gJ2d0YWcnLlxyXG4gKi9cclxubGV0IGd0YWdOYW1lID0gJ2d0YWcnO1xyXG4vKipcclxuICogUmVwcm9kdWN0aW9uIG9mIHN0YW5kYXJkIGd0YWcgZnVuY3Rpb24gb3IgcmVmZXJlbmNlIHRvIGV4aXN0aW5nXHJcbiAqIGd0YWcgZnVuY3Rpb24gb24gd2luZG93IG9iamVjdC5cclxuICovXHJcbmxldCBndGFnQ29yZUZ1bmN0aW9uO1xyXG4vKipcclxuICogV3JhcHBlciBhcm91bmQgZ3RhZyBmdW5jdGlvbiB0aGF0IGVuc3VyZXMgRklEIGlzIHNlbnQgd2l0aCBhbGxcclxuICogcmVsZXZhbnQgZXZlbnQgYW5kIGNvbmZpZyBjYWxscy5cclxuICovXHJcbmxldCB3cmFwcGVkR3RhZ0Z1bmN0aW9uO1xyXG4vKipcclxuICogRmxhZyB0byBlbnN1cmUgcGFnZSBpbml0aWFsaXphdGlvbiBzdGVwcyAoY3JlYXRpb24gb3Igd3JhcHBpbmcgb2ZcclxuICogZGF0YUxheWVyIGFuZCBndGFnIHNjcmlwdCkgYXJlIG9ubHkgcnVuIG9uY2UgcGVyIHBhZ2UgbG9hZC5cclxuICovXHJcbmxldCBnbG9iYWxJbml0RG9uZSA9IGZhbHNlO1xyXG4vKipcclxuICogQ29uZmlndXJlcyBGaXJlYmFzZSBBbmFseXRpY3MgdG8gdXNlIGN1c3RvbSBgZ3RhZ2Agb3IgYGRhdGFMYXllcmAgbmFtZXMuXHJcbiAqIEludGVuZGVkIHRvIGJlIHVzZWQgaWYgYGd0YWcuanNgIHNjcmlwdCBoYXMgYmVlbiBpbnN0YWxsZWQgb25cclxuICogdGhpcyBwYWdlIGluZGVwZW5kZW50bHkgb2YgRmlyZWJhc2UgQW5hbHl0aWNzLCBhbmQgaXMgdXNpbmcgbm9uLWRlZmF1bHRcclxuICogbmFtZXMgZm9yIGVpdGhlciB0aGUgYGd0YWdgIGZ1bmN0aW9uIG9yIGZvciBgZGF0YUxheWVyYC5cclxuICogTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGdldEFuYWx5dGljcygpYCBvciBpdCB3b24ndFxyXG4gKiBoYXZlIGFueSBlZmZlY3QuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICpcclxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZ3RhZyBhbmQgZGF0YUxheWVyIG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0dGluZ3Mob3B0aW9ucykge1xyXG4gICAgaWYgKGdsb2JhbEluaXREb25lKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQW5hbHl0aWNzRXJyb3IuQUxSRUFEWV9JTklUSUFMSVpFRCAqLyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5kYXRhTGF5ZXJOYW1lKSB7XHJcbiAgICAgICAgZGF0YUxheWVyTmFtZSA9IG9wdGlvbnMuZGF0YUxheWVyTmFtZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmd0YWdOYW1lKSB7XHJcbiAgICAgICAgZ3RhZ05hbWUgPSBvcHRpb25zLmd0YWdOYW1lO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgbm8gZW52aXJvbm1lbnQgbWlzbWF0Y2ggaXMgZm91bmQuXHJcbiAqIElmIGVudmlyb25tZW50IG1pc21hdGNoZXMgYXJlIGZvdW5kLCB0aHJvd3MgYW4gSU5WQUxJRF9BTkFMWVRJQ1NfQ09OVEVYVFxyXG4gKiBlcnJvciB0aGF0IGFsc28gbGlzdHMgZGV0YWlscyBmb3IgZWFjaCBtaXNtYXRjaCBmb3VuZC5cclxuICovXHJcbmZ1bmN0aW9uIHdhcm5PbkJyb3dzZXJDb250ZXh0TWlzbWF0Y2goKSB7XHJcbiAgICBjb25zdCBtaXNtYXRjaGVkRW52TWVzc2FnZXMgPSBbXTtcclxuICAgIGlmIChpc0Jyb3dzZXJFeHRlbnNpb24oKSkge1xyXG4gICAgICAgIG1pc21hdGNoZWRFbnZNZXNzYWdlcy5wdXNoKCdUaGlzIGlzIGEgYnJvd3NlciBleHRlbnNpb24gZW52aXJvbm1lbnQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFyZUNvb2tpZXNFbmFibGVkKCkpIHtcclxuICAgICAgICBtaXNtYXRjaGVkRW52TWVzc2FnZXMucHVzaCgnQ29va2llcyBhcmUgbm90IGF2YWlsYWJsZS4nKTtcclxuICAgIH1cclxuICAgIGlmIChtaXNtYXRjaGVkRW52TWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBtaXNtYXRjaGVkRW52TWVzc2FnZXNcclxuICAgICAgICAgICAgLm1hcCgobWVzc2FnZSwgaW5kZXgpID0+IGAoJHtpbmRleCArIDF9KSAke21lc3NhZ2V9YClcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICBjb25zdCBlcnIgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtYW5hbHl0aWNzLWNvbnRleHRcIiAvKiBBbmFseXRpY3NFcnJvci5JTlZBTElEX0FOQUxZVElDU19DT05URVhUICovLCB7XHJcbiAgICAgICAgICAgIGVycm9ySW5mbzogZGV0YWlsc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxvZ2dlci53YXJuKGVyci5tZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW5hbHl0aWNzIGluc3RhbmNlIGZhY3RvcnkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZmFjdG9yeShhcHAsIGluc3RhbGxhdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHdhcm5PbkJyb3dzZXJDb250ZXh0TWlzbWF0Y2goKTtcclxuICAgIGNvbnN0IGFwcElkID0gYXBwLm9wdGlvbnMuYXBwSWQ7XHJcbiAgICBpZiAoIWFwcElkKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHAtaWRcIiAvKiBBbmFseXRpY3NFcnJvci5OT19BUFBfSUQgKi8pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhcHAub3B0aW9ucy5hcGlLZXkpIHtcclxuICAgICAgICBpZiAoYXBwLm9wdGlvbnMubWVhc3VyZW1lbnRJZCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIFwiYXBpS2V5XCIgZmllbGQgaXMgZW1wdHkgaW4gdGhlIGxvY2FsIEZpcmViYXNlIGNvbmZpZy4gVGhpcyBpcyBuZWVkZWQgdG8gZmV0Y2ggdGhlIGxhdGVzdGAgK1xyXG4gICAgICAgICAgICAgICAgYCBtZWFzdXJlbWVudCBJRCBmb3IgdGhpcyBGaXJlYmFzZSBhcHAuIEZhbGxpbmcgYmFjayB0byB0aGUgbWVhc3VyZW1lbnQgSUQgJHthcHAub3B0aW9ucy5tZWFzdXJlbWVudElkfWAgK1xyXG4gICAgICAgICAgICAgICAgYCBwcm92aWRlZCBpbiB0aGUgXCJtZWFzdXJlbWVudElkXCIgZmllbGQgaW4gdGhlIGxvY2FsIEZpcmViYXNlIGNvbmZpZy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBpLWtleVwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0FQSV9LRVkgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FwcElkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhbHJlYWR5LWV4aXN0c1wiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfRVhJU1RTICovLCB7XHJcbiAgICAgICAgICAgIGlkOiBhcHBJZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFnbG9iYWxJbml0RG9uZSkge1xyXG4gICAgICAgIC8vIFN0ZXBzIGhlcmUgc2hvdWxkIG9ubHkgYmUgZG9uZSBvbmNlIHBlciBwYWdlOiBjcmVhdGlvbiBvciB3cmFwcGluZ1xyXG4gICAgICAgIC8vIG9mIGRhdGFMYXllciBhbmQgZ2xvYmFsIGd0YWcgZnVuY3Rpb24uXHJcbiAgICAgICAgZ2V0T3JDcmVhdGVEYXRhTGF5ZXIoZGF0YUxheWVyTmFtZSk7XHJcbiAgICAgICAgY29uc3QgeyB3cmFwcGVkR3RhZywgZ3RhZ0NvcmUgfSA9IHdyYXBPckNyZWF0ZUd0YWcoaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIGRhdGFMYXllck5hbWUsIGd0YWdOYW1lKTtcclxuICAgICAgICB3cmFwcGVkR3RhZ0Z1bmN0aW9uID0gd3JhcHBlZEd0YWc7XHJcbiAgICAgICAgZ3RhZ0NvcmVGdW5jdGlvbiA9IGd0YWdDb3JlO1xyXG4gICAgICAgIGdsb2JhbEluaXREb25lID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIEFzeW5jIGJ1dCBub24tYmxvY2tpbmcuXHJcbiAgICAvLyBUaGlzIG1hcCByZWZsZWN0cyB0aGUgY29tcGxldGlvbiBzdGF0ZSBvZiBhbGwgcHJvbWlzZXMgZm9yIGVhY2ggYXBwSWQuXHJcbiAgICBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FwcElkXSA9IF9pbml0aWFsaXplQW5hbHl0aWNzKGFwcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIGluc3RhbGxhdGlvbnMsIGd0YWdDb3JlRnVuY3Rpb24sIGRhdGFMYXllck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgYW5hbHl0aWNzSW5zdGFuY2UgPSBuZXcgQW5hbHl0aWNzU2VydmljZShhcHApO1xyXG4gICAgcmV0dXJuIGFuYWx5dGljc0luc3RhbmNlO1xyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYW4ge0BsaW5rIEFuYWx5dGljc30gaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcHAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gdG8gdXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QW5hbHl0aWNzKGFwcCA9IGdldEFwcCgpKSB7XHJcbiAgICBhcHAgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXBwKTtcclxuICAgIC8vIERlcGVuZGVuY2llc1xyXG4gICAgY29uc3QgYW5hbHl0aWNzUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCBBTkFMWVRJQ1NfVFlQRSk7XHJcbiAgICBpZiAoYW5hbHl0aWNzUHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFuYWx5dGljc1Byb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluaXRpYWxpemVBbmFseXRpY3MoYXBwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiB7QGxpbmsgQW5hbHl0aWNzfSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFwcC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSB0byB1c2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQW5hbHl0aWNzKGFwcCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIGNvbnN0IGFuYWx5dGljc1Byb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgQU5BTFlUSUNTX1RZUEUpO1xyXG4gICAgaWYgKGFuYWx5dGljc1Byb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBhbmFseXRpY3NQcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGFuYWx5dGljc1Byb3ZpZGVyLmdldE9wdGlvbnMoKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBbmFseXRpY3NFcnJvci5BTFJFQURZX0lOSVRJQUxJWkVEICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBhbmFseXRpY3NJbnN0YW5jZSA9IGFuYWx5dGljc1Byb3ZpZGVyLmluaXRpYWxpemUoeyBvcHRpb25zIH0pO1xyXG4gICAgcmV0dXJuIGFuYWx5dGljc0luc3RhbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgcHVibGljIHN0YXRpYyBtZXRob2QgcHJvdmlkZWQgdG8gdXNlcnMgdGhhdCB3cmFwcyBmb3VyIGRpZmZlcmVudCBjaGVja3M6XHJcbiAqXHJcbiAqIDEuIENoZWNrIGlmIGl0J3Mgbm90IGEgYnJvd3NlciBleHRlbnNpb24gZW52aXJvbm1lbnQuXHJcbiAqIDIuIENoZWNrIGlmIGNvb2tpZXMgYXJlIGVuYWJsZWQgaW4gY3VycmVudCBicm93c2VyLlxyXG4gKiAzLiBDaGVjayBpZiBJbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIGVudmlyb25tZW50LlxyXG4gKiA0LiBDaGVjayBpZiB0aGUgY3VycmVudCBicm93c2VyIGNvbnRleHQgaXMgdmFsaWQgZm9yIHVzaW5nIGBJbmRleGVkREIub3BlbigpYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICBpZiAoaXNCcm93c2VyRXh0ZW5zaW9uKCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFyZUNvb2tpZXNFbmFibGVkKCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGlzREJPcGVuYWJsZSA9IGF3YWl0IHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKTtcclxuICAgICAgICByZXR1cm4gaXNEQk9wZW5hYmxlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2UgZ3RhZyBgY29uZmlnYCBjb21tYW5kIHRvIHNldCBgc2NyZWVuX25hbWVgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgbG9nRXZlbnR9IHdpdGggYGV2ZW50TmFtZWAgYXMgJ3NjcmVlbl92aWV3JyBhbmQgYWRkIHJlbGV2YW50IGBldmVudFBhcmFtc2AuXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYW5hbHl0aWNzL3NjcmVlbnZpZXdzIHwgVHJhY2sgU2NyZWVudmlld3N9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYW5hbHl0aWNzSW5zdGFuY2UgLSBUaGUge0BsaW5rIEFuYWx5dGljc30gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBzY3JlZW5OYW1lIC0gU2NyZWVuIG5hbWUgdG8gc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3VycmVudFNjcmVlbihhbmFseXRpY3NJbnN0YW5jZSwgc2NyZWVuTmFtZSwgb3B0aW9ucykge1xyXG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xyXG4gICAgc2V0Q3VycmVudFNjcmVlbiQxKHdyYXBwZWRHdGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYW5hbHl0aWNzSW5zdGFuY2UuYXBwLm9wdGlvbnMuYXBwSWRdLCBzY3JlZW5OYW1lLCBvcHRpb25zKS5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHVuaXF1ZSBHb29nbGUgQW5hbHl0aWNzIGlkZW50aWZpZXIgZm9yIHRoZSB3ZWIgY2xpZW50LlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9nYTQvcmVmZXJlbmNlL2NvbmZpZyNjbGllbnRfaWQgfCBjbGllbnRfaWR9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IHRvIHVzZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEdvb2dsZUFuYWx5dGljc0NsaWVudElkKGFuYWx5dGljc0luc3RhbmNlKSB7XHJcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gaW50ZXJuYWxHZXRHb29nbGVBbmFseXRpY3NDbGllbnRJZCh3cmFwcGVkR3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSk7XHJcbn1cclxuLyoqXHJcbiAqIFVzZSBndGFnIGBjb25maWdgIGNvbW1hbmQgdG8gc2V0IGB1c2VyX2lkYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBAcGFyYW0gYW5hbHl0aWNzSW5zdGFuY2UgLSBUaGUge0BsaW5rIEFuYWx5dGljc30gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBpZCAtIFVzZXIgSUQgdG8gc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VXNlcklkKGFuYWx5dGljc0luc3RhbmNlLCBpZCwgb3B0aW9ucykge1xyXG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xyXG4gICAgc2V0VXNlcklkJDEod3JhcHBlZEd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFthbmFseXRpY3NJbnN0YW5jZS5hcHAub3B0aW9ucy5hcHBJZF0sIGlkLCBvcHRpb25zKS5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XHJcbn1cclxuLyoqXHJcbiAqIFVzZSBndGFnIGBjb25maWdgIGNvbW1hbmQgdG8gc2V0IGFsbCBwYXJhbXMgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRVc2VyUHJvcGVydGllcyhhbmFseXRpY3NJbnN0YW5jZSwgcHJvcGVydGllcywgb3B0aW9ucykge1xyXG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xyXG4gICAgc2V0VXNlclByb3BlcnRpZXMkMSh3cmFwcGVkR3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSwgcHJvcGVydGllcywgb3B0aW9ucykuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHdoZXRoZXIgR29vZ2xlIEFuYWx5dGljcyBjb2xsZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoaXMgYXBwIG9uIHRoaXMgZGV2aWNlLlxyXG4gKiBTZXRzIGdsb2JhbCBgd2luZG93WydnYS1kaXNhYmxlLWFuYWx5dGljc0lkJ10gPSB0cnVlO2BcclxuICpcclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBAcGFyYW0gYW5hbHl0aWNzSW5zdGFuY2UgLSBUaGUge0BsaW5rIEFuYWx5dGljc30gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbmFibGVkIC0gSWYgdHJ1ZSwgZW5hYmxlcyBjb2xsZWN0aW9uLCBpZiBmYWxzZSwgZGlzYWJsZXMgaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRBbmFseXRpY3NDb2xsZWN0aW9uRW5hYmxlZChhbmFseXRpY3NJbnN0YW5jZSwgZW5hYmxlZCkge1xyXG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xyXG4gICAgc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQkMShpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSwgZW5hYmxlZCkuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGRhdGEgdGhhdCB3aWxsIGJlIHNldCBvbiBldmVyeSBldmVudCBsb2dnZWQgZnJvbSB0aGUgU0RLLCBpbmNsdWRpbmcgYXV0b21hdGljIG9uZXMuXHJcbiAqIFdpdGggZ3RhZydzIFwic2V0XCIgY29tbWFuZCwgdGhlIHZhbHVlcyBwYXNzZWQgcGVyc2lzdCBvbiB0aGUgY3VycmVudCBwYWdlIGFuZCBhcmUgcGFzc2VkIHdpdGhcclxuICogYWxsIHN1YnNlcXVlbnQgZXZlbnRzLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBjdXN0b21QYXJhbXMgLSBBbnkgY3VzdG9tIHBhcmFtcyB0aGUgdXNlciBtYXkgcGFzcyB0byBndGFnLmpzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGVmYXVsdEV2ZW50UGFyYW1ldGVycyhjdXN0b21QYXJhbXMpIHtcclxuICAgIC8vIENoZWNrIGlmIHJlZmVyZW5jZSB0byBleGlzdGluZyBndGFnIGZ1bmN0aW9uIG9uIHdpbmRvdyBvYmplY3QgZXhpc3RzXHJcbiAgICBpZiAod3JhcHBlZEd0YWdGdW5jdGlvbikge1xyXG4gICAgICAgIHdyYXBwZWRHdGFnRnVuY3Rpb24oXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIGN1c3RvbVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBfc2V0RGVmYXVsdEV2ZW50UGFyYW1ldGVyc0ZvckluaXQoY3VzdG9tUGFyYW1zKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2VuZHMgYSBHb29nbGUgQW5hbHl0aWNzIGV2ZW50IHdpdGggZ2l2ZW4gYGV2ZW50UGFyYW1zYC4gVGhpcyBtZXRob2RcclxuICogYXV0b21hdGljYWxseSBhc3NvY2lhdGVzIHRoaXMgbG9nZ2VkIGV2ZW50IHdpdGggdGhpcyBGaXJlYmFzZSB3ZWJcclxuICogYXBwIGluc3RhbmNlIG9uIHRoaXMgZGV2aWNlLlxyXG4gKiBMaXN0IG9mIG9mZmljaWFsIGV2ZW50IHBhcmFtZXRlcnMgY2FuIGJlIGZvdW5kIGluIHRoZSBndGFnLmpzXHJcbiAqIHJlZmVyZW5jZSBkb2N1bWVudGF0aW9uOlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vZ3RhZ2pzL3JlZmVyZW5jZS9nYTQtZXZlbnRzXHJcbiAqIHwgdGhlIEdBNCByZWZlcmVuY2UgZG9jdW1lbnRhdGlvbn0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGxvZ0V2ZW50KGFuYWx5dGljc0luc3RhbmNlLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XHJcbiAgICBsb2dFdmVudCQxKHdyYXBwZWRHdGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYW5hbHl0aWNzSW5zdGFuY2UuYXBwLm9wdGlvbnMuYXBwSWRdLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKS5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgdGhlIGFwcGxpY2FibGUgZW5kIHVzZXIgY29uc2VudCBzdGF0ZSBmb3IgdGhpcyB3ZWIgYXBwIGFjcm9zcyBhbGwgZ3RhZyByZWZlcmVuY2VzIG9uY2VcclxuICogRmlyZWJhc2UgQW5hbHl0aWNzIGlzIGluaXRpYWxpemVkLlxyXG4gKlxyXG4gKiBVc2UgdGhlIHtAbGluayBDb25zZW50U2V0dGluZ3N9IHRvIHNwZWNpZnkgaW5kaXZpZHVhbCBjb25zZW50IHR5cGUgdmFsdWVzLiBCeSBkZWZhdWx0IGNvbnNlbnRcclxuICogdHlwZXMgYXJlIHNldCB0byBcImdyYW50ZWRcIi5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gY29uc2VudFNldHRpbmdzIC0gTWFwcyB0aGUgYXBwbGljYWJsZSBlbmQgdXNlciBjb25zZW50IHN0YXRlIGZvciBndGFnLmpzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q29uc2VudChjb25zZW50U2V0dGluZ3MpIHtcclxuICAgIC8vIENoZWNrIGlmIHJlZmVyZW5jZSB0byBleGlzdGluZyBndGFnIGZ1bmN0aW9uIG9uIHdpbmRvdyBvYmplY3QgZXhpc3RzXHJcbiAgICBpZiAod3JhcHBlZEd0YWdGdW5jdGlvbikge1xyXG4gICAgICAgIHdyYXBwZWRHdGFnRnVuY3Rpb24oXCJjb25zZW50XCIgLyogR3RhZ0NvbW1hbmQuQ09OU0VOVCAqLywgJ3VwZGF0ZScsIGNvbnNlbnRTZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBfc2V0Q29uc2VudERlZmF1bHRGb3JJbml0KGNvbnNlbnRTZXR0aW5ncyk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2FuYWx5dGljc1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xMC42XCI7XG5cbi8qKlxyXG4gKiBUaGUgRmlyZWJhc2UgQW5hbHl0aWNzIFdlYiBTREsuXHJcbiAqIFRoaXMgU0RLIGRvZXMgbm90IHdvcmsgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LlxyXG4gKlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQW5hbHl0aWNzKCkge1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoQU5BTFlUSUNTX1RZUEUsIChjb250YWluZXIsIHsgb3B0aW9uczogYW5hbHl0aWNzT3B0aW9ucyB9KSA9PiB7XHJcbiAgICAgICAgLy8gZ2V0SW1tZWRpYXRlIGZvciBGaXJlYmFzZUFwcCB3aWxsIGFsd2F5cyBzdWNjZWVkXHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsYXRpb25zID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcignaW5zdGFsbGF0aW9ucy1pbnRlcm5hbCcpXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICByZXR1cm4gZmFjdG9yeShhcHAsIGluc3RhbGxhdGlvbnMsIGFuYWx5dGljc09wdGlvbnMpO1xyXG4gICAgfSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FuYWx5dGljcy1pbnRlcm5hbCcsIGludGVybmFsRmFjdG9yeSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbik7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XHJcbiAgICBmdW5jdGlvbiBpbnRlcm5hbEZhY3RvcnkoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYW5hbHl0aWNzID0gY29udGFpbmVyLmdldFByb3ZpZGVyKEFOQUxZVElDU19UWVBFKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxvZ0V2ZW50OiAoZXZlbnROYW1lLCBldmVudFBhcmFtcywgb3B0aW9ucykgPT4gbG9nRXZlbnQoYW5hbHl0aWNzLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludGVyb3AtY29tcG9uZW50LXJlZy1mYWlsZWRcIiAvKiBBbmFseXRpY3NFcnJvci5JTlRFUk9QX0NPTVBPTkVOVF9SRUdfRkFJTEVEICovLCB7XHJcbiAgICAgICAgICAgICAgICByZWFzb246IGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnJlZ2lzdGVyQW5hbHl0aWNzKCk7XG5cbmV4cG9ydCB7IGdldEFuYWx5dGljcywgZ2V0R29vZ2xlQW5hbHl0aWNzQ2xpZW50SWQsIGluaXRpYWxpemVBbmFseXRpY3MsIGlzU3VwcG9ydGVkLCBsb2dFdmVudCwgc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQsIHNldENvbnNlbnQsIHNldEN1cnJlbnRTY3JlZW4sIHNldERlZmF1bHRFdmVudFBhcmFtZXRlcnMsIHNldFVzZXJJZCwgc2V0VXNlclByb3BlcnRpZXMsIHNldHRpbmdzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass PlatformLoggerServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n    }\r\n    // In initial implementation, this will be called by installations on\r\n    // auth token refresh, and installations will send this string.\r\n    getPlatformInfoString() {\r\n        const providers = this.container.getProviders();\r\n        // Loop through providers and get library/version pairs from any that are\r\n        // version components.\r\n        return providers\r\n            .map(provider => {\r\n            if (isVersionServiceProvider(provider)) {\r\n                const service = provider.getImmediate();\r\n                return `${service.library}/${service.version}`;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        })\r\n            .filter(logString => logString)\r\n            .join(' ');\r\n    }\r\n}\r\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\r\nfunction isVersionServiceProvider(provider) {\r\n    const component = provider.getComponent();\r\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\r\n}\n\nconst name$p = \"@firebase/app\";\nconst version$1 = \"0.10.7\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$o = \"@firebase/app-compat\";\n\nconst name$n = \"@firebase/analytics-compat\";\n\nconst name$m = \"@firebase/analytics\";\n\nconst name$l = \"@firebase/app-check-compat\";\n\nconst name$k = \"@firebase/app-check\";\n\nconst name$j = \"@firebase/auth\";\n\nconst name$i = \"@firebase/auth-compat\";\n\nconst name$h = \"@firebase/database\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai-preview\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"10.12.4\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The default app name\r\n *\r\n * @internal\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\r\nconst PLATFORM_LOG_STRING = {\r\n    [name$p]: 'fire-core',\r\n    [name$o]: 'fire-core-compat',\r\n    [name$m]: 'fire-analytics',\r\n    [name$n]: 'fire-analytics-compat',\r\n    [name$k]: 'fire-app-check',\r\n    [name$l]: 'fire-app-check-compat',\r\n    [name$j]: 'fire-auth',\r\n    [name$i]: 'fire-auth-compat',\r\n    [name$h]: 'fire-rtdb',\r\n    [name$g]: 'fire-rtdb-compat',\r\n    [name$f]: 'fire-fn',\r\n    [name$e]: 'fire-fn-compat',\r\n    [name$d]: 'fire-iid',\r\n    [name$c]: 'fire-iid-compat',\r\n    [name$b]: 'fire-fcm',\r\n    [name$a]: 'fire-fcm-compat',\r\n    [name$9]: 'fire-perf',\r\n    [name$8]: 'fire-perf-compat',\r\n    [name$7]: 'fire-rc',\r\n    [name$6]: 'fire-rc-compat',\r\n    [name$5]: 'fire-gcs',\r\n    [name$4]: 'fire-gcs-compat',\r\n    [name$3]: 'fire-fst',\r\n    [name$1]: 'fire-fst-compat',\r\n    [name$2]: 'fire-vertex',\r\n    'fire-js': 'fire-js',\r\n    [name]: 'fire-js-all'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nconst _apps = new Map();\r\n/**\r\n * @internal\r\n */\r\nconst _serverApps = new Map();\r\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst _components = new Map();\r\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */\r\nfunction _addComponent(app, component) {\r\n    try {\r\n        app.container.addComponent(component);\r\n    }\r\n    catch (e) {\r\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n */\r\nfunction _addOrOverwriteComponent(app, component) {\r\n    app.container.addOrOverwriteComponent(component);\r\n}\r\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */\r\nfunction _registerComponent(component) {\r\n    const componentName = component.name;\r\n    if (_components.has(componentName)) {\r\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\r\n        return false;\r\n    }\r\n    _components.set(componentName, component);\r\n    // add the component to existing app instances\r\n    for (const app of _apps.values()) {\r\n        _addComponent(app, component);\r\n    }\r\n    for (const serverApp of _serverApps.values()) {\r\n        _addComponent(serverApp, component);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */\r\nfunction _getProvider(app, name) {\r\n    const heartbeatController = app.container\r\n        .getProvider('heartbeat')\r\n        .getImmediate({ optional: true });\r\n    if (heartbeatController) {\r\n        void heartbeatController.triggerHeartbeat();\r\n    }\r\n    return app.container.getProvider(name);\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */\r\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\r\n    _getProvider(app, name).clearInstance(instanceIdentifier);\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseApp(obj) {\r\n    return obj.options !== undefined;\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseServerApp(obj) {\r\n    return obj.settings !== undefined;\r\n}\r\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */\r\nfunction _clearComponents() {\r\n    _components.clear();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\r\n        'call initializeApp() first',\r\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\r\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\r\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\r\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\r\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\r\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\r\n        'Firebase App instance.',\r\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\r\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\r\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\r\n};\r\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseAppImpl {\r\n    constructor(options, config, container) {\r\n        this._isDeleted = false;\r\n        this._options = Object.assign({}, options);\r\n        this._config = Object.assign({}, config);\r\n        this._name = config.name;\r\n        this._automaticDataCollectionEnabled =\r\n            config.automaticDataCollectionEnabled;\r\n        this._container = container;\r\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    }\r\n    get automaticDataCollectionEnabled() {\r\n        this.checkDestroyed();\r\n        return this._automaticDataCollectionEnabled;\r\n    }\r\n    set automaticDataCollectionEnabled(val) {\r\n        this.checkDestroyed();\r\n        this._automaticDataCollectionEnabled = val;\r\n    }\r\n    get name() {\r\n        this.checkDestroyed();\r\n        return this._name;\r\n    }\r\n    get options() {\r\n        this.checkDestroyed();\r\n        return this._options;\r\n    }\r\n    get config() {\r\n        this.checkDestroyed();\r\n        return this._config;\r\n    }\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    get isDeleted() {\r\n        return this._isDeleted;\r\n    }\r\n    set isDeleted(val) {\r\n        this._isDeleted = val;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\r\n    constructor(options, serverConfig, name, container) {\r\n        // Build configuration parameters for the FirebaseAppImpl base class.\r\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\r\n            ? serverConfig.automaticDataCollectionEnabled\r\n            : false;\r\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\r\n        const config = {\r\n            name,\r\n            automaticDataCollectionEnabled\r\n        };\r\n        if (options.apiKey !== undefined) {\r\n            // Construct the parent FirebaseAppImp object.\r\n            super(options, config, container);\r\n        }\r\n        else {\r\n            const appImpl = options;\r\n            super(appImpl.options, config, container);\r\n        }\r\n        // Now construct the data for the FirebaseServerAppImpl.\r\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\r\n        this._finalizationRegistry = null;\r\n        if (typeof FinalizationRegistry !== 'undefined') {\r\n            this._finalizationRegistry = new FinalizationRegistry(() => {\r\n                this.automaticCleanup();\r\n            });\r\n        }\r\n        this._refCount = 0;\r\n        this.incRefCount(this._serverConfig.releaseOnDeref);\r\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegisry\r\n        // will never trigger.\r\n        this._serverConfig.releaseOnDeref = undefined;\r\n        serverConfig.releaseOnDeref = undefined;\r\n        registerVersion(name$p, version$1, 'serverapp');\r\n    }\r\n    toJSON() {\r\n        return undefined;\r\n    }\r\n    get refCount() {\r\n        return this._refCount;\r\n    }\r\n    // Increment the reference count of this server app. If an object is provided, register it\r\n    // with the finalization registry.\r\n    incRefCount(obj) {\r\n        if (this.isDeleted) {\r\n            return;\r\n        }\r\n        this._refCount++;\r\n        if (obj !== undefined && this._finalizationRegistry !== null) {\r\n            this._finalizationRegistry.register(obj, this);\r\n        }\r\n    }\r\n    // Decrement the reference count.\r\n    decRefCount() {\r\n        if (this.isDeleted) {\r\n            return 0;\r\n        }\r\n        return --this._refCount;\r\n    }\r\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\r\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\r\n    // handles this is in deleteApp(...).\r\n    automaticCleanup() {\r\n        void deleteApp(this);\r\n    }\r\n    get settings() {\r\n        this.checkDestroyed();\r\n        return this._serverConfig;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */\r\nconst SDK_VERSION = version;\r\nfunction initializeApp(_options, rawConfig = {}) {\r\n    let options = _options;\r\n    if (typeof rawConfig !== 'object') {\r\n        const name = rawConfig;\r\n        rawConfig = { name };\r\n    }\r\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\r\n    const name = config.name;\r\n    if (typeof name !== 'string' || !name) {\r\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\r\n            appName: String(name)\r\n        });\r\n    }\r\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\r\n    if (!options) {\r\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\r\n    }\r\n    const existingApp = _apps.get(name);\r\n    if (existingApp) {\r\n        // return the existing app if options and config deep equal the ones in the existing app.\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\r\n            return existingApp;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\r\n        }\r\n    }\r\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseAppImpl(options, config, container);\r\n    _apps.set(name, newApp);\r\n    return newApp;\r\n}\r\nfunction initializeServerApp(_options, _serverAppConfig) {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\r\n        // FirebaseServerApp isn't designed to be run in browsers.\r\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\r\n    }\r\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\r\n        _serverAppConfig.automaticDataCollectionEnabled = false;\r\n    }\r\n    let appOptions;\r\n    if (_isFirebaseApp(_options)) {\r\n        appOptions = _options.options;\r\n    }\r\n    else {\r\n        appOptions = _options;\r\n    }\r\n    // Build an app name based on a hash of the configuration options.\r\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\r\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\r\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\r\n    if (nameObj.releaseOnDeref !== undefined) {\r\n        delete nameObj.releaseOnDeref;\r\n    }\r\n    const hashCode = (s) => {\r\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\r\n    };\r\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\r\n        if (typeof FinalizationRegistry === 'undefined') {\r\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\r\n        }\r\n    }\r\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\r\n    const existingApp = _serverApps.get(nameString);\r\n    if (existingApp) {\r\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\r\n        return existingApp;\r\n    }\r\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\r\n    _serverApps.set(nameString, newApp);\r\n    return newApp;\r\n}\r\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */\r\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\r\n    const app = _apps.get(name);\r\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\r\n        return initializeApp();\r\n    }\r\n    if (!app) {\r\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\r\n    }\r\n    return app;\r\n}\r\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */\r\nfunction getApps() {\r\n    return Array.from(_apps.values());\r\n}\r\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */\r\nasync function deleteApp(app) {\r\n    let cleanupProviders = false;\r\n    const name = app.name;\r\n    if (_apps.has(name)) {\r\n        cleanupProviders = true;\r\n        _apps.delete(name);\r\n    }\r\n    else if (_serverApps.has(name)) {\r\n        const firebaseServerApp = app;\r\n        if (firebaseServerApp.decRefCount() <= 0) {\r\n            _serverApps.delete(name);\r\n            cleanupProviders = true;\r\n        }\r\n    }\r\n    if (cleanupProviders) {\r\n        await Promise.all(app.container\r\n            .getProviders()\r\n            .map(provider => provider.delete()));\r\n        app.isDeleted = true;\r\n    }\r\n}\r\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */\r\nfunction registerVersion(libraryKeyOrName, version, variant) {\r\n    var _a;\r\n    // TODO: We can use this check to whitelist strings when/if we set up\r\n    // a good whitelist system.\r\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\r\n    if (variant) {\r\n        library += `-${variant}`;\r\n    }\r\n    const libraryMismatch = library.match(/\\s|\\//);\r\n    const versionMismatch = version.match(/\\s|\\//);\r\n    if (libraryMismatch || versionMismatch) {\r\n        const warning = [\r\n            `Unable to register library \"${library}\" with version \"${version}\":`\r\n        ];\r\n        if (libraryMismatch) {\r\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        if (libraryMismatch && versionMismatch) {\r\n            warning.push('and');\r\n        }\r\n        if (versionMismatch) {\r\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        logger.warn(warning.join(' '));\r\n        return;\r\n    }\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\r\n}\r\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */\r\nfunction onLog(logCallback, options) {\r\n    if (logCallback !== null && typeof logCallback !== 'function') {\r\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\r\n    }\r\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\r\n}\r\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */\r\nfunction setLogLevel(logLevel) {\r\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DB_NAME = 'firebase-heartbeat-database';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'firebase-heartbeat-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        try {\r\n                            db.createObjectStore(STORE_NAME);\r\n                        }\r\n                        catch (e) {\r\n                            // Safari/iOS browsers throw occasional exceptions on\r\n                            // db.createObjectStore() that may be a bug. Avoid blocking\r\n                            // the rest of the app functionality.\r\n                            console.warn(e);\r\n                        }\r\n                }\r\n            }\r\n        }).catch(e => {\r\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\r\n                originalErrorMessage: e.message\r\n            });\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\nasync function readHeartbeatsFromIndexedDB(app) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME);\r\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\r\n        // We already have the value but tx.done can throw,\r\n        // so we need to await it here to catch errors\r\n        await tx.done;\r\n        return result;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME, 'readwrite');\r\n        const objectStore = tx.objectStore(STORE_NAME);\r\n        await objectStore.put(heartbeatObject, computeKey(app));\r\n        await tx.done;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nfunction computeKey(app) {\r\n    return `${app.name}!${app.options.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_HEADER_BYTES = 1024;\r\n// 30 days\r\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\r\nclass HeartbeatServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */\r\n        this._heartbeatsCache = null;\r\n        const app = this.container.getProvider('app').getImmediate();\r\n        this._storage = new HeartbeatStorageImpl(app);\r\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\r\n            this._heartbeatsCache = result;\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */\r\n    async triggerHeartbeat() {\r\n        var _a, _b;\r\n        const platformLogger = this.container\r\n            .getProvider('platform-logger')\r\n            .getImmediate();\r\n        // This is the \"Firebase user agent\" string from the platform logger\r\n        // service, not the browser user agent.\r\n        const agent = platformLogger.getPlatformInfoString();\r\n        const date = getUTCDateString();\r\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\r\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\r\n            // If we failed to construct a heartbeats cache, then return immediately.\r\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\r\n                return;\r\n            }\r\n        }\r\n        // Do not store a heartbeat if one is already stored for this day\r\n        // or if a header has already been sent today.\r\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\r\n            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\r\n            return;\r\n        }\r\n        else {\r\n            // There is no entry for this date. Create one.\r\n            this._heartbeatsCache.heartbeats.push({ date, agent });\r\n        }\r\n        // Remove entries older than 30 days.\r\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\r\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\r\n            const now = Date.now();\r\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\r\n        });\r\n        return this._storage.overwrite(this._heartbeatsCache);\r\n    }\r\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */\r\n    async getHeartbeatsHeader() {\r\n        var _a;\r\n        if (this._heartbeatsCache === null) {\r\n            await this._heartbeatsCachePromise;\r\n        }\r\n        // If it's still null or the array is empty, there is no data to send.\r\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\r\n            this._heartbeatsCache.heartbeats.length === 0) {\r\n            return '';\r\n        }\r\n        const date = getUTCDateString();\r\n        // Extract as many heartbeats from the cache as will fit under the size limit.\r\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\r\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\r\n        // Store last sent date to prevent another being logged/sent for the same day.\r\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\r\n        if (unsentEntries.length > 0) {\r\n            // Store any unsent entries if they exist.\r\n            this._heartbeatsCache.heartbeats = unsentEntries;\r\n            // This seems more likely than emptying the array (below) to lead to some odd state\r\n            // since the cache isn't empty and this will be called again on the next request,\r\n            // and is probably safest if we await it.\r\n            await this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        else {\r\n            this._heartbeatsCache.heartbeats = [];\r\n            // Do not wait for this, to reduce latency.\r\n            void this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        return headerString;\r\n    }\r\n}\r\nfunction getUTCDateString() {\r\n    const today = new Date();\r\n    // Returns date format 'YYYY-MM-DD'\r\n    return today.toISOString().substring(0, 10);\r\n}\r\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\r\n    // Heartbeats grouped by user agent in the standard format to be sent in\r\n    // the header.\r\n    const heartbeatsToSend = [];\r\n    // Single date format heartbeats that are not sent.\r\n    let unsentEntries = heartbeatsCache.slice();\r\n    for (const singleDateHeartbeat of heartbeatsCache) {\r\n        // Look for an existing entry with the same user agent.\r\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\r\n        if (!heartbeatEntry) {\r\n            // If no entry for this user agent exists, create one.\r\n            heartbeatsToSend.push({\r\n                agent: singleDateHeartbeat.agent,\r\n                dates: [singleDateHeartbeat.date]\r\n            });\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                // If the header would exceed max size, remove the added heartbeat\r\n                // entry and stop adding to the header.\r\n                heartbeatsToSend.pop();\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\r\n            // If the header would exceed max size, remove the added date\r\n            // and stop adding to the header.\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                heartbeatEntry.dates.pop();\r\n                break;\r\n            }\r\n        }\r\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\r\n        // quota and the loop breaks early.)\r\n        unsentEntries = unsentEntries.slice(1);\r\n    }\r\n    return {\r\n        heartbeatsToSend,\r\n        unsentEntries\r\n    };\r\n}\r\nclass HeartbeatStorageImpl {\r\n    constructor(app) {\r\n        this.app = app;\r\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\r\n    }\r\n    async runIndexedDBEnvironmentCheck() {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\r\n                .then(() => true)\r\n                .catch(() => false);\r\n        }\r\n    }\r\n    /**\r\n     * Read all heartbeats.\r\n     */\r\n    async read() {\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return { heartbeats: [] };\r\n        }\r\n        else {\r\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\r\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\r\n                return idbHeartbeatObject;\r\n            }\r\n            else {\r\n                return { heartbeats: [] };\r\n            }\r\n        }\r\n    }\r\n    // overwrite the storage with the provided heartbeats\r\n    async overwrite(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: heartbeatsObject.heartbeats\r\n            });\r\n        }\r\n    }\r\n    // add heartbeats\r\n    async add(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: [\r\n                    ...existingHeartbeatsObject.heartbeats,\r\n                    ...heartbeatsObject.heartbeats\r\n                ]\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */\r\nfunction countBytes(heartbeatsCache) {\r\n    // base64 has a restricted set of characters, all of which should be 1 byte.\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\r\n    // heartbeatsCache wrapper properties\r\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerCoreComponents(variant) {\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    // Register `app` package.\r\n    registerVersion(name$p, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name$p, version$1, 'esm2017');\r\n    // Register platform SDK identifier (no version).\r\n    registerVersion('fire-js', '');\r\n}\n\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */\r\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzBHO0FBQ3RKO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLHNDQUFzQyxTQUFTO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQSx1RUFBdUUsU0FBUztBQUNoRiwwRUFBMEUsU0FBUztBQUNuRixzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBLGlHQUFpRyxzQkFBc0I7QUFDdkgsb0dBQW9HLHNCQUFzQjtBQUMxSCxvR0FBb0csc0JBQXNCO0FBQzFILDJHQUEyRyxzQkFBc0I7QUFDakk7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFZOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMERBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHFCQUFxQjtBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG1DQUFtQyxpRUFBaUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEIsbUVBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckIsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsZUFBZTtBQUN0RztBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUyxPQUFPLDJEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtRUFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsa0JBQWtCLFFBQVE7QUFDN0U7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUyxJQUFJLFFBQVEsb0JBQW9CLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBYTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEdBQUcsa0JBQWtCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRCw2QkFBNkIsNkVBQTZCLGtCQUFrQiwwQ0FBMEM7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUVBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2RUFBNkI7QUFDeEM7QUFDQSxxQkFBcUIseUNBQXlDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQVM7QUFDcEMsMkJBQTJCLDBEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtVztBQUNuVyIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVudG9yeV9tYW5hZ21lbnQvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzAyYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgc2V0VXNlckxvZ0hhbmRsZXIsIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsJDEgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgZ2V0RGVmYXVsdEFwcENvbmZpZywgZGVlcEVxdWFsLCBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyLCBGaXJlYmFzZUVycm9yLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIC8vIEluIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgaW5zdGFsbGF0aW9ucyBvblxyXG4gICAgLy8gYXV0aCB0b2tlbiByZWZyZXNoLCBhbmQgaW5zdGFsbGF0aW9ucyB3aWxsIHNlbmQgdGhpcyBzdHJpbmcuXHJcbiAgICBnZXRQbGF0Zm9ybUluZm9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gdGhpcy5jb250YWluZXIuZ2V0UHJvdmlkZXJzKCk7XHJcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHByb3ZpZGVycyBhbmQgZ2V0IGxpYnJhcnkvdmVyc2lvbiBwYWlycyBmcm9tIGFueSB0aGF0IGFyZVxyXG4gICAgICAgIC8vIHZlcnNpb24gY29tcG9uZW50cy5cclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJzXHJcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2UubGlicmFyeX0vJHtzZXJ2aWNlLnZlcnNpb259YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihsb2dTdHJpbmcgPT4gbG9nU3RyaW5nKVxyXG4gICAgICAgICAgICAuam9pbignICcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvdmlkZXIgY2hlY2sgaWYgdGhpcyBwcm92aWRlciBwcm92aWRlcyBhIFZlcnNpb25TZXJ2aWNlXHJcbiAqXHJcbiAqIE5PVEU6IFVzaW5nIFByb3ZpZGVyPCdhcHAtdmVyc2lvbic+IGlzIGEgaGFjayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBwcm92aWRlclxyXG4gKiBwcm92aWRlcyBWZXJzaW9uU2VydmljZS4gVGhlIHByb3ZpZGVyIGlzIG5vdCBuZWNlc3NhcmlseSBhICdhcHAtdmVyc2lvbidcclxuICogcHJvdmlkZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHByb3ZpZGVyLmdldENvbXBvbmVudCgpO1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQgPT09IG51bGwgfHwgY29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnQudHlwZSkgPT09IFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLztcclxufVxuXG5jb25zdCBuYW1lJHAgPSBcIkBmaXJlYmFzZS9hcHBcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiMC4xMC43XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hcHAnKTtcblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3MtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbSA9IFwiQGZpcmViYXNlL2FuYWx5dGljc1wiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2stY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkayA9IFwiQGZpcmViYXNlL2FwcC1jaGVja1wiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hdXRoXCI7XG5cbmNvbnN0IG5hbWUkaSA9IFwiQGZpcmViYXNlL2F1dGgtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkaCA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5cbmNvbnN0IG5hbWUkZyA9IFwiQGZpcmViYXNlL2RhdGFiYXNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnNcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGQgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zXCI7XG5cbmNvbnN0IG5hbWUkYyA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYiA9IFwiQGZpcmViYXNlL21lc3NhZ2luZ1wiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkOSA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlXCI7XG5cbmNvbnN0IG5hbWUkOCA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnXCI7XG5cbmNvbnN0IG5hbWUkNiA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNSA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcblxuY29uc3QgbmFtZSQ0ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQzID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL3ZlcnRleGFpLXByZXZpZXdcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMTAuMTIuNFwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgYXBwIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcclxuY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcclxuICAgIFtuYW1lJHBdOiAnZmlyZS1jb3JlJyxcclxuICAgIFtuYW1lJG9dOiAnZmlyZS1jb3JlLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRtXTogJ2ZpcmUtYW5hbHl0aWNzJyxcclxuICAgIFtuYW1lJG5dOiAnZmlyZS1hbmFseXRpY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJGtdOiAnZmlyZS1hcHAtY2hlY2snLFxyXG4gICAgW25hbWUkbF06ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxyXG4gICAgW25hbWUkal06ICdmaXJlLWF1dGgnLFxyXG4gICAgW25hbWUkaV06ICdmaXJlLWF1dGgtY29tcGF0JyxcclxuICAgIFtuYW1lJGhdOiAnZmlyZS1ydGRiJyxcclxuICAgIFtuYW1lJGddOiAnZmlyZS1ydGRiLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRmXTogJ2ZpcmUtZm4nLFxyXG4gICAgW25hbWUkZV06ICdmaXJlLWZuLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRkXTogJ2ZpcmUtaWlkJyxcclxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQtY29tcGF0JyxcclxuICAgIFtuYW1lJGJdOiAnZmlyZS1mY20nLFxyXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbS1jb21wYXQnLFxyXG4gICAgW25hbWUkOV06ICdmaXJlLXBlcmYnLFxyXG4gICAgW25hbWUkOF06ICdmaXJlLXBlcmYtY29tcGF0JyxcclxuICAgIFtuYW1lJDddOiAnZmlyZS1yYycsXHJcbiAgICBbbmFtZSQ2XTogJ2ZpcmUtcmMtY29tcGF0JyxcclxuICAgIFtuYW1lJDVdOiAnZmlyZS1nY3MnLFxyXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcy1jb21wYXQnLFxyXG4gICAgW25hbWUkM106ICdmaXJlLWZzdCcsXHJcbiAgICBbbmFtZSQxXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXHJcbiAgICBbbmFtZSQyXTogJ2ZpcmUtdmVydGV4JyxcclxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLFxyXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xyXG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcclxuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcclxuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoc2VydmVyQXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLm9wdGlvbnMgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9J1wiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi9dOiAnRmlyZWJhc2UgU2VydmVyIEFwcCBoYXMgYmVlbiBkZWxldGVkJyxcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBkZWxldGVPbkRlcmVmIGZpZWxkIGRlZmluZWQgYnV0IHRoZSBKUyBydW50aW1lIGRvZXMgbm90IHN1cHBvcnQgRmluYWxpemF0aW9uUmVnaXN0cnkuJyxcclxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZVNlcnZlckFwcEltcGwgZXh0ZW5kcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cclxuICAgICAgICBjb25zdCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBGaXJlYmFzZUFwcFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIEZpcmViYXNlQXBwSW1wIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHBhcmVudCBGaXJlYmFzZUFwcEltcCBvYmplY3QuXHJcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0b21hdGljQ2xlYW51cCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5jUmVmQ291bnQodGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcclxuICAgICAgICAvLyBEbyBub3QgcmV0YWluIGEgaGFyZCByZWZlcmVuY2UgdG8gdGhlIGRyZWYgb2JqZWN0LCBvdGhlcndpc2UgdGhlIEZpbmFsaXphdGlvblJlZ2lzcnlcclxuICAgICAgICAvLyB3aWxsIG5ldmVyIHRyaWdnZXIuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHNlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZWdpc3RlclZlcnNpb24obmFtZSRwLCB2ZXJzaW9uJDEsICdzZXJ2ZXJhcHAnKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlZkNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEluY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgc2VydmVyIGFwcC4gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkLCByZWdpc3RlciBpdFxyXG4gICAgLy8gd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5LlxyXG4gICAgaW5jUmVmQ291bnQob2JqKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQrKztcclxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIob2JqLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudC5cclxuICAgIGRlY1JlZkNvdW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0tdGhpcy5fcmVmQ291bnQ7XHJcbiAgICB9XHJcbiAgICAvLyBJbnZva2VkIGJ5IHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeSBjYWxsYmFjayB0byBub3RlIHRoYXQgdGhpcyBhcHAgc2hvdWxkIGdvIHRocm91Z2ggaXRzXHJcbiAgICAvLyByZWZlcmVuY2UgY291bnRzIGFuZCBkZWxldGUgaXRzZWxmIGlmIG5vIHJlZmVyZW5jZSBjb3VudCByZW1haW4uIFRoZSBjb29yZGluYXRpbmcgbG9naWMgdGhhdFxyXG4gICAgLy8gaGFuZGxlcyB0aGlzIGlzIGluIGRlbGV0ZUFwcCguLi4pLlxyXG4gICAgYXV0b21hdGljQ2xlYW51cCgpIHtcclxuICAgICAgICB2b2lkIGRlbGV0ZUFwcCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCBzZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cclxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxyXG4gICAgICovXHJcbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcclxuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xyXG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XHJcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IGdldERlZmF1bHRBcHBDb25maWcoKSk7XHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cclxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXHJcbiAgICAgICAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xyXG4gICAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XHJcbiAgICByZXR1cm4gbmV3QXBwO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRpYWxpemVTZXJ2ZXJBcHAoX29wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcpIHtcclxuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhaXNXZWJXb3JrZXIoKSkge1xyXG4gICAgICAgIC8vIEZpcmViYXNlU2VydmVyQXBwIGlzbid0IGRlc2lnbmVkIHRvIGJlIHJ1biBpbiBicm93c2Vycy5cclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIF9zZXJ2ZXJBcHBDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgYXBwT3B0aW9ucztcclxuICAgIGlmIChfaXNGaXJlYmFzZUFwcChfb3B0aW9ucykpIHtcclxuICAgICAgICBhcHBPcHRpb25zID0gX29wdGlvbnMub3B0aW9ucztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIEJ1aWxkIGFuIGFwcCBuYW1lIGJhc2VkIG9uIGEgaGFzaCBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgY29uc3QgbmFtZU9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3NlcnZlckFwcENvbmZpZyksIGFwcE9wdGlvbnMpO1xyXG4gICAgLy8gSG93ZXZlciwgRG8gbm90IG1hbmdsZSB0aGUgbmFtZSBiYXNlZCBvbiByZWxlYXNlT25EZXJlZiwgc2luY2UgaXQgd2lsbCB2YXJ5IGJldHdlZW4gdGhlXHJcbiAgICAvLyBjb25zdHJ1Y3Rpb24gb2YgRmlyZWJhc2VTZXJ2ZXJBcHAgaW5zdGFuY2VzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9iamVjdCBpcyB0aGUgcmVxdWVzdCBoZWFkZXJzLlxyXG4gICAgaWYgKG5hbWVPYmoucmVsZWFzZU9uRGVyZWYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGRlbGV0ZSBuYW1lT2JqLnJlbGVhc2VPbkRlcmVmO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzaENvZGUgPSAocykgPT4ge1xyXG4gICAgICAgIHJldHVybiBbLi4uc10ucmVkdWNlKChoYXNoLCBjKSA9PiAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGMuY2hhckNvZGVBdCgwKSkgfCAwLCAwKTtcclxuICAgIH07XHJcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZVN0cmluZyA9ICcnICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkobmFtZU9iaikpO1xyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfc2VydmVyQXBwcy5nZXQobmFtZVN0cmluZyk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICBleGlzdGluZ0FwcC5pbmNSZWZDb3VudChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWVTdHJpbmcpO1xyXG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgX2NvbXBvbmVudHMudmFsdWVzKCkpIHtcclxuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdBcHAgPSBuZXcgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsKGFwcE9wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcsIG5hbWVTdHJpbmcsIGNvbnRhaW5lcik7XHJcbiAgICBfc2VydmVyQXBwcy5zZXQobmFtZVN0cmluZywgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cclxuICpcclxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxyXG4gKiBpcyBwcm92aWRlZCwgdGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cclxuICpcclxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXHJcbiAqIGluaXRpYWxpemVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiB0aGUgZGVmYXVsdCBhcHBcclxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiBhIG5hbWVkIGFwcFxyXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXHJcbiAqICAgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGBcIltERUZBVUxUXVwiYC5cclxuICpcclxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cclxuICogICBJZiBubyBhcHAgbmFtZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHAobmFtZSA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKCFhcHAgJiYgbmFtZSA9PT0gREVGQVVMVF9FTlRSWV9OQU1FICYmIGdldERlZmF1bHRBcHBDb25maWcoKSkge1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwcCkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwO1xyXG59XHJcbi8qKlxyXG4gKiBBIChyZWFkLW9ubHkpIGFycmF5IG9mIGFsbCBpbml0aWFsaXplZCBhcHBzLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHBzKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXHJcbiAqIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGRlbGV0ZUFwcChhcHApXHJcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICogICB9KVxyXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcclxuICogICB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcclxuICAgIGxldCBjbGVhbnVwUHJvdmlkZXJzID0gZmFsc2U7XHJcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XHJcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX3NlcnZlckFwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTZXJ2ZXJBcHAgPSBhcHA7XHJcbiAgICAgICAgaWYgKGZpcmViYXNlU2VydmVyQXBwLmRlY1JlZkNvdW50KCkgPD0gMCkge1xyXG4gICAgICAgICAgICBfc2VydmVyQXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjbGVhbnVwUHJvdmlkZXJzKSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXJzKClcclxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSkpO1xyXG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBsaWJyYXJ5J3MgbmFtZSBhbmQgdmVyc2lvbiBmb3IgcGxhdGZvcm0gbG9nZ2luZyBwdXJwb3Nlcy5cclxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcclxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxyXG4gKiBAcGFyYW0gdmFyaWFudCAtIEJ1bmRsZSB2YXJpYW50LCBlLmcuLCBub2RlLCBybiwgZXRjLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclZlcnNpb24obGlicmFyeUtleU9yTmFtZSwgdmVyc2lvbiwgdmFyaWFudCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLy8gVE9ETzogV2UgY2FuIHVzZSB0aGlzIGNoZWNrIHRvIHdoaXRlbGlzdCBzdHJpbmdzIHdoZW4vaWYgd2Ugc2V0IHVwXHJcbiAgICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cclxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcclxuICAgIGlmICh2YXJpYW50KSB7XHJcbiAgICAgICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGlicmFyeU1pc21hdGNoID0gbGlicmFyeS5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB3YXJuaW5nID0gW1xyXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoICYmIHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZy5qb2luKCcgJykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KGAke2xpYnJhcnl9LXZlcnNpb25gLCAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLCBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi8pKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXHJcbiAqIEBwYXJhbSBsb2dDYWxsYmFjayAtIEFuIG9wdGlvbmFsIGN1c3RvbSBsb2cgaGFuZGxlciB0aGF0IGV4ZWN1dGVzIHVzZXIgY29kZSB3aGVuZXZlclxyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbkxvZyhsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgaWYgKGxvZ0NhbGxiYWNrICE9PSBudWxsICYmIHR5cGVvZiBsb2dDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgbG9nIGxldmVsIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICpcclxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYGluZm9gLCBlcnJvcnMgYXJlIGxvZ2dlZCwgYnV0IGBkZWJ1Z2AgYW5kXHJcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xyXG4gICAgc2V0TG9nTGV2ZWwkMShsb2dMZXZlbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREJfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtZGF0YWJhc2UnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xyXG5sZXQgZGJQcm9taXNlID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xyXG4gICAgaWYgKCFkYlByb21pc2UpIHtcclxuICAgICAgICBkYlByb21pc2UgPSBvcGVuREIoREJfTkFNRSwgREJfVkVSU0lPTiwge1xyXG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpL2lPUyBicm93c2VycyB0aHJvdyBvY2Nhc2lvbmFsIGV4Y2VwdGlvbnMgb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCkgdGhhdCBtYXkgYmUgYSBidWcuIEF2b2lkIGJsb2NraW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGUgYXBwIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGJQcm9taXNlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihhcHApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmdldChjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgdmFsdWUgYnV0IHR4LmRvbmUgY2FuIHRocm93LFxyXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYXdhaXQgaXQgaGVyZSB0byBjYXRjaCBlcnJvcnNcclxuICAgICAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgYXdhaXQgb2JqZWN0U3RvcmUucHV0KGhlYXJ0YmVhdE9iamVjdCwgY29tcHV0ZUtleShhcHApKTtcclxuICAgICAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlS2V5KGFwcCkge1xyXG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTUFYX0hFQURFUl9CWVRFUyA9IDEwMjQ7XHJcbi8vIDMwIGRheXNcclxuY29uc3QgU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyA9IDMwICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuY2xhc3MgSGVhcnRiZWF0U2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxyXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxyXG4gICAgICAgICAqIFN0b3JlcyBvbmUgcmVjb3JkIHBlciBkYXRlLiBUaGlzIHdpbGwgYmUgY29uc29saWRhdGVkIGludG8gdGhlIHN0YW5kYXJkXHJcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxyXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXHJcbiAgICAgICAgICogYmUga2VwdCBpbiBzeW5jIHdpdGggaW5kZXhlZERCLlxyXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UgPSB0aGlzLl9zdG9yYWdlLnJlYWQoKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHRvIHJlcG9ydCBhIGhlYXJ0YmVhdC4gVGhlIGZ1bmN0aW9uIHdpbGwgZ2VuZXJhdGVcclxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcclxuICAgICAqIHRvIEluZGV4ZWREQi5cclxuICAgICAqIE5vdGUgdGhhdCB3ZSBvbmx5IHN0b3JlIG9uZSBoZWFydGJlYXQgcGVyIGRheS4gU28gaWYgYSBoZWFydGJlYXQgZm9yIHRvZGF5IGlzXHJcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHRyaWdnZXJIZWFydGJlYXQoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcclxuICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBjb25zdHJ1Y3QgYSBoZWFydGJlYXRzIGNhY2hlLCB0aGVuIHJldHVybiBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFydGJlYXRzKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcclxuICAgICAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgZW50cmllcyBvbGRlciB0aGFuIDMwIGRheXMuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5maWx0ZXIoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHdoaWNoIGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgaGVhcnRiZWF0LXNwZWNpZmljIGhlYWRlciBkaXJlY3RseS5cclxuICAgICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IENvbnN1bWluZyBwcm9kdWN0IFNES3Mgc2hvdWxkIG5vdCBzZW5kIHRoZSBoZWFkZXIgaWYgdGhpcyBtZXRob2RcclxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRIZWFydGJlYXRzSGVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCBvciB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZXJlIGlzIG5vIGRhdGEgdG8gc2VuZC5cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICAvLyBFeHRyYWN0IGFzIG1hbnkgaGVhcnRiZWF0cyBmcm9tIHRoZSBjYWNoZSBhcyB3aWxsIGZpdCB1bmRlciB0aGUgc2l6ZSBsaW1pdC5cclxuICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xyXG4gICAgICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xyXG4gICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcclxuICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNhY2hlIGlzbid0IGVtcHR5IGFuZCB0aGlzIHdpbGwgYmUgY2FsbGVkIGFnYWluIG9uIHRoZSBuZXh0IHJlcXVlc3QsXHJcbiAgICAgICAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlclN0cmluZztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRVVENEYXRlU3RyaW5nKCkge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgLy8gUmV0dXJucyBkYXRlIGZvcm1hdCAnWVlZWS1NTS1ERCdcclxuICAgIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoaGVhcnRiZWF0c0NhY2hlLCBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFUykge1xyXG4gICAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXHJcbiAgICAvLyB0aGUgaGVhZGVyLlxyXG4gICAgY29uc3QgaGVhcnRiZWF0c1RvU2VuZCA9IFtdO1xyXG4gICAgLy8gU2luZ2xlIGRhdGUgZm9ybWF0IGhlYXJ0YmVhdHMgdGhhdCBhcmUgbm90IHNlbnQuXHJcbiAgICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xyXG4gICAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xyXG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChoYiA9PiBoYi5hZ2VudCA9PT0gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCk7XHJcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxyXG4gICAgICAgICAgICAgICAgZGF0ZXM6IFtzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGVdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxyXG4gICAgICAgICAgICAgICAgLy8gZW50cnkgYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxyXG4gICAgICAgICAgICAvLyBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcCB1bnNlbnQgZW50cnkgZnJvbSBxdWV1ZS4gKFNraXBwZWQgaWYgYWRkaW5nIHRoZSBlbnRyeSBleGNlZWRlZFxyXG4gICAgICAgIC8vIHF1b3RhIGFuZCB0aGUgbG9vcCBicmVha3MgZWFybHkuKVxyXG4gICAgICAgIHVuc2VudEVudHJpZXMgPSB1bnNlbnRFbnRyaWVzLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLFxyXG4gICAgICAgIHVuc2VudEVudHJpZXNcclxuICAgIH07XHJcbn1cclxuY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpIHtcclxuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGFsbCBoZWFydGJlYXRzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkKCkge1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkhlYXJ0YmVhdE9iamVjdCA9IGF3YWl0IHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQih0aGlzLmFwcCk7XHJcbiAgICAgICAgICAgIGlmIChpZGJIZWFydGJlYXRPYmplY3QgPT09IG51bGwgfHwgaWRiSGVhcnRiZWF0T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGJIZWFydGJlYXRPYmplY3QuaGVhcnRiZWF0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvdmVyd3JpdGUgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgaGVhcnRiZWF0c1xyXG4gICAgYXN5bmMgb3ZlcndyaXRlKGhlYXJ0YmVhdHNPYmplY3QpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGFkZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBhZGQoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcclxuICogaW4gYSBwbGF0Zm9ybSBsb2dnaW5nIGhlYWRlciBKU09OIG9iamVjdCwgc3RyaW5naWZpZWQsIGFuZCBjb252ZXJ0ZWRcclxuICogdG8gYmFzZSA2NC5cclxuICovXHJcbmZ1bmN0aW9uIGNvdW50Qnl0ZXMoaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAvLyBiYXNlNjQgaGFzIGEgcmVzdHJpY3RlZCBzZXQgb2YgY2hhcmFjdGVycywgYWxsIG9mIHdoaWNoIHNob3VsZCBiZSAxIGJ5dGUuXHJcbiAgICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXHJcbiAgICAvLyBoZWFydGJlYXRzQ2FjaGUgd3JhcHBlciBwcm9wZXJ0aWVzXHJcbiAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNDYWNoZSB9KSkubGVuZ3RoO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudCkge1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ3BsYXRmb3JtLWxvZ2dlcicsIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdoZWFydGJlYXQnLCBjb250YWluZXIgPT4gbmV3IEhlYXJ0YmVhdFNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHAsIHZlcnNpb24kMSwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcCwgdmVyc2lvbiQxLCAnZXNtMjAxNycpO1xyXG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlLWpzJywgJycpO1xyXG59XG5cbi8qKlxyXG4gKiBGaXJlYmFzZSBBcHBcclxuICpcclxuICogQHJlbWFya3MgVGhpcyBwYWNrYWdlIGNvb3JkaW5hdGVzIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGRpZmZlcmVudCBGaXJlYmFzZSBjb21wb25lbnRzXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygnJyk7XG5cbmV4cG9ydCB7IFNES19WRVJTSU9OLCBERUZBVUxUX0VOVFJZX05BTUUgYXMgX0RFRkFVTFRfRU5UUllfTkFNRSwgX2FkZENvbXBvbmVudCwgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50LCBfYXBwcywgX2NsZWFyQ29tcG9uZW50cywgX2NvbXBvbmVudHMsIF9nZXRQcm92aWRlciwgX2lzRmlyZWJhc2VBcHAsIF9pc0ZpcmViYXNlU2VydmVyQXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIF9zZXJ2ZXJBcHBzLCBkZWxldGVBcHAsIGdldEFwcCwgZ2V0QXBwcywgaW5pdGlhbGl6ZUFwcCwgaW5pdGlhbGl6ZVNlcnZlckFwcCwgb25Mb2csIHJlZ2lzdGVyVmVyc2lvbiwgc2V0TG9nTGV2ZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52ZW50b3J5X21hbmFnbWVudC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/ZWUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* binding */ Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* binding */ CollectionReference),\n/* harmony export */   DocumentReference: () => (/* binding */ DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* binding */ FieldPath),\n/* harmony export */   FieldValue: () => (/* binding */ FieldValue),\n/* harmony export */   Firestore: () => (/* binding */ Firestore),\n/* harmony export */   FirestoreError: () => (/* binding */ FirestoreError),\n/* harmony export */   GeoPoint: () => (/* binding */ GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* binding */ LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* binding */ PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* binding */ SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   _AutoId: () => (/* binding */ AutoId),\n/* harmony export */   _ByteString: () => (/* binding */ ByteString),\n/* harmony export */   _DatabaseId: () => (/* binding */ DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* binding */ DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* binding */ FieldPath$1),\n/* harmony export */   _TestingHooks: () => (/* binding */ TestingHooks),\n/* harmony export */   _cast: () => (/* binding */ cast),\n/* harmony export */   _debugAssert: () => (/* binding */ debugAssert),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* binding */ _internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* binding */ _internalQueryToProtoQueryTarget),\n/* harmony export */   _isBase64Available: () => (/* binding */ isBase64Available),\n/* harmony export */   _logWarn: () => (/* binding */ logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* binding */ arrayRemove),\n/* harmony export */   arrayUnion: () => (/* binding */ arrayUnion),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   collectionGroup: () => (/* binding */ collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* binding */ deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* binding */ deleteField),\n/* harmony export */   disableNetwork: () => (/* binding */ disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* binding */ disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   documentId: () => (/* binding */ documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* binding */ enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* binding */ enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* binding */ executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* binding */ getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* binding */ getCountFromServer),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocFromCache: () => (/* binding */ getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* binding */ getDocFromServer),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getDocsFromCache: () => (/* binding */ getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* binding */ getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* binding */ getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* binding */ getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   initializeFirestore: () => (/* binding */ initializeFirestore),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   loadBundle: () => (/* binding */ loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* binding */ memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* binding */ memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* binding */ memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* binding */ namedQuery),\n/* harmony export */   onSnapshot: () => (/* binding */ onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   persistentLocalCache: () => (/* binding */ persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* binding */ persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* binding */ persistentSingleTabManager),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* binding */ queryEqual),\n/* harmony export */   refEqual: () => (/* binding */ refEqual),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* binding */ setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   waitForPendingWrites: () => (/* binding */ waitForPendingWrites),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @firebase/webchannel-wrapper/bloom-blob */ \"(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n\nconst name = \"@firebase/firestore\";\nconst version$1 = \"4.6.4\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Simple wrapper around a nullable UID. Mostly exists to make code more\r\n * readable.\r\n */\r\nclass User {\r\n    constructor(uid) {\r\n        this.uid = uid;\r\n    }\r\n    isAuthenticated() {\r\n        return this.uid != null;\r\n    }\r\n    /**\r\n     * Returns a key representing this user, suitable for inclusion in a\r\n     * dictionary.\r\n     */\r\n    toKey() {\r\n        if (this.isAuthenticated()) {\r\n            return 'uid:' + this.uid;\r\n        }\r\n        else {\r\n            return 'anonymous-user';\r\n        }\r\n    }\r\n    isEqual(otherUser) {\r\n        return otherUser.uid === this.uid;\r\n    }\r\n}\r\n/** A user with a null UID. */\r\nUser.UNAUTHENTICATED = new User(null);\r\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\r\n// non-FirebaseAuth providers.\r\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\r\nUser.FIRST_PARTY = new User('first-party-uid');\r\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"10.12.3\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet SDK_VERSION = version;\r\nfunction setSDKVersion(version) {\r\n    SDK_VERSION = version;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Formats an object as a JSON string, suitable for logging. */\r\nfunction formatJSON(value) {\r\n    // util.inspect() results in much more readable output than JSON.stringify()\r\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, { depth: 100 });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/firestore');\r\n// Helper methods are needed because variables can't be exported as read/write\r\nfunction getLogLevel() {\r\n    return logClient.logLevel;\r\n}\r\n/**\r\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\r\n *\r\n * @param logLevel - The verbosity you set for activity and error logging. Can\r\n *   be any of the following values:\r\n *\r\n *   <ul>\r\n *     <li>`debug` for the most verbose logging level, primarily for\r\n *     debugging.</li>\r\n *     <li>`error` to log errors only.</li>\r\n *     <li><code>`silent` to turn off logging.</li>\r\n *   </ul>\r\n */\r\nfunction setLogLevel(logLevel) {\r\n    logClient.setLogLevel(logLevel);\r\n}\r\nfunction logDebug(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n        const args = obj.map(argToString);\r\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\nfunction logError(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\r\n        const args = obj.map(argToString);\r\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction logWarn(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\r\n        const args = obj.map(argToString);\r\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\n/**\r\n * Converts an additional log parameter to a string representation.\r\n */\r\nfunction argToString(obj) {\r\n    if (typeof obj === 'string') {\r\n        return obj;\r\n    }\r\n    else {\r\n        try {\r\n            return formatJSON(obj);\r\n        }\r\n        catch (e) {\r\n            // Converting to JSON failed, just log the object directly\r\n            return obj;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Unconditionally fails, throwing an Error with the given message.\r\n * Messages are stripped in production builds.\r\n *\r\n * Returns `never` and can be used in expressions:\r\n * @example\r\n * let futureVar = fail('not implemented yet');\r\n */\r\nfunction fail(failure = 'Unexpected state') {\r\n    // Log the failure in addition to throw an exception, just in case the\r\n    // exception is swallowed.\r\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\r\n    logError(message);\r\n    // NOTE: We don't use FirestoreError here because these are internal failures\r\n    // that cannot be handled by the user. (Also it would create a circular\r\n    // dependency between the error and assert modules which doesn't work.)\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * Messages are stripped in production builds.\r\n */\r\nfunction hardAssert(assertion, message) {\r\n    if (!assertion) {\r\n        fail();\r\n    }\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * The code of callsites invoking this function are stripped out in production\r\n * builds. Any side-effects of code within the debugAssert() invocation will not\r\n * happen in this case.\r\n *\r\n * @internal\r\n */\r\nfunction debugAssert(assertion, message) {\r\n    if (!assertion) {\r\n        fail();\r\n    }\r\n}\r\n/**\r\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\r\n * instance of `T` before casting.\r\n */\r\nfunction debugCast(obj, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconstructor) {\r\n    return obj;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst Code = {\r\n    // Causes are copied from:\r\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n    /** Not an error; returned on success. */\r\n    OK: 'ok',\r\n    /** The operation was cancelled (typically by the caller). */\r\n    CANCELLED: 'cancelled',\r\n    /** Unknown error or an error from a different error domain. */\r\n    UNKNOWN: 'unknown',\r\n    /**\r\n     * Client specified an invalid argument. Note that this differs from\r\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\r\n     * problematic regardless of the state of the system (e.g., a malformed file\r\n     * name).\r\n     */\r\n    INVALID_ARGUMENT: 'invalid-argument',\r\n    /**\r\n     * Deadline expired before operation could complete. For operations that\r\n     * change the state of the system, this error may be returned even if the\r\n     * operation has completed successfully. For example, a successful response\r\n     * from a server could have been delayed long enough for the deadline to\r\n     * expire.\r\n     */\r\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\r\n    /** Some requested entity (e.g., file or directory) was not found. */\r\n    NOT_FOUND: 'not-found',\r\n    /**\r\n     * Some entity that we attempted to create (e.g., file or directory) already\r\n     * exists.\r\n     */\r\n    ALREADY_EXISTS: 'already-exists',\r\n    /**\r\n     * The caller does not have permission to execute the specified operation.\r\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\r\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\r\n     * PERMISSION_DENIED must not be used if the caller can not be identified\r\n     * (use UNAUTHENTICATED instead for those errors).\r\n     */\r\n    PERMISSION_DENIED: 'permission-denied',\r\n    /**\r\n     * The request does not have valid authentication credentials for the\r\n     * operation.\r\n     */\r\n    UNAUTHENTICATED: 'unauthenticated',\r\n    /**\r\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\r\n     * entire file system is out of space.\r\n     */\r\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\r\n    /**\r\n     * Operation was rejected because the system is not in a state required for\r\n     * the operation's execution. For example, directory to be deleted may be\r\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\r\n     *\r\n     * A litmus test that may help a service implementor in deciding\r\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\r\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\r\n     *  (b) Use ABORTED if the client should retry at a higher-level\r\n     *      (e.g., restarting a read-modify-write sequence).\r\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\r\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\r\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\r\n     *      should be returned since the client should not retry unless\r\n     *      they have first fixed up the directory by deleting files from it.\r\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\r\n     *      REST Get/Update/Delete on a resource and the resource on the\r\n     *      server does not match the condition. E.g., conflicting\r\n     *      read-modify-write on the same resource.\r\n     */\r\n    FAILED_PRECONDITION: 'failed-precondition',\r\n    /**\r\n     * The operation was aborted, typically due to a concurrency issue like\r\n     * sequencer check failures, transaction aborts, etc.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */\r\n    ABORTED: 'aborted',\r\n    /**\r\n     * Operation was attempted past the valid range. E.g., seeking or reading\r\n     * past end of file.\r\n     *\r\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\r\n     * if the system state changes. For example, a 32-bit file system will\r\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\r\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\r\n     * an offset past the current file size.\r\n     *\r\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\r\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\r\n     * when it applies so that callers who are iterating through a space can\r\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\r\n     */\r\n    OUT_OF_RANGE: 'out-of-range',\r\n    /** Operation is not implemented or not supported/enabled in this service. */\r\n    UNIMPLEMENTED: 'unimplemented',\r\n    /**\r\n     * Internal errors. Means some invariants expected by underlying System has\r\n     * been broken. If you see one of these errors, Something is very broken.\r\n     */\r\n    INTERNAL: 'internal',\r\n    /**\r\n     * The service is currently unavailable. This is a most likely a transient\r\n     * condition and may be corrected by retrying with a backoff.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */\r\n    UNAVAILABLE: 'unavailable',\r\n    /** Unrecoverable data loss or corruption. */\r\n    DATA_LOSS: 'data-loss'\r\n};\r\n/** An error returned by a Firestore operation. */\r\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\r\n    /** @hideconstructor */\r\n    constructor(\r\n    /**\r\n     * The backend error code associated with this error.\r\n     */\r\n    code, \r\n    /**\r\n     * A custom error description.\r\n     */\r\n    message) {\r\n        super(code, message);\r\n        this.code = code;\r\n        this.message = message;\r\n        // HACK: We write a toString property directly because Error is not a real\r\n        // class and so inheritance does not work correctly. We could alternatively\r\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\r\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass OAuthToken {\r\n    constructor(value, user) {\r\n        this.user = user;\r\n        this.type = 'OAuth';\r\n        this.headers = new Map();\r\n        this.headers.set('Authorization', `Bearer ${value}`);\r\n    }\r\n}\r\n/**\r\n * A CredentialsProvider that always yields an empty token.\r\n * @internal\r\n */\r\nclass EmptyAuthCredentialsProvider {\r\n    getToken() {\r\n        return Promise.resolve(null);\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) {\r\n        // Fire with initial user.\r\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\r\n    }\r\n    shutdown() { }\r\n}\r\n/**\r\n * A CredentialsProvider that always returns a constant token. Used for\r\n * emulator token mocking.\r\n */\r\nclass EmulatorAuthCredentialsProvider {\r\n    constructor(token) {\r\n        this.token = token;\r\n        /**\r\n         * Stores the listener registered with setChangeListener()\r\n         * This isn't actually necessary since the UID never changes, but we use this\r\n         * to verify the listen contract is adhered to in tests.\r\n         */\r\n        this.changeListener = null;\r\n    }\r\n    getToken() {\r\n        return Promise.resolve(this.token);\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) {\r\n        this.changeListener = changeListener;\r\n        // Fire with initial user.\r\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\r\n    }\r\n    shutdown() {\r\n        this.changeListener = null;\r\n    }\r\n}\r\nclass FirebaseAuthCredentialsProvider {\r\n    constructor(authProvider) {\r\n        this.authProvider = authProvider;\r\n        /** Tracks the current User. */\r\n        this.currentUser = User.UNAUTHENTICATED;\r\n        /**\r\n         * Counter used to detect if the token changed while a getToken request was\r\n         * outstanding.\r\n         */\r\n        this.tokenCounter = 0;\r\n        this.forceRefresh = false;\r\n        this.auth = null;\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        let lastTokenId = this.tokenCounter;\r\n        // A change listener that prevents double-firing for the same token change.\r\n        const guardedChangeListener = user => {\r\n            if (this.tokenCounter !== lastTokenId) {\r\n                lastTokenId = this.tokenCounter;\r\n                return changeListener(user);\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        };\r\n        // A promise that can be waited on to block on the next token change.\r\n        // This promise is re-created after each change.\r\n        let nextToken = new Deferred();\r\n        this.tokenListener = () => {\r\n            this.tokenCounter++;\r\n            this.currentUser = this.getUser();\r\n            nextToken.resolve();\r\n            nextToken = new Deferred();\r\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\r\n        };\r\n        const awaitNextToken = () => {\r\n            const currentTokenAttempt = nextToken;\r\n            asyncQueue.enqueueRetryable(async () => {\r\n                await currentTokenAttempt.promise;\r\n                await guardedChangeListener(this.currentUser);\r\n            });\r\n        };\r\n        const registerAuth = (auth) => {\r\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\r\n            this.auth = auth;\r\n            this.auth.addAuthTokenListener(this.tokenListener);\r\n            awaitNextToken();\r\n        };\r\n        this.authProvider.onInit(auth => registerAuth(auth));\r\n        // Our users can initialize Auth right after Firestore, so we give it\r\n        // a chance to register itself with the component framework before we\r\n        // determine whether to start up in unauthenticated mode.\r\n        setTimeout(() => {\r\n            if (!this.auth) {\r\n                const auth = this.authProvider.getImmediate({ optional: true });\r\n                if (auth) {\r\n                    registerAuth(auth);\r\n                }\r\n                else {\r\n                    // If auth is still not available, proceed with `null` user\r\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\r\n                    nextToken.resolve();\r\n                    nextToken = new Deferred();\r\n                }\r\n            }\r\n        }, 0);\r\n        awaitNextToken();\r\n    }\r\n    getToken() {\r\n        // Take note of the current value of the tokenCounter so that this method\r\n        // can fail (with an ABORTED error) if there is a token change while the\r\n        // request is outstanding.\r\n        const initialTokenCounter = this.tokenCounter;\r\n        const forceRefresh = this.forceRefresh;\r\n        this.forceRefresh = false;\r\n        if (!this.auth) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.auth.getToken(forceRefresh).then(tokenData => {\r\n            // Cancel the request since the token changed while the request was\r\n            // outstanding so the response is potentially for a previous user (which\r\n            // user, we can't be sure).\r\n            if (this.tokenCounter !== initialTokenCounter) {\r\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\r\n                return this.getToken();\r\n            }\r\n            else {\r\n                if (tokenData) {\r\n                    hardAssert(typeof tokenData.accessToken === 'string');\r\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    invalidateToken() {\r\n        this.forceRefresh = true;\r\n    }\r\n    shutdown() {\r\n        if (this.auth) {\r\n            this.auth.removeAuthTokenListener(this.tokenListener);\r\n        }\r\n    }\r\n    // Auth.getUid() can return null even with a user logged in. It is because\r\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\r\n    // This method should only be called in the AuthTokenListener callback\r\n    // to guarantee to get the actual user.\r\n    getUser() {\r\n        const currentUid = this.auth && this.auth.getUid();\r\n        hardAssert(currentUid === null || typeof currentUid === 'string');\r\n        return new User(currentUid);\r\n    }\r\n}\r\n/*\r\n * FirstPartyToken provides a fresh token each time its value\r\n * is requested, because if the token is too old, requests will be rejected.\r\n * Technically this may no longer be necessary since the SDK should gracefully\r\n * recover from unauthenticated errors (see b/33147818 for context), but it's\r\n * safer to keep the implementation as-is.\r\n */\r\nclass FirstPartyToken {\r\n    constructor(sessionIndex, iamToken, authTokenFactory) {\r\n        this.sessionIndex = sessionIndex;\r\n        this.iamToken = iamToken;\r\n        this.authTokenFactory = authTokenFactory;\r\n        this.type = 'FirstParty';\r\n        this.user = User.FIRST_PARTY;\r\n        this._headers = new Map();\r\n    }\r\n    /**\r\n     * Gets an authorization token, using a provided factory function, or return\r\n     * null.\r\n     */\r\n    getAuthToken() {\r\n        if (this.authTokenFactory) {\r\n            return this.authTokenFactory();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    get headers() {\r\n        this._headers.set('X-Goog-AuthUser', this.sessionIndex);\r\n        // Use array notation to prevent minification\r\n        const authHeaderTokenValue = this.getAuthToken();\r\n        if (authHeaderTokenValue) {\r\n            this._headers.set('Authorization', authHeaderTokenValue);\r\n        }\r\n        if (this.iamToken) {\r\n            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\r\n        }\r\n        return this._headers;\r\n    }\r\n}\r\n/*\r\n * Provides user credentials required for the Firestore JavaScript SDK\r\n * to authenticate the user, using technique that is only available\r\n * to applications hosted by Google.\r\n */\r\nclass FirstPartyAuthCredentialsProvider {\r\n    constructor(sessionIndex, iamToken, authTokenFactory) {\r\n        this.sessionIndex = sessionIndex;\r\n        this.iamToken = iamToken;\r\n        this.authTokenFactory = authTokenFactory;\r\n    }\r\n    getToken() {\r\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        // Fire with initial uid.\r\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\r\n    }\r\n    shutdown() { }\r\n    invalidateToken() { }\r\n}\r\nclass AppCheckToken {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.type = 'AppCheck';\r\n        this.headers = new Map();\r\n        if (value && value.length > 0) {\r\n            this.headers.set('x-firebase-appcheck', this.value);\r\n        }\r\n    }\r\n}\r\nclass FirebaseAppCheckTokenProvider {\r\n    constructor(appCheckProvider) {\r\n        this.appCheckProvider = appCheckProvider;\r\n        this.forceRefresh = false;\r\n        this.appCheck = null;\r\n        this.latestAppCheckToken = null;\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        const onTokenChanged = tokenResult => {\r\n            if (tokenResult.error != null) {\r\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\r\n            }\r\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\r\n            this.latestAppCheckToken = tokenResult.token;\r\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\r\n            return tokenUpdated\r\n                ? changeListener(tokenResult.token)\r\n                : Promise.resolve();\r\n        };\r\n        this.tokenListener = (tokenResult) => {\r\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\r\n        };\r\n        const registerAppCheck = (appCheck) => {\r\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\r\n            this.appCheck = appCheck;\r\n            this.appCheck.addTokenListener(this.tokenListener);\r\n        };\r\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\r\n        // Our users can initialize AppCheck after Firestore, so we give it\r\n        // a chance to register itself with the component framework.\r\n        setTimeout(() => {\r\n            if (!this.appCheck) {\r\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\r\n                if (appCheck) {\r\n                    registerAppCheck(appCheck);\r\n                }\r\n                else {\r\n                    // If AppCheck is still not available, proceed without it.\r\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\r\n                }\r\n            }\r\n        }, 0);\r\n    }\r\n    getToken() {\r\n        const forceRefresh = this.forceRefresh;\r\n        this.forceRefresh = false;\r\n        if (!this.appCheck) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\r\n            if (tokenResult) {\r\n                hardAssert(typeof tokenResult.token === 'string');\r\n                this.latestAppCheckToken = tokenResult.token;\r\n                return new AppCheckToken(tokenResult.token);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n    invalidateToken() {\r\n        this.forceRefresh = true;\r\n    }\r\n    shutdown() {\r\n        if (this.appCheck) {\r\n            this.appCheck.removeTokenListener(this.tokenListener);\r\n        }\r\n    }\r\n}\r\n/**\r\n * An AppCheck token provider that always yields an empty token.\r\n * @internal\r\n */\r\nclass EmptyAppCheckTokenProvider {\r\n    getToken() {\r\n        return Promise.resolve(new AppCheckToken(''));\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) { }\r\n    shutdown() { }\r\n}\r\n/**\r\n * Builds a CredentialsProvider depending on the type of\r\n * the credentials passed in.\r\n */\r\nfunction makeAuthCredentialsProvider(credentials) {\r\n    if (!credentials) {\r\n        return new EmptyAuthCredentialsProvider();\r\n    }\r\n    switch (credentials['type']) {\r\n        case 'firstParty':\r\n            return new FirstPartyAuthCredentialsProvider(credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);\r\n        case 'provider':\r\n            return credentials['client'];\r\n        default:\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Generates `nBytes` of random bytes.\r\n *\r\n * If `nBytes < 0` , an error will be thrown.\r\n */\r\nfunction randomBytes(nBytes) {\r\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A utility class for generating unique alphanumeric IDs of a specified length.\r\n *\r\n * @internal\r\n * Exported internally for testing purposes.\r\n */\r\nclass AutoId {\r\n    static newId() {\r\n        // Alphanumeric characters\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        // The largest byte value that is a multiple of `char.length`.\r\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\r\n        let autoId = '';\r\n        const targetLength = 20;\r\n        while (autoId.length < targetLength) {\r\n            const bytes = randomBytes(40);\r\n            for (let i = 0; i < bytes.length; ++i) {\r\n                // Only accept values that are [0, maxMultiple), this ensures they can\r\n                // be evenly mapped to indices of `chars` via a modulo operation.\r\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\r\n                    autoId += chars.charAt(bytes[i] % chars.length);\r\n                }\r\n            }\r\n        }\r\n        return autoId;\r\n    }\r\n}\r\nfunction primitiveComparator(left, right) {\r\n    if (left < right) {\r\n        return -1;\r\n    }\r\n    if (left > right) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n/** Helper to compare arrays using isEqual(). */\r\nfunction arrayEquals(left, right, comparator) {\r\n    if (left.length !== right.length) {\r\n        return false;\r\n    }\r\n    return left.every((value, index) => comparator(value, right[index]));\r\n}\r\n/**\r\n * Returns the immediate lexicographically-following string. This is useful to\r\n * construct an inclusive range for indexeddb iterators.\r\n */\r\nfunction immediateSuccessor(s) {\r\n    // Return the input string, with an additional NUL byte appended.\r\n    return s + '\\0';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\r\nconst MIN_SECONDS = -62135596800;\r\n// Number of nanoseconds in a millisecond.\r\nconst MS_TO_NANOS = 1e6;\r\n/**\r\n * A `Timestamp` represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time.\r\n *\r\n * It is encoded using the Proleptic Gregorian Calendar which extends the\r\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\r\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\r\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\r\n * 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * For examples and further specifications, refer to the\r\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\r\n */\r\nclass Timestamp {\r\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @param seconds - The number of seconds of UTC time since Unix epoch\r\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     *     9999-12-31T23:59:59Z inclusive.\r\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\r\n     *     resolution. Negative second values with fractions must still have\r\n     *     non-negative nanoseconds values that count forward in time. Must be\r\n     *     from 0 to 999,999,999 inclusive.\r\n     */\r\n    constructor(\r\n    /**\r\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    seconds, \r\n    /**\r\n     * The fractions of a second at nanosecond resolution.*\r\n     */\r\n    nanoseconds) {\r\n        this.seconds = seconds;\r\n        this.nanoseconds = nanoseconds;\r\n        if (nanoseconds < 0) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\r\n        }\r\n        if (nanoseconds >= 1e9) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\r\n        }\r\n        if (seconds < MIN_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\r\n        }\r\n        // This will break in the year 10,000.\r\n        if (seconds >= 253402300800) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @returns a new timestamp representing the current date.\r\n     */\r\n    static now() {\r\n        return Timestamp.fromMillis(Date.now());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @param date - The date to initialize the `Timestamp` from.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     date.\r\n     */\r\n    static fromDate(date) {\r\n        return Timestamp.fromMillis(date.getTime());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @param milliseconds - Number of milliseconds since Unix epoch\r\n     *     1970-01-01T00:00:00Z.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     number of milliseconds.\r\n     */\r\n    static fromMillis(milliseconds) {\r\n        const seconds = Math.floor(milliseconds / 1000);\r\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\r\n        return new Timestamp(seconds, nanos);\r\n    }\r\n    /**\r\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\r\n     * causes a loss of precision since `Date` objects only support millisecond\r\n     * precision.\r\n     *\r\n     * @returns JavaScript `Date` object representing the same point in time as\r\n     *     this `Timestamp`, with millisecond precision.\r\n     */\r\n    toDate() {\r\n        return new Date(this.toMillis());\r\n    }\r\n    /**\r\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\r\n     * epoch). This operation causes a loss of precision.\r\n     *\r\n     * @returns The point in time corresponding to this timestamp, represented as\r\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    toMillis() {\r\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\r\n    }\r\n    _compareTo(other) {\r\n        if (this.seconds === other.seconds) {\r\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\r\n        }\r\n        return primitiveComparator(this.seconds, other.seconds);\r\n    }\r\n    /**\r\n     * Returns true if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @param other - The `Timestamp` to compare against.\r\n     * @returns true if this `Timestamp` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\r\n    }\r\n    /** Returns a textual representation of this `Timestamp`. */\r\n    toString() {\r\n        return ('Timestamp(seconds=' +\r\n            this.seconds +\r\n            ', nanoseconds=' +\r\n            this.nanoseconds +\r\n            ')');\r\n    }\r\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\r\n    toJSON() {\r\n        return { seconds: this.seconds, nanoseconds: this.nanoseconds };\r\n    }\r\n    /**\r\n     * Converts this object to a primitive string, which allows `Timestamp` objects\r\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\r\n     */\r\n    valueOf() {\r\n        // This method returns a string of the form <seconds>.<nanoseconds> where\r\n        // <seconds> is translated to have a non-negative value and both <seconds>\r\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\r\n        // Strings with this format then have a lexiographical ordering that matches\r\n        // the expected ordering. The <seconds> translation is done to avoid having\r\n        // a leading negative sign (i.e. a leading '-' character) in its string\r\n        // representation, which would affect its lexiographical ordering.\r\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\r\n        // Note: Up to 12 decimal digits are required to represent all valid\r\n        // 'seconds' values.\r\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\r\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\r\n        return formattedSeconds + '.' + formattedNanoseconds;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A version of a document in Firestore. This corresponds to the version\r\n * timestamp, such as update_time or read_time.\r\n */\r\nclass SnapshotVersion {\r\n    constructor(timestamp) {\r\n        this.timestamp = timestamp;\r\n    }\r\n    static fromTimestamp(value) {\r\n        return new SnapshotVersion(value);\r\n    }\r\n    static min() {\r\n        return new SnapshotVersion(new Timestamp(0, 0));\r\n    }\r\n    static max() {\r\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\r\n    }\r\n    compareTo(other) {\r\n        return this.timestamp._compareTo(other.timestamp);\r\n    }\r\n    isEqual(other) {\r\n        return this.timestamp.isEqual(other.timestamp);\r\n    }\r\n    /** Returns a number representation of the version for use in spec tests. */\r\n    toMicroseconds() {\r\n        // Convert to microseconds.\r\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\r\n    }\r\n    toString() {\r\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\r\n    }\r\n    toTimestamp() {\r\n        return this.timestamp;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DOCUMENT_KEY_NAME = '__name__';\r\n/**\r\n * Path represents an ordered sequence of string segments.\r\n */\r\nclass BasePath {\r\n    constructor(segments, offset, length) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n        else if (offset > segments.length) {\r\n            fail();\r\n        }\r\n        if (length === undefined) {\r\n            length = segments.length - offset;\r\n        }\r\n        else if (length > segments.length - offset) {\r\n            fail();\r\n        }\r\n        this.segments = segments;\r\n        this.offset = offset;\r\n        this.len = length;\r\n    }\r\n    get length() {\r\n        return this.len;\r\n    }\r\n    isEqual(other) {\r\n        return BasePath.comparator(this, other) === 0;\r\n    }\r\n    child(nameOrPath) {\r\n        const segments = this.segments.slice(this.offset, this.limit());\r\n        if (nameOrPath instanceof BasePath) {\r\n            nameOrPath.forEach(segment => {\r\n                segments.push(segment);\r\n            });\r\n        }\r\n        else {\r\n            segments.push(nameOrPath);\r\n        }\r\n        return this.construct(segments);\r\n    }\r\n    /** The index of one past the last segment of the path. */\r\n    limit() {\r\n        return this.offset + this.length;\r\n    }\r\n    popFirst(size) {\r\n        size = size === undefined ? 1 : size;\r\n        return this.construct(this.segments, this.offset + size, this.length - size);\r\n    }\r\n    popLast() {\r\n        return this.construct(this.segments, this.offset, this.length - 1);\r\n    }\r\n    firstSegment() {\r\n        return this.segments[this.offset];\r\n    }\r\n    lastSegment() {\r\n        return this.get(this.length - 1);\r\n    }\r\n    get(index) {\r\n        return this.segments[this.offset + index];\r\n    }\r\n    isEmpty() {\r\n        return this.length === 0;\r\n    }\r\n    isPrefixOf(other) {\r\n        if (other.length < this.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (this.get(i) !== other.get(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    isImmediateParentOf(potentialChild) {\r\n        if (this.length + 1 !== potentialChild.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (this.get(i) !== potentialChild.get(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    forEach(fn) {\r\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\r\n            fn(this.segments[i]);\r\n        }\r\n    }\r\n    toArray() {\r\n        return this.segments.slice(this.offset, this.limit());\r\n    }\r\n    static comparator(p1, p2) {\r\n        const len = Math.min(p1.length, p2.length);\r\n        for (let i = 0; i < len; i++) {\r\n            const left = p1.get(i);\r\n            const right = p2.get(i);\r\n            if (left < right) {\r\n                return -1;\r\n            }\r\n            if (left > right) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (p1.length < p2.length) {\r\n            return -1;\r\n        }\r\n        if (p1.length > p2.length) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n/**\r\n * A slash-separated path for navigating resources (documents and collections)\r\n * within Firestore.\r\n *\r\n * @internal\r\n */\r\nclass ResourcePath extends BasePath {\r\n    construct(segments, offset, length) {\r\n        return new ResourcePath(segments, offset, length);\r\n    }\r\n    canonicalString() {\r\n        // NOTE: The client is ignorant of any path segments containing escape\r\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\r\n        // for legacy reasons and should not be used frequently).\r\n        return this.toArray().join('/');\r\n    }\r\n    toString() {\r\n        return this.canonicalString();\r\n    }\r\n    /**\r\n     * Returns a string representation of this path\r\n     * where each path segment has been encoded with\r\n     * `encodeURIComponent`.\r\n     */\r\n    toUriEncodedString() {\r\n        return this.toArray().map(encodeURIComponent).join('/');\r\n    }\r\n    /**\r\n     * Creates a resource path from the given slash-delimited string. If multiple\r\n     * arguments are provided, all components are combined. Leading and trailing\r\n     * slashes from all components are ignored.\r\n     */\r\n    static fromString(...pathComponents) {\r\n        // NOTE: The client is ignorant of any path segments containing escape\r\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\r\n        // for legacy reasons and should not be used frequently).\r\n        const segments = [];\r\n        for (const path of pathComponents) {\r\n            if (path.indexOf('//') >= 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\r\n            }\r\n            // Strip leading and traling slashed.\r\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\r\n        }\r\n        return new ResourcePath(segments);\r\n    }\r\n    static emptyPath() {\r\n        return new ResourcePath([]);\r\n    }\r\n}\r\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\r\n/**\r\n * A dot-separated path for navigating sub-objects within a document.\r\n * @internal\r\n */\r\nclass FieldPath$1 extends BasePath {\r\n    construct(segments, offset, length) {\r\n        return new FieldPath$1(segments, offset, length);\r\n    }\r\n    /**\r\n     * Returns true if the string could be used as a segment in a field path\r\n     * without escaping.\r\n     */\r\n    static isValidIdentifier(segment) {\r\n        return identifierRegExp.test(segment);\r\n    }\r\n    canonicalString() {\r\n        return this.toArray()\r\n            .map(str => {\r\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\r\n            if (!FieldPath$1.isValidIdentifier(str)) {\r\n                str = '`' + str + '`';\r\n            }\r\n            return str;\r\n        })\r\n            .join('.');\r\n    }\r\n    toString() {\r\n        return this.canonicalString();\r\n    }\r\n    /**\r\n     * Returns true if this field references the key of a document.\r\n     */\r\n    isKeyField() {\r\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\r\n    }\r\n    /**\r\n     * The field designating the key of a document.\r\n     */\r\n    static keyField() {\r\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\r\n    }\r\n    /**\r\n     * Parses a field string from the given server-formatted string.\r\n     *\r\n     * - Splitting the empty string is not allowed (for now at least).\r\n     * - Empty segments within the string (e.g. if there are two consecutive\r\n     *   separators) are not allowed.\r\n     *\r\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\r\n     * non-identifier path components, even if they aren't escaped.\r\n     */\r\n    static fromServerFormat(path) {\r\n        const segments = [];\r\n        let current = '';\r\n        let i = 0;\r\n        const addCurrentSegment = () => {\r\n            if (current.length === 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\r\n                    `with '.', end with '.', or contain '..'`);\r\n            }\r\n            segments.push(current);\r\n            current = '';\r\n        };\r\n        let inBackticks = false;\r\n        while (i < path.length) {\r\n            const c = path[i];\r\n            if (c === '\\\\') {\r\n                if (i + 1 === path.length) {\r\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\r\n                }\r\n                const next = path[i + 1];\r\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\r\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\r\n                }\r\n                current += next;\r\n                i += 2;\r\n            }\r\n            else if (c === '`') {\r\n                inBackticks = !inBackticks;\r\n                i++;\r\n            }\r\n            else if (c === '.' && !inBackticks) {\r\n                addCurrentSegment();\r\n                i++;\r\n            }\r\n            else {\r\n                current += c;\r\n                i++;\r\n            }\r\n        }\r\n        addCurrentSegment();\r\n        if (inBackticks) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\r\n        }\r\n        return new FieldPath$1(segments);\r\n    }\r\n    static emptyPath() {\r\n        return new FieldPath$1([]);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nclass DocumentKey {\r\n    constructor(path) {\r\n        this.path = path;\r\n    }\r\n    static fromPath(path) {\r\n        return new DocumentKey(ResourcePath.fromString(path));\r\n    }\r\n    static fromName(name) {\r\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\r\n    }\r\n    static empty() {\r\n        return new DocumentKey(ResourcePath.emptyPath());\r\n    }\r\n    get collectionGroup() {\r\n        return this.path.popLast().lastSegment();\r\n    }\r\n    /** Returns true if the document is in the specified collectionId. */\r\n    hasCollectionId(collectionId) {\r\n        return (this.path.length >= 2 &&\r\n            this.path.get(this.path.length - 2) === collectionId);\r\n    }\r\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\r\n    getCollectionGroup() {\r\n        return this.path.get(this.path.length - 2);\r\n    }\r\n    /** Returns the fully qualified path to the parent collection. */\r\n    getCollectionPath() {\r\n        return this.path.popLast();\r\n    }\r\n    isEqual(other) {\r\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\r\n    }\r\n    toString() {\r\n        return this.path.toString();\r\n    }\r\n    static comparator(k1, k2) {\r\n        return ResourcePath.comparator(k1.path, k2.path);\r\n    }\r\n    static isDocumentKey(path) {\r\n        return path.length % 2 === 0;\r\n    }\r\n    /**\r\n     * Creates and returns a new document key with the given segments.\r\n     *\r\n     * @param segments - The segments of the path to the document\r\n     * @returns A new instance of DocumentKey\r\n     */\r\n    static fromSegments(segments) {\r\n        return new DocumentKey(new ResourcePath(segments.slice()));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The initial mutation batch id for each index. Gets updated during index\r\n * backfill.\r\n */\r\nconst INITIAL_LARGEST_BATCH_ID = -1;\r\n/**\r\n * The initial sequence number for each index. Gets updated during index\r\n * backfill.\r\n */\r\nconst INITIAL_SEQUENCE_NUMBER = 0;\r\n/**\r\n * An index definition for field indexes in Firestore.\r\n *\r\n * Every index is associated with a collection. The definition contains a list\r\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\r\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\r\n *\r\n * Unlike the backend, the SDK does not differentiate between collection or\r\n * collection group-scoped indices. Every index can be used for both single\r\n * collection and collection group queries.\r\n */\r\nclass FieldIndex {\r\n    constructor(\r\n    /**\r\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\r\n     * has not yet been persisted).\r\n     */\r\n    indexId, \r\n    /** The collection ID this index applies to. */\r\n    collectionGroup, \r\n    /** The field segments for this index. */\r\n    fields, \r\n    /** Shows how up-to-date the index is for the current user. */\r\n    indexState) {\r\n        this.indexId = indexId;\r\n        this.collectionGroup = collectionGroup;\r\n        this.fields = fields;\r\n        this.indexState = indexState;\r\n    }\r\n}\r\n/** An ID for an index that has not yet been added to persistence.  */\r\nFieldIndex.UNKNOWN_ID = -1;\r\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\r\nfunction fieldIndexGetArraySegment(fieldIndex) {\r\n    return fieldIndex.fields.find(s => s.kind === 2 /* IndexKind.CONTAINS */);\r\n}\r\n/** Returns all directional (ascending/descending) segments for this index. */\r\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\r\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* IndexKind.CONTAINS */);\r\n}\r\n/**\r\n * Returns the order of the document key component for the given index.\r\n *\r\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\r\n */\r\nfunction fieldIndexGetKeyOrder(fieldIndex) {\r\n    const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\r\n    return directionalSegments.length === 0\r\n        ? 0 /* IndexKind.ASCENDING */\r\n        : directionalSegments[directionalSegments.length - 1].kind;\r\n}\r\n/**\r\n * Compares indexes by collection group and segments. Ignores update time and\r\n * index ID.\r\n */\r\nfunction fieldIndexSemanticComparator(left, right) {\r\n    let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\r\n        cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\r\n        if (cmp !== 0) {\r\n            return cmp;\r\n        }\r\n    }\r\n    return primitiveComparator(left.fields.length, right.fields.length);\r\n}\r\n/** Returns a debug representation of the field index */\r\nfunction fieldIndexToString(fieldIndex) {\r\n    return `id=${fieldIndex.indexId}|cg=${fieldIndex.collectionGroup}|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\r\n}\r\n/** An index component consisting of field path and index type.  */\r\nclass IndexSegment {\r\n    constructor(\r\n    /** The field path of the component. */\r\n    fieldPath, \r\n    /** The fields sorting order. */\r\n    kind) {\r\n        this.fieldPath = fieldPath;\r\n        this.kind = kind;\r\n    }\r\n}\r\nfunction indexSegmentComparator(left, right) {\r\n    const cmp = FieldPath$1.comparator(left.fieldPath, right.fieldPath);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return primitiveComparator(left.kind, right.kind);\r\n}\r\n/**\r\n * Stores the \"high water mark\" that indicates how updated the Index is for the\r\n * current user.\r\n */\r\nclass IndexState {\r\n    constructor(\r\n    /**\r\n     * Indicates when the index was last updated (relative to other indexes).\r\n     */\r\n    sequenceNumber, \r\n    /** The the latest indexed read time, document and batch id. */\r\n    offset) {\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.offset = offset;\r\n    }\r\n    /** The state of an index that has not yet been backfilled. */\r\n    static empty() {\r\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\r\n    }\r\n}\r\n/**\r\n * Creates an offset that matches all documents with a read time higher than\r\n * `readTime`.\r\n */\r\nfunction newIndexOffsetSuccessorFromReadTime(readTime, largestBatchId) {\r\n    // We want to create an offset that matches all documents with a read time\r\n    // greater than the provided read time. To do so, we technically need to\r\n    // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\r\n    // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\r\n    // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\r\n    // all valid document IDs.\r\n    const successorSeconds = readTime.toTimestamp().seconds;\r\n    const successorNanos = readTime.toTimestamp().nanoseconds + 1;\r\n    const successor = SnapshotVersion.fromTimestamp(successorNanos === 1e9\r\n        ? new Timestamp(successorSeconds + 1, 0)\r\n        : new Timestamp(successorSeconds, successorNanos));\r\n    return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\r\n}\r\n/** Creates a new offset based on the provided document. */\r\nfunction newIndexOffsetFromDocument(document) {\r\n    return new IndexOffset(document.readTime, document.key, INITIAL_LARGEST_BATCH_ID);\r\n}\r\n/**\r\n * Stores the latest read time, document and batch ID that were processed for an\r\n * index.\r\n */\r\nclass IndexOffset {\r\n    constructor(\r\n    /**\r\n     * The latest read time version that has been indexed by Firestore for this\r\n     * field index.\r\n     */\r\n    readTime, \r\n    /**\r\n     * The key of the last document that was indexed for this query. Use\r\n     * `DocumentKey.empty()` if no document has been indexed.\r\n     */\r\n    documentKey, \r\n    /*\r\n     * The largest mutation batch id that's been processed by Firestore.\r\n     */\r\n    largestBatchId) {\r\n        this.readTime = readTime;\r\n        this.documentKey = documentKey;\r\n        this.largestBatchId = largestBatchId;\r\n    }\r\n    /** Returns an offset that sorts before all regular offsets. */\r\n    static min() {\r\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\r\n    }\r\n    /** Returns an offset that sorts after all regular offsets. */\r\n    static max() {\r\n        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\r\n    }\r\n}\r\nfunction indexOffsetComparator(left, right) {\r\n    let cmp = left.readTime.compareTo(right.readTime);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return primitiveComparator(left.largestBatchId, right.largestBatchId);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\r\n    'It might be necessary to refresh the browser tab.';\r\n/**\r\n * A base class representing a persistence transaction, encapsulating both the\r\n * transaction's sequence numbers as well as a list of onCommitted listeners.\r\n *\r\n * When you call Persistence.runTransaction(), it will create a transaction and\r\n * pass it to your callback. You then pass it to any method that operates\r\n * on persistence.\r\n */\r\nclass PersistenceTransaction {\r\n    constructor() {\r\n        this.onCommittedListeners = [];\r\n    }\r\n    addOnCommittedListener(listener) {\r\n        this.onCommittedListeners.push(listener);\r\n    }\r\n    raiseOnCommittedEvent() {\r\n        this.onCommittedListeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\r\n * operation fails because the primary lease has been taken by another client,\r\n * we ignore the error (the persistence layer will immediately call\r\n * `applyPrimaryLease` to propagate the primary state change). All other errors\r\n * are re-thrown.\r\n *\r\n * @param err - An error returned by a LocalStore operation.\r\n * @returns A Promise that resolves after we recovered, or the original error.\r\n */\r\nasync function ignoreIfPrimaryLeaseLoss(err) {\r\n    if (err.code === Code.FAILED_PRECONDITION &&\r\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\r\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * PersistencePromise is essentially a re-implementation of Promise except\r\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\r\n * are executed synchronously when a PersistencePromise resolves rather than\r\n * asynchronously (Promise implementations use setImmediate() or similar).\r\n *\r\n * This is necessary to interoperate with IndexedDB which will automatically\r\n * commit transactions if control is returned to the event loop without\r\n * synchronously initiating another operation on the transaction.\r\n *\r\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\r\n * Promises.\r\n */\r\nclass PersistencePromise {\r\n    constructor(callback) {\r\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\r\n        // not the user's raw next() or catch() callbacks.\r\n        this.nextCallback = null;\r\n        this.catchCallback = null;\r\n        // When the operation resolves, we'll set result or error and mark isDone.\r\n        this.result = undefined;\r\n        this.error = undefined;\r\n        this.isDone = false;\r\n        // Set to true when .then() or .catch() are called and prevents additional\r\n        // chaining.\r\n        this.callbackAttached = false;\r\n        callback(value => {\r\n            this.isDone = true;\r\n            this.result = value;\r\n            if (this.nextCallback) {\r\n                // value should be defined unless T is Void, but we can't express\r\n                // that in the type system.\r\n                this.nextCallback(value);\r\n            }\r\n        }, error => {\r\n            this.isDone = true;\r\n            this.error = error;\r\n            if (this.catchCallback) {\r\n                this.catchCallback(error);\r\n            }\r\n        });\r\n    }\r\n    catch(fn) {\r\n        return this.next(undefined, fn);\r\n    }\r\n    next(nextFn, catchFn) {\r\n        if (this.callbackAttached) {\r\n            fail();\r\n        }\r\n        this.callbackAttached = true;\r\n        if (this.isDone) {\r\n            if (!this.error) {\r\n                return this.wrapSuccess(nextFn, this.result);\r\n            }\r\n            else {\r\n                return this.wrapFailure(catchFn, this.error);\r\n            }\r\n        }\r\n        else {\r\n            return new PersistencePromise((resolve, reject) => {\r\n                this.nextCallback = (value) => {\r\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\r\n                };\r\n                this.catchCallback = (error) => {\r\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\r\n                };\r\n            });\r\n        }\r\n    }\r\n    toPromise() {\r\n        return new Promise((resolve, reject) => {\r\n            this.next(resolve, reject);\r\n        });\r\n    }\r\n    wrapUserFunction(fn) {\r\n        try {\r\n            const result = fn();\r\n            if (result instanceof PersistencePromise) {\r\n                return result;\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve(result);\r\n            }\r\n        }\r\n        catch (e) {\r\n            return PersistencePromise.reject(e);\r\n        }\r\n    }\r\n    wrapSuccess(nextFn, value) {\r\n        if (nextFn) {\r\n            return this.wrapUserFunction(() => nextFn(value));\r\n        }\r\n        else {\r\n            // If there's no nextFn, then R must be the same as T\r\n            return PersistencePromise.resolve(value);\r\n        }\r\n    }\r\n    wrapFailure(catchFn, error) {\r\n        if (catchFn) {\r\n            return this.wrapUserFunction(() => catchFn(error));\r\n        }\r\n        else {\r\n            return PersistencePromise.reject(error);\r\n        }\r\n    }\r\n    static resolve(result) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            resolve(result);\r\n        });\r\n    }\r\n    static reject(error) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            reject(error);\r\n        });\r\n    }\r\n    static waitFor(\r\n    // Accept all Promise types in waitFor().\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    all) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            let expectedCount = 0;\r\n            let resolvedCount = 0;\r\n            let done = false;\r\n            all.forEach(element => {\r\n                ++expectedCount;\r\n                element.next(() => {\r\n                    ++resolvedCount;\r\n                    if (done && resolvedCount === expectedCount) {\r\n                        resolve();\r\n                    }\r\n                }, err => reject(err));\r\n            });\r\n            done = true;\r\n            if (resolvedCount === expectedCount) {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Given an array of predicate functions that asynchronously evaluate to a\r\n     * boolean, implements a short-circuiting `or` between the results. Predicates\r\n     * will be evaluated until one of them returns `true`, then stop. The final\r\n     * result will be whether any of them returned `true`.\r\n     */\r\n    static or(predicates) {\r\n        let p = PersistencePromise.resolve(false);\r\n        for (const predicate of predicates) {\r\n            p = p.next(isTrue => {\r\n                if (isTrue) {\r\n                    return PersistencePromise.resolve(isTrue);\r\n                }\r\n                else {\r\n                    return predicate();\r\n                }\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n    static forEach(collection, f) {\r\n        const promises = [];\r\n        collection.forEach((r, s) => {\r\n            promises.push(f.call(this, r, s));\r\n        });\r\n        return this.waitFor(promises);\r\n    }\r\n    /**\r\n     * Concurrently map all array elements through asynchronous function.\r\n     */\r\n    static mapArray(array, f) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            const expectedCount = array.length;\r\n            const results = new Array(expectedCount);\r\n            let resolvedCount = 0;\r\n            for (let i = 0; i < expectedCount; i++) {\r\n                const current = i;\r\n                f(array[current]).next(result => {\r\n                    results[current] = result;\r\n                    ++resolvedCount;\r\n                    if (resolvedCount === expectedCount) {\r\n                        resolve(results);\r\n                    }\r\n                }, err => reject(err));\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * An alternative to recursive PersistencePromise calls, that avoids\r\n     * potential memory problems from unbounded chains of promises.\r\n     *\r\n     * The `action` will be called repeatedly while `condition` is true.\r\n     */\r\n    static doWhile(condition, action) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            const process = () => {\r\n                if (condition() === true) {\r\n                    action().next(() => {\r\n                        process();\r\n                    }, reject);\r\n                }\r\n                else {\r\n                    resolve();\r\n                }\r\n            };\r\n            process();\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// References to `window` are guarded by SimpleDb.isAvailable()\r\n/* eslint-disable no-restricted-globals */\r\nconst LOG_TAG$i = 'SimpleDb';\r\n/**\r\n * The maximum number of retry attempts for an IndexedDb transaction that fails\r\n * with a DOMException.\r\n */\r\nconst TRANSACTION_RETRY_COUNT = 3;\r\n/**\r\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\r\n * specific object store.\r\n */\r\nclass SimpleDbTransaction {\r\n    constructor(action, transaction) {\r\n        this.action = action;\r\n        this.transaction = transaction;\r\n        this.aborted = false;\r\n        /**\r\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\r\n         */\r\n        this.completionDeferred = new Deferred();\r\n        this.transaction.oncomplete = () => {\r\n            this.completionDeferred.resolve();\r\n        };\r\n        this.transaction.onabort = () => {\r\n            if (transaction.error) {\r\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\r\n            }\r\n            else {\r\n                this.completionDeferred.resolve();\r\n            }\r\n        };\r\n        this.transaction.onerror = (event) => {\r\n            const error = checkForAndReportiOSError(event.target.error);\r\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\r\n        };\r\n    }\r\n    static open(db, action, mode, objectStoreNames) {\r\n        try {\r\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\r\n        }\r\n        catch (e) {\r\n            throw new IndexedDbTransactionError(action, e);\r\n        }\r\n    }\r\n    get completionPromise() {\r\n        return this.completionDeferred.promise;\r\n    }\r\n    abort(error) {\r\n        if (error) {\r\n            this.completionDeferred.reject(error);\r\n        }\r\n        if (!this.aborted) {\r\n            logDebug(LOG_TAG$i, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\r\n            this.aborted = true;\r\n            this.transaction.abort();\r\n        }\r\n    }\r\n    maybeCommit() {\r\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\r\n        // speed up index DB processing if the event loop remains blocks.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const maybeV3IndexedDb = this.transaction;\r\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\r\n            maybeV3IndexedDb.commit();\r\n        }\r\n    }\r\n    /**\r\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\r\n     * operations performed on the SimpleDbStore happen within the context of this\r\n     * transaction and it cannot be used anymore once the transaction is\r\n     * completed.\r\n     *\r\n     * Note that we can't actually enforce that the KeyType and ValueType are\r\n     * correct, but they allow type safety through the rest of the consuming code.\r\n     */\r\n    store(storeName) {\r\n        const store = this.transaction.objectStore(storeName);\r\n        return new SimpleDbStore(store);\r\n    }\r\n}\r\n/**\r\n * Provides a wrapper around IndexedDb with a simplified interface that uses\r\n * Promise-like return values to chain operations. Real promises cannot be used\r\n * since .then() continuations are executed asynchronously (e.g. via\r\n * .setImmediate), which would cause IndexedDB to end the transaction.\r\n * See PersistencePromise for more details.\r\n */\r\nclass SimpleDb {\r\n    /*\r\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\r\n     *\r\n     * Note that `version` must not be a downgrade. IndexedDB does not support\r\n     * downgrading the schema version. We currently do not support any way to do\r\n     * versioning outside of IndexedDB's versioning mechanism, as only\r\n     * version-upgrade transactions are allowed to do things like create\r\n     * objectstores.\r\n     */\r\n    constructor(name, version, schemaConverter) {\r\n        this.name = name;\r\n        this.version = version;\r\n        this.schemaConverter = schemaConverter;\r\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\r\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\r\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\r\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\r\n        // log on 12.2.\r\n        if (iOSVersion === 12.2) {\r\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\r\n                'Safari that may cause your app to stop working. See ' +\r\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\r\n                'and a potential workaround.');\r\n        }\r\n    }\r\n    /** Deletes the specified database. */\r\n    static delete(name) {\r\n        logDebug(LOG_TAG$i, 'Removing database:', name);\r\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\r\n    }\r\n    /** Returns true if IndexedDB is available in the current environment. */\r\n    static isAvailable() {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\r\n            return false;\r\n        }\r\n        if (SimpleDb.isMockPersistence()) {\r\n            return true;\r\n        }\r\n        // We extensively use indexed array values and compound keys,\r\n        // which IE and Edge do not support. However, they still have indexedDB\r\n        // defined on the window, so we need to check for them here and make sure\r\n        // to return that persistence is not enabled for those browsers.\r\n        // For tracking support of this feature, see here:\r\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\r\n        // Check the UA string to find out the browser.\r\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)();\r\n        // IE 10\r\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\r\n        // IE 11\r\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\r\n        // Edge\r\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\r\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\r\n        // iOS Safari: Disable for users running iOS version < 10.\r\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\r\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\r\n        // Android browser: Disable for userse running version < 4.5.\r\n        const androidVersion = getAndroidVersion(ua);\r\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\r\n        if (ua.indexOf('MSIE ') > 0 ||\r\n            ua.indexOf('Trident/') > 0 ||\r\n            ua.indexOf('Edge/') > 0 ||\r\n            isUnsupportedIOS ||\r\n            isUnsupportedAndroid) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\r\n     * (see https://github.com/axemclion/IndexedDBShim).\r\n     */\r\n    static isMockPersistence() {\r\n        var _a;\r\n        return (typeof process !== 'undefined' &&\r\n            ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === 'YES');\r\n    }\r\n    /** Helper to get a typed SimpleDbStore from a transaction. */\r\n    static getStore(txn, store) {\r\n        return txn.store(store);\r\n    }\r\n    // visible for testing\r\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\r\n    static getIOSVersion(ua) {\r\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\r\n        const version = iOSVersionRegex\r\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\r\n            : '-1';\r\n        return Number(version);\r\n    }\r\n    /**\r\n     * Opens the specified database, creating or upgrading it if necessary.\r\n     */\r\n    async ensureDb(action) {\r\n        if (!this.db) {\r\n            logDebug(LOG_TAG$i, 'Opening database:', this.name);\r\n            this.db = await new Promise((resolve, reject) => {\r\n                // TODO(mikelehen): Investigate browser compatibility.\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\r\n                // suggests IE9 and older WebKit browsers handle upgrade\r\n                // differently. They expect setVersion, as described here:\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\r\n                const request = indexedDB.open(this.name, this.version);\r\n                request.onsuccess = (event) => {\r\n                    const db = event.target.result;\r\n                    resolve(db);\r\n                };\r\n                request.onblocked = () => {\r\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\r\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\r\n                };\r\n                request.onerror = (event) => {\r\n                    const error = event.target.error;\r\n                    if (error.name === 'VersionError') {\r\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\r\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\r\n                            'will operate with persistence disabled. If you need persistence, please ' +\r\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\r\n                            'data for your app to start fresh.'));\r\n                    }\r\n                    else if (error.name === 'InvalidStateError') {\r\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\r\n                            'private browsing session on a browser whose private browsing sessions do not ' +\r\n                            'support IndexedDB: ' +\r\n                            error));\r\n                    }\r\n                    else {\r\n                        reject(new IndexedDbTransactionError(action, error));\r\n                    }\r\n                };\r\n                request.onupgradeneeded = (event) => {\r\n                    logDebug(LOG_TAG$i, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\r\n                    const db = event.target.result;\r\n                    this.schemaConverter\r\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\r\n                        .next(() => {\r\n                        logDebug(LOG_TAG$i, 'Database upgrade to version ' + this.version + ' complete');\r\n                    });\r\n                };\r\n            });\r\n        }\r\n        if (this.versionchangelistener) {\r\n            this.db.onversionchange = event => this.versionchangelistener(event);\r\n        }\r\n        return this.db;\r\n    }\r\n    setVersionChangeListener(versionChangeListener) {\r\n        this.versionchangelistener = versionChangeListener;\r\n        if (this.db) {\r\n            this.db.onversionchange = (event) => {\r\n                return versionChangeListener(event);\r\n            };\r\n        }\r\n    }\r\n    async runTransaction(action, mode, objectStores, transactionFn) {\r\n        const readonly = mode === 'readonly';\r\n        let attemptNumber = 0;\r\n        while (true) {\r\n            ++attemptNumber;\r\n            try {\r\n                this.db = await this.ensureDb(action);\r\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\r\n                const transactionFnResult = transactionFn(transaction)\r\n                    .next(result => {\r\n                    transaction.maybeCommit();\r\n                    return result;\r\n                })\r\n                    .catch(error => {\r\n                    // Abort the transaction if there was an error.\r\n                    transaction.abort(error);\r\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\r\n                    // completion promise to be rejected. This in turn means that we won't use\r\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\r\n                    // possibility of returning `void` to the type of `transactionFnResult`.\r\n                    return PersistencePromise.reject(error);\r\n                })\r\n                    .toPromise();\r\n                // As noted above, errors are propagated by aborting the transaction. So\r\n                // we swallow any error here to avoid the browser logging it as unhandled.\r\n                transactionFnResult.catch(() => { });\r\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\r\n                // fire), but still return the original transactionFnResult back to the\r\n                // caller.\r\n                await transaction.completionPromise;\r\n                return transactionFnResult;\r\n            }\r\n            catch (e) {\r\n                const error = e;\r\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\r\n                // not retry exceptions that are likely unrecoverable (such as quota\r\n                // exceeded errors).\r\n                // Note: We cannot use an instanceof check for FirestoreException, since the\r\n                // exception is wrapped in a generic error by our async/await handling.\r\n                const retryable = error.name !== 'FirebaseError' &&\r\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\r\n                logDebug(LOG_TAG$i, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\r\n                this.close();\r\n                if (!retryable) {\r\n                    return Promise.reject(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    close() {\r\n        if (this.db) {\r\n            this.db.close();\r\n        }\r\n        this.db = undefined;\r\n    }\r\n}\r\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\r\nfunction getAndroidVersion(ua) {\r\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\r\n    const version = androidVersionRegex\r\n        ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\r\n        : '-1';\r\n    return Number(version);\r\n}\r\n/**\r\n * A controller for iterating over a key range or index. It allows an iterate\r\n * callback to delete the currently-referenced object, or jump to a new key\r\n * within the key range or index.\r\n */\r\nclass IterationController {\r\n    constructor(dbCursor) {\r\n        this.dbCursor = dbCursor;\r\n        this.shouldStop = false;\r\n        this.nextKey = null;\r\n    }\r\n    get isDone() {\r\n        return this.shouldStop;\r\n    }\r\n    get skipToKey() {\r\n        return this.nextKey;\r\n    }\r\n    set cursor(value) {\r\n        this.dbCursor = value;\r\n    }\r\n    /**\r\n     * This function can be called to stop iteration at any point.\r\n     */\r\n    done() {\r\n        this.shouldStop = true;\r\n    }\r\n    /**\r\n     * This function can be called to skip to that next key, which could be\r\n     * an index or a primary key.\r\n     */\r\n    skip(key) {\r\n        this.nextKey = key;\r\n    }\r\n    /**\r\n     * Delete the current cursor value from the object store.\r\n     *\r\n     * NOTE: You CANNOT do this with a keysOnly query.\r\n     */\r\n    delete() {\r\n        return wrapRequest(this.dbCursor.delete());\r\n    }\r\n}\r\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\r\nclass IndexedDbTransactionError extends FirestoreError {\r\n    constructor(actionName, cause) {\r\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\r\n        this.name = 'IndexedDbTransactionError';\r\n    }\r\n}\r\n/** Verifies whether `e` is an IndexedDbTransactionError. */\r\nfunction isIndexedDbTransactionError(e) {\r\n    // Use name equality, as instanceof checks on errors don't work with errors\r\n    // that wrap other errors.\r\n    return e.name === 'IndexedDbTransactionError';\r\n}\r\n/**\r\n * A wrapper around an IDBObjectStore providing an API that:\r\n *\r\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\r\n * methods for acting against the object store.\r\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\r\n * method return a PersistencePromise instead.\r\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\r\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\r\n */\r\nclass SimpleDbStore {\r\n    constructor(store) {\r\n        this.store = store;\r\n    }\r\n    put(keyOrValue, value) {\r\n        let request;\r\n        if (value !== undefined) {\r\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, keyOrValue, value);\r\n            request = this.store.put(value, keyOrValue);\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, '<auto-key>', keyOrValue);\r\n            request = this.store.put(keyOrValue);\r\n        }\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * Adds a new value into an Object Store and returns the new key. Similar to\r\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\r\n     *\r\n     * @param value - The object to write.\r\n     * @returns The key of the value to add.\r\n     */\r\n    add(value) {\r\n        logDebug(LOG_TAG$i, 'ADD', this.store.name, value, value);\r\n        const request = this.store.add(value);\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * Gets the object with the specified key from the specified store, or null\r\n     * if no object exists with the specified key.\r\n     *\r\n     * @key The key of the object to get.\r\n     * @returns The object with the specified key or null if no object exists.\r\n     */\r\n    get(key) {\r\n        const request = this.store.get(key);\r\n        // We're doing an unsafe cast to ValueType.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return wrapRequest(request).next(result => {\r\n            // Normalize nonexistence to null.\r\n            if (result === undefined) {\r\n                result = null;\r\n            }\r\n            logDebug(LOG_TAG$i, 'GET', this.store.name, key, result);\r\n            return result;\r\n        });\r\n    }\r\n    delete(key) {\r\n        logDebug(LOG_TAG$i, 'DELETE', this.store.name, key);\r\n        const request = this.store.delete(key);\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * If we ever need more of the count variants, we can add overloads. For now,\r\n     * all we need is to count everything in a store.\r\n     *\r\n     * Returns the number of rows in the store.\r\n     */\r\n    count() {\r\n        logDebug(LOG_TAG$i, 'COUNT', this.store.name);\r\n        const request = this.store.count();\r\n        return wrapRequest(request);\r\n    }\r\n    loadAll(indexOrRange, range) {\r\n        const iterateOptions = this.options(indexOrRange, range);\r\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\r\n        // 20% faster.\r\n        const store = iterateOptions.index\r\n            ? this.store.index(iterateOptions.index)\r\n            : this.store;\r\n        if (typeof store.getAll === 'function') {\r\n            const request = store.getAll(iterateOptions.range);\r\n            return new PersistencePromise((resolve, reject) => {\r\n                request.onerror = (event) => {\r\n                    reject(event.target.error);\r\n                };\r\n                request.onsuccess = (event) => {\r\n                    resolve(event.target.result);\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            const cursor = this.cursor(iterateOptions);\r\n            const results = [];\r\n            return this.iterateCursor(cursor, (key, value) => {\r\n                results.push(value);\r\n            }).next(() => {\r\n                return results;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Loads the first `count` elements from the provided index range. Loads all\r\n     * elements if no limit is provided.\r\n     */\r\n    loadFirst(range, count) {\r\n        const request = this.store.getAll(range, count === null ? undefined : count);\r\n        return new PersistencePromise((resolve, reject) => {\r\n            request.onerror = (event) => {\r\n                reject(event.target.error);\r\n            };\r\n            request.onsuccess = (event) => {\r\n                resolve(event.target.result);\r\n            };\r\n        });\r\n    }\r\n    deleteAll(indexOrRange, range) {\r\n        logDebug(LOG_TAG$i, 'DELETE ALL', this.store.name);\r\n        const options = this.options(indexOrRange, range);\r\n        options.keysOnly = false;\r\n        const cursor = this.cursor(options);\r\n        return this.iterateCursor(cursor, (key, value, control) => {\r\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\r\n            // calling delete() on an object store with a single key\r\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\r\n            // however, this requires us *not* to use a keysOnly cursor\r\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\r\n            // may want to compare the performance of each method.\r\n            return control.delete();\r\n        });\r\n    }\r\n    iterate(optionsOrCallback, callback) {\r\n        let options;\r\n        if (!callback) {\r\n            options = {};\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        const cursor = this.cursor(options);\r\n        return this.iterateCursor(cursor, callback);\r\n    }\r\n    /**\r\n     * Iterates over a store, but waits for the given callback to complete for\r\n     * each entry before iterating the next entry. This allows the callback to do\r\n     * asynchronous work to determine if this iteration should continue.\r\n     *\r\n     * The provided callback should return `true` to continue iteration, and\r\n     * `false` otherwise.\r\n     */\r\n    iterateSerial(callback) {\r\n        const cursorRequest = this.cursor({});\r\n        return new PersistencePromise((resolve, reject) => {\r\n            cursorRequest.onerror = (event) => {\r\n                const error = checkForAndReportiOSError(event.target.error);\r\n                reject(error);\r\n            };\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (!cursor) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\r\n                    if (shouldContinue) {\r\n                        cursor.continue();\r\n                    }\r\n                    else {\r\n                        resolve();\r\n                    }\r\n                });\r\n            };\r\n        });\r\n    }\r\n    iterateCursor(cursorRequest, fn) {\r\n        const results = [];\r\n        return new PersistencePromise((resolve, reject) => {\r\n            cursorRequest.onerror = (event) => {\r\n                reject(event.target.error);\r\n            };\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (!cursor) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                const controller = new IterationController(cursor);\r\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\r\n                if (userResult instanceof PersistencePromise) {\r\n                    const userPromise = userResult.catch(err => {\r\n                        controller.done();\r\n                        return PersistencePromise.reject(err);\r\n                    });\r\n                    results.push(userPromise);\r\n                }\r\n                if (controller.isDone) {\r\n                    resolve();\r\n                }\r\n                else if (controller.skipToKey === null) {\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    cursor.continue(controller.skipToKey);\r\n                }\r\n            };\r\n        }).next(() => PersistencePromise.waitFor(results));\r\n    }\r\n    options(indexOrRange, range) {\r\n        let indexName = undefined;\r\n        if (indexOrRange !== undefined) {\r\n            if (typeof indexOrRange === 'string') {\r\n                indexName = indexOrRange;\r\n            }\r\n            else {\r\n                range = indexOrRange;\r\n            }\r\n        }\r\n        return { index: indexName, range };\r\n    }\r\n    cursor(options) {\r\n        let direction = 'next';\r\n        if (options.reverse) {\r\n            direction = 'prev';\r\n        }\r\n        if (options.index) {\r\n            const index = this.store.index(options.index);\r\n            if (options.keysOnly) {\r\n                return index.openKeyCursor(options.range, direction);\r\n            }\r\n            else {\r\n                return index.openCursor(options.range, direction);\r\n            }\r\n        }\r\n        else {\r\n            return this.store.openCursor(options.range, direction);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\r\n * handlers to resolve / reject the PersistencePromise as appropriate.\r\n */\r\nfunction wrapRequest(request) {\r\n    return new PersistencePromise((resolve, reject) => {\r\n        request.onsuccess = (event) => {\r\n            const result = event.target.result;\r\n            resolve(result);\r\n        };\r\n        request.onerror = (event) => {\r\n            const error = checkForAndReportiOSError(event.target.error);\r\n            reject(error);\r\n        };\r\n    });\r\n}\r\n// Guard so we only report the error once.\r\nlet reportedIOSError = false;\r\nfunction checkForAndReportiOSError(error) {\r\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\r\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\r\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\r\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\r\n            // Wrap error in a more descriptive one.\r\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\r\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\r\n                `for details and a potential workaround.`);\r\n            if (!reportedIOSError) {\r\n                reportedIOSError = true;\r\n                // Throw a global exception outside of this promise chain, for the user to\r\n                // potentially catch.\r\n                setTimeout(() => {\r\n                    throw newError;\r\n                }, 0);\r\n            }\r\n            return newError;\r\n        }\r\n    }\r\n    return error;\r\n}\n\nconst LOG_TAG$h = 'IndexBackfiller';\r\n/** How long we wait to try running index backfill after SDK initialization. */\r\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\r\n/** Minimum amount of time between backfill checks, after the first one. */\r\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\r\n/** The maximum number of documents to process each time backfill() is called. */\r\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\r\n/** This class is responsible for the scheduling of Index Backfiller. */\r\nclass IndexBackfillerScheduler {\r\n    constructor(asyncQueue, backfiller) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.backfiller = backfiller;\r\n        this.task = null;\r\n    }\r\n    start() {\r\n        this.schedule(INITIAL_BACKFILL_DELAY_MS);\r\n    }\r\n    stop() {\r\n        if (this.task) {\r\n            this.task.cancel();\r\n            this.task = null;\r\n        }\r\n    }\r\n    get started() {\r\n        return this.task !== null;\r\n    }\r\n    schedule(delay) {\r\n        logDebug(LOG_TAG$h, `Scheduled in ${delay}ms`);\r\n        this.task = this.asyncQueue.enqueueAfterDelay(\"index_backfill\" /* TimerId.IndexBackfill */, delay, async () => {\r\n            this.task = null;\r\n            try {\r\n                const documentsProcessed = await this.backfiller.backfill();\r\n                logDebug(LOG_TAG$h, `Documents written: ${documentsProcessed}`);\r\n            }\r\n            catch (e) {\r\n                if (isIndexedDbTransactionError(e)) {\r\n                    logDebug(LOG_TAG$h, 'Ignoring IndexedDB error during index backfill: ', e);\r\n                }\r\n                else {\r\n                    await ignoreIfPrimaryLeaseLoss(e);\r\n                }\r\n            }\r\n            await this.schedule(REGULAR_BACKFILL_DELAY_MS);\r\n        });\r\n    }\r\n}\r\n/** Implements the steps for backfilling indexes. */\r\nclass IndexBackfiller {\r\n    constructor(\r\n    /**\r\n     * LocalStore provides access to IndexManager and LocalDocumentView.\r\n     * These properties will update when the user changes. Consequently,\r\n     * making a local copy of IndexManager and LocalDocumentView will require\r\n     * updates over time. The simpler solution is to rely on LocalStore to have\r\n     * an up-to-date references to IndexManager and LocalDocumentStore.\r\n     */\r\n    localStore, persistence) {\r\n        this.localStore = localStore;\r\n        this.persistence = persistence;\r\n    }\r\n    async backfill(maxDocumentsToProcess = MAX_DOCUMENTS_TO_PROCESS) {\r\n        return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', txn => this.writeIndexEntries(txn, maxDocumentsToProcess));\r\n    }\r\n    /** Writes index entries until the cap is reached. Returns the number of documents processed. */\r\n    writeIndexEntries(transation, maxDocumentsToProcess) {\r\n        const processedCollectionGroups = new Set();\r\n        let documentsRemaining = maxDocumentsToProcess;\r\n        let continueLoop = true;\r\n        return PersistencePromise.doWhile(() => continueLoop === true && documentsRemaining > 0, () => {\r\n            return this.localStore.indexManager\r\n                .getNextCollectionGroupToUpdate(transation)\r\n                .next((collectionGroup) => {\r\n                if (collectionGroup === null ||\r\n                    processedCollectionGroups.has(collectionGroup)) {\r\n                    continueLoop = false;\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$h, `Processing collection: ${collectionGroup}`);\r\n                    return this.writeEntriesForCollectionGroup(transation, collectionGroup, documentsRemaining).next(documentsProcessed => {\r\n                        documentsRemaining -= documentsProcessed;\r\n                        processedCollectionGroups.add(collectionGroup);\r\n                    });\r\n                }\r\n            });\r\n        }).next(() => maxDocumentsToProcess - documentsRemaining);\r\n    }\r\n    /**\r\n     * Writes entries for the provided collection group. Returns the number of documents processed.\r\n     */\r\n    writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemainingUnderCap) {\r\n        // Use the earliest offset of all field indexes to query the local cache.\r\n        return this.localStore.indexManager\r\n            .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\r\n            .next(existingOffset => this.localStore.localDocuments\r\n            .getNextDocuments(transaction, collectionGroup, existingOffset, documentsRemainingUnderCap)\r\n            .next(nextBatch => {\r\n            const docs = nextBatch.changes;\r\n            return this.localStore.indexManager\r\n                .updateIndexEntries(transaction, docs)\r\n                .next(() => this.getNewOffset(existingOffset, nextBatch))\r\n                .next(newOffset => {\r\n                logDebug(LOG_TAG$h, `Updating offset: ${newOffset}`);\r\n                return this.localStore.indexManager.updateCollectionGroup(transaction, collectionGroup, newOffset);\r\n            })\r\n                .next(() => docs.size);\r\n        }));\r\n    }\r\n    /** Returns the next offset based on the provided documents. */\r\n    getNewOffset(existingOffset, lookupResult) {\r\n        let maxOffset = existingOffset;\r\n        lookupResult.changes.forEach((key, document) => {\r\n            const newOffset = newIndexOffsetFromDocument(document);\r\n            if (indexOffsetComparator(newOffset, maxOffset) > 0) {\r\n                maxOffset = newOffset;\r\n            }\r\n        });\r\n        return new IndexOffset(maxOffset.readTime, maxOffset.documentKey, Math.max(lookupResult.batchId, existingOffset.largestBatchId));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\r\n * exceed. All subsequent calls to next will return increasing values. If provided with a\r\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\r\n * well as write out sequence numbers that it produces via `next()`.\r\n */\r\nclass ListenSequence {\r\n    constructor(previousValue, sequenceNumberSyncer) {\r\n        this.previousValue = previousValue;\r\n        if (sequenceNumberSyncer) {\r\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\r\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\r\n        }\r\n    }\r\n    setPreviousValue(externalPreviousValue) {\r\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\r\n        return this.previousValue;\r\n    }\r\n    next() {\r\n        const nextValue = ++this.previousValue;\r\n        if (this.writeNewSequenceNumber) {\r\n            this.writeNewSequenceNumber(nextValue);\r\n        }\r\n        return nextValue;\r\n    }\r\n}\r\nListenSequence.INVALID = -1;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst escapeChar = '\\u0001';\r\nconst encodedSeparatorChar = '\\u0001';\r\nconst encodedNul = '\\u0010';\r\nconst encodedEscape = '\\u0011';\r\n/**\r\n * Encodes a resource path into a IndexedDb-compatible string form.\r\n */\r\nfunction encodeResourcePath(path) {\r\n    let result = '';\r\n    for (let i = 0; i < path.length; i++) {\r\n        if (result.length > 0) {\r\n            result = encodeSeparator(result);\r\n        }\r\n        result = encodeSegment(path.get(i), result);\r\n    }\r\n    return encodeSeparator(result);\r\n}\r\n/** Encodes a single segment of a resource path into the given result */\r\nfunction encodeSegment(segment, resultBuf) {\r\n    let result = resultBuf;\r\n    const length = segment.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const c = segment.charAt(i);\r\n        switch (c) {\r\n            case '\\0':\r\n                result += escapeChar + encodedNul;\r\n                break;\r\n            case escapeChar:\r\n                result += escapeChar + encodedEscape;\r\n                break;\r\n            default:\r\n                result += c;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/** Encodes a path separator into the given result */\r\nfunction encodeSeparator(result) {\r\n    return result + escapeChar + encodedSeparatorChar;\r\n}\r\n/**\r\n * Decodes the given IndexedDb-compatible string form of a resource path into\r\n * a ResourcePath instance. Note that this method is not suitable for use with\r\n * decoding resource names from the server; those are One Platform format\r\n * strings.\r\n */\r\nfunction decodeResourcePath(path) {\r\n    // Event the empty path must encode as a path of at least length 2. A path\r\n    // with exactly 2 must be the empty path.\r\n    const length = path.length;\r\n    hardAssert(length >= 2);\r\n    if (length === 2) {\r\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar);\r\n        return ResourcePath.emptyPath();\r\n    }\r\n    // Escape characters cannot exist past the second-to-last position in the\r\n    // source value.\r\n    const lastReasonableEscapeIndex = length - 2;\r\n    const segments = [];\r\n    let segmentBuilder = '';\r\n    for (let start = 0; start < length;) {\r\n        // The last two characters of a valid encoded path must be a separator, so\r\n        // there must be an end to this segment.\r\n        const end = path.indexOf(escapeChar, start);\r\n        if (end < 0 || end > lastReasonableEscapeIndex) {\r\n            fail();\r\n        }\r\n        const next = path.charAt(end + 1);\r\n        switch (next) {\r\n            case encodedSeparatorChar:\r\n                const currentPiece = path.substring(start, end);\r\n                let segment;\r\n                if (segmentBuilder.length === 0) {\r\n                    // Avoid copying for the common case of a segment that excludes \\0\r\n                    // and \\001\r\n                    segment = currentPiece;\r\n                }\r\n                else {\r\n                    segmentBuilder += currentPiece;\r\n                    segment = segmentBuilder;\r\n                    segmentBuilder = '';\r\n                }\r\n                segments.push(segment);\r\n                break;\r\n            case encodedNul:\r\n                segmentBuilder += path.substring(start, end);\r\n                segmentBuilder += '\\0';\r\n                break;\r\n            case encodedEscape:\r\n                // The escape character can be used in the output to encode itself.\r\n                segmentBuilder += path.substring(start, end + 1);\r\n                break;\r\n            default:\r\n                fail();\r\n        }\r\n        start = end + 2;\r\n    }\r\n    return new ResourcePath(segments);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DbRemoteDocumentStore$1 = 'remoteDocuments';\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Name of the IndexedDb object store.\r\n *\r\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\r\n * older clients that only supported single locked access to the persistence\r\n * layer.\r\n */\r\nconst DbPrimaryClientStore = 'owner';\r\n/**\r\n * The key string used for the single object that exists in the\r\n * DbPrimaryClient store.\r\n */\r\nconst DbPrimaryClientKey = 'owner';\r\n/** Name of the IndexedDb object store.  */\r\nconst DbMutationQueueStore = 'mutationQueues';\r\n/** Keys are automatically assigned via the userId property. */\r\nconst DbMutationQueueKeyPath = 'userId';\r\n/** Name of the IndexedDb object store.  */\r\nconst DbMutationBatchStore = 'mutations';\r\n/** Keys are automatically assigned via the userId, batchId properties. */\r\nconst DbMutationBatchKeyPath = 'batchId';\r\n/** The index name for lookup of mutations by user. */\r\nconst DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\r\n/** The user mutations index is keyed by [userId, batchId] pairs. */\r\nconst DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\r\n/**\r\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\r\n * over all of a user's document mutations.\r\n */\r\nfunction newDbDocumentMutationPrefixForUser(userId) {\r\n    return [userId];\r\n}\r\n/**\r\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\r\n * index to iterate over all at document mutations for a given path or lower.\r\n */\r\nfunction newDbDocumentMutationPrefixForPath(userId, path) {\r\n    return [userId, encodeResourcePath(path)];\r\n}\r\n/**\r\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\r\n * and deleting into the DbDocumentMutations index.\r\n */\r\nfunction newDbDocumentMutationKey(userId, path, batchId) {\r\n    return [userId, encodeResourcePath(path), batchId];\r\n}\r\n/**\r\n * Because we store all the useful information for this store in the key,\r\n * there is no useful information to store as the value. The raw (unencoded)\r\n * path cannot be stored because IndexedDb doesn't store prototype\r\n * information.\r\n */\r\nconst DbDocumentMutationPlaceholder = {};\r\nconst DbDocumentMutationStore = 'documentMutations';\r\nconst DbRemoteDocumentStore = 'remoteDocumentsV14';\r\n/**\r\n * The primary key of the remote documents store, which allows for efficient\r\n * access by collection path and read time.\r\n */\r\nconst DbRemoteDocumentKeyPath = [\r\n    'prefixPath',\r\n    'collectionGroup',\r\n    'readTime',\r\n    'documentId'\r\n];\r\n/** An index that provides access to documents by key. */\r\nconst DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\r\nconst DbRemoteDocumentDocumentKeyIndexPath = [\r\n    'prefixPath',\r\n    'collectionGroup',\r\n    'documentId'\r\n];\r\n/**\r\n * An index that provides access to documents by collection group and read\r\n * time.\r\n *\r\n * This index is used by the index backfiller.\r\n */\r\nconst DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\r\nconst DbRemoteDocumentCollectionGroupIndexPath = [\r\n    'collectionGroup',\r\n    'readTime',\r\n    'prefixPath',\r\n    'documentId'\r\n];\r\nconst DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\r\nconst DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\r\nconst DbTargetStore = 'targets';\r\n/** Keys are automatically assigned via the targetId property. */\r\nconst DbTargetKeyPath = 'targetId';\r\n/** The name of the queryTargets index. */\r\nconst DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\r\n/**\r\n * The index of all canonicalIds to the targets that they match. This is not\r\n * a unique mapping because canonicalId does not promise a unique name for all\r\n * possible queries, so we append the targetId to make the mapping unique.\r\n */\r\nconst DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\r\n/** Name of the IndexedDb object store.  */\r\nconst DbTargetDocumentStore = 'targetDocuments';\r\n/** Keys are automatically assigned via the targetId, path properties. */\r\nconst DbTargetDocumentKeyPath = ['targetId', 'path'];\r\n/** The index name for the reverse index. */\r\nconst DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\r\n/** We also need to create the reverse index for these properties. */\r\nconst DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\r\n/**\r\n * The key string used for the single object that exists in the\r\n * DbTargetGlobal store.\r\n */\r\nconst DbTargetGlobalKey = 'targetGlobalKey';\r\nconst DbTargetGlobalStore = 'targetGlobal';\r\n/** Name of the IndexedDb object store. */\r\nconst DbCollectionParentStore = 'collectionParents';\r\n/** Keys are automatically assigned via the collectionId, parent properties. */\r\nconst DbCollectionParentKeyPath = ['collectionId', 'parent'];\r\n/** Name of the IndexedDb object store. */\r\nconst DbClientMetadataStore = 'clientMetadata';\r\n/** Keys are automatically assigned via the clientId properties. */\r\nconst DbClientMetadataKeyPath = 'clientId';\r\n/** Name of the IndexedDb object store. */\r\nconst DbBundleStore = 'bundles';\r\nconst DbBundleKeyPath = 'bundleId';\r\n/** Name of the IndexedDb object store. */\r\nconst DbNamedQueryStore = 'namedQueries';\r\nconst DbNamedQueryKeyPath = 'name';\r\n/** Name of the IndexedDb object store. */\r\nconst DbIndexConfigurationStore = 'indexConfiguration';\r\nconst DbIndexConfigurationKeyPath = 'indexId';\r\n/**\r\n * An index that provides access to the index configurations by collection\r\n * group.\r\n *\r\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\r\n * not possible here as the Web client supports concurrent access to\r\n * persistence via multi-tab.\r\n */\r\nconst DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\r\nconst DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\r\n/** Name of the IndexedDb object store. */\r\nconst DbIndexStateStore = 'indexState';\r\nconst DbIndexStateKeyPath = ['indexId', 'uid'];\r\n/**\r\n * An index that provides access to documents in a collection sorted by last\r\n * update time. Used by the backfiller.\r\n *\r\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\r\n * not possible here as the Web client supports concurrent access to\r\n * persistence via multi-tab.\r\n */\r\nconst DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\r\nconst DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\r\n/** Name of the IndexedDb object store. */\r\nconst DbIndexEntryStore = 'indexEntries';\r\nconst DbIndexEntryKeyPath = [\r\n    'indexId',\r\n    'uid',\r\n    'arrayValue',\r\n    'directionalValue',\r\n    'orderedDocumentKey',\r\n    'documentKey'\r\n];\r\nconst DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\r\nconst DbIndexEntryDocumentKeyIndexPath = [\r\n    'indexId',\r\n    'uid',\r\n    'orderedDocumentKey'\r\n];\r\n/** Name of the IndexedDb object store. */\r\nconst DbDocumentOverlayStore = 'documentOverlays';\r\nconst DbDocumentOverlayKeyPath = [\r\n    'userId',\r\n    'collectionPath',\r\n    'documentId'\r\n];\r\nconst DbDocumentOverlayCollectionPathOverlayIndex = 'collectionPathOverlayIndex';\r\nconst DbDocumentOverlayCollectionPathOverlayIndexPath = [\r\n    'userId',\r\n    'collectionPath',\r\n    'largestBatchId'\r\n];\r\nconst DbDocumentOverlayCollectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\r\nconst DbDocumentOverlayCollectionGroupOverlayIndexPath = [\r\n    'userId',\r\n    'collectionGroup',\r\n    'largestBatchId'\r\n];\r\n// Visible for testing\r\nconst V1_STORES = [\r\n    DbMutationQueueStore,\r\n    DbMutationBatchStore,\r\n    DbDocumentMutationStore,\r\n    DbRemoteDocumentStore$1,\r\n    DbTargetStore,\r\n    DbPrimaryClientStore,\r\n    DbTargetGlobalStore,\r\n    DbTargetDocumentStore\r\n];\r\n// Visible for testing\r\nconst V3_STORES = V1_STORES;\r\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\r\nconst V4_STORES = [...V3_STORES, DbClientMetadataStore];\r\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\r\nconst V8_STORES = [...V6_STORES, DbCollectionParentStore];\r\nconst V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\r\nconst V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\r\nconst V13_STORES = [\r\n    DbMutationQueueStore,\r\n    DbMutationBatchStore,\r\n    DbDocumentMutationStore,\r\n    DbRemoteDocumentStore,\r\n    DbTargetStore,\r\n    DbPrimaryClientStore,\r\n    DbTargetGlobalStore,\r\n    DbTargetDocumentStore,\r\n    DbClientMetadataStore,\r\n    DbRemoteDocumentGlobalStore,\r\n    DbCollectionParentStore,\r\n    DbBundleStore,\r\n    DbNamedQueryStore,\r\n    DbDocumentOverlayStore\r\n];\r\nconst V14_STORES = V13_STORES;\r\nconst V15_STORES = [\r\n    ...V14_STORES,\r\n    DbIndexConfigurationStore,\r\n    DbIndexStateStore,\r\n    DbIndexEntryStore\r\n];\r\nconst V16_STORES = V15_STORES;\r\n/** Returns the object stores for the provided schema. */\r\nfunction getObjectStores(schemaVersion) {\r\n    if (schemaVersion === 16) {\r\n        return V16_STORES;\r\n    }\r\n    else if (schemaVersion === 15) {\r\n        return V15_STORES;\r\n    }\r\n    else if (schemaVersion === 14) {\r\n        return V14_STORES;\r\n    }\r\n    else if (schemaVersion === 13) {\r\n        return V13_STORES;\r\n    }\r\n    else if (schemaVersion === 12) {\r\n        return V12_STORES;\r\n    }\r\n    else if (schemaVersion === 11) {\r\n        return V11_STORES;\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbTransaction extends PersistenceTransaction {\r\n    constructor(simpleDbTransaction, currentSequenceNumber) {\r\n        super();\r\n        this.simpleDbTransaction = simpleDbTransaction;\r\n        this.currentSequenceNumber = currentSequenceNumber;\r\n    }\r\n}\r\nfunction getStore(txn, store) {\r\n    const indexedDbTransaction = debugCast(txn);\r\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction objectSize(obj) {\r\n    let count = 0;\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}\r\nfunction forEach(obj, fn) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            fn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\nfunction mapToArray(obj, fn) {\r\n    const result = [];\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            result.push(fn(obj[key], key, obj));\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n// tree.\r\nclass SortedMap {\r\n    constructor(comparator, root) {\r\n        this.comparator = comparator;\r\n        this.root = root ? root : LLRBNode.EMPTY;\r\n    }\r\n    // Returns a copy of the map, with the specified key/value added or replaced.\r\n    insert(key, value) {\r\n        return new SortedMap(this.comparator, this.root\r\n            .insert(key, value, this.comparator)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    // Returns a copy of the map, with the specified key removed.\r\n    remove(key) {\r\n        return new SortedMap(this.comparator, this.root\r\n            .remove(key, this.comparator)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    // Returns the value of the node with the given key, or null.\r\n    get(key) {\r\n        let node = this.root;\r\n        while (!node.isEmpty()) {\r\n            const cmp = this.comparator(key, node.key);\r\n            if (cmp === 0) {\r\n                return node.value;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\r\n    // exist.\r\n    indexOf(key) {\r\n        // Number of nodes that were pruned when descending right\r\n        let prunedNodes = 0;\r\n        let node = this.root;\r\n        while (!node.isEmpty()) {\r\n            const cmp = this.comparator(key, node.key);\r\n            if (cmp === 0) {\r\n                return prunedNodes + node.left.size;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else {\r\n                // Count all nodes left of the node plus the node itself\r\n                prunedNodes += node.left.size + 1;\r\n                node = node.right;\r\n            }\r\n        }\r\n        // Node not found\r\n        return -1;\r\n    }\r\n    isEmpty() {\r\n        return this.root.isEmpty();\r\n    }\r\n    // Returns the total number of nodes in the map.\r\n    get size() {\r\n        return this.root.size;\r\n    }\r\n    // Returns the minimum key in the map.\r\n    minKey() {\r\n        return this.root.minKey();\r\n    }\r\n    // Returns the maximum key in the map.\r\n    maxKey() {\r\n        return this.root.maxKey();\r\n    }\r\n    // Traverses the map in key order and calls the specified action function\r\n    // for each key/value pair. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    inorderTraversal(action) {\r\n        return this.root.inorderTraversal(action);\r\n    }\r\n    forEach(fn) {\r\n        this.inorderTraversal((k, v) => {\r\n            fn(k, v);\r\n            return false;\r\n        });\r\n    }\r\n    toString() {\r\n        const descriptions = [];\r\n        this.inorderTraversal((k, v) => {\r\n            descriptions.push(`${k}:${v}`);\r\n            return false;\r\n        });\r\n        return `{${descriptions.join(', ')}}`;\r\n    }\r\n    // Traverses the map in reverse key order and calls the specified action\r\n    // function for each key/value pair. If action returns true, traversal is\r\n    // aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    reverseTraversal(action) {\r\n        return this.root.reverseTraversal(action);\r\n    }\r\n    // Returns an iterator over the SortedMap.\r\n    getIterator() {\r\n        return new SortedMapIterator(this.root, null, this.comparator, false);\r\n    }\r\n    getIteratorFrom(key) {\r\n        return new SortedMapIterator(this.root, key, this.comparator, false);\r\n    }\r\n    getReverseIterator() {\r\n        return new SortedMapIterator(this.root, null, this.comparator, true);\r\n    }\r\n    getReverseIteratorFrom(key) {\r\n        return new SortedMapIterator(this.root, key, this.comparator, true);\r\n    }\r\n} // end SortedMap\r\n// An iterator over an LLRBNode.\r\nclass SortedMapIterator {\r\n    constructor(node, startKey, comparator, isReverse) {\r\n        this.isReverse = isReverse;\r\n        this.nodeStack = [];\r\n        let cmp = 1;\r\n        while (!node.isEmpty()) {\r\n            cmp = startKey ? comparator(node.key, startKey) : 1;\r\n            // flip the comparison if we're going in reverse\r\n            if (startKey && isReverse) {\r\n                cmp *= -1;\r\n            }\r\n            if (cmp < 0) {\r\n                // This node is less than our start key. ignore it\r\n                if (this.isReverse) {\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = node.right;\r\n                }\r\n            }\r\n            else if (cmp === 0) {\r\n                // This node is exactly equal to our start key. Push it on the stack,\r\n                // but stop iterating;\r\n                this.nodeStack.push(node);\r\n                break;\r\n            }\r\n            else {\r\n                // This node is greater than our start key, add it to the stack and move\r\n                // to the next one\r\n                this.nodeStack.push(node);\r\n                if (this.isReverse) {\r\n                    node = node.right;\r\n                }\r\n                else {\r\n                    node = node.left;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getNext() {\r\n        let node = this.nodeStack.pop();\r\n        const result = { key: node.key, value: node.value };\r\n        if (this.isReverse) {\r\n            node = node.left;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack.push(node);\r\n                node = node.right;\r\n            }\r\n        }\r\n        else {\r\n            node = node.right;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack.push(node);\r\n                node = node.left;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    hasNext() {\r\n        return this.nodeStack.length > 0;\r\n    }\r\n    peek() {\r\n        if (this.nodeStack.length === 0) {\r\n            return null;\r\n        }\r\n        const node = this.nodeStack[this.nodeStack.length - 1];\r\n        return { key: node.key, value: node.value };\r\n    }\r\n} // end SortedMapIterator\r\n// Represents a node in a Left-leaning Red-Black tree.\r\nclass LLRBNode {\r\n    constructor(key, value, color, left, right) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.color = color != null ? color : LLRBNode.RED;\r\n        this.left = left != null ? left : LLRBNode.EMPTY;\r\n        this.right = right != null ? right : LLRBNode.EMPTY;\r\n        this.size = this.left.size + 1 + this.right.size;\r\n    }\r\n    // Returns a copy of the current node, optionally replacing pieces of it.\r\n    copy(key, value, color, left, right) {\r\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\r\n    }\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    // Traverses the tree in key order and calls the specified action function\r\n    // for each node. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    inorderTraversal(action) {\r\n        return (this.left.inorderTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.right.inorderTraversal(action));\r\n    }\r\n    // Traverses the tree in reverse key order and calls the specified action\r\n    // function for each node. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    reverseTraversal(action) {\r\n        return (this.right.reverseTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.left.reverseTraversal(action));\r\n    }\r\n    // Returns the minimum node in the tree.\r\n    min() {\r\n        if (this.left.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left.min();\r\n        }\r\n    }\r\n    // Returns the maximum key in the tree.\r\n    minKey() {\r\n        return this.min().key;\r\n    }\r\n    // Returns the maximum key in the tree.\r\n    maxKey() {\r\n        if (this.right.isEmpty()) {\r\n            return this.key;\r\n        }\r\n        else {\r\n            return this.right.maxKey();\r\n        }\r\n    }\r\n    // Returns new tree, with the key/value added.\r\n    insert(key, value, comparator) {\r\n        let n = this;\r\n        const cmp = comparator(key, n.key);\r\n        if (cmp < 0) {\r\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\r\n        }\r\n        else if (cmp === 0) {\r\n            n = n.copy(null, value, null, null, null);\r\n        }\r\n        else {\r\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\r\n        }\r\n        return n.fixUp();\r\n    }\r\n    removeMin() {\r\n        if (this.left.isEmpty()) {\r\n            return LLRBNode.EMPTY;\r\n        }\r\n        let n = this;\r\n        if (!n.left.isRed() && !n.left.left.isRed()) {\r\n            n = n.moveRedLeft();\r\n        }\r\n        n = n.copy(null, null, null, n.left.removeMin(), null);\r\n        return n.fixUp();\r\n    }\r\n    // Returns new tree, with the specified item removed.\r\n    remove(key, comparator) {\r\n        let smallest;\r\n        let n = this;\r\n        if (comparator(key, n.key) < 0) {\r\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\r\n                n = n.moveRedLeft();\r\n            }\r\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\r\n        }\r\n        else {\r\n            if (n.left.isRed()) {\r\n                n = n.rotateRight();\r\n            }\r\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\r\n                n = n.moveRedRight();\r\n            }\r\n            if (comparator(key, n.key) === 0) {\r\n                if (n.right.isEmpty()) {\r\n                    return LLRBNode.EMPTY;\r\n                }\r\n                else {\r\n                    smallest = n.right.min();\r\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\r\n                }\r\n            }\r\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\r\n        }\r\n        return n.fixUp();\r\n    }\r\n    isRed() {\r\n        return this.color;\r\n    }\r\n    // Returns new tree after performing any needed rotations.\r\n    fixUp() {\r\n        let n = this;\r\n        if (n.right.isRed() && !n.left.isRed()) {\r\n            n = n.rotateLeft();\r\n        }\r\n        if (n.left.isRed() && n.left.left.isRed()) {\r\n            n = n.rotateRight();\r\n        }\r\n        if (n.left.isRed() && n.right.isRed()) {\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    moveRedLeft() {\r\n        let n = this.colorFlip();\r\n        if (n.right.left.isRed()) {\r\n            n = n.copy(null, null, null, null, n.right.rotateRight());\r\n            n = n.rotateLeft();\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    moveRedRight() {\r\n        let n = this.colorFlip();\r\n        if (n.left.left.isRed()) {\r\n            n = n.rotateRight();\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    rotateLeft() {\r\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\r\n        return this.right.copy(null, null, this.color, nl, null);\r\n    }\r\n    rotateRight() {\r\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\r\n        return this.left.copy(null, null, this.color, null, nr);\r\n    }\r\n    colorFlip() {\r\n        const left = this.left.copy(null, null, !this.left.color, null, null);\r\n        const right = this.right.copy(null, null, !this.right.color, null, null);\r\n        return this.copy(null, null, !this.color, left, right);\r\n    }\r\n    // For testing.\r\n    checkMaxDepth() {\r\n        const blackDepth = this.check();\r\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\r\n    // leaves is equal on both sides.  This function verifies that or asserts.\r\n    check() {\r\n        if (this.isRed() && this.left.isRed()) {\r\n            throw fail();\r\n        }\r\n        if (this.right.isRed()) {\r\n            throw fail();\r\n        }\r\n        const blackDepth = this.left.check();\r\n        if (blackDepth !== this.right.check()) {\r\n            throw fail();\r\n        }\r\n        else {\r\n            return blackDepth + (this.isRed() ? 0 : 1);\r\n        }\r\n    }\r\n} // end LLRBNode\r\n// Empty node is shared between all LLRB trees.\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nLLRBNode.EMPTY = null;\r\nLLRBNode.RED = true;\r\nLLRBNode.BLACK = false;\r\n// Represents an empty node (a leaf node in the Red-Black Tree).\r\nclass LLRBEmptyNode {\r\n    constructor() {\r\n        this.size = 0;\r\n    }\r\n    get key() {\r\n        throw fail();\r\n    }\r\n    get value() {\r\n        throw fail();\r\n    }\r\n    get color() {\r\n        throw fail();\r\n    }\r\n    get left() {\r\n        throw fail();\r\n    }\r\n    get right() {\r\n        throw fail();\r\n    }\r\n    // Returns a copy of the current node.\r\n    copy(key, value, color, left, right) {\r\n        return this;\r\n    }\r\n    // Returns a copy of the tree, with the specified key/value added.\r\n    insert(key, value, comparator) {\r\n        return new LLRBNode(key, value);\r\n    }\r\n    // Returns a copy of the tree, with the specified key removed.\r\n    remove(key, comparator) {\r\n        return this;\r\n    }\r\n    isEmpty() {\r\n        return true;\r\n    }\r\n    inorderTraversal(action) {\r\n        return false;\r\n    }\r\n    reverseTraversal(action) {\r\n        return false;\r\n    }\r\n    minKey() {\r\n        return null;\r\n    }\r\n    maxKey() {\r\n        return null;\r\n    }\r\n    isRed() {\r\n        return false;\r\n    }\r\n    // For testing.\r\n    checkMaxDepth() {\r\n        return true;\r\n    }\r\n    check() {\r\n        return 0;\r\n    }\r\n} // end LLRBEmptyNode\r\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * SortedSet is an immutable (copy-on-write) collection that holds elements\r\n * in order specified by the provided comparator.\r\n *\r\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\r\n * be equal!\r\n */\r\nclass SortedSet {\r\n    constructor(comparator) {\r\n        this.comparator = comparator;\r\n        this.data = new SortedMap(this.comparator);\r\n    }\r\n    has(elem) {\r\n        return this.data.get(elem) !== null;\r\n    }\r\n    first() {\r\n        return this.data.minKey();\r\n    }\r\n    last() {\r\n        return this.data.maxKey();\r\n    }\r\n    get size() {\r\n        return this.data.size;\r\n    }\r\n    indexOf(elem) {\r\n        return this.data.indexOf(elem);\r\n    }\r\n    /** Iterates elements in order defined by \"comparator\" */\r\n    forEach(cb) {\r\n        this.data.inorderTraversal((k, v) => {\r\n            cb(k);\r\n            return false;\r\n        });\r\n    }\r\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\r\n    forEachInRange(range, cb) {\r\n        const iter = this.data.getIteratorFrom(range[0]);\r\n        while (iter.hasNext()) {\r\n            const elem = iter.getNext();\r\n            if (this.comparator(elem.key, range[1]) >= 0) {\r\n                return;\r\n            }\r\n            cb(elem.key);\r\n        }\r\n    }\r\n    /**\r\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\r\n     */\r\n    forEachWhile(cb, start) {\r\n        let iter;\r\n        if (start !== undefined) {\r\n            iter = this.data.getIteratorFrom(start);\r\n        }\r\n        else {\r\n            iter = this.data.getIterator();\r\n        }\r\n        while (iter.hasNext()) {\r\n            const elem = iter.getNext();\r\n            const result = cb(elem.key);\r\n            if (!result) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /** Finds the least element greater than or equal to `elem`. */\r\n    firstAfterOrEqual(elem) {\r\n        const iter = this.data.getIteratorFrom(elem);\r\n        return iter.hasNext() ? iter.getNext().key : null;\r\n    }\r\n    getIterator() {\r\n        return new SortedSetIterator(this.data.getIterator());\r\n    }\r\n    getIteratorFrom(key) {\r\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\r\n    }\r\n    /** Inserts or updates an element */\r\n    add(elem) {\r\n        return this.copy(this.data.remove(elem).insert(elem, true));\r\n    }\r\n    /** Deletes an element */\r\n    delete(elem) {\r\n        if (!this.has(elem)) {\r\n            return this;\r\n        }\r\n        return this.copy(this.data.remove(elem));\r\n    }\r\n    isEmpty() {\r\n        return this.data.isEmpty();\r\n    }\r\n    unionWith(other) {\r\n        let result = this;\r\n        // Make sure `result` always refers to the larger one of the two sets.\r\n        if (result.size < other.size) {\r\n            result = other;\r\n            other = this;\r\n        }\r\n        other.forEach(elem => {\r\n            result = result.add(elem);\r\n        });\r\n        return result;\r\n    }\r\n    isEqual(other) {\r\n        if (!(other instanceof SortedSet)) {\r\n            return false;\r\n        }\r\n        if (this.size !== other.size) {\r\n            return false;\r\n        }\r\n        const thisIt = this.data.getIterator();\r\n        const otherIt = other.data.getIterator();\r\n        while (thisIt.hasNext()) {\r\n            const thisElem = thisIt.getNext().key;\r\n            const otherElem = otherIt.getNext().key;\r\n            if (this.comparator(thisElem, otherElem) !== 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    toArray() {\r\n        const res = [];\r\n        this.forEach(targetId => {\r\n            res.push(targetId);\r\n        });\r\n        return res;\r\n    }\r\n    toString() {\r\n        const result = [];\r\n        this.forEach(elem => result.push(elem));\r\n        return 'SortedSet(' + result.toString() + ')';\r\n    }\r\n    copy(data) {\r\n        const result = new SortedSet(this.comparator);\r\n        result.data = data;\r\n        return result;\r\n    }\r\n}\r\nclass SortedSetIterator {\r\n    constructor(iter) {\r\n        this.iter = iter;\r\n    }\r\n    getNext() {\r\n        return this.iter.getNext().key;\r\n    }\r\n    hasNext() {\r\n        return this.iter.hasNext();\r\n    }\r\n}\r\n/**\r\n * Compares two sorted sets for equality using their natural ordering. The\r\n * method computes the intersection and invokes `onAdd` for every element that\r\n * is in `after` but not `before`. `onRemove` is invoked for every element in\r\n * `before` but missing from `after`.\r\n *\r\n * The method creates a copy of both `before` and `after` and runs in O(n log\r\n * n), where n is the size of the two lists.\r\n *\r\n * @param before - The elements that exist in the original set.\r\n * @param after - The elements to diff against the original set.\r\n * @param comparator - The comparator for the elements in before and after.\r\n * @param onAdd - A function to invoke for every element that is part of `\r\n * after` but not `before`.\r\n * @param onRemove - A function to invoke for every element that is part of\r\n * `before` but not `after`.\r\n */\r\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\r\n    const beforeIt = before.getIterator();\r\n    const afterIt = after.getIterator();\r\n    let beforeValue = advanceIterator(beforeIt);\r\n    let afterValue = advanceIterator(afterIt);\r\n    // Walk through the two sets at the same time, using the ordering defined by\r\n    // `comparator`.\r\n    while (beforeValue || afterValue) {\r\n        let added = false;\r\n        let removed = false;\r\n        if (beforeValue && afterValue) {\r\n            const cmp = comparator(beforeValue, afterValue);\r\n            if (cmp < 0) {\r\n                // The element was removed if the next element in our ordered\r\n                // walkthrough is only in `before`.\r\n                removed = true;\r\n            }\r\n            else if (cmp > 0) {\r\n                // The element was added if the next element in our ordered walkthrough\r\n                // is only in `after`.\r\n                added = true;\r\n            }\r\n        }\r\n        else if (beforeValue != null) {\r\n            removed = true;\r\n        }\r\n        else {\r\n            added = true;\r\n        }\r\n        if (added) {\r\n            onAdd(afterValue);\r\n            afterValue = advanceIterator(afterIt);\r\n        }\r\n        else if (removed) {\r\n            onRemove(beforeValue);\r\n            beforeValue = advanceIterator(beforeIt);\r\n        }\r\n        else {\r\n            beforeValue = advanceIterator(beforeIt);\r\n            afterValue = advanceIterator(afterIt);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns the next element from the iterator or `undefined` if none available.\r\n */\r\nfunction advanceIterator(it) {\r\n    return it.hasNext() ? it.getNext() : undefined;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides a set of fields that can be used to partially patch a document.\r\n * FieldMask is used in conjunction with ObjectValue.\r\n * Examples:\r\n *   foo - Overwrites foo entirely with the provided value. If foo is not\r\n *         present in the companion ObjectValue, the field is deleted.\r\n *   foo.bar - Overwrites only the field bar of the object foo.\r\n *             If foo is not an object, foo is replaced with an object\r\n *             containing foo\r\n */\r\nclass FieldMask {\r\n    constructor(fields) {\r\n        this.fields = fields;\r\n        // TODO(dimond): validation of FieldMask\r\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\r\n        fields.sort(FieldPath$1.comparator);\r\n    }\r\n    static empty() {\r\n        return new FieldMask([]);\r\n    }\r\n    /**\r\n     * Returns a new FieldMask object that is the result of adding all the given\r\n     * fields paths to this field mask.\r\n     */\r\n    unionWith(extraFields) {\r\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\r\n        for (const fieldPath of this.fields) {\r\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\r\n        }\r\n        for (const fieldPath of extraFields) {\r\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\r\n        }\r\n        return new FieldMask(mergedMaskSet.toArray());\r\n    }\r\n    /**\r\n     * Verifies that `fieldPath` is included by at least one field in this field\r\n     * mask.\r\n     *\r\n     * This is an O(n) operation, where `n` is the size of the field mask.\r\n     */\r\n    covers(fieldPath) {\r\n        for (const fieldMaskPath of this.fields) {\r\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isEqual(other) {\r\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Converts a Base64 encoded string to a binary string. */\r\nfunction decodeBase64(encoded) {\r\n    // Note: We used to validate the base64 string here via a regular expression.\r\n    // This was removed to improve the performance of indexing.\r\n    return Buffer.from(encoded, 'base64').toString('binary');\r\n}\r\n/** Converts a binary string to a Base64 encoded string. */\r\nfunction encodeBase64(raw) {\r\n    return Buffer.from(raw, 'binary').toString('base64');\r\n}\r\n/** True if and only if the Base64 conversion functions are available. */\r\nfunction isBase64Available() {\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Immutable class that represents a \"proto\" byte string.\r\n *\r\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\r\n * sent on the wire. This class abstracts away this differentiation by holding\r\n * the proto byte string in a common class that must be converted into a string\r\n * before being sent as a proto.\r\n * @internal\r\n */\r\nclass ByteString {\r\n    constructor(binaryString) {\r\n        this.binaryString = binaryString;\r\n    }\r\n    static fromBase64String(base64) {\r\n        const binaryString = decodeBase64(base64);\r\n        return new ByteString(binaryString);\r\n    }\r\n    static fromUint8Array(array) {\r\n        // TODO(indexing); Remove the copy of the byte string here as this method\r\n        // is frequently called during indexing.\r\n        const binaryString = binaryStringFromUint8Array(array);\r\n        return new ByteString(binaryString);\r\n    }\r\n    [Symbol.iterator]() {\r\n        let i = 0;\r\n        return {\r\n            next: () => {\r\n                if (i < this.binaryString.length) {\r\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n    }\r\n    toBase64() {\r\n        return encodeBase64(this.binaryString);\r\n    }\r\n    toUint8Array() {\r\n        return uint8ArrayFromBinaryString(this.binaryString);\r\n    }\r\n    approximateByteSize() {\r\n        return this.binaryString.length * 2;\r\n    }\r\n    compareTo(other) {\r\n        return primitiveComparator(this.binaryString, other.binaryString);\r\n    }\r\n    isEqual(other) {\r\n        return this.binaryString === other.binaryString;\r\n    }\r\n}\r\nByteString.EMPTY_BYTE_STRING = new ByteString('');\r\n/**\r\n * Helper function to convert an Uint8array to a binary string.\r\n */\r\nfunction binaryStringFromUint8Array(array) {\r\n    let binaryString = '';\r\n    for (let i = 0; i < array.length; ++i) {\r\n        binaryString += String.fromCharCode(array[i]);\r\n    }\r\n    return binaryString;\r\n}\r\n/**\r\n * Helper function to convert a binary string to an Uint8Array.\r\n */\r\nfunction uint8ArrayFromBinaryString(binaryString) {\r\n    const buffer = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n        buffer[i] = binaryString.charCodeAt(i);\r\n    }\r\n    return buffer;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\r\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\r\n/**\r\n * Converts the possible Proto values for a timestamp value into a \"seconds and\r\n * nanos\" representation.\r\n */\r\nfunction normalizeTimestamp(date) {\r\n    hardAssert(!!date);\r\n    // The json interface (for the browser) will return an iso timestamp string,\r\n    // while the proto js library (for node) will return a\r\n    // google.protobuf.Timestamp instance.\r\n    if (typeof date === 'string') {\r\n        // The date string can have higher precision (nanos) than the Date class\r\n        // (millis), so we do some custom parsing here.\r\n        // Parse the nanos right out of the string.\r\n        let nanos = 0;\r\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\r\n        hardAssert(!!fraction);\r\n        if (fraction[1]) {\r\n            // Pad the fraction out to 9 digits (nanos).\r\n            let nanoStr = fraction[1];\r\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\r\n            nanos = Number(nanoStr);\r\n        }\r\n        // Parse the date to get the seconds.\r\n        const parsedDate = new Date(date);\r\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\r\n        return { seconds, nanos };\r\n    }\r\n    else {\r\n        // TODO(b/37282237): Use strings for Proto3 timestamps\r\n        // assert(!this.options.useProto3Json,\r\n        //   'The timestamp instance format requires Proto JS.');\r\n        const seconds = normalizeNumber(date.seconds);\r\n        const nanos = normalizeNumber(date.nanos);\r\n        return { seconds, nanos };\r\n    }\r\n}\r\n/**\r\n * Converts the possible Proto types for numbers into a JavaScript number.\r\n * Returns 0 if the value is not numeric.\r\n */\r\nfunction normalizeNumber(value) {\r\n    // TODO(bjornick): Handle int64 greater than 53 bits.\r\n    if (typeof value === 'number') {\r\n        return value;\r\n    }\r\n    else if (typeof value === 'string') {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n/** Converts the possible Proto types for Blobs into a ByteString. */\r\nfunction normalizeByteString(blob) {\r\n    if (typeof blob === 'string') {\r\n        return ByteString.fromBase64String(blob);\r\n    }\r\n    else {\r\n        return ByteString.fromUint8Array(blob);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a locally-applied ServerTimestamp.\r\n *\r\n * Server Timestamps are backed by MapValues that contain an internal field\r\n * `__type__` with a value of `server_timestamp`. The previous value and local\r\n * write time are stored in its `__previous_value__` and `__local_write_time__`\r\n * fields respectively.\r\n *\r\n * Notes:\r\n * - ServerTimestampValue instances are created as the result of applying a\r\n *   transform. They can only exist in the local view of a document. Therefore\r\n *   they do not need to be parsed or serialized.\r\n * - When evaluated locally (e.g. for snapshot.data()), they by default\r\n *   evaluate to `null`. This behavior can be configured by passing custom\r\n *   FieldValueOptions to value().\r\n * - With respect to other ServerTimestampValues, they sort by their\r\n *   localWriteTime.\r\n */\r\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\r\nconst TYPE_KEY = '__type__';\r\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\r\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\r\nfunction isServerTimestamp(value) {\r\n    var _a, _b;\r\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\r\n    return type === SERVER_TIMESTAMP_SENTINEL;\r\n}\r\n/**\r\n * Creates a new ServerTimestamp proto value (using the internal format).\r\n */\r\nfunction serverTimestamp$1(localWriteTime, previousValue) {\r\n    const mapValue = {\r\n        fields: {\r\n            [TYPE_KEY]: {\r\n                stringValue: SERVER_TIMESTAMP_SENTINEL\r\n            },\r\n            [LOCAL_WRITE_TIME_KEY]: {\r\n                timestampValue: {\r\n                    seconds: localWriteTime.seconds,\r\n                    nanos: localWriteTime.nanoseconds\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // We should avoid storing deeply nested server timestamp map values\r\n    // because we never use the intermediate \"previous values\".\r\n    // For example:\r\n    // previous: 42L, add: t1, result: t1 -> 42L\r\n    // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\r\n    // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\r\n    // `getPreviousValue` recursively traverses server timestamps to find the\r\n    // least recent Value.\r\n    if (previousValue && isServerTimestamp(previousValue)) {\r\n        previousValue = getPreviousValue(previousValue);\r\n    }\r\n    if (previousValue) {\r\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\r\n    }\r\n    return { mapValue };\r\n}\r\n/**\r\n * Returns the value of the field before this ServerTimestamp was set.\r\n *\r\n * Preserving the previous values allows the user to display the last resoled\r\n * value until the backend responds with the timestamp.\r\n */\r\nfunction getPreviousValue(value) {\r\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\r\n    if (isServerTimestamp(previousValue)) {\r\n        return getPreviousValue(previousValue);\r\n    }\r\n    return previousValue;\r\n}\r\n/**\r\n * Returns the local time at which this timestamp was first set.\r\n */\r\nfunction getLocalWriteTime(value) {\r\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\r\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass DatabaseInfo {\r\n    /**\r\n     * Constructs a DatabaseInfo using the provided host, databaseId and\r\n     * persistenceKey.\r\n     *\r\n     * @param databaseId - The database to use.\r\n     * @param appId - The Firebase App Id.\r\n     * @param persistenceKey - A unique identifier for this Firestore's local\r\n     * storage (used in conjunction with the databaseId).\r\n     * @param host - The Firestore backend host to connect to.\r\n     * @param ssl - Whether to use SSL when connecting.\r\n     * @param forceLongPolling - Whether to use the forceLongPolling option\r\n     * when using WebChannel as the network transport.\r\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\r\n     * option when using WebChannel as the network transport.\r\n     * @param longPollingOptions Options that configure long-polling.\r\n     * @param useFetchStreams Whether to use the Fetch API instead of\r\n     * XMLHTTPRequest\r\n     */\r\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams) {\r\n        this.databaseId = databaseId;\r\n        this.appId = appId;\r\n        this.persistenceKey = persistenceKey;\r\n        this.host = host;\r\n        this.ssl = ssl;\r\n        this.forceLongPolling = forceLongPolling;\r\n        this.autoDetectLongPolling = autoDetectLongPolling;\r\n        this.longPollingOptions = longPollingOptions;\r\n        this.useFetchStreams = useFetchStreams;\r\n    }\r\n}\r\n/** The default database name for a project. */\r\nconst DEFAULT_DATABASE_NAME = '(default)';\r\n/**\r\n * Represents the database ID a Firestore client is associated with.\r\n * @internal\r\n */\r\nclass DatabaseId {\r\n    constructor(projectId, database) {\r\n        this.projectId = projectId;\r\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\r\n    }\r\n    static empty() {\r\n        return new DatabaseId('', '');\r\n    }\r\n    get isDefaultDatabase() {\r\n        return this.database === DEFAULT_DATABASE_NAME;\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof DatabaseId &&\r\n            other.projectId === this.projectId &&\r\n            other.database === this.database);\r\n    }\r\n}\r\nfunction databaseIdFromApp(app, database) {\r\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\r\n    }\r\n    return new DatabaseId(app.options.projectId, database);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Sentinel value that sorts before any Mutation Batch ID. */\r\nconst BATCHID_UNKNOWN = -1;\r\n/**\r\n * Returns whether a variable is either undefined or null.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\n/** Returns whether the value represents -0. */\r\nfunction isNegativeZero(value) {\r\n    // Detect if the value is -0.0. Based on polyfill from\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n    return value === 0 && 1 / value === 1 / -0;\r\n}\r\n/**\r\n * Returns whether a value is an integer and in the safe integer range\r\n * @param value - The value to test for being an integer and in the safe range\r\n */\r\nfunction isSafeInteger(value) {\r\n    return (typeof value === 'number' &&\r\n        Number.isInteger(value) &&\r\n        !isNegativeZero(value) &&\r\n        value <= Number.MAX_SAFE_INTEGER &&\r\n        value >= Number.MIN_SAFE_INTEGER);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_VALUE_TYPE = '__max__';\r\nconst MAX_VALUE = {\r\n    mapValue: {\r\n        fields: {\r\n            '__type__': { stringValue: MAX_VALUE_TYPE }\r\n        }\r\n    }\r\n};\r\nconst MIN_VALUE = {\r\n    nullValue: 'NULL_VALUE'\r\n};\r\n/** Extracts the backend's type order for the provided value. */\r\nfunction typeOrder(value) {\r\n    if ('nullValue' in value) {\r\n        return 0 /* TypeOrder.NullValue */;\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return 1 /* TypeOrder.BooleanValue */;\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return 2 /* TypeOrder.NumberValue */;\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return 3 /* TypeOrder.TimestampValue */;\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return 5 /* TypeOrder.StringValue */;\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return 6 /* TypeOrder.BlobValue */;\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return 7 /* TypeOrder.RefValue */;\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return 8 /* TypeOrder.GeoPointValue */;\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return 9 /* TypeOrder.ArrayValue */;\r\n    }\r\n    else if ('mapValue' in value) {\r\n        if (isServerTimestamp(value)) {\r\n            return 4 /* TypeOrder.ServerTimestampValue */;\r\n        }\r\n        else if (isMaxValue(value)) {\r\n            return 9007199254740991 /* TypeOrder.MaxValue */;\r\n        }\r\n        return 10 /* TypeOrder.ObjectValue */;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** Tests `left` and `right` for equality based on the backend semantics. */\r\nfunction valueEquals(left, right) {\r\n    if (left === right) {\r\n        return true;\r\n    }\r\n    const leftType = typeOrder(left);\r\n    const rightType = typeOrder(right);\r\n    if (leftType !== rightType) {\r\n        return false;\r\n    }\r\n    switch (leftType) {\r\n        case 0 /* TypeOrder.NullValue */:\r\n            return true;\r\n        case 1 /* TypeOrder.BooleanValue */:\r\n            return left.booleanValue === right.booleanValue;\r\n        case 4 /* TypeOrder.ServerTimestampValue */:\r\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\r\n        case 3 /* TypeOrder.TimestampValue */:\r\n            return timestampEquals(left, right);\r\n        case 5 /* TypeOrder.StringValue */:\r\n            return left.stringValue === right.stringValue;\r\n        case 6 /* TypeOrder.BlobValue */:\r\n            return blobEquals(left, right);\r\n        case 7 /* TypeOrder.RefValue */:\r\n            return left.referenceValue === right.referenceValue;\r\n        case 8 /* TypeOrder.GeoPointValue */:\r\n            return geoPointEquals(left, right);\r\n        case 2 /* TypeOrder.NumberValue */:\r\n            return numberEquals(left, right);\r\n        case 9 /* TypeOrder.ArrayValue */:\r\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\r\n        case 10 /* TypeOrder.ObjectValue */:\r\n            return objectEquals(left, right);\r\n        case 9007199254740991 /* TypeOrder.MaxValue */:\r\n            return true;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction timestampEquals(left, right) {\r\n    if (typeof left.timestampValue === 'string' &&\r\n        typeof right.timestampValue === 'string' &&\r\n        left.timestampValue.length === right.timestampValue.length) {\r\n        // Use string equality for ISO 8601 timestamps\r\n        return left.timestampValue === right.timestampValue;\r\n    }\r\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\r\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\r\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\r\n        leftTimestamp.nanos === rightTimestamp.nanos);\r\n}\r\nfunction geoPointEquals(left, right) {\r\n    return (normalizeNumber(left.geoPointValue.latitude) ===\r\n        normalizeNumber(right.geoPointValue.latitude) &&\r\n        normalizeNumber(left.geoPointValue.longitude) ===\r\n            normalizeNumber(right.geoPointValue.longitude));\r\n}\r\nfunction blobEquals(left, right) {\r\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\r\n}\r\nfunction numberEquals(left, right) {\r\n    if ('integerValue' in left && 'integerValue' in right) {\r\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\r\n    }\r\n    else if ('doubleValue' in left && 'doubleValue' in right) {\r\n        const n1 = normalizeNumber(left.doubleValue);\r\n        const n2 = normalizeNumber(right.doubleValue);\r\n        if (n1 === n2) {\r\n            return isNegativeZero(n1) === isNegativeZero(n2);\r\n        }\r\n        else {\r\n            return isNaN(n1) && isNaN(n2);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction objectEquals(left, right) {\r\n    const leftMap = left.mapValue.fields || {};\r\n    const rightMap = right.mapValue.fields || {};\r\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\r\n        return false;\r\n    }\r\n    for (const key in leftMap) {\r\n        if (leftMap.hasOwnProperty(key)) {\r\n            if (rightMap[key] === undefined ||\r\n                !valueEquals(leftMap[key], rightMap[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/** Returns true if the ArrayValue contains the specified element. */\r\nfunction arrayValueContains(haystack, needle) {\r\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\r\n}\r\nfunction valueCompare(left, right) {\r\n    if (left === right) {\r\n        return 0;\r\n    }\r\n    const leftType = typeOrder(left);\r\n    const rightType = typeOrder(right);\r\n    if (leftType !== rightType) {\r\n        return primitiveComparator(leftType, rightType);\r\n    }\r\n    switch (leftType) {\r\n        case 0 /* TypeOrder.NullValue */:\r\n        case 9007199254740991 /* TypeOrder.MaxValue */:\r\n            return 0;\r\n        case 1 /* TypeOrder.BooleanValue */:\r\n            return primitiveComparator(left.booleanValue, right.booleanValue);\r\n        case 2 /* TypeOrder.NumberValue */:\r\n            return compareNumbers(left, right);\r\n        case 3 /* TypeOrder.TimestampValue */:\r\n            return compareTimestamps(left.timestampValue, right.timestampValue);\r\n        case 4 /* TypeOrder.ServerTimestampValue */:\r\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\r\n        case 5 /* TypeOrder.StringValue */:\r\n            return primitiveComparator(left.stringValue, right.stringValue);\r\n        case 6 /* TypeOrder.BlobValue */:\r\n            return compareBlobs(left.bytesValue, right.bytesValue);\r\n        case 7 /* TypeOrder.RefValue */:\r\n            return compareReferences(left.referenceValue, right.referenceValue);\r\n        case 8 /* TypeOrder.GeoPointValue */:\r\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\r\n        case 9 /* TypeOrder.ArrayValue */:\r\n            return compareArrays(left.arrayValue, right.arrayValue);\r\n        case 10 /* TypeOrder.ObjectValue */:\r\n            return compareMaps(left.mapValue, right.mapValue);\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\nfunction compareNumbers(left, right) {\r\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\r\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\r\n    if (leftNumber < rightNumber) {\r\n        return -1;\r\n    }\r\n    else if (leftNumber > rightNumber) {\r\n        return 1;\r\n    }\r\n    else if (leftNumber === rightNumber) {\r\n        return 0;\r\n    }\r\n    else {\r\n        // one or both are NaN.\r\n        if (isNaN(leftNumber)) {\r\n            return isNaN(rightNumber) ? 0 : -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n}\r\nfunction compareTimestamps(left, right) {\r\n    if (typeof left === 'string' &&\r\n        typeof right === 'string' &&\r\n        left.length === right.length) {\r\n        return primitiveComparator(left, right);\r\n    }\r\n    const leftTimestamp = normalizeTimestamp(left);\r\n    const rightTimestamp = normalizeTimestamp(right);\r\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\r\n    if (comparison !== 0) {\r\n        return comparison;\r\n    }\r\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\r\n}\r\nfunction compareReferences(leftPath, rightPath) {\r\n    const leftSegments = leftPath.split('/');\r\n    const rightSegments = rightPath.split('/');\r\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\r\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\r\n        if (comparison !== 0) {\r\n            return comparison;\r\n        }\r\n    }\r\n    return primitiveComparator(leftSegments.length, rightSegments.length);\r\n}\r\nfunction compareGeoPoints(left, right) {\r\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\r\n    if (comparison !== 0) {\r\n        return comparison;\r\n    }\r\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\r\n}\r\nfunction compareBlobs(left, right) {\r\n    const leftBytes = normalizeByteString(left);\r\n    const rightBytes = normalizeByteString(right);\r\n    return leftBytes.compareTo(rightBytes);\r\n}\r\nfunction compareArrays(left, right) {\r\n    const leftArray = left.values || [];\r\n    const rightArray = right.values || [];\r\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\r\n        const compare = valueCompare(leftArray[i], rightArray[i]);\r\n        if (compare) {\r\n            return compare;\r\n        }\r\n    }\r\n    return primitiveComparator(leftArray.length, rightArray.length);\r\n}\r\nfunction compareMaps(left, right) {\r\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\r\n        return 0;\r\n    }\r\n    else if (left === MAX_VALUE.mapValue) {\r\n        return 1;\r\n    }\r\n    else if (right === MAX_VALUE.mapValue) {\r\n        return -1;\r\n    }\r\n    const leftMap = left.fields || {};\r\n    const leftKeys = Object.keys(leftMap);\r\n    const rightMap = right.fields || {};\r\n    const rightKeys = Object.keys(rightMap);\r\n    // Even though MapValues are likely sorted correctly based on their insertion\r\n    // order (e.g. when received from the backend), local modifications can bring\r\n    // elements out of order. We need to re-sort the elements to ensure that\r\n    // canonical IDs are independent of insertion order.\r\n    leftKeys.sort();\r\n    rightKeys.sort();\r\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\r\n        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\r\n        if (keyCompare !== 0) {\r\n            return keyCompare;\r\n        }\r\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\r\n        if (compare !== 0) {\r\n            return compare;\r\n        }\r\n    }\r\n    return primitiveComparator(leftKeys.length, rightKeys.length);\r\n}\r\n/**\r\n * Generates the canonical ID for the provided field value (as used in Target\r\n * serialization).\r\n */\r\nfunction canonicalId(value) {\r\n    return canonifyValue(value);\r\n}\r\nfunction canonifyValue(value) {\r\n    if ('nullValue' in value) {\r\n        return 'null';\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return '' + value.booleanValue;\r\n    }\r\n    else if ('integerValue' in value) {\r\n        return '' + value.integerValue;\r\n    }\r\n    else if ('doubleValue' in value) {\r\n        return '' + value.doubleValue;\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return canonifyTimestamp(value.timestampValue);\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return value.stringValue;\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return canonifyByteString(value.bytesValue);\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return canonifyReference(value.referenceValue);\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return canonifyGeoPoint(value.geoPointValue);\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return canonifyArray(value.arrayValue);\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return canonifyMap(value.mapValue);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction canonifyByteString(byteString) {\r\n    return normalizeByteString(byteString).toBase64();\r\n}\r\nfunction canonifyTimestamp(timestamp) {\r\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\r\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\r\n}\r\nfunction canonifyGeoPoint(geoPoint) {\r\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\r\n}\r\nfunction canonifyReference(referenceValue) {\r\n    return DocumentKey.fromName(referenceValue).toString();\r\n}\r\nfunction canonifyMap(mapValue) {\r\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\r\n    // matching canonical IDs for identical maps, we need to sort the keys.\r\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\r\n    let result = '{';\r\n    let first = true;\r\n    for (const key of sortedKeys) {\r\n        if (!first) {\r\n            result += ',';\r\n        }\r\n        else {\r\n            first = false;\r\n        }\r\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\r\n    }\r\n    return result + '}';\r\n}\r\nfunction canonifyArray(arrayValue) {\r\n    let result = '[';\r\n    let first = true;\r\n    for (const value of arrayValue.values || []) {\r\n        if (!first) {\r\n            result += ',';\r\n        }\r\n        else {\r\n            first = false;\r\n        }\r\n        result += canonifyValue(value);\r\n    }\r\n    return result + ']';\r\n}\r\n/**\r\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\r\n * value.\r\n *\r\n * The memory size takes into account only the actual user data as it resides\r\n * in memory and ignores object overhead.\r\n */\r\nfunction estimateByteSize(value) {\r\n    switch (typeOrder(value)) {\r\n        case 0 /* TypeOrder.NullValue */:\r\n            return 4;\r\n        case 1 /* TypeOrder.BooleanValue */:\r\n            return 4;\r\n        case 2 /* TypeOrder.NumberValue */:\r\n            return 8;\r\n        case 3 /* TypeOrder.TimestampValue */:\r\n            // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\r\n            return 16;\r\n        case 4 /* TypeOrder.ServerTimestampValue */:\r\n            const previousValue = getPreviousValue(value);\r\n            return previousValue ? 16 + estimateByteSize(previousValue) : 16;\r\n        case 5 /* TypeOrder.StringValue */:\r\n            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\r\n            // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\r\n            // integer values\"\r\n            return value.stringValue.length * 2;\r\n        case 6 /* TypeOrder.BlobValue */:\r\n            return normalizeByteString(value.bytesValue).approximateByteSize();\r\n        case 7 /* TypeOrder.RefValue */:\r\n            return value.referenceValue.length;\r\n        case 8 /* TypeOrder.GeoPointValue */:\r\n            // GeoPoints are made up of two distinct numbers (latitude + longitude)\r\n            return 16;\r\n        case 9 /* TypeOrder.ArrayValue */:\r\n            return estimateArrayByteSize(value.arrayValue);\r\n        case 10 /* TypeOrder.ObjectValue */:\r\n            return estimateMapByteSize(value.mapValue);\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\nfunction estimateMapByteSize(mapValue) {\r\n    let size = 0;\r\n    forEach(mapValue.fields, (key, val) => {\r\n        size += key.length + estimateByteSize(val);\r\n    });\r\n    return size;\r\n}\r\nfunction estimateArrayByteSize(arrayValue) {\r\n    return (arrayValue.values || []).reduce((previousSize, value) => previousSize + estimateByteSize(value), 0);\r\n}\r\n/** Returns a reference value for the provided database and key. */\r\nfunction refValue(databaseId, key) {\r\n    return {\r\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\r\n    };\r\n}\r\n/** Returns true if `value` is an IntegerValue . */\r\nfunction isInteger(value) {\r\n    return !!value && 'integerValue' in value;\r\n}\r\n/** Returns true if `value` is a DoubleValue. */\r\nfunction isDouble(value) {\r\n    return !!value && 'doubleValue' in value;\r\n}\r\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\r\nfunction isNumber(value) {\r\n    return isInteger(value) || isDouble(value);\r\n}\r\n/** Returns true if `value` is an ArrayValue. */\r\nfunction isArray(value) {\r\n    return !!value && 'arrayValue' in value;\r\n}\r\n/** Returns true if `value` is a NullValue. */\r\nfunction isNullValue(value) {\r\n    return !!value && 'nullValue' in value;\r\n}\r\n/** Returns true if `value` is NaN. */\r\nfunction isNanValue(value) {\r\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\r\n}\r\n/** Returns true if `value` is a MapValue. */\r\nfunction isMapValue(value) {\r\n    return !!value && 'mapValue' in value;\r\n}\r\n/** Creates a deep copy of `source`. */\r\nfunction deepClone(source) {\r\n    if (source.geoPointValue) {\r\n        return { geoPointValue: Object.assign({}, source.geoPointValue) };\r\n    }\r\n    else if (source.timestampValue &&\r\n        typeof source.timestampValue === 'object') {\r\n        return { timestampValue: Object.assign({}, source.timestampValue) };\r\n    }\r\n    else if (source.mapValue) {\r\n        const target = { mapValue: { fields: {} } };\r\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\r\n        return target;\r\n    }\r\n    else if (source.arrayValue) {\r\n        const target = { arrayValue: { values: [] } };\r\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\r\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\r\n        }\r\n        return target;\r\n    }\r\n    else {\r\n        return Object.assign({}, source);\r\n    }\r\n}\r\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\r\nfunction isMaxValue(value) {\r\n    return ((((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\r\n        MAX_VALUE_TYPE);\r\n}\r\n/** Returns the lowest value for the given value type (inclusive). */\r\nfunction valuesGetLowerBound(value) {\r\n    if ('nullValue' in value) {\r\n        return MIN_VALUE;\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return { booleanValue: false };\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return { doubleValue: NaN };\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return { stringValue: '' };\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return { bytesValue: '' };\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return { arrayValue: {} };\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return { mapValue: {} };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** Returns the largest value for the given value type (exclusive). */\r\nfunction valuesGetUpperBound(value) {\r\n    if ('nullValue' in value) {\r\n        return { booleanValue: false };\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return { doubleValue: NaN };\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return { stringValue: '' };\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return { bytesValue: '' };\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return { arrayValue: {} };\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return { mapValue: {} };\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return MAX_VALUE;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction lowerBoundCompare(left, right) {\r\n    const cmp = valueCompare(left.value, right.value);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    if (left.inclusive && !right.inclusive) {\r\n        return -1;\r\n    }\r\n    else if (!left.inclusive && right.inclusive) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction upperBoundCompare(left, right) {\r\n    const cmp = valueCompare(left.value, right.value);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    if (left.inclusive && !right.inclusive) {\r\n        return 1;\r\n    }\r\n    else if (!left.inclusive && right.inclusive) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\r\n * ability to add and remove fields (via the ObjectValueBuilder).\r\n */\r\nclass ObjectValue {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    static empty() {\r\n        return new ObjectValue({ mapValue: {} });\r\n    }\r\n    /**\r\n     * Returns the value at the given path or null.\r\n     *\r\n     * @param path - the path to search\r\n     * @returns The value at the path or null if the path is not set.\r\n     */\r\n    field(path) {\r\n        if (path.isEmpty()) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            let currentLevel = this.value;\r\n            for (let i = 0; i < path.length - 1; ++i) {\r\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\r\n                if (!isMapValue(currentLevel)) {\r\n                    return null;\r\n                }\r\n            }\r\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\r\n            return currentLevel || null;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the field to the provided value.\r\n     *\r\n     * @param path - The field path to set.\r\n     * @param value - The value to set.\r\n     */\r\n    set(path, value) {\r\n        const fieldsMap = this.getFieldsMap(path.popLast());\r\n        fieldsMap[path.lastSegment()] = deepClone(value);\r\n    }\r\n    /**\r\n     * Sets the provided fields to the provided values.\r\n     *\r\n     * @param data - A map of fields to values (or null for deletes).\r\n     */\r\n    setAll(data) {\r\n        let parent = FieldPath$1.emptyPath();\r\n        let upserts = {};\r\n        let deletes = [];\r\n        data.forEach((value, path) => {\r\n            if (!parent.isImmediateParentOf(path)) {\r\n                // Insert the accumulated changes at this parent location\r\n                const fieldsMap = this.getFieldsMap(parent);\r\n                this.applyChanges(fieldsMap, upserts, deletes);\r\n                upserts = {};\r\n                deletes = [];\r\n                parent = path.popLast();\r\n            }\r\n            if (value) {\r\n                upserts[path.lastSegment()] = deepClone(value);\r\n            }\r\n            else {\r\n                deletes.push(path.lastSegment());\r\n            }\r\n        });\r\n        const fieldsMap = this.getFieldsMap(parent);\r\n        this.applyChanges(fieldsMap, upserts, deletes);\r\n    }\r\n    /**\r\n     * Removes the field at the specified path. If there is no field at the\r\n     * specified path, nothing is changed.\r\n     *\r\n     * @param path - The field path to remove.\r\n     */\r\n    delete(path) {\r\n        const nestedValue = this.field(path.popLast());\r\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\r\n            delete nestedValue.mapValue.fields[path.lastSegment()];\r\n        }\r\n    }\r\n    isEqual(other) {\r\n        return valueEquals(this.value, other.value);\r\n    }\r\n    /**\r\n     * Returns the map that contains the leaf element of `path`. If the parent\r\n     * entry does not yet exist, or if it is not a map, a new map will be created.\r\n     */\r\n    getFieldsMap(path) {\r\n        let current = this.value;\r\n        if (!current.mapValue.fields) {\r\n            current.mapValue = { fields: {} };\r\n        }\r\n        for (let i = 0; i < path.length; ++i) {\r\n            let next = current.mapValue.fields[path.get(i)];\r\n            if (!isMapValue(next) || !next.mapValue.fields) {\r\n                next = { mapValue: { fields: {} } };\r\n                current.mapValue.fields[path.get(i)] = next;\r\n            }\r\n            current = next;\r\n        }\r\n        return current.mapValue.fields;\r\n    }\r\n    /**\r\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\r\n     * entries.\r\n     */\r\n    applyChanges(fieldsMap, inserts, deletes) {\r\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\r\n        for (const field of deletes) {\r\n            delete fieldsMap[field];\r\n        }\r\n    }\r\n    clone() {\r\n        return new ObjectValue(deepClone(this.value));\r\n    }\r\n}\r\n/**\r\n * Returns a FieldMask built from all fields in a MapValue.\r\n */\r\nfunction extractFieldMask(value) {\r\n    const fields = [];\r\n    forEach(value.fields, (key, value) => {\r\n        const currentPath = new FieldPath$1([key]);\r\n        if (isMapValue(value)) {\r\n            const nestedMask = extractFieldMask(value.mapValue);\r\n            const nestedFields = nestedMask.fields;\r\n            if (nestedFields.length === 0) {\r\n                // Preserve the empty map by adding it to the FieldMask.\r\n                fields.push(currentPath);\r\n            }\r\n            else {\r\n                // For nested and non-empty ObjectValues, add the FieldPath of the\r\n                // leaf nodes.\r\n                for (const nestedPath of nestedFields) {\r\n                    fields.push(currentPath.child(nestedPath));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\r\n            // nodes.\r\n            fields.push(currentPath);\r\n        }\r\n    });\r\n    return new FieldMask(fields);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a document in Firestore with a key, version, data and whether it\r\n * has local mutations applied to it.\r\n *\r\n * Documents can transition between states via `convertToFoundDocument()`,\r\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\r\n * not transition to one of these states even after all mutations have been\r\n * applied, `isValidDocument()` returns false and the document should be removed\r\n * from all views.\r\n */\r\nclass MutableDocument {\r\n    constructor(key, documentType, version, readTime, createTime, data, documentState) {\r\n        this.key = key;\r\n        this.documentType = documentType;\r\n        this.version = version;\r\n        this.readTime = readTime;\r\n        this.createTime = createTime;\r\n        this.data = data;\r\n        this.documentState = documentState;\r\n    }\r\n    /**\r\n     * Creates a document with no known version or data, but which can serve as\r\n     * base document for mutations.\r\n     */\r\n    static newInvalidDocument(documentKey) {\r\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, \r\n        /* version */ SnapshotVersion.min(), \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\r\n    }\r\n    /**\r\n     * Creates a new document that is known to exist with the given data at the\r\n     * given version.\r\n     */\r\n    static newFoundDocument(documentKey, version, createTime, value) {\r\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, \r\n        /* version */ version, \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);\r\n    }\r\n    /** Creates a new document that is known to not exist at the given version. */\r\n    static newNoDocument(documentKey, version) {\r\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, \r\n        /* version */ version, \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\r\n    }\r\n    /**\r\n     * Creates a new document that is known to exist at the given version but\r\n     * whose data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */\r\n    static newUnknownDocument(documentKey, version) {\r\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, \r\n        /* version */ version, \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it exists and that its version\r\n     * and data are known.\r\n     */\r\n    convertToFoundDocument(version, value) {\r\n        // If a document is switching state from being an invalid or deleted\r\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\r\n        // update from Watch or due to applying a local set mutation on top\r\n        // of a deleted document, our best guess about its createTime would be the\r\n        // version at which the document transitioned to a FOUND_DOCUMENT.\r\n        if (this.createTime.isEqual(SnapshotVersion.min()) &&\r\n            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||\r\n                this.documentType === 0 /* DocumentType.INVALID */)) {\r\n            this.createTime = version;\r\n        }\r\n        this.version = version;\r\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;\r\n        this.data = value;\r\n        this.documentState = 0 /* DocumentState.SYNCED */;\r\n        return this;\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it doesn't exist at the given\r\n     * version.\r\n     */\r\n    convertToNoDocument(version) {\r\n        this.version = version;\r\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;\r\n        this.data = ObjectValue.empty();\r\n        this.documentState = 0 /* DocumentState.SYNCED */;\r\n        return this;\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it exists at a given version but\r\n     * that its data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */\r\n    convertToUnknownDocument(version) {\r\n        this.version = version;\r\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;\r\n        this.data = ObjectValue.empty();\r\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setHasCommittedMutations() {\r\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setHasLocalMutations() {\r\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\r\n        this.version = SnapshotVersion.min();\r\n        return this;\r\n    }\r\n    setReadTime(readTime) {\r\n        this.readTime = readTime;\r\n        return this;\r\n    }\r\n    get hasLocalMutations() {\r\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\r\n    }\r\n    get hasCommittedMutations() {\r\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\r\n    }\r\n    get hasPendingWrites() {\r\n        return this.hasLocalMutations || this.hasCommittedMutations;\r\n    }\r\n    isValidDocument() {\r\n        return this.documentType !== 0 /* DocumentType.INVALID */;\r\n    }\r\n    isFoundDocument() {\r\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;\r\n    }\r\n    isNoDocument() {\r\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;\r\n    }\r\n    isUnknownDocument() {\r\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof MutableDocument &&\r\n            this.key.isEqual(other.key) &&\r\n            this.version.isEqual(other.version) &&\r\n            this.documentType === other.documentType &&\r\n            this.documentState === other.documentState &&\r\n            this.data.isEqual(other.data));\r\n    }\r\n    mutableCopy() {\r\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\r\n    }\r\n    toString() {\r\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\r\n            `{createTime: ${this.createTime}}), ` +\r\n            `{documentType: ${this.documentType}}), ` +\r\n            `{documentState: ${this.documentState}})`);\r\n    }\r\n}\r\n/**\r\n * Compares the value for field `field` in the provided documents. Throws if\r\n * the field does not exist in both documents.\r\n */\r\nfunction compareDocumentsByField(field, d1, d2) {\r\n    const v1 = d1.data.field(field);\r\n    const v2 = d2.data.field(field);\r\n    if (v1 !== null && v2 !== null) {\r\n        return valueCompare(v1, v2);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a bound of a query.\r\n *\r\n * The bound is specified with the given components representing a position and\r\n * whether it's just before or just after the position (relative to whatever the\r\n * query order is).\r\n *\r\n * The position represents a logical index position for a query. It's a prefix\r\n * of values for the (potentially implicit) order by clauses of a query.\r\n *\r\n * Bound provides a function to determine whether a document comes before or\r\n * after a bound. This is influenced by whether the position is just before or\r\n * just after the provided values.\r\n */\r\nclass Bound {\r\n    constructor(position, inclusive) {\r\n        this.position = position;\r\n        this.inclusive = inclusive;\r\n    }\r\n}\r\nfunction boundCompareToDocument(bound, orderBy, doc) {\r\n    let comparison = 0;\r\n    for (let i = 0; i < bound.position.length; i++) {\r\n        const orderByComponent = orderBy[i];\r\n        const component = bound.position[i];\r\n        if (orderByComponent.field.isKeyField()) {\r\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\r\n        }\r\n        else {\r\n            const docValue = doc.data.field(orderByComponent.field);\r\n            comparison = valueCompare(component, docValue);\r\n        }\r\n        if (orderByComponent.dir === \"desc\" /* Direction.DESCENDING */) {\r\n            comparison = comparison * -1;\r\n        }\r\n        if (comparison !== 0) {\r\n            break;\r\n        }\r\n    }\r\n    return comparison;\r\n}\r\n/**\r\n * Returns true if a document sorts after a bound using the provided sort\r\n * order.\r\n */\r\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\r\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\r\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\r\n}\r\n/**\r\n * Returns true if a document sorts before a bound using the provided sort\r\n * order.\r\n */\r\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\r\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\r\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\r\n}\r\nfunction boundEquals(left, right) {\r\n    if (left === null) {\r\n        return right === null;\r\n    }\r\n    else if (right === null) {\r\n        return false;\r\n    }\r\n    if (left.inclusive !== right.inclusive ||\r\n        left.position.length !== right.position.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.position.length; i++) {\r\n        const leftPosition = left.position[i];\r\n        const rightPosition = right.position[i];\r\n        if (!valueEquals(leftPosition, rightPosition)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\r\n */\r\nclass OrderBy {\r\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */) {\r\n        this.field = field;\r\n        this.dir = dir;\r\n    }\r\n}\r\nfunction canonifyOrderBy(orderBy) {\r\n    // TODO(b/29183165): Make this collision robust.\r\n    return orderBy.field.canonicalString() + orderBy.dir;\r\n}\r\nfunction stringifyOrderBy(orderBy) {\r\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\r\n}\r\nfunction orderByEquals(left, right) {\r\n    return left.dir === right.dir && left.field.isEqual(right.field);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Filter {\r\n}\r\nclass FieldFilter extends Filter {\r\n    constructor(field, op, value) {\r\n        super();\r\n        this.field = field;\r\n        this.op = op;\r\n        this.value = value;\r\n    }\r\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */\r\n    static create(field, op, value) {\r\n        if (field.isKeyField()) {\r\n            if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\r\n                return this.createKeyFieldInFilter(field, op, value);\r\n            }\r\n            else {\r\n                return new KeyFieldFilter(field, op, value);\r\n            }\r\n        }\r\n        else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */) {\r\n            return new ArrayContainsFilter(field, value);\r\n        }\r\n        else if (op === \"in\" /* Operator.IN */) {\r\n            return new InFilter(field, value);\r\n        }\r\n        else if (op === \"not-in\" /* Operator.NOT_IN */) {\r\n            return new NotInFilter(field, value);\r\n        }\r\n        else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n            return new ArrayContainsAnyFilter(field, value);\r\n        }\r\n        else {\r\n            return new FieldFilter(field, op, value);\r\n        }\r\n    }\r\n    static createKeyFieldInFilter(field, op, value) {\r\n        return op === \"in\" /* Operator.IN */\r\n            ? new KeyFieldInFilter(field, value)\r\n            : new KeyFieldNotInFilter(field, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        // Types do not have to match in NOT_EQUAL filters.\r\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */) {\r\n            return (other !== null &&\r\n                this.matchesComparison(valueCompare(other, this.value)));\r\n        }\r\n        // Only compare types with matching backend order (such as double and int).\r\n        return (other !== null &&\r\n            typeOrder(this.value) === typeOrder(other) &&\r\n            this.matchesComparison(valueCompare(other, this.value)));\r\n    }\r\n    matchesComparison(comparison) {\r\n        switch (this.op) {\r\n            case \"<\" /* Operator.LESS_THAN */:\r\n                return comparison < 0;\r\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\r\n                return comparison <= 0;\r\n            case \"==\" /* Operator.EQUAL */:\r\n                return comparison === 0;\r\n            case \"!=\" /* Operator.NOT_EQUAL */:\r\n                return comparison !== 0;\r\n            case \">\" /* Operator.GREATER_THAN */:\r\n                return comparison > 0;\r\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\r\n                return comparison >= 0;\r\n            default:\r\n                return fail();\r\n        }\r\n    }\r\n    isInequality() {\r\n        return ([\r\n            \"<\" /* Operator.LESS_THAN */,\r\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */,\r\n            \">\" /* Operator.GREATER_THAN */,\r\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */,\r\n            \"!=\" /* Operator.NOT_EQUAL */,\r\n            \"not-in\" /* Operator.NOT_IN */\r\n        ].indexOf(this.op) >= 0);\r\n    }\r\n    getFlattenedFilters() {\r\n        return [this];\r\n    }\r\n    getFilters() {\r\n        return [this];\r\n    }\r\n}\r\nclass CompositeFilter extends Filter {\r\n    constructor(filters, op) {\r\n        super();\r\n        this.filters = filters;\r\n        this.op = op;\r\n        this.memoizedFlattenedFilters = null;\r\n    }\r\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */\r\n    static create(filters, op) {\r\n        return new CompositeFilter(filters, op);\r\n    }\r\n    matches(doc) {\r\n        if (compositeFilterIsConjunction(this)) {\r\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\r\n            return this.filters.find(filter => !filter.matches(doc)) === undefined;\r\n        }\r\n        else {\r\n            // For disjunctions, at least one filter should match.\r\n            return this.filters.find(filter => filter.matches(doc)) !== undefined;\r\n        }\r\n    }\r\n    getFlattenedFilters() {\r\n        if (this.memoizedFlattenedFilters !== null) {\r\n            return this.memoizedFlattenedFilters;\r\n        }\r\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\r\n            return result.concat(subfilter.getFlattenedFilters());\r\n        }, []);\r\n        return this.memoizedFlattenedFilters;\r\n    }\r\n    // Returns a mutable copy of `this.filters`\r\n    getFilters() {\r\n        return Object.assign([], this.filters);\r\n    }\r\n}\r\nfunction compositeFilterIsConjunction(compositeFilter) {\r\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */;\r\n}\r\nfunction compositeFilterIsDisjunction(compositeFilter) {\r\n    return compositeFilter.op === \"or\" /* CompositeOperator.OR */;\r\n}\r\n/**\r\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\r\n */\r\nfunction compositeFilterIsFlatConjunction(compositeFilter) {\r\n    return (compositeFilterIsFlat(compositeFilter) &&\r\n        compositeFilterIsConjunction(compositeFilter));\r\n}\r\n/**\r\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\r\n */\r\nfunction compositeFilterIsFlat(compositeFilter) {\r\n    for (const filter of compositeFilter.filters) {\r\n        if (filter instanceof CompositeFilter) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction canonifyFilter(filter) {\r\n    if (filter instanceof FieldFilter) {\r\n        // TODO(b/29183165): Technically, this won't be unique if two values have\r\n        // the same description, such as the int 3 and the string \"3\". So we should\r\n        // add the types in here somehow, too.\r\n        return (filter.field.canonicalString() +\r\n            filter.op.toString() +\r\n            canonicalId(filter.value));\r\n    }\r\n    else if (compositeFilterIsFlatConjunction(filter)) {\r\n        // Older SDK versions use an implicit AND operation between their filters.\r\n        // In the new SDK versions, the developer may use an explicit AND filter.\r\n        // To stay consistent with the old usages, we add a special case to ensure\r\n        // the canonical ID for these two are the same. For example:\r\n        // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\r\n        // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\r\n        return filter.filters.map(filter => canonifyFilter(filter)).join(',');\r\n    }\r\n    else {\r\n        // filter instanceof CompositeFilter\r\n        const canonicalIdsString = filter.filters\r\n            .map(filter => canonifyFilter(filter))\r\n            .join(',');\r\n        return `${filter.op}(${canonicalIdsString})`;\r\n    }\r\n}\r\nfunction filterEquals(f1, f2) {\r\n    if (f1 instanceof FieldFilter) {\r\n        return fieldFilterEquals(f1, f2);\r\n    }\r\n    else if (f1 instanceof CompositeFilter) {\r\n        return compositeFilterEquals(f1, f2);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n}\r\nfunction fieldFilterEquals(f1, f2) {\r\n    return (f2 instanceof FieldFilter &&\r\n        f1.op === f2.op &&\r\n        f1.field.isEqual(f2.field) &&\r\n        valueEquals(f1.value, f2.value));\r\n}\r\nfunction compositeFilterEquals(f1, f2) {\r\n    if (f2 instanceof CompositeFilter &&\r\n        f1.op === f2.op &&\r\n        f1.filters.length === f2.filters.length) {\r\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);\r\n        return subFiltersMatch;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns a new composite filter that contains all filter from\r\n * `compositeFilter` plus all the given filters in `otherFilters`.\r\n */\r\nfunction compositeFilterWithAddedFilters(compositeFilter, otherFilters) {\r\n    const mergedFilters = compositeFilter.filters.concat(otherFilters);\r\n    return CompositeFilter.create(mergedFilters, compositeFilter.op);\r\n}\r\n/** Returns a debug description for `filter`. */\r\nfunction stringifyFilter(filter) {\r\n    if (filter instanceof FieldFilter) {\r\n        return stringifyFieldFilter(filter);\r\n    }\r\n    else if (filter instanceof CompositeFilter) {\r\n        return stringifyCompositeFilter(filter);\r\n    }\r\n    else {\r\n        return 'Filter';\r\n    }\r\n}\r\nfunction stringifyCompositeFilter(filter) {\r\n    return (filter.op.toString() +\r\n        ` {` +\r\n        filter.getFilters().map(stringifyFilter).join(' ,') +\r\n        '}');\r\n}\r\nfunction stringifyFieldFilter(filter) {\r\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\r\n}\r\n/** Filter that matches on key fields (i.e. '__name__'). */\r\nclass KeyFieldFilter extends FieldFilter {\r\n    constructor(field, op, value) {\r\n        super(field, op, value);\r\n        this.key = DocumentKey.fromName(value.referenceValue);\r\n    }\r\n    matches(doc) {\r\n        const comparison = DocumentKey.comparator(doc.key, this.key);\r\n        return this.matchesComparison(comparison);\r\n    }\r\n}\r\n/** Filter that matches on key fields within an array. */\r\nclass KeyFieldInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"in\" /* Operator.IN */, value);\r\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */, value);\r\n    }\r\n    matches(doc) {\r\n        return this.keys.some(key => key.isEqual(doc.key));\r\n    }\r\n}\r\n/** Filter that matches on key fields not present within an array. */\r\nclass KeyFieldNotInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\r\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */, value);\r\n    }\r\n    matches(doc) {\r\n        return !this.keys.some(key => key.isEqual(doc.key));\r\n    }\r\n}\r\nfunction extractDocumentKeysFromArrayValue(op, value) {\r\n    var _a;\r\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => {\r\n        return DocumentKey.fromName(v.referenceValue);\r\n    });\r\n}\r\n/** A Filter that implements the array-contains operator. */\r\nclass ArrayContainsFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\r\n    }\r\n}\r\n/** A Filter that implements the IN operator. */\r\nclass InFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"in\" /* Operator.IN */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\r\n    }\r\n}\r\n/** A Filter that implements the not-in operator. */\r\nclass NotInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\r\n    }\r\n    matches(doc) {\r\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\r\n            return false;\r\n        }\r\n        const other = doc.data.field(this.field);\r\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\r\n    }\r\n}\r\n/** A Filter that implements the array-contains-any operator. */\r\nclass ArrayContainsAnyFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        if (!isArray(other) || !other.arrayValue.values) {\r\n            return false;\r\n        }\r\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Visible for testing\r\nclass TargetImpl {\r\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\r\n        this.path = path;\r\n        this.collectionGroup = collectionGroup;\r\n        this.orderBy = orderBy;\r\n        this.filters = filters;\r\n        this.limit = limit;\r\n        this.startAt = startAt;\r\n        this.endAt = endAt;\r\n        this.memoizedCanonicalId = null;\r\n    }\r\n}\r\n/**\r\n * Initializes a Target with a path and optional additional query constraints.\r\n * Path must currently be empty if this is a collection group query.\r\n *\r\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\r\n * using this factory method, because `Query` provides an implicit `orderBy`\r\n * property.\r\n */\r\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\r\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\r\n}\r\nfunction canonifyTarget(target) {\r\n    const targetImpl = debugCast(target);\r\n    if (targetImpl.memoizedCanonicalId === null) {\r\n        let str = targetImpl.path.canonicalString();\r\n        if (targetImpl.collectionGroup !== null) {\r\n            str += '|cg:' + targetImpl.collectionGroup;\r\n        }\r\n        str += '|f:';\r\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\r\n        str += '|ob:';\r\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\r\n        if (!isNullOrUndefined(targetImpl.limit)) {\r\n            str += '|l:';\r\n            str += targetImpl.limit;\r\n        }\r\n        if (targetImpl.startAt) {\r\n            str += '|lb:';\r\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\r\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\r\n        }\r\n        if (targetImpl.endAt) {\r\n            str += '|ub:';\r\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\r\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\r\n        }\r\n        targetImpl.memoizedCanonicalId = str;\r\n    }\r\n    return targetImpl.memoizedCanonicalId;\r\n}\r\nfunction stringifyTarget(target) {\r\n    let str = target.path.canonicalString();\r\n    if (target.collectionGroup !== null) {\r\n        str += ' collectionGroup=' + target.collectionGroup;\r\n    }\r\n    if (target.filters.length > 0) {\r\n        str += `, filters: [${target.filters\r\n            .map(f => stringifyFilter(f))\r\n            .join(', ')}]`;\r\n    }\r\n    if (!isNullOrUndefined(target.limit)) {\r\n        str += ', limit: ' + target.limit;\r\n    }\r\n    if (target.orderBy.length > 0) {\r\n        str += `, orderBy: [${target.orderBy\r\n            .map(o => stringifyOrderBy(o))\r\n            .join(', ')}]`;\r\n    }\r\n    if (target.startAt) {\r\n        str += ', startAt: ';\r\n        str += target.startAt.inclusive ? 'b:' : 'a:';\r\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\r\n    }\r\n    if (target.endAt) {\r\n        str += ', endAt: ';\r\n        str += target.endAt.inclusive ? 'a:' : 'b:';\r\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\r\n    }\r\n    return `Target(${str})`;\r\n}\r\nfunction targetEquals(left, right) {\r\n    if (left.limit !== right.limit) {\r\n        return false;\r\n    }\r\n    if (left.orderBy.length !== right.orderBy.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.orderBy.length; i++) {\r\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    if (left.filters.length !== right.filters.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.filters.length; i++) {\r\n        if (!filterEquals(left.filters[i], right.filters[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    if (left.collectionGroup !== right.collectionGroup) {\r\n        return false;\r\n    }\r\n    if (!left.path.isEqual(right.path)) {\r\n        return false;\r\n    }\r\n    if (!boundEquals(left.startAt, right.startAt)) {\r\n        return false;\r\n    }\r\n    return boundEquals(left.endAt, right.endAt);\r\n}\r\nfunction targetIsDocumentTarget(target) {\r\n    return (DocumentKey.isDocumentKey(target.path) &&\r\n        target.collectionGroup === null &&\r\n        target.filters.length === 0);\r\n}\r\n/** Returns the field filters that target the given field path. */\r\nfunction targetGetFieldFiltersForPath(target, path) {\r\n    return target.filters.filter(f => f instanceof FieldFilter && f.field.isEqual(path));\r\n}\r\n/**\r\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\r\n * filters. Returns `null` if there are no such filters.\r\n */\r\nfunction targetGetArrayValues(target, fieldIndex) {\r\n    const segment = fieldIndexGetArraySegment(fieldIndex);\r\n    if (segment === undefined) {\r\n        return null;\r\n    }\r\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\r\n        switch (fieldFilter.op) {\r\n            case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\r\n                return fieldFilter.value.arrayValue.values || [];\r\n            case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\r\n                return [fieldFilter.value];\r\n            // Remaining filters are not array filters.\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns the list of values that are used in != or NOT_IN filters. Returns\r\n * `null` if there are no such filters.\r\n */\r\nfunction targetGetNotInValues(target, fieldIndex) {\r\n    const values = new Map();\r\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n        for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\r\n            switch (fieldFilter.op) {\r\n                case \"==\" /* Operator.EQUAL */:\r\n                case \"in\" /* Operator.IN */:\r\n                    // Encode equality prefix, which is encoded in the index value before\r\n                    // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\r\n                    // `value != 'ab'`).\r\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\r\n                    break;\r\n                case \"not-in\" /* Operator.NOT_IN */:\r\n                case \"!=\" /* Operator.NOT_EQUAL */:\r\n                    // NotIn/NotEqual is always a suffix. There cannot be any remaining\r\n                    // segments and hence we can return early here.\r\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\r\n                    return Array.from(values.values());\r\n                // Remaining filters cannot be used as notIn bounds.\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns a lower bound of field values that can be used as a starting point to\r\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\r\n * exists.\r\n */\r\nfunction targetGetLowerBound(target, fieldIndex) {\r\n    const values = [];\r\n    let inclusive = true;\r\n    // For each segment, retrieve a lower bound if there is a suitable filter or\r\n    // startAt.\r\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\r\n            ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\r\n            : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\r\n        values.push(segmentBound.value);\r\n        inclusive && (inclusive = segmentBound.inclusive);\r\n    }\r\n    return new Bound(values, inclusive);\r\n}\r\n/**\r\n * Returns an upper bound of field values that can be used as an ending point\r\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\r\n * upper bound exists.\r\n */\r\nfunction targetGetUpperBound(target, fieldIndex) {\r\n    const values = [];\r\n    let inclusive = true;\r\n    // For each segment, retrieve an upper bound if there is a suitable filter or\r\n    // endAt.\r\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\r\n            ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\r\n            : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\r\n        values.push(segmentBound.value);\r\n        inclusive && (inclusive = segmentBound.inclusive);\r\n    }\r\n    return new Bound(values, inclusive);\r\n}\r\n/**\r\n * Returns the value to use as the lower bound for ascending index segment at\r\n * the provided `fieldPath` (or the upper bound for an descending segment).\r\n */\r\nfunction targetGetAscendingBound(target, fieldPath, bound) {\r\n    let value = MIN_VALUE;\r\n    let inclusive = true;\r\n    // Process all filters to find a value for the current field segment\r\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\r\n        let filterValue = MIN_VALUE;\r\n        let filterInclusive = true;\r\n        switch (fieldFilter.op) {\r\n            case \"<\" /* Operator.LESS_THAN */:\r\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\r\n                filterValue = valuesGetLowerBound(fieldFilter.value);\r\n                break;\r\n            case \"==\" /* Operator.EQUAL */:\r\n            case \"in\" /* Operator.IN */:\r\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\r\n                filterValue = fieldFilter.value;\r\n                break;\r\n            case \">\" /* Operator.GREATER_THAN */:\r\n                filterValue = fieldFilter.value;\r\n                filterInclusive = false;\r\n                break;\r\n            case \"!=\" /* Operator.NOT_EQUAL */:\r\n            case \"not-in\" /* Operator.NOT_IN */:\r\n                filterValue = MIN_VALUE;\r\n                break;\r\n            // Remaining filters cannot be used as lower bounds.\r\n        }\r\n        if (lowerBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) < 0) {\r\n            value = filterValue;\r\n            inclusive = filterInclusive;\r\n        }\r\n    }\r\n    // If there is an additional bound, compare the values against the existing\r\n    // range to see if we can narrow the scope.\r\n    if (bound !== null) {\r\n        for (let i = 0; i < target.orderBy.length; ++i) {\r\n            const orderBy = target.orderBy[i];\r\n            if (orderBy.field.isEqual(fieldPath)) {\r\n                const cursorValue = bound.position[i];\r\n                if (lowerBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) < 0) {\r\n                    value = cursorValue;\r\n                    inclusive = bound.inclusive;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return { value, inclusive };\r\n}\r\n/**\r\n * Returns the value to use as the upper bound for ascending index segment at\r\n * the provided `fieldPath` (or the lower bound for a descending segment).\r\n */\r\nfunction targetGetDescendingBound(target, fieldPath, bound) {\r\n    let value = MAX_VALUE;\r\n    let inclusive = true;\r\n    // Process all filters to find a value for the current field segment\r\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\r\n        let filterValue = MAX_VALUE;\r\n        let filterInclusive = true;\r\n        switch (fieldFilter.op) {\r\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\r\n            case \">\" /* Operator.GREATER_THAN */:\r\n                filterValue = valuesGetUpperBound(fieldFilter.value);\r\n                filterInclusive = false;\r\n                break;\r\n            case \"==\" /* Operator.EQUAL */:\r\n            case \"in\" /* Operator.IN */:\r\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\r\n                filterValue = fieldFilter.value;\r\n                break;\r\n            case \"<\" /* Operator.LESS_THAN */:\r\n                filterValue = fieldFilter.value;\r\n                filterInclusive = false;\r\n                break;\r\n            case \"!=\" /* Operator.NOT_EQUAL */:\r\n            case \"not-in\" /* Operator.NOT_IN */:\r\n                filterValue = MAX_VALUE;\r\n                break;\r\n            // Remaining filters cannot be used as upper bounds.\r\n        }\r\n        if (upperBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) > 0) {\r\n            value = filterValue;\r\n            inclusive = filterInclusive;\r\n        }\r\n    }\r\n    // If there is an additional bound, compare the values against the existing\r\n    // range to see if we can narrow the scope.\r\n    if (bound !== null) {\r\n        for (let i = 0; i < target.orderBy.length; ++i) {\r\n            const orderBy = target.orderBy[i];\r\n            if (orderBy.field.isEqual(fieldPath)) {\r\n                const cursorValue = bound.position[i];\r\n                if (upperBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) > 0) {\r\n                    value = cursorValue;\r\n                    inclusive = bound.inclusive;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return { value, inclusive };\r\n}\r\n/** Returns the number of segments of a perfect index for this target. */\r\nfunction targetGetSegmentCount(target) {\r\n    let fields = new SortedSet(FieldPath$1.comparator);\r\n    let hasArraySegment = false;\r\n    for (const filter of target.filters) {\r\n        for (const subFilter of filter.getFlattenedFilters()) {\r\n            // __name__ is not an explicit segment of any index, so we don't need to\r\n            // count it.\r\n            if (subFilter.field.isKeyField()) {\r\n                continue;\r\n            }\r\n            // ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filters must be counted separately.\r\n            // For instance, it is possible to have an index for \"a ARRAY a ASC\". Even\r\n            // though these are on the same field, they should be counted as two\r\n            // separate segments in an index.\r\n            if (subFilter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\r\n                subFilter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n                hasArraySegment = true;\r\n            }\r\n            else {\r\n                fields = fields.add(subFilter.field);\r\n            }\r\n        }\r\n    }\r\n    for (const orderBy of target.orderBy) {\r\n        // __name__ is not an explicit segment of any index, so we don't need to\r\n        // count it.\r\n        if (!orderBy.field.isKeyField()) {\r\n            fields = fields.add(orderBy.field);\r\n        }\r\n    }\r\n    return fields.size + (hasArraySegment ? 1 : 0);\r\n}\r\nfunction targetHasLimit(target) {\r\n    return target.limit !== null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Query encapsulates all the query attributes we support in the SDK. It can\r\n * be run against the LocalStore, as well as be converted to a `Target` to\r\n * query the RemoteStore results.\r\n *\r\n * Visible for testing.\r\n */\r\nclass QueryImpl {\r\n    /**\r\n     * Initializes a Query with a path and optional additional query constraints.\r\n     * Path must currently be empty if this is a collection group query.\r\n     */\r\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */, startAt = null, endAt = null) {\r\n        this.path = path;\r\n        this.collectionGroup = collectionGroup;\r\n        this.explicitOrderBy = explicitOrderBy;\r\n        this.filters = filters;\r\n        this.limit = limit;\r\n        this.limitType = limitType;\r\n        this.startAt = startAt;\r\n        this.endAt = endAt;\r\n        this.memoizedNormalizedOrderBy = null;\r\n        // The corresponding `Target` of this `Query` instance, for use with\r\n        // non-aggregate queries.\r\n        this.memoizedTarget = null;\r\n        // The corresponding `Target` of this `Query` instance, for use with\r\n        // aggregate queries. Unlike targets for non-aggregate queries,\r\n        // aggregate query targets do not contain normalized order-bys, they only\r\n        // contain explicit order-bys.\r\n        this.memoizedAggregateTarget = null;\r\n        if (this.startAt) ;\r\n        if (this.endAt) ;\r\n    }\r\n}\r\n/** Creates a new Query instance with the options provided. */\r\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\r\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\r\n}\r\n/** Creates a new Query for a query that matches all documents at `path` */\r\nfunction newQueryForPath(path) {\r\n    return new QueryImpl(path);\r\n}\r\n/**\r\n * Helper to convert a collection group query into a collection query at a\r\n * specific path. This is used when executing collection group queries, since\r\n * we have to split the query into a set of collection queries at multiple\r\n * paths.\r\n */\r\nfunction asCollectionQueryAtPath(query, path) {\r\n    return new QueryImpl(path, \r\n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\n/**\r\n * Returns true if this query does not specify any query constraints that\r\n * could remove results.\r\n */\r\nfunction queryMatchesAllDocuments(query) {\r\n    return (query.filters.length === 0 &&\r\n        query.limit === null &&\r\n        query.startAt == null &&\r\n        query.endAt == null &&\r\n        (query.explicitOrderBy.length === 0 ||\r\n            (query.explicitOrderBy.length === 1 &&\r\n                query.explicitOrderBy[0].field.isKeyField())));\r\n}\r\n// Returns the sorted set of inequality filter fields used in this query.\r\nfunction getInequalityFilterFields(query) {\r\n    let result = new SortedSet(FieldPath$1.comparator);\r\n    query.filters.forEach((filter) => {\r\n        const subFilters = filter.getFlattenedFilters();\r\n        subFilters.forEach((filter) => {\r\n            if (filter.isInequality()) {\r\n                result = result.add(filter.field);\r\n            }\r\n        });\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * Creates a new Query for a collection group query that matches all documents\r\n * within the provided collection group.\r\n */\r\nfunction newQueryForCollectionGroup(collectionId) {\r\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\r\n}\r\n/**\r\n * Returns whether the query matches a single document by path (rather than a\r\n * collection).\r\n */\r\nfunction isDocumentQuery$1(query) {\r\n    return (DocumentKey.isDocumentKey(query.path) &&\r\n        query.collectionGroup === null &&\r\n        query.filters.length === 0);\r\n}\r\n/**\r\n * Returns whether the query matches a collection group rather than a specific\r\n * collection.\r\n */\r\nfunction isCollectionGroupQuery(query) {\r\n    return query.collectionGroup !== null;\r\n}\r\n/**\r\n * Returns the normalized order-by constraint that is used to execute the Query,\r\n * which can be different from the order-by constraints the user provided (e.g.\r\n * the SDK and backend always orders by `__name__`). The normalized order-by\r\n * includes implicit order-bys in addition to the explicit user provided\r\n * order-bys.\r\n */\r\nfunction queryNormalizedOrderBy(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\r\n        queryImpl.memoizedNormalizedOrderBy = [];\r\n        const fieldsNormalized = new Set();\r\n        // Any explicit order by fields should be added as is.\r\n        for (const orderBy of queryImpl.explicitOrderBy) {\r\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\r\n            fieldsNormalized.add(orderBy.field.canonicalString());\r\n        }\r\n        // The order of the implicit ordering always matches the last explicit order by.\r\n        const lastDirection = queryImpl.explicitOrderBy.length > 0\r\n            ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir\r\n            : \"asc\" /* Direction.ASCENDING */;\r\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\r\n        // order. When there are multiple inequality filters on the same field, the field should be added\r\n        // only once.\r\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\r\n        // field to be sorted last.\r\n        const inequalityFields = getInequalityFilterFields(queryImpl);\r\n        inequalityFields.forEach(field => {\r\n            if (!fieldsNormalized.has(field.canonicalString()) &&\r\n                !field.isKeyField()) {\r\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\r\n            }\r\n        });\r\n        // Add the document key field to the last if it is not explicitly ordered.\r\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\r\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\r\n        }\r\n    }\r\n    return queryImpl.memoizedNormalizedOrderBy;\r\n}\r\n/**\r\n * Converts this `Query` instance to its corresponding `Target` representation.\r\n */\r\nfunction queryToTarget(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (!queryImpl.memoizedTarget) {\r\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\r\n    }\r\n    return queryImpl.memoizedTarget;\r\n}\r\n/**\r\n * Converts this `Query` instance to its corresponding `Target` representation,\r\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\r\n * aggregate query targets do not contain normalized order-bys, they only\r\n * contain explicit order-bys.\r\n */\r\nfunction queryToAggregateTarget(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (!queryImpl.memoizedAggregateTarget) {\r\n        // Do not include implicit order-bys for aggregate queries.\r\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\r\n    }\r\n    return queryImpl.memoizedAggregateTarget;\r\n}\r\nfunction _queryToTarget(queryImpl, orderBys) {\r\n    if (queryImpl.limitType === \"F\" /* LimitType.First */) {\r\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\r\n    }\r\n    else {\r\n        // Flip the orderBy directions since we want the last results\r\n        orderBys = orderBys.map(orderBy => {\r\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */\r\n                ? \"asc\" /* Direction.ASCENDING */\r\n                : \"desc\" /* Direction.DESCENDING */;\r\n            return new OrderBy(orderBy.field, dir);\r\n        });\r\n        // We need to swap the cursors to match the now-flipped query ordering.\r\n        const startAt = queryImpl.endAt\r\n            ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)\r\n            : null;\r\n        const endAt = queryImpl.startAt\r\n            ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)\r\n            : null;\r\n        // Now return as a LimitType.First query.\r\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\r\n    }\r\n}\r\nfunction queryWithAddedFilter(query, filter) {\r\n    const newFilters = query.filters.concat([filter]);\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithAddedOrderBy(query, orderBy) {\r\n    // TODO(dimond): validate that orderBy does not list the same key twice.\r\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\r\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithLimit(query, limit, limitType) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithStartAt(query, bound) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\r\n}\r\nfunction queryWithEndAt(query, bound) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\r\n}\r\nfunction queryEquals(left, right) {\r\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\r\n        left.limitType === right.limitType);\r\n}\r\n// TODO(b/29183165): This is used to get a unique string from a query to, for\r\n// example, use as a dictionary key, but the implementation is subject to\r\n// collisions. Make it collision-free.\r\nfunction canonifyQuery(query) {\r\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\r\n}\r\nfunction stringifyQuery(query) {\r\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\r\n}\r\n/** Returns whether `doc` matches the constraints of `query`. */\r\nfunction queryMatches(query, doc) {\r\n    return (doc.isFoundDocument() &&\r\n        queryMatchesPathAndCollectionGroup(query, doc) &&\r\n        queryMatchesOrderBy(query, doc) &&\r\n        queryMatchesFilters(query, doc) &&\r\n        queryMatchesBounds(query, doc));\r\n}\r\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\r\n    const docPath = doc.key.path;\r\n    if (query.collectionGroup !== null) {\r\n        // NOTE: this.path is currently always empty since we don't expose Collection\r\n        // Group queries rooted at a document path yet.\r\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\r\n            query.path.isPrefixOf(docPath));\r\n    }\r\n    else if (DocumentKey.isDocumentKey(query.path)) {\r\n        // exact match for document queries\r\n        return query.path.isEqual(docPath);\r\n    }\r\n    else {\r\n        // shallow ancestor queries by default\r\n        return query.path.isImmediateParentOf(docPath);\r\n    }\r\n}\r\n/**\r\n * A document must have a value for every ordering clause in order to show up\r\n * in the results.\r\n */\r\nfunction queryMatchesOrderBy(query, doc) {\r\n    // We must use `queryNormalizedOrderBy()` to get the list of all orderBys (both implicit and explicit).\r\n    // Note that for OR queries, orderBy applies to all disjunction terms and implicit orderBys must\r\n    // be taken into account. For example, the query \"a > 1 || b==1\" has an implicit \"orderBy a\" due\r\n    // to the inequality, and is evaluated as \"a > 1 orderBy a || b==1 orderBy a\".\r\n    // A document with content of {b:1} matches the filters, but does not match the orderBy because\r\n    // it's missing the field 'a'.\r\n    for (const orderBy of queryNormalizedOrderBy(query)) {\r\n        // order-by key always matches\r\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction queryMatchesFilters(query, doc) {\r\n    for (const filter of query.filters) {\r\n        if (!filter.matches(doc)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/** Makes sure a document is within the bounds, if provided. */\r\nfunction queryMatchesBounds(query, doc) {\r\n    if (query.startAt &&\r\n        !boundSortsBeforeDocument(query.startAt, queryNormalizedOrderBy(query), doc)) {\r\n        return false;\r\n    }\r\n    if (query.endAt &&\r\n        !boundSortsAfterDocument(query.endAt, queryNormalizedOrderBy(query), doc)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns the collection group that this query targets.\r\n *\r\n * PORTING NOTE: This is only used in the Web SDK to facilitate multi-tab\r\n * synchronization for query results.\r\n */\r\nfunction queryCollectionGroup(query) {\r\n    return (query.collectionGroup ||\r\n        (query.path.length % 2 === 1\r\n            ? query.path.lastSegment()\r\n            : query.path.get(query.path.length - 2)));\r\n}\r\n/**\r\n * Returns a new comparator function that can be used to compare two documents\r\n * based on the Query's ordering constraint.\r\n */\r\nfunction newQueryComparator(query) {\r\n    return (d1, d2) => {\r\n        let comparedOnKeyField = false;\r\n        for (const orderBy of queryNormalizedOrderBy(query)) {\r\n            const comp = compareDocs(orderBy, d1, d2);\r\n            if (comp !== 0) {\r\n                return comp;\r\n            }\r\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\r\n        }\r\n        return 0;\r\n    };\r\n}\r\nfunction compareDocs(orderBy, d1, d2) {\r\n    const comparison = orderBy.field.isKeyField()\r\n        ? DocumentKey.comparator(d1.key, d2.key)\r\n        : compareDocumentsByField(orderBy.field, d1, d2);\r\n    switch (orderBy.dir) {\r\n        case \"asc\" /* Direction.ASCENDING */:\r\n            return comparison;\r\n        case \"desc\" /* Direction.DESCENDING */:\r\n            return -1 * comparison;\r\n        default:\r\n            return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A map implementation that uses objects as keys. Objects must have an\r\n * associated equals function and must be immutable. Entries in the map are\r\n * stored together with the key being produced from the mapKeyFn. This map\r\n * automatically handles collisions of keys.\r\n */\r\nclass ObjectMap {\r\n    constructor(mapKeyFn, equalsFn) {\r\n        this.mapKeyFn = mapKeyFn;\r\n        this.equalsFn = equalsFn;\r\n        /**\r\n         * The inner map for a key/value pair. Due to the possibility of collisions we\r\n         * keep a list of entries that we do a linear search through to find an actual\r\n         * match. Note that collisions should be rare, so we still expect near\r\n         * constant time lookups in practice.\r\n         */\r\n        this.inner = {};\r\n        /** The number of entries stored in the map */\r\n        this.innerSize = 0;\r\n    }\r\n    /** Get a value for this key, or undefined if it does not exist. */\r\n    get(key) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            return undefined;\r\n        }\r\n        for (const [otherKey, value] of matches) {\r\n            if (this.equalsFn(otherKey, key)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    has(key) {\r\n        return this.get(key) !== undefined;\r\n    }\r\n    /** Put this key and value in the map. */\r\n    set(key, value) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            this.inner[id] = [[key, value]];\r\n            this.innerSize++;\r\n            return;\r\n        }\r\n        for (let i = 0; i < matches.length; i++) {\r\n            if (this.equalsFn(matches[i][0], key)) {\r\n                // This is updating an existing entry and does not increase `innerSize`.\r\n                matches[i] = [key, value];\r\n                return;\r\n            }\r\n        }\r\n        matches.push([key, value]);\r\n        this.innerSize++;\r\n    }\r\n    /**\r\n     * Remove this key from the map. Returns a boolean if anything was deleted.\r\n     */\r\n    delete(key) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < matches.length; i++) {\r\n            if (this.equalsFn(matches[i][0], key)) {\r\n                if (matches.length === 1) {\r\n                    delete this.inner[id];\r\n                }\r\n                else {\r\n                    matches.splice(i, 1);\r\n                }\r\n                this.innerSize--;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    forEach(fn) {\r\n        forEach(this.inner, (_, entries) => {\r\n            for (const [k, v] of entries) {\r\n                fn(k, v);\r\n            }\r\n        });\r\n    }\r\n    isEmpty() {\r\n        return isEmpty(this.inner);\r\n    }\r\n    size() {\r\n        return this.innerSize;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction mutableDocumentMap() {\r\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction documentMap(...docs) {\r\n    let map = EMPTY_DOCUMENT_MAP;\r\n    for (const doc of docs) {\r\n        map = map.insert(doc.key, doc);\r\n    }\r\n    return map;\r\n}\r\nfunction newOverlayedDocumentMap() {\r\n    return newDocumentKeyMap();\r\n}\r\nfunction convertOverlayedDocumentMapToDocumentMap(collection) {\r\n    let documents = EMPTY_DOCUMENT_MAP;\r\n    collection.forEach((k, v) => (documents = documents.insert(k, v.overlayedDocument)));\r\n    return documents;\r\n}\r\nfunction newOverlayMap() {\r\n    return newDocumentKeyMap();\r\n}\r\nfunction newMutationMap() {\r\n    return newDocumentKeyMap();\r\n}\r\nfunction newDocumentKeyMap() {\r\n    return new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n}\r\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction documentVersionMap() {\r\n    return EMPTY_DOCUMENT_VERSION_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\r\nfunction documentKeySet(...keys) {\r\n    let set = EMPTY_DOCUMENT_KEY_SET;\r\n    for (const key of keys) {\r\n        set = set.add(key);\r\n    }\r\n    return set;\r\n}\r\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\r\nfunction targetIdSet() {\r\n    return EMPTY_TARGET_ID_SET;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an DoubleValue for `value` that is encoded based the serializer's\r\n * `useProto3Json` setting.\r\n */\r\nfunction toDouble(serializer, value) {\r\n    if (serializer.useProto3Json) {\r\n        if (isNaN(value)) {\r\n            return { doubleValue: 'NaN' };\r\n        }\r\n        else if (value === Infinity) {\r\n            return { doubleValue: 'Infinity' };\r\n        }\r\n        else if (value === -Infinity) {\r\n            return { doubleValue: '-Infinity' };\r\n        }\r\n    }\r\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\r\n}\r\n/**\r\n * Returns an IntegerValue for `value`.\r\n */\r\nfunction toInteger(value) {\r\n    return { integerValue: '' + value };\r\n}\r\n/**\r\n * Returns a value for a number that's appropriate to put into a proto.\r\n * The return value is an IntegerValue if it can safely represent the value,\r\n * otherwise a DoubleValue is returned.\r\n */\r\nfunction toNumber(serializer, value) {\r\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Used to represent a field transform on a mutation. */\r\nclass TransformOperation {\r\n    constructor() {\r\n        // Make sure that the structural type of `TransformOperation` is unique.\r\n        // See https://github.com/microsoft/TypeScript/issues/5451\r\n        this._ = undefined;\r\n    }\r\n}\r\n/**\r\n * Computes the local transform result against the provided `previousValue`,\r\n * optionally using the provided localWriteTime.\r\n */\r\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\r\n    if (transform instanceof ServerTimestampTransform) {\r\n        return serverTimestamp$1(localWriteTime, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayUnionTransformOperation) {\r\n        return applyArrayUnionTransformOperation(transform, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return applyArrayRemoveTransformOperation(transform, previousValue);\r\n    }\r\n    else {\r\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\r\n    }\r\n}\r\n/**\r\n * Computes a final transform result after the transform has been acknowledged\r\n * by the server, potentially using the server-provided transformResult.\r\n */\r\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\r\n    // The server just sends null as the transform result for array operations,\r\n    // so we have to calculate a result the same as we do for local\r\n    // applications.\r\n    if (transform instanceof ArrayUnionTransformOperation) {\r\n        return applyArrayUnionTransformOperation(transform, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return applyArrayRemoveTransformOperation(transform, previousValue);\r\n    }\r\n    return transformResult;\r\n}\r\n/**\r\n * If this transform operation is not idempotent, returns the base value to\r\n * persist for this transform. If a base value is returned, the transform\r\n * operation is always applied to this base value, even if document has\r\n * already been updated.\r\n *\r\n * Base values provide consistent behavior for non-idempotent transforms and\r\n * allow us to return the same latency-compensated value even if the backend\r\n * has already applied the transform operation. The base value is null for\r\n * idempotent transforms, as they can be re-played even if the backend has\r\n * already applied them.\r\n *\r\n * @returns a base value to store along with the mutation, or null for\r\n * idempotent transforms.\r\n */\r\nfunction computeTransformOperationBaseValue(transform, previousValue) {\r\n    if (transform instanceof NumericIncrementTransformOperation) {\r\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\r\n    }\r\n    return null;\r\n}\r\nfunction transformOperationEquals(left, right) {\r\n    if (left instanceof ArrayUnionTransformOperation &&\r\n        right instanceof ArrayUnionTransformOperation) {\r\n        return arrayEquals(left.elements, right.elements, valueEquals);\r\n    }\r\n    else if (left instanceof ArrayRemoveTransformOperation &&\r\n        right instanceof ArrayRemoveTransformOperation) {\r\n        return arrayEquals(left.elements, right.elements, valueEquals);\r\n    }\r\n    else if (left instanceof NumericIncrementTransformOperation &&\r\n        right instanceof NumericIncrementTransformOperation) {\r\n        return valueEquals(left.operand, right.operand);\r\n    }\r\n    return (left instanceof ServerTimestampTransform &&\r\n        right instanceof ServerTimestampTransform);\r\n}\r\n/** Transforms a value into a server-generated timestamp. */\r\nclass ServerTimestampTransform extends TransformOperation {\r\n}\r\n/** Transforms an array value via a union operation. */\r\nclass ArrayUnionTransformOperation extends TransformOperation {\r\n    constructor(elements) {\r\n        super();\r\n        this.elements = elements;\r\n    }\r\n}\r\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\r\n    const values = coercedFieldValuesArray(previousValue);\r\n    for (const toUnion of transform.elements) {\r\n        if (!values.some(element => valueEquals(element, toUnion))) {\r\n            values.push(toUnion);\r\n        }\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/** Transforms an array value via a remove operation. */\r\nclass ArrayRemoveTransformOperation extends TransformOperation {\r\n    constructor(elements) {\r\n        super();\r\n        this.elements = elements;\r\n    }\r\n}\r\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\r\n    let values = coercedFieldValuesArray(previousValue);\r\n    for (const toRemove of transform.elements) {\r\n        values = values.filter(element => !valueEquals(element, toRemove));\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/**\r\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\r\n * transforms. Converts all field values to integers or doubles, but unlike the\r\n * backend does not cap integer values at 2^63. Instead, JavaScript number\r\n * arithmetic is used and precision loss can occur for values greater than 2^53.\r\n */\r\nclass NumericIncrementTransformOperation extends TransformOperation {\r\n    constructor(serializer, operand) {\r\n        super();\r\n        this.serializer = serializer;\r\n        this.operand = operand;\r\n    }\r\n}\r\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\r\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\r\n    // precision and resolves overflows by reducing precision, we do not\r\n    // manually cap overflows at 2^63.\r\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\r\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\r\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\r\n        return toInteger(sum);\r\n    }\r\n    else {\r\n        return toDouble(transform.serializer, sum);\r\n    }\r\n}\r\nfunction asNumber(value) {\r\n    return normalizeNumber(value.integerValue || value.doubleValue);\r\n}\r\nfunction coercedFieldValuesArray(value) {\r\n    return isArray(value) && value.arrayValue.values\r\n        ? value.arrayValue.values.slice()\r\n        : [];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** A field path and the TransformOperation to perform upon it. */\r\nclass FieldTransform {\r\n    constructor(field, transform) {\r\n        this.field = field;\r\n        this.transform = transform;\r\n    }\r\n}\r\nfunction fieldTransformEquals(left, right) {\r\n    return (left.field.isEqual(right.field) &&\r\n        transformOperationEquals(left.transform, right.transform));\r\n}\r\nfunction fieldTransformsAreEqual(left, right) {\r\n    if (left === undefined && right === undefined) {\r\n        return true;\r\n    }\r\n    if (left && right) {\r\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\r\n    }\r\n    return false;\r\n}\r\n/** The result of successfully applying a mutation to the backend. */\r\nclass MutationResult {\r\n    constructor(\r\n    /**\r\n     * The version at which the mutation was committed:\r\n     *\r\n     * - For most operations, this is the updateTime in the WriteResult.\r\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\r\n     *   not stored and have no updateTime).\r\n     *\r\n     * Note that these versions can be different: No-op writes will not change\r\n     * the updateTime even though the commitTime advances.\r\n     */\r\n    version, \r\n    /**\r\n     * The resulting fields returned from the backend after a mutation\r\n     * containing field transforms has been committed. Contains one FieldValue\r\n     * for each FieldTransform that was in the mutation.\r\n     *\r\n     * Will be empty if the mutation did not contain any field transforms.\r\n     */\r\n    transformResults) {\r\n        this.version = version;\r\n        this.transformResults = transformResults;\r\n    }\r\n}\r\n/**\r\n * Encodes a precondition for a mutation. This follows the model that the\r\n * backend accepts with the special case of an explicit \"empty\" precondition\r\n * (meaning no precondition).\r\n */\r\nclass Precondition {\r\n    constructor(updateTime, exists) {\r\n        this.updateTime = updateTime;\r\n        this.exists = exists;\r\n    }\r\n    /** Creates a new empty Precondition. */\r\n    static none() {\r\n        return new Precondition();\r\n    }\r\n    /** Creates a new Precondition with an exists flag. */\r\n    static exists(exists) {\r\n        return new Precondition(undefined, exists);\r\n    }\r\n    /** Creates a new Precondition based on a version a document exists at. */\r\n    static updateTime(version) {\r\n        return new Precondition(version);\r\n    }\r\n    /** Returns whether this Precondition is empty. */\r\n    get isNone() {\r\n        return this.updateTime === undefined && this.exists === undefined;\r\n    }\r\n    isEqual(other) {\r\n        return (this.exists === other.exists &&\r\n            (this.updateTime\r\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\r\n                : !other.updateTime));\r\n    }\r\n}\r\n/** Returns true if the preconditions is valid for the given document. */\r\nfunction preconditionIsValidForDocument(precondition, document) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return (document.isFoundDocument() &&\r\n            document.version.isEqual(precondition.updateTime));\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return precondition.exists === document.isFoundDocument();\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n/**\r\n * A mutation describes a self-contained change to a document. Mutations can\r\n * create, replace, delete, and update subsets of documents.\r\n *\r\n * Mutations not only act on the value of the document but also its version.\r\n *\r\n * For local mutations (mutations that haven't been committed yet), we preserve\r\n * the existing version for Set and Patch mutations. For Delete mutations, we\r\n * reset the version to 0.\r\n *\r\n * Here's the expected transition table.\r\n *\r\n * MUTATION           APPLIED TO            RESULTS IN\r\n *\r\n * SetMutation        Document(v3)          Document(v3)\r\n * SetMutation        NoDocument(v3)        Document(v0)\r\n * SetMutation        InvalidDocument(v0)   Document(v0)\r\n * PatchMutation      Document(v3)          Document(v3)\r\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\r\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\r\n * DeleteMutation     Document(v3)          NoDocument(v0)\r\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\r\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\r\n *\r\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\r\n * the resulting version for Set and Patch mutations. As deletes have no\r\n * explicit update time, we use the commitTime of the WriteResponse for\r\n * Delete mutations.\r\n *\r\n * If a mutation is acknowledged by the backend but fails the precondition check\r\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\r\n * the updated version.\r\n *\r\n * Field transforms are used only with Patch and Set Mutations. We use the\r\n * `updateTransforms` message to store transforms, rather than the `transforms`s\r\n * messages.\r\n *\r\n * ## Subclassing Notes\r\n *\r\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\r\n * applyToLocalView() to implement the actual behavior of applying the mutation\r\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\r\n * example).\r\n */\r\nclass Mutation {\r\n}\r\n/**\r\n * A utility method to calculate a `Mutation` representing the overlay from the\r\n * final state of the document, and a `FieldMask` representing the fields that\r\n * are mutated by the local mutations.\r\n */\r\nfunction calculateOverlayMutation(doc, mask) {\r\n    if (!doc.hasLocalMutations || (mask && mask.fields.length === 0)) {\r\n        return null;\r\n    }\r\n    // mask is null when sets or deletes are applied to the current document.\r\n    if (mask === null) {\r\n        if (doc.isNoDocument()) {\r\n            return new DeleteMutation(doc.key, Precondition.none());\r\n        }\r\n        else {\r\n            return new SetMutation(doc.key, doc.data, Precondition.none());\r\n        }\r\n    }\r\n    else {\r\n        const docValue = doc.data;\r\n        const patchValue = ObjectValue.empty();\r\n        let maskSet = new SortedSet(FieldPath$1.comparator);\r\n        for (let path of mask.fields) {\r\n            if (!maskSet.has(path)) {\r\n                let value = docValue.field(path);\r\n                // If we are deleting a nested field, we take the immediate parent as\r\n                // the mask used to construct the resulting mutation.\r\n                // Justification: Nested fields can create parent fields implicitly. If\r\n                // only a leaf entry is deleted in later mutations, the parent field\r\n                // should still remain, but we may have lost this information.\r\n                // Consider mutation (foo.bar 1), then mutation (foo.bar delete()).\r\n                // This leaves the final result (foo, {}). Despite the fact that `doc`\r\n                // has the correct result, `foo` is not in `mask`, and the resulting\r\n                // mutation would miss `foo`.\r\n                if (value === null && path.length > 1) {\r\n                    path = path.popLast();\r\n                    value = docValue.field(path);\r\n                }\r\n                if (value === null) {\r\n                    patchValue.delete(path);\r\n                }\r\n                else {\r\n                    patchValue.set(path, value);\r\n                }\r\n                maskSet = maskSet.add(path);\r\n            }\r\n        }\r\n        return new PatchMutation(doc.key, patchValue, new FieldMask(maskSet.toArray()), Precondition.none());\r\n    }\r\n}\r\n/**\r\n * Applies this mutation to the given document for the purposes of computing a\r\n * new remote document. If the input document doesn't match the expected state\r\n * (e.g. it is invalid or outdated), the document type may transition to\r\n * unknown.\r\n *\r\n * @param mutation - The mutation to apply.\r\n * @param document - The document to mutate. The input document can be an\r\n *     invalid document if the client has no knowledge of the pre-mutation state\r\n *     of the document.\r\n * @param mutationResult - The result of applying the mutation from the backend.\r\n */\r\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    if (mutation instanceof SetMutation) {\r\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n    else {\r\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n}\r\n/**\r\n * Applies this mutation to the given document for the purposes of computing\r\n * the new local view of a document. If the input document doesn't match the\r\n * expected state, the document is not modified.\r\n *\r\n * @param mutation - The mutation to apply.\r\n * @param document - The document to mutate. The input document can be an\r\n *     invalid document if the client has no knowledge of the pre-mutation state\r\n *     of the document.\r\n * @param previousMask - The fields that have been updated before applying this mutation.\r\n * @param localWriteTime - A timestamp indicating the local write time of the\r\n *     batch this mutation is a part of.\r\n * @returns A `FieldMask` representing the fields that are changed by applying this mutation.\r\n */\r\nfunction mutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\r\n    if (mutation instanceof SetMutation) {\r\n        return setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        return patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\r\n    }\r\n    else {\r\n        return deleteMutationApplyToLocalView(mutation, document, previousMask);\r\n    }\r\n}\r\n/**\r\n * If this mutation is not idempotent, returns the base value to persist with\r\n * this mutation. If a base value is returned, the mutation is always applied\r\n * to this base value, even if document has already been updated.\r\n *\r\n * The base value is a sparse object that consists of only the document\r\n * fields for which this mutation contains a non-idempotent transformation\r\n * (e.g. a numeric increment). The provided value guarantees consistent\r\n * behavior for non-idempotent transforms and allow us to return the same\r\n * latency-compensated value even if the backend has already applied the\r\n * mutation. The base value is null for idempotent mutations, as they can be\r\n * re-played even if the backend has already applied them.\r\n *\r\n * @returns a base value to store along with the mutation, or null for\r\n * idempotent mutations.\r\n */\r\nfunction mutationExtractBaseValue(mutation, document) {\r\n    let baseObject = null;\r\n    for (const fieldTransform of mutation.fieldTransforms) {\r\n        const existingValue = document.data.field(fieldTransform.field);\r\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\r\n        if (coercedValue != null) {\r\n            if (baseObject === null) {\r\n                baseObject = ObjectValue.empty();\r\n            }\r\n            baseObject.set(fieldTransform.field, coercedValue);\r\n        }\r\n    }\r\n    return baseObject ? baseObject : null;\r\n}\r\nfunction mutationEquals(left, right) {\r\n    if (left.type !== right.type) {\r\n        return false;\r\n    }\r\n    if (!left.key.isEqual(right.key)) {\r\n        return false;\r\n    }\r\n    if (!left.precondition.isEqual(right.precondition)) {\r\n        return false;\r\n    }\r\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\r\n        return false;\r\n    }\r\n    if (left.type === 0 /* MutationType.Set */) {\r\n        return left.value.isEqual(right.value);\r\n    }\r\n    if (left.type === 1 /* MutationType.Patch */) {\r\n        return (left.data.isEqual(right.data) &&\r\n            left.fieldMask.isEqual(right.fieldMask));\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * A mutation that creates or replaces the document at the given key with the\r\n * object value contents.\r\n */\r\nclass SetMutation extends Mutation {\r\n    constructor(key, value, precondition, fieldTransforms = []) {\r\n        super();\r\n        this.key = key;\r\n        this.value = value;\r\n        this.precondition = precondition;\r\n        this.fieldTransforms = fieldTransforms;\r\n        this.type = 0 /* MutationType.Set */;\r\n    }\r\n    getFieldMask() {\r\n        return null;\r\n    }\r\n}\r\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\r\n    // remote document the server has accepted the mutation so the precondition\r\n    // must have held.\r\n    const newData = mutation.value.clone();\r\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(mutationResult.version, newData)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // The mutation failed to apply (e.g. a document ID created with add()\r\n        // caused a name collision).\r\n        return previousMask;\r\n    }\r\n    const newData = mutation.value.clone();\r\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(document.version, newData)\r\n        .setHasLocalMutations();\r\n    return null; // SetMutation overwrites all fields.\r\n}\r\n/**\r\n * A mutation that modifies fields of the document at the given key with the\r\n * given values. The values are applied through a field mask:\r\n *\r\n *  * When a field is in both the mask and the values, the corresponding field\r\n *    is updated.\r\n *  * When a field is in neither the mask nor the values, the corresponding\r\n *    field is unmodified.\r\n *  * When a field is in the mask but not in the values, the corresponding field\r\n *    is deleted.\r\n *  * When a field is not in the mask but is in the values, the values map is\r\n *    ignored.\r\n */\r\nclass PatchMutation extends Mutation {\r\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\r\n        super();\r\n        this.key = key;\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.precondition = precondition;\r\n        this.fieldTransforms = fieldTransforms;\r\n        this.type = 1 /* MutationType.Patch */;\r\n    }\r\n    getFieldMask() {\r\n        return this.fieldMask;\r\n    }\r\n}\r\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // Since the mutation was not rejected, we know that the precondition\r\n        // matched on the backend. We therefore must not have the expected version\r\n        // of the document in our cache and convert to an UnknownDocument with a\r\n        // known updateTime.\r\n        document.convertToUnknownDocument(mutationResult.version);\r\n        return;\r\n    }\r\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\r\n    const newData = document.data;\r\n    newData.setAll(getPatch(mutation));\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(mutationResult.version, newData)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        return previousMask;\r\n    }\r\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\r\n    const newData = document.data;\r\n    newData.setAll(getPatch(mutation));\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(document.version, newData)\r\n        .setHasLocalMutations();\r\n    if (previousMask === null) {\r\n        return null;\r\n    }\r\n    return previousMask\r\n        .unionWith(mutation.fieldMask.fields)\r\n        .unionWith(mutation.fieldTransforms.map(transform => transform.field));\r\n}\r\n/**\r\n * Returns a FieldPath/Value map with the content of the PatchMutation.\r\n */\r\nfunction getPatch(mutation) {\r\n    const result = new Map();\r\n    mutation.fieldMask.fields.forEach(fieldPath => {\r\n        if (!fieldPath.isEmpty()) {\r\n            const newValue = mutation.data.field(fieldPath);\r\n            result.set(fieldPath, newValue);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * Creates a list of \"transform results\" (a transform result is a field value\r\n * representing the result of applying a transform) for use after a mutation\r\n * containing transforms has been acknowledged by the server.\r\n *\r\n * @param fieldTransforms - The field transforms to apply the result to.\r\n * @param mutableDocument - The current state of the document after applying all\r\n * previous mutations.\r\n * @param serverTransformResults - The transform results received by the server.\r\n * @returns The transform results list.\r\n */\r\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\r\n    const transformResults = new Map();\r\n    hardAssert(fieldTransforms.length === serverTransformResults.length);\r\n    for (let i = 0; i < serverTransformResults.length; i++) {\r\n        const fieldTransform = fieldTransforms[i];\r\n        const transform = fieldTransform.transform;\r\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\r\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\r\n    }\r\n    return transformResults;\r\n}\r\n/**\r\n * Creates a list of \"transform results\" (a transform result is a field value\r\n * representing the result of applying a transform) for use when applying a\r\n * transform locally.\r\n *\r\n * @param fieldTransforms - The field transforms to apply the result to.\r\n * @param localWriteTime - The local time of the mutation (used to\r\n *     generate ServerTimestampValues).\r\n * @param mutableDocument - The document to apply transforms on.\r\n * @returns The transform results list.\r\n */\r\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\r\n    const transformResults = new Map();\r\n    for (const fieldTransform of fieldTransforms) {\r\n        const transform = fieldTransform.transform;\r\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\r\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\r\n    }\r\n    return transformResults;\r\n}\r\n/** A mutation that deletes the document at the given key. */\r\nclass DeleteMutation extends Mutation {\r\n    constructor(key, precondition) {\r\n        super();\r\n        this.key = key;\r\n        this.precondition = precondition;\r\n        this.type = 2 /* MutationType.Delete */;\r\n        this.fieldTransforms = [];\r\n    }\r\n    getFieldMask() {\r\n        return null;\r\n    }\r\n}\r\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\r\n    // document the server has accepted the mutation so the precondition must\r\n    // have held.\r\n    document\r\n        .convertToNoDocument(mutationResult.version)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction deleteMutationApplyToLocalView(mutation, document, previousMask) {\r\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        document.convertToNoDocument(document.version).setHasLocalMutations();\r\n        return null;\r\n    }\r\n    return previousMask;\r\n}\r\n/**\r\n * A mutation that verifies the existence of the document at the given key with\r\n * the provided precondition.\r\n *\r\n * The `verify` operation is only used in Transactions, and this class serves\r\n * primarily to facilitate serialization into protos.\r\n */\r\nclass VerifyMutation extends Mutation {\r\n    constructor(key, precondition) {\r\n        super();\r\n        this.key = key;\r\n        this.precondition = precondition;\r\n        this.type = 3 /* MutationType.Verify */;\r\n        this.fieldTransforms = [];\r\n    }\r\n    getFieldMask() {\r\n        return null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A batch of mutations that will be sent as one unit to the backend.\r\n */\r\nclass MutationBatch {\r\n    /**\r\n     * @param batchId - The unique ID of this mutation batch.\r\n     * @param localWriteTime - The original write time of this mutation.\r\n     * @param baseMutations - Mutations that are used to populate the base\r\n     * values when this mutation is applied locally. This can be used to locally\r\n     * overwrite values that are persisted in the remote document cache. Base\r\n     * mutations are never sent to the backend.\r\n     * @param mutations - The user-provided mutations in this mutation batch.\r\n     * User-provided mutations are applied both locally and remotely on the\r\n     * backend.\r\n     */\r\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\r\n        this.batchId = batchId;\r\n        this.localWriteTime = localWriteTime;\r\n        this.baseMutations = baseMutations;\r\n        this.mutations = mutations;\r\n    }\r\n    /**\r\n     * Applies all the mutations in this MutationBatch to the specified document\r\n     * to compute the state of the remote document\r\n     *\r\n     * @param document - The document to apply mutations to.\r\n     * @param batchResult - The result of applying the MutationBatch to the\r\n     * backend.\r\n     */\r\n    applyToRemoteDocument(document, batchResult) {\r\n        const mutationResults = batchResult.mutationResults;\r\n        for (let i = 0; i < this.mutations.length; i++) {\r\n            const mutation = this.mutations[i];\r\n            if (mutation.key.isEqual(document.key)) {\r\n                const mutationResult = mutationResults[i];\r\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Computes the local view of a document given all the mutations in this\r\n     * batch.\r\n     *\r\n     * @param document - The document to apply mutations to.\r\n     * @param mutatedFields - Fields that have been updated before applying this mutation batch.\r\n     * @returns A `FieldMask` representing all the fields that are mutated.\r\n     */\r\n    applyToLocalView(document, mutatedFields) {\r\n        // First, apply the base state. This allows us to apply non-idempotent\r\n        // transform against a consistent set of values.\r\n        for (const mutation of this.baseMutations) {\r\n            if (mutation.key.isEqual(document.key)) {\r\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\r\n            }\r\n        }\r\n        // Second, apply all user-provided mutations.\r\n        for (const mutation of this.mutations) {\r\n            if (mutation.key.isEqual(document.key)) {\r\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\r\n            }\r\n        }\r\n        return mutatedFields;\r\n    }\r\n    /**\r\n     * Computes the local view for all provided documents given the mutations in\r\n     * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to\r\n     * replace all the mutation applications.\r\n     */\r\n    applyToLocalDocumentSet(documentMap, documentsWithoutRemoteVersion) {\r\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\r\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\r\n        // to O(n).\r\n        const overlays = newMutationMap();\r\n        this.mutations.forEach(m => {\r\n            const overlayedDocument = documentMap.get(m.key);\r\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\r\n            // and we should remove this cast.\r\n            const mutableDocument = overlayedDocument.overlayedDocument;\r\n            let mutatedFields = this.applyToLocalView(mutableDocument, overlayedDocument.mutatedFields);\r\n            // Set mutatedFields to null if the document is only from local mutations.\r\n            // This creates a Set or Delete mutation, instead of trying to create a\r\n            // patch mutation as the overlay.\r\n            mutatedFields = documentsWithoutRemoteVersion.has(m.key)\r\n                ? null\r\n                : mutatedFields;\r\n            const overlay = calculateOverlayMutation(mutableDocument, mutatedFields);\r\n            if (overlay !== null) {\r\n                overlays.set(m.key, overlay);\r\n            }\r\n            if (!mutableDocument.isValidDocument()) {\r\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\r\n            }\r\n        });\r\n        return overlays;\r\n    }\r\n    keys() {\r\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\r\n    }\r\n    isEqual(other) {\r\n        return (this.batchId === other.batchId &&\r\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\r\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\r\n    }\r\n}\r\n/** The result of applying a mutation batch to the backend. */\r\nclass MutationBatchResult {\r\n    constructor(batch, commitVersion, mutationResults, \r\n    /**\r\n     * A pre-computed mapping from each mutated document to the resulting\r\n     * version.\r\n     */\r\n    docVersions) {\r\n        this.batch = batch;\r\n        this.commitVersion = commitVersion;\r\n        this.mutationResults = mutationResults;\r\n        this.docVersions = docVersions;\r\n    }\r\n    /**\r\n     * Creates a new MutationBatchResult for the given batch and results. There\r\n     * must be one result for each mutation in the batch. This static factory\r\n     * caches a document=&gt;version mapping (docVersions).\r\n     */\r\n    static from(batch, commitVersion, results) {\r\n        hardAssert(batch.mutations.length === results.length);\r\n        let versionMap = documentVersionMap();\r\n        const mutations = batch.mutations;\r\n        for (let i = 0; i < mutations.length; i++) {\r\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\r\n        }\r\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Representation of an overlay computed by Firestore.\r\n *\r\n * Holds information about a mutation and the largest batch id in Firestore when\r\n * the mutation was created.\r\n */\r\nclass Overlay {\r\n    constructor(largestBatchId, mutation) {\r\n        this.largestBatchId = largestBatchId;\r\n        this.mutation = mutation;\r\n    }\r\n    getKey() {\r\n        return this.mutation.key;\r\n    }\r\n    isEqual(other) {\r\n        return other !== null && this.mutation === other.mutation;\r\n    }\r\n    toString() {\r\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ExistenceFilter {\r\n    constructor(count, unchangedNames) {\r\n        this.count = count;\r\n        this.unchangedNames = unchangedNames;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Error Codes describing the different ways GRPC can fail. These are copied\r\n * directly from GRPC's sources here:\r\n *\r\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n *\r\n * Important! The names of these identifiers matter because the string forms\r\n * are used for reverse lookups from the webchannel stream. Do NOT change the\r\n * names of these identifiers or change this into a const enum.\r\n */\r\nvar RpcCode;\r\n(function (RpcCode) {\r\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\r\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\r\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\r\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\r\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\r\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\r\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\r\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\r\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\r\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\r\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\r\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\r\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\r\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\r\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\r\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\r\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\r\n})(RpcCode || (RpcCode = {}));\r\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a non-write operation.\r\n *\r\n * See isPermanentWriteError for classifying write errors.\r\n */\r\nfunction isPermanentError(code) {\r\n    switch (code) {\r\n        case Code.OK:\r\n            return fail();\r\n        case Code.CANCELLED:\r\n        case Code.UNKNOWN:\r\n        case Code.DEADLINE_EXCEEDED:\r\n        case Code.RESOURCE_EXHAUSTED:\r\n        case Code.INTERNAL:\r\n        case Code.UNAVAILABLE:\r\n        // Unauthenticated means something went wrong with our token and we need\r\n        // to retry with new credentials which will happen automatically.\r\n        case Code.UNAUTHENTICATED:\r\n            return false;\r\n        case Code.INVALID_ARGUMENT:\r\n        case Code.NOT_FOUND:\r\n        case Code.ALREADY_EXISTS:\r\n        case Code.PERMISSION_DENIED:\r\n        case Code.FAILED_PRECONDITION:\r\n        // Aborted might be retried in some scenarios, but that is dependant on\r\n        // the context and should handled individually by the calling code.\r\n        // See https://cloud.google.com/apis/design/errors.\r\n        case Code.ABORTED:\r\n        case Code.OUT_OF_RANGE:\r\n        case Code.UNIMPLEMENTED:\r\n        case Code.DATA_LOSS:\r\n            return true;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a write operation.\r\n *\r\n * Write operations must be handled specially because as of b/119437764, ABORTED\r\n * errors on the write stream should be retried too (even though ABORTED errors\r\n * are not generally retryable).\r\n *\r\n * Note that during the initial handshake on the write stream an ABORTED error\r\n * signals that we should discard our stream token (i.e. it is permanent). This\r\n * means a handshake error should be classified with isPermanentError, above.\r\n */\r\nfunction isPermanentWriteError(code) {\r\n    return isPermanentError(code) && code !== Code.ABORTED;\r\n}\r\n/**\r\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\r\n * are not the same as HTTP status codes.\r\n *\r\n * @returns The Code equivalent to the given GRPC status code. Fails if there\r\n *     is no match.\r\n */\r\nfunction mapCodeFromRpcCode(code) {\r\n    if (code === undefined) {\r\n        // This shouldn't normally happen, but in certain error cases (like trying\r\n        // to send invalid proto messages) we may get an error with no GRPC code.\r\n        logError('GRPC error has no .code');\r\n        return Code.UNKNOWN;\r\n    }\r\n    switch (code) {\r\n        case RpcCode.OK:\r\n            return Code.OK;\r\n        case RpcCode.CANCELLED:\r\n            return Code.CANCELLED;\r\n        case RpcCode.UNKNOWN:\r\n            return Code.UNKNOWN;\r\n        case RpcCode.DEADLINE_EXCEEDED:\r\n            return Code.DEADLINE_EXCEEDED;\r\n        case RpcCode.RESOURCE_EXHAUSTED:\r\n            return Code.RESOURCE_EXHAUSTED;\r\n        case RpcCode.INTERNAL:\r\n            return Code.INTERNAL;\r\n        case RpcCode.UNAVAILABLE:\r\n            return Code.UNAVAILABLE;\r\n        case RpcCode.UNAUTHENTICATED:\r\n            return Code.UNAUTHENTICATED;\r\n        case RpcCode.INVALID_ARGUMENT:\r\n            return Code.INVALID_ARGUMENT;\r\n        case RpcCode.NOT_FOUND:\r\n            return Code.NOT_FOUND;\r\n        case RpcCode.ALREADY_EXISTS:\r\n            return Code.ALREADY_EXISTS;\r\n        case RpcCode.PERMISSION_DENIED:\r\n            return Code.PERMISSION_DENIED;\r\n        case RpcCode.FAILED_PRECONDITION:\r\n            return Code.FAILED_PRECONDITION;\r\n        case RpcCode.ABORTED:\r\n            return Code.ABORTED;\r\n        case RpcCode.OUT_OF_RANGE:\r\n            return Code.OUT_OF_RANGE;\r\n        case RpcCode.UNIMPLEMENTED:\r\n            return Code.UNIMPLEMENTED;\r\n        case RpcCode.DATA_LOSS:\r\n            return Code.DATA_LOSS;\r\n        default:\r\n            return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An error encountered while decoding base64 string.\r\n */\r\nclass Base64DecodeError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'Base64DecodeError';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The global, singleton instance of TestingHooksSpi.\r\n *\r\n * This variable will be `null` in all cases _except_ when running from\r\n * integration tests that have registered callbacks to be notified of events\r\n * that happen during the test execution.\r\n */\r\nlet testingHooksSpi = null;\r\n/**\r\n * Sets the value of the `testingHooksSpi` object.\r\n * @param instance the instance to set.\r\n */\r\nfunction setTestingHooksSpi(instance) {\r\n    if (testingHooksSpi) {\r\n        throw new Error('a TestingHooksSpi instance is already set');\r\n    }\r\n    testingHooksSpi = instance;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An instance of the Platform's 'TextEncoder' implementation.\r\n */\r\nfunction newTextEncoder() {\r\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\r\n}\r\n/**\r\n * An instance of the Platform's 'TextDecoder' implementation.\r\n */\r\nfunction newTextDecoder() {\r\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder('utf-8');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_64_BIT_UNSIGNED_INTEGER = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([0xffffffff, 0xffffffff], 0);\r\n// Hash a string using md5 hashing algorithm.\r\nfunction getMd5HashValue(value) {\r\n    const encodedValue = newTextEncoder().encode(value);\r\n    const md5 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Md5();\r\n    md5.update(encodedValue);\r\n    return new Uint8Array(md5.digest());\r\n}\r\n// Interpret the 16 bytes array as two 64-bit unsigned integers, encoded using\r\n// 2’s complement using little endian.\r\nfunction get64BitUints(Bytes) {\r\n    const dataView = new DataView(Bytes.buffer);\r\n    const chunk1 = dataView.getUint32(0, /* littleEndian= */ true);\r\n    const chunk2 = dataView.getUint32(4, /* littleEndian= */ true);\r\n    const chunk3 = dataView.getUint32(8, /* littleEndian= */ true);\r\n    const chunk4 = dataView.getUint32(12, /* littleEndian= */ true);\r\n    const integer1 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk1, chunk2], 0);\r\n    const integer2 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk3, chunk4], 0);\r\n    return [integer1, integer2];\r\n}\r\nclass BloomFilter {\r\n    constructor(bitmap, padding, hashCount) {\r\n        this.bitmap = bitmap;\r\n        this.padding = padding;\r\n        this.hashCount = hashCount;\r\n        if (padding < 0 || padding >= 8) {\r\n            throw new BloomFilterError(`Invalid padding: ${padding}`);\r\n        }\r\n        if (hashCount < 0) {\r\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\r\n        }\r\n        if (bitmap.length > 0 && this.hashCount === 0) {\r\n            // Only empty bloom filter can have 0 hash count.\r\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\r\n        }\r\n        if (bitmap.length === 0 && padding !== 0) {\r\n            // Empty bloom filter should have 0 padding.\r\n            throw new BloomFilterError(`Invalid padding when bitmap length is 0: ${padding}`);\r\n        }\r\n        this.bitCount = bitmap.length * 8 - padding;\r\n        // Set the bit count in Integer to avoid repetition in mightContain().\r\n        this.bitCountInInteger = _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(this.bitCount);\r\n    }\r\n    // Calculate the ith hash value based on the hashed 64bit integers,\r\n    // and calculate its corresponding bit index in the bitmap to be checked.\r\n    getBitIndex(num1, num2, hashIndex) {\r\n        // Calculate hashed value h(i) = h1 + (i * h2).\r\n        let hashValue = num1.add(num2.multiply(_firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(hashIndex)));\r\n        // Wrap if hash value overflow 64bit.\r\n        if (hashValue.compare(MAX_64_BIT_UNSIGNED_INTEGER) === 1) {\r\n            hashValue = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([hashValue.getBits(0), hashValue.getBits(1)], 0);\r\n        }\r\n        return hashValue.modulo(this.bitCountInInteger).toNumber();\r\n    }\r\n    // Return whether the bit on the given index in the bitmap is set to 1.\r\n    isBitSet(index) {\r\n        // To retrieve bit n, calculate: (bitmap[n / 8] & (0x01 << (n % 8))).\r\n        const byte = this.bitmap[Math.floor(index / 8)];\r\n        const offset = index % 8;\r\n        return (byte & (0x01 << offset)) !== 0;\r\n    }\r\n    mightContain(value) {\r\n        // Empty bitmap should always return false on membership check.\r\n        if (this.bitCount === 0) {\r\n            return false;\r\n        }\r\n        const md5HashedValue = getMd5HashValue(value);\r\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\r\n        for (let i = 0; i < this.hashCount; i++) {\r\n            const index = this.getBitIndex(hash1, hash2, i);\r\n            if (!this.isBitSet(index)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /** Create bloom filter for testing purposes only. */\r\n    static create(bitCount, hashCount, contains) {\r\n        const padding = bitCount % 8 === 0 ? 0 : 8 - (bitCount % 8);\r\n        const bitmap = new Uint8Array(Math.ceil(bitCount / 8));\r\n        const bloomFilter = new BloomFilter(bitmap, padding, hashCount);\r\n        contains.forEach(item => bloomFilter.insert(item));\r\n        return bloomFilter;\r\n    }\r\n    insert(value) {\r\n        if (this.bitCount === 0) {\r\n            return;\r\n        }\r\n        const md5HashedValue = getMd5HashValue(value);\r\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\r\n        for (let i = 0; i < this.hashCount; i++) {\r\n            const index = this.getBitIndex(hash1, hash2, i);\r\n            this.setBit(index);\r\n        }\r\n    }\r\n    setBit(index) {\r\n        const indexOfByte = Math.floor(index / 8);\r\n        const offset = index % 8;\r\n        this.bitmap[indexOfByte] |= 0x01 << offset;\r\n    }\r\n}\r\nclass BloomFilterError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'BloomFilterError';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An event from the RemoteStore. It is split into targetChanges (changes to the\r\n * state or the set of documents in our watched targets) and documentUpdates\r\n * (changes to the actual documents).\r\n */\r\nclass RemoteEvent {\r\n    constructor(\r\n    /**\r\n     * The snapshot version this event brings us up to, or MIN if not set.\r\n     */\r\n    snapshotVersion, \r\n    /**\r\n     * A map from target to changes to the target. See TargetChange.\r\n     */\r\n    targetChanges, \r\n    /**\r\n     * A map of targets that is known to be inconsistent, and the purpose for\r\n     * re-listening. Listens for these targets should be re-established without\r\n     * resume tokens.\r\n     */\r\n    targetMismatches, \r\n    /**\r\n     * A set of which documents have changed or been deleted, along with the\r\n     * doc's new values (if not deleted).\r\n     */\r\n    documentUpdates, \r\n    /**\r\n     * A set of which document updates are due only to limbo resolution targets.\r\n     */\r\n    resolvedLimboDocuments) {\r\n        this.snapshotVersion = snapshotVersion;\r\n        this.targetChanges = targetChanges;\r\n        this.targetMismatches = targetMismatches;\r\n        this.documentUpdates = documentUpdates;\r\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\r\n    }\r\n    /**\r\n     * HACK: Views require RemoteEvents in order to determine whether the view is\r\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\r\n     * used to create a synthesized RemoteEvent that can be used to apply a\r\n     * CURRENT status change to a View, for queries executed in a different tab.\r\n     */\r\n    // PORTING NOTE: Multi-tab only\r\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current, resumeToken) {\r\n        const targetChanges = new Map();\r\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken));\r\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, new SortedMap(primitiveComparator), mutableDocumentMap(), documentKeySet());\r\n    }\r\n}\r\n/**\r\n * A TargetChange specifies the set of changes for a specific target as part of\r\n * a RemoteEvent. These changes track which documents are added, modified or\r\n * removed, as well as the target's resume token and whether the target is\r\n * marked CURRENT.\r\n * The actual changes *to* documents are not part of the TargetChange since\r\n * documents may be part of multiple targets.\r\n */\r\nclass TargetChange {\r\n    constructor(\r\n    /**\r\n     * An opaque, server-assigned token that allows watching a query to be resumed\r\n     * after disconnecting without retransmitting all the data that matches the\r\n     * query. The resume token essentially identifies a point in time from which\r\n     * the server should resume sending results.\r\n     */\r\n    resumeToken, \r\n    /**\r\n     * The \"current\" (synced) status of this target. Note that \"current\"\r\n     * has special meaning in the RPC protocol that implies that a target is\r\n     * both up-to-date and consistent with the rest of the watch stream.\r\n     */\r\n    current, \r\n    /**\r\n     * The set of documents that were newly assigned to this target as part of\r\n     * this remote event.\r\n     */\r\n    addedDocuments, \r\n    /**\r\n     * The set of documents that were already assigned to this target but received\r\n     * an update during this remote event.\r\n     */\r\n    modifiedDocuments, \r\n    /**\r\n     * The set of documents that were removed from this target as part of this\r\n     * remote event.\r\n     */\r\n    removedDocuments) {\r\n        this.resumeToken = resumeToken;\r\n        this.current = current;\r\n        this.addedDocuments = addedDocuments;\r\n        this.modifiedDocuments = modifiedDocuments;\r\n        this.removedDocuments = removedDocuments;\r\n    }\r\n    /**\r\n     * This method is used to create a synthesized TargetChanges that can be used to\r\n     * apply a CURRENT status change to a View (for queries executed in a different\r\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\r\n     */\r\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken) {\r\n        return new TargetChange(resumeToken, current, documentKeySet(), documentKeySet(), documentKeySet());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a changed document and a list of target ids to which this change\r\n * applies.\r\n *\r\n * If document has been deleted NoDocument will be provided.\r\n */\r\nclass DocumentWatchChange {\r\n    constructor(\r\n    /** The new document applies to all of these targets. */\r\n    updatedTargetIds, \r\n    /** The new document is removed from all of these targets. */\r\n    removedTargetIds, \r\n    /** The key of the document for this change. */\r\n    key, \r\n    /**\r\n     * The new document or NoDocument if it was deleted. Is null if the\r\n     * document went out of view without the server sending a new document.\r\n     */\r\n    newDoc) {\r\n        this.updatedTargetIds = updatedTargetIds;\r\n        this.removedTargetIds = removedTargetIds;\r\n        this.key = key;\r\n        this.newDoc = newDoc;\r\n    }\r\n}\r\nclass ExistenceFilterChange {\r\n    constructor(targetId, existenceFilter) {\r\n        this.targetId = targetId;\r\n        this.existenceFilter = existenceFilter;\r\n    }\r\n}\r\nclass WatchTargetChange {\r\n    constructor(\r\n    /** What kind of change occurred to the watch target. */\r\n    state, \r\n    /** The target IDs that were added/removed/set. */\r\n    targetIds, \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a target to be\r\n     * resumed after disconnecting without retransmitting all the data that\r\n     * matches the target. The resume token essentially identifies a point in\r\n     * time from which the server should resume sending results.\r\n     */\r\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \r\n    /** An RPC error indicating why the watch failed. */\r\n    cause = null) {\r\n        this.state = state;\r\n        this.targetIds = targetIds;\r\n        this.resumeToken = resumeToken;\r\n        this.cause = cause;\r\n    }\r\n}\r\n/** Tracks the internal state of a Watch target. */\r\nclass TargetState {\r\n    constructor() {\r\n        /**\r\n         * The number of pending responses (adds or removes) that we are waiting on.\r\n         * We only consider targets active that have no pending responses.\r\n         */\r\n        this.pendingResponses = 0;\r\n        /**\r\n         * Keeps track of the document changes since the last raised snapshot.\r\n         *\r\n         * These changes are continuously updated as we receive document updates and\r\n         * always reflect the current set of changes against the last issued snapshot.\r\n         */\r\n        this.documentChanges = snapshotChangesMap();\r\n        /** See public getters for explanations of these fields. */\r\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\r\n        this._current = false;\r\n        /**\r\n         * Whether this target state should be included in the next snapshot. We\r\n         * initialize to true so that newly-added targets are included in the next\r\n         * RemoteEvent.\r\n         */\r\n        this._hasPendingChanges = true;\r\n    }\r\n    /**\r\n     * Whether this target has been marked 'current'.\r\n     *\r\n     * 'Current' has special meaning in the RPC protocol: It implies that the\r\n     * Watch backend has sent us all changes up to the point at which the target\r\n     * was added and that the target is consistent with the rest of the watch\r\n     * stream.\r\n     */\r\n    get current() {\r\n        return this._current;\r\n    }\r\n    /** The last resume token sent to us for this target. */\r\n    get resumeToken() {\r\n        return this._resumeToken;\r\n    }\r\n    /** Whether this target has pending target adds or target removes. */\r\n    get isPending() {\r\n        return this.pendingResponses !== 0;\r\n    }\r\n    /** Whether we have modified any state that should trigger a snapshot. */\r\n    get hasPendingChanges() {\r\n        return this._hasPendingChanges;\r\n    }\r\n    /**\r\n     * Applies the resume token to the TargetChange, but only when it has a new\r\n     * value. Empty resumeTokens are discarded.\r\n     */\r\n    updateResumeToken(resumeToken) {\r\n        if (resumeToken.approximateByteSize() > 0) {\r\n            this._hasPendingChanges = true;\r\n            this._resumeToken = resumeToken;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a target change from the current set of changes.\r\n     *\r\n     * To reset the document changes after raising this snapshot, call\r\n     * `clearPendingChanges()`.\r\n     */\r\n    toTargetChange() {\r\n        let addedDocuments = documentKeySet();\r\n        let modifiedDocuments = documentKeySet();\r\n        let removedDocuments = documentKeySet();\r\n        this.documentChanges.forEach((key, changeType) => {\r\n            switch (changeType) {\r\n                case 0 /* ChangeType.Added */:\r\n                    addedDocuments = addedDocuments.add(key);\r\n                    break;\r\n                case 2 /* ChangeType.Modified */:\r\n                    modifiedDocuments = modifiedDocuments.add(key);\r\n                    break;\r\n                case 1 /* ChangeType.Removed */:\r\n                    removedDocuments = removedDocuments.add(key);\r\n                    break;\r\n                default:\r\n                    fail();\r\n            }\r\n        });\r\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\r\n    }\r\n    /**\r\n     * Resets the document changes and sets `hasPendingChanges` to false.\r\n     */\r\n    clearPendingChanges() {\r\n        this._hasPendingChanges = false;\r\n        this.documentChanges = snapshotChangesMap();\r\n    }\r\n    addDocumentChange(key, changeType) {\r\n        this._hasPendingChanges = true;\r\n        this.documentChanges = this.documentChanges.insert(key, changeType);\r\n    }\r\n    removeDocumentChange(key) {\r\n        this._hasPendingChanges = true;\r\n        this.documentChanges = this.documentChanges.remove(key);\r\n    }\r\n    recordPendingTargetRequest() {\r\n        this.pendingResponses += 1;\r\n    }\r\n    recordTargetResponse() {\r\n        this.pendingResponses -= 1;\r\n        hardAssert(this.pendingResponses >= 0);\r\n    }\r\n    markCurrent() {\r\n        this._hasPendingChanges = true;\r\n        this._current = true;\r\n    }\r\n}\r\nconst LOG_TAG$g = 'WatchChangeAggregator';\r\n/**\r\n * A helper class to accumulate watch changes into a RemoteEvent.\r\n */\r\nclass WatchChangeAggregator {\r\n    constructor(metadataProvider) {\r\n        this.metadataProvider = metadataProvider;\r\n        /** The internal state of all tracked targets. */\r\n        this.targetStates = new Map();\r\n        /** Keeps track of the documents to update since the last raised snapshot. */\r\n        this.pendingDocumentUpdates = mutableDocumentMap();\r\n        /** A mapping of document keys to their set of target IDs. */\r\n        this.pendingDocumentTargetMapping = documentTargetMap();\r\n        /**\r\n         * A map of targets with existence filter mismatches. These targets are\r\n         * known to be inconsistent and their listens needs to be re-established by\r\n         * RemoteStore.\r\n         */\r\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\r\n    }\r\n    /**\r\n     * Processes and adds the DocumentWatchChange to the current set of changes.\r\n     */\r\n    handleDocumentChange(docChange) {\r\n        for (const targetId of docChange.updatedTargetIds) {\r\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\r\n                this.addDocumentToTarget(targetId, docChange.newDoc);\r\n            }\r\n            else {\r\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\r\n            }\r\n        }\r\n        for (const targetId of docChange.removedTargetIds) {\r\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\r\n        }\r\n    }\r\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\r\n    handleTargetChange(targetChange) {\r\n        this.forEachTarget(targetChange, targetId => {\r\n            const targetState = this.ensureTargetState(targetId);\r\n            switch (targetChange.state) {\r\n                case 0 /* WatchTargetChangeState.NoChange */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                case 1 /* WatchTargetChangeState.Added */:\r\n                    // We need to decrement the number of pending acks needed from watch\r\n                    // for this targetId.\r\n                    targetState.recordTargetResponse();\r\n                    if (!targetState.isPending) {\r\n                        // We have a freshly added target, so we need to reset any state\r\n                        // that we had previously. This can happen e.g. when remove and add\r\n                        // back a target for existence filter mismatches.\r\n                        targetState.clearPendingChanges();\r\n                    }\r\n                    targetState.updateResumeToken(targetChange.resumeToken);\r\n                    break;\r\n                case 2 /* WatchTargetChangeState.Removed */:\r\n                    // We need to keep track of removed targets to we can post-filter and\r\n                    // remove any target changes.\r\n                    // We need to decrement the number of pending acks needed from watch\r\n                    // for this targetId.\r\n                    targetState.recordTargetResponse();\r\n                    if (!targetState.isPending) {\r\n                        this.removeTarget(targetId);\r\n                    }\r\n                    break;\r\n                case 3 /* WatchTargetChangeState.Current */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        targetState.markCurrent();\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                case 4 /* WatchTargetChangeState.Reset */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        // Reset the target and synthesizes removes for all existing\r\n                        // documents. The backend will re-add any documents that still\r\n                        // match the target before it sends the next global snapshot.\r\n                        this.resetTarget(targetId);\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                default:\r\n                    fail();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Iterates over all targetIds that the watch change applies to: either the\r\n     * targetIds explicitly listed in the change or the targetIds of all currently\r\n     * active targets.\r\n     */\r\n    forEachTarget(targetChange, fn) {\r\n        if (targetChange.targetIds.length > 0) {\r\n            targetChange.targetIds.forEach(fn);\r\n        }\r\n        else {\r\n            this.targetStates.forEach((_, targetId) => {\r\n                if (this.isActiveTarget(targetId)) {\r\n                    fn(targetId);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Handles existence filters and synthesizes deletes for filter mismatches.\r\n     * Targets that are invalidated by filter mismatches are added to\r\n     * `pendingTargetResets`.\r\n     */\r\n    handleExistenceFilter(watchChange) {\r\n        const targetId = watchChange.targetId;\r\n        const expectedCount = watchChange.existenceFilter.count;\r\n        const targetData = this.targetDataForActiveTarget(targetId);\r\n        if (targetData) {\r\n            const target = targetData.target;\r\n            if (targetIsDocumentTarget(target)) {\r\n                if (expectedCount === 0) {\r\n                    // The existence filter told us the document does not exist. We deduce\r\n                    // that this document does not exist and apply a deleted document to\r\n                    // our updates. Without applying this deleted document there might be\r\n                    // another query that will raise this document as part of a snapshot\r\n                    // until it is resolved, essentially exposing inconsistency between\r\n                    // queries.\r\n                    const key = new DocumentKey(target.path);\r\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\r\n                }\r\n                else {\r\n                    hardAssert(expectedCount === 1);\r\n                }\r\n            }\r\n            else {\r\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\r\n                // Existence filter mismatch. Mark the documents as being in limbo, and\r\n                // raise a snapshot with `isFromCache:true`.\r\n                if (currentSize !== expectedCount) {\r\n                    // Apply bloom filter to identify and mark removed documents.\r\n                    const bloomFilter = this.parseBloomFilter(watchChange);\r\n                    const status = bloomFilter\r\n                        ? this.applyBloomFilter(bloomFilter, watchChange, currentSize)\r\n                        : 1 /* BloomFilterApplicationStatus.Skipped */;\r\n                    if (status !== 0 /* BloomFilterApplicationStatus.Success */) {\r\n                        // If bloom filter application fails, we reset the mapping and\r\n                        // trigger re-run of the query.\r\n                        this.resetTarget(targetId);\r\n                        const purpose = status === 2 /* BloomFilterApplicationStatus.FalsePositive */\r\n                            ? \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */\r\n                            : \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */;\r\n                        this.pendingTargetResets = this.pendingTargetResets.insert(targetId, purpose);\r\n                    }\r\n                    testingHooksSpi === null || testingHooksSpi === void 0 ? void 0 : testingHooksSpi.notifyOnExistenceFilterMismatch(createExistenceFilterMismatchInfoForTestingHooks(currentSize, watchChange.existenceFilter, this.metadataProvider.getDatabaseId(), bloomFilter, status));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Parse the bloom filter from the \"unchanged_names\" field of an existence\r\n     * filter.\r\n     */\r\n    parseBloomFilter(watchChange) {\r\n        const unchangedNames = watchChange.existenceFilter.unchangedNames;\r\n        if (!unchangedNames || !unchangedNames.bits) {\r\n            return null;\r\n        }\r\n        const { bits: { bitmap = '', padding = 0 }, hashCount = 0 } = unchangedNames;\r\n        let normalizedBitmap;\r\n        try {\r\n            normalizedBitmap = normalizeByteString(bitmap).toUint8Array();\r\n        }\r\n        catch (err) {\r\n            if (err instanceof Base64DecodeError) {\r\n                logWarn('Decoding the base64 bloom filter in existence filter failed (' +\r\n                    err.message +\r\n                    '); ignoring the bloom filter and falling back to full re-query.');\r\n                return null;\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n        let bloomFilter;\r\n        try {\r\n            // BloomFilter throws error if the inputs are invalid.\r\n            bloomFilter = new BloomFilter(normalizedBitmap, padding, hashCount);\r\n        }\r\n        catch (err) {\r\n            if (err instanceof BloomFilterError) {\r\n                logWarn('BloomFilter error: ', err);\r\n            }\r\n            else {\r\n                logWarn('Applying bloom filter failed: ', err);\r\n            }\r\n            return null;\r\n        }\r\n        if (bloomFilter.bitCount === 0) {\r\n            return null;\r\n        }\r\n        return bloomFilter;\r\n    }\r\n    /**\r\n     * Apply bloom filter to remove the deleted documents, and return the\r\n     * application status.\r\n     */\r\n    applyBloomFilter(bloomFilter, watchChange, currentCount) {\r\n        const expectedCount = watchChange.existenceFilter.count;\r\n        const removedDocumentCount = this.filterRemovedDocuments(bloomFilter, watchChange.targetId);\r\n        return expectedCount === currentCount - removedDocumentCount\r\n            ? 0 /* BloomFilterApplicationStatus.Success */\r\n            : 2 /* BloomFilterApplicationStatus.FalsePositive */;\r\n    }\r\n    /**\r\n     * Filter out removed documents based on bloom filter membership result and\r\n     * return number of documents removed.\r\n     */\r\n    filterRemovedDocuments(bloomFilter, targetId) {\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        let removalCount = 0;\r\n        existingKeys.forEach(key => {\r\n            const databaseId = this.metadataProvider.getDatabaseId();\r\n            const documentPath = `projects/${databaseId.projectId}` +\r\n                `/databases/${databaseId.database}` +\r\n                `/documents/${key.path.canonicalString()}`;\r\n            if (!bloomFilter.mightContain(documentPath)) {\r\n                this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\r\n                removalCount++;\r\n            }\r\n        });\r\n        return removalCount;\r\n    }\r\n    /**\r\n     * Converts the currently accumulated state into a remote event at the\r\n     * provided snapshot version. Resets the accumulated changes before returning.\r\n     */\r\n    createRemoteEvent(snapshotVersion) {\r\n        const targetChanges = new Map();\r\n        this.targetStates.forEach((targetState, targetId) => {\r\n            const targetData = this.targetDataForActiveTarget(targetId);\r\n            if (targetData) {\r\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\r\n                    // Document queries for document that don't exist can produce an empty\r\n                    // result set. To update our local cache, we synthesize a document\r\n                    // delete if we have not previously received the document. This\r\n                    // resolves the limbo state of the document, removing it from\r\n                    // limboDocumentRefs.\r\n                    //\r\n                    // TODO(dimond): Ideally we would have an explicit lookup target\r\n                    // instead resulting in an explicit delete message and we could\r\n                    // remove this special logic.\r\n                    const key = new DocumentKey(targetData.target.path);\r\n                    if (this.pendingDocumentUpdates.get(key) === null &&\r\n                        !this.targetContainsDocument(targetId, key)) {\r\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\r\n                    }\r\n                }\r\n                if (targetState.hasPendingChanges) {\r\n                    targetChanges.set(targetId, targetState.toTargetChange());\r\n                    targetState.clearPendingChanges();\r\n                }\r\n            }\r\n        });\r\n        let resolvedLimboDocuments = documentKeySet();\r\n        // We extract the set of limbo-only document updates as the GC logic\r\n        // special-cases documents that do not appear in the target cache.\r\n        //\r\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\r\n        // client.\r\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\r\n            let isOnlyLimboTarget = true;\r\n            targets.forEachWhile(targetId => {\r\n                const targetData = this.targetDataForActiveTarget(targetId);\r\n                if (targetData &&\r\n                    targetData.purpose !== \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */) {\r\n                    isOnlyLimboTarget = false;\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            if (isOnlyLimboTarget) {\r\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\r\n            }\r\n        });\r\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\r\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\r\n        this.pendingDocumentUpdates = mutableDocumentMap();\r\n        this.pendingDocumentTargetMapping = documentTargetMap();\r\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\r\n        return remoteEvent;\r\n    }\r\n    /**\r\n     * Adds the provided document to the internal list of document updates and\r\n     * its document key to the given target's mapping.\r\n     */\r\n    // Visible for testing.\r\n    addDocumentToTarget(targetId, document) {\r\n        if (!this.isActiveTarget(targetId)) {\r\n            return;\r\n        }\r\n        const changeType = this.targetContainsDocument(targetId, document.key)\r\n            ? 2 /* ChangeType.Modified */\r\n            : 0 /* ChangeType.Added */;\r\n        const targetState = this.ensureTargetState(targetId);\r\n        targetState.addDocumentChange(document.key, changeType);\r\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\r\n        this.pendingDocumentTargetMapping =\r\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\r\n    }\r\n    /**\r\n     * Removes the provided document from the target mapping. If the\r\n     * document no longer matches the target, but the document's state is still\r\n     * known (e.g. we know that the document was deleted or we received the change\r\n     * that caused the filter mismatch), the new document can be provided\r\n     * to update the remote document cache.\r\n     */\r\n    // Visible for testing.\r\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\r\n        if (!this.isActiveTarget(targetId)) {\r\n            return;\r\n        }\r\n        const targetState = this.ensureTargetState(targetId);\r\n        if (this.targetContainsDocument(targetId, key)) {\r\n            targetState.addDocumentChange(key, 1 /* ChangeType.Removed */);\r\n        }\r\n        else {\r\n            // The document may have entered and left the target before we raised a\r\n            // snapshot, so we can just ignore the change.\r\n            targetState.removeDocumentChange(key);\r\n        }\r\n        this.pendingDocumentTargetMapping =\r\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\r\n        if (updatedDocument) {\r\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\r\n        }\r\n    }\r\n    removeTarget(targetId) {\r\n        this.targetStates.delete(targetId);\r\n    }\r\n    /**\r\n     * Returns the current count of documents in the target. This includes both\r\n     * the number of documents that the LocalStore considers to be part of the\r\n     * target as well as any accumulated changes.\r\n     */\r\n    getCurrentDocumentCountForTarget(targetId) {\r\n        const targetState = this.ensureTargetState(targetId);\r\n        const targetChange = targetState.toTargetChange();\r\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\r\n            targetChange.addedDocuments.size -\r\n            targetChange.removedDocuments.size);\r\n    }\r\n    /**\r\n     * Increment the number of acks needed from watch before we can consider the\r\n     * server to be 'in-sync' with the client's active targets.\r\n     */\r\n    recordPendingTargetRequest(targetId) {\r\n        // For each request we get we need to record we need a response for it.\r\n        const targetState = this.ensureTargetState(targetId);\r\n        targetState.recordPendingTargetRequest();\r\n    }\r\n    ensureTargetState(targetId) {\r\n        let result = this.targetStates.get(targetId);\r\n        if (!result) {\r\n            result = new TargetState();\r\n            this.targetStates.set(targetId, result);\r\n        }\r\n        return result;\r\n    }\r\n    ensureDocumentTargetMapping(key) {\r\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\r\n        if (!targetMapping) {\r\n            targetMapping = new SortedSet(primitiveComparator);\r\n            this.pendingDocumentTargetMapping =\r\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\r\n        }\r\n        return targetMapping;\r\n    }\r\n    /**\r\n     * Verifies that the user is still interested in this target (by calling\r\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\r\n     * from watch.\r\n     */\r\n    isActiveTarget(targetId) {\r\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\r\n        if (!targetActive) {\r\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\r\n        }\r\n        return targetActive;\r\n    }\r\n    /**\r\n     * Returns the TargetData for an active target (i.e. a target that the user\r\n     * is still interested in that has no outstanding target change requests).\r\n     */\r\n    targetDataForActiveTarget(targetId) {\r\n        const targetState = this.targetStates.get(targetId);\r\n        return targetState && targetState.isPending\r\n            ? null\r\n            : this.metadataProvider.getTargetDataForTarget(targetId);\r\n    }\r\n    /**\r\n     * Resets the state of a Watch target to its initial state (e.g. sets\r\n     * 'current' to false, clears the resume token and removes its target mapping\r\n     * from all documents).\r\n     */\r\n    resetTarget(targetId) {\r\n        this.targetStates.set(targetId, new TargetState());\r\n        // Trigger removal for any documents currently mapped to this target.\r\n        // These removals will be part of the initial snapshot if Watch does not\r\n        // resend these documents.\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        existingKeys.forEach(key => {\r\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\r\n        });\r\n    }\r\n    /**\r\n     * Returns whether the LocalStore considers the document to be part of the\r\n     * specified target.\r\n     */\r\n    targetContainsDocument(targetId, key) {\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        return existingKeys.has(key);\r\n    }\r\n}\r\nfunction documentTargetMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\nfunction snapshotChangesMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\nfunction createExistenceFilterMismatchInfoForTestingHooks(localCacheCount, existenceFilter, databaseId, bloomFilter, bloomFilterStatus) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const result = {\r\n        localCacheCount,\r\n        existenceFilterCount: existenceFilter.count,\r\n        databaseId: databaseId.database,\r\n        projectId: databaseId.projectId\r\n    };\r\n    const unchangedNames = existenceFilter.unchangedNames;\r\n    if (unchangedNames) {\r\n        result.bloomFilter = {\r\n            applied: bloomFilterStatus === 0 /* BloomFilterApplicationStatus.Success */,\r\n            hashCount: (_a = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.hashCount) !== null && _a !== void 0 ? _a : 0,\r\n            bitmapLength: (_d = (_c = (_b = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _b === void 0 ? void 0 : _b.bitmap) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\r\n            padding: (_f = (_e = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _e === void 0 ? void 0 : _e.padding) !== null && _f !== void 0 ? _f : 0,\r\n            mightContain: (value) => { var _a; return (_a = bloomFilter === null || bloomFilter === void 0 ? void 0 : bloomFilter.mightContain(value)) !== null && _a !== void 0 ? _a : false; }\r\n        };\r\n    }\r\n    return result;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DIRECTIONS = (() => {\r\n    const dirs = {};\r\n    dirs[\"asc\" /* Direction.ASCENDING */] = 'ASCENDING';\r\n    dirs[\"desc\" /* Direction.DESCENDING */] = 'DESCENDING';\r\n    return dirs;\r\n})();\r\nconst OPERATORS = (() => {\r\n    const ops = {};\r\n    ops[\"<\" /* Operator.LESS_THAN */] = 'LESS_THAN';\r\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\r\n    ops[\">\" /* Operator.GREATER_THAN */] = 'GREATER_THAN';\r\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\r\n    ops[\"==\" /* Operator.EQUAL */] = 'EQUAL';\r\n    ops[\"!=\" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';\r\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\r\n    ops[\"in\" /* Operator.IN */] = 'IN';\r\n    ops[\"not-in\" /* Operator.NOT_IN */] = 'NOT_IN';\r\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\r\n    return ops;\r\n})();\r\nconst COMPOSITE_OPERATORS = (() => {\r\n    const ops = {};\r\n    ops[\"and\" /* CompositeOperator.AND */] = 'AND';\r\n    ops[\"or\" /* CompositeOperator.OR */] = 'OR';\r\n    return ops;\r\n})();\r\nfunction assertPresent(value, description) {\r\n}\r\n/**\r\n * This class generates JsonObject values for the Datastore API suitable for\r\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\r\n *\r\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\r\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\r\n * format.\r\n *\r\n * For a description of the Proto3 JSON format check\r\n * https://developers.google.com/protocol-buffers/docs/proto3#json\r\n *\r\n * TODO(klimt): We can remove the databaseId argument if we keep the full\r\n * resource name in documents.\r\n */\r\nclass JsonProtoSerializer {\r\n    constructor(databaseId, useProto3Json) {\r\n        this.databaseId = databaseId;\r\n        this.useProto3Json = useProto3Json;\r\n    }\r\n}\r\nfunction fromRpcStatus(status) {\r\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\r\n    return new FirestoreError(code, status.message || '');\r\n}\r\n/**\r\n * Returns a value for a number (or null) that's appropriate to put into\r\n * a google.protobuf.Int32Value proto.\r\n * DO NOT USE THIS FOR ANYTHING ELSE.\r\n * This method cheats. It's typed as returning \"number\" because that's what\r\n * our generated proto interfaces say Int32Value must be. But GRPC actually\r\n * expects a { value: <number> } struct.\r\n */\r\nfunction toInt32Proto(serializer, val) {\r\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\r\n        return val;\r\n    }\r\n    else {\r\n        return { value: val };\r\n    }\r\n}\r\n/**\r\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\r\n */\r\nfunction fromInt32Proto(val) {\r\n    let result;\r\n    if (typeof val === 'object') {\r\n        result = val.value;\r\n    }\r\n    else {\r\n        result = val;\r\n    }\r\n    return isNullOrUndefined(result) ? null : result;\r\n}\r\n/**\r\n * Returns a value for a Date that's appropriate to put into a proto.\r\n */\r\nfunction toTimestamp(serializer, timestamp) {\r\n    if (serializer.useProto3Json) {\r\n        // Serialize to ISO-8601 date format, but with full nano resolution.\r\n        // Since JS Date has only millis, let's only use it for the seconds and\r\n        // then manually add the fractions to the end.\r\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\r\n        // Remove .xxx frac part and Z in the end.\r\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\r\n        // Pad the fraction out to 9 digits (nanos).\r\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\r\n        return `${strUntilSeconds}.${nanoStr}Z`;\r\n    }\r\n    else {\r\n        return {\r\n            seconds: '' + timestamp.seconds,\r\n            nanos: timestamp.nanoseconds\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        };\r\n    }\r\n}\r\nfunction fromTimestamp(date) {\r\n    const timestamp = normalizeTimestamp(date);\r\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\r\n}\r\n/**\r\n * Returns a value for bytes that's appropriate to put in a proto.\r\n *\r\n * Visible for testing.\r\n */\r\nfunction toBytes(serializer, bytes) {\r\n    if (serializer.useProto3Json) {\r\n        return bytes.toBase64();\r\n    }\r\n    else {\r\n        return bytes.toUint8Array();\r\n    }\r\n}\r\n/**\r\n * Returns a ByteString based on the proto string value.\r\n */\r\nfunction fromBytes(serializer, value) {\r\n    if (serializer.useProto3Json) {\r\n        hardAssert(value === undefined || typeof value === 'string');\r\n        return ByteString.fromBase64String(value ? value : '');\r\n    }\r\n    else {\r\n        hardAssert(value === undefined ||\r\n            // Check if the value is an instance of both Buffer and Uint8Array,\r\n            // despite the fact that Buffer extends Uint8Array. In some\r\n            // environments, such as jsdom, the prototype chain of Buffer\r\n            // does not indicate that it extends Uint8Array.\r\n            value instanceof Buffer ||\r\n            value instanceof Uint8Array);\r\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\r\n    }\r\n}\r\nfunction toVersion(serializer, version) {\r\n    return toTimestamp(serializer, version.toTimestamp());\r\n}\r\nfunction fromVersion(version) {\r\n    hardAssert(!!version);\r\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\r\n}\r\nfunction toResourceName(databaseId, path) {\r\n    return toResourcePath(databaseId, path).canonicalString();\r\n}\r\nfunction toResourcePath(databaseId, path) {\r\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child('documents');\r\n    return path === undefined ? resourcePath : resourcePath.child(path);\r\n}\r\nfunction fromResourceName(name) {\r\n    const resource = ResourcePath.fromString(name);\r\n    hardAssert(isValidResourceName(resource));\r\n    return resource;\r\n}\r\nfunction toName(serializer, key) {\r\n    return toResourceName(serializer.databaseId, key.path);\r\n}\r\nfunction fromName(serializer, name) {\r\n    const resource = fromResourceName(name);\r\n    if (resource.get(1) !== serializer.databaseId.projectId) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\r\n            resource.get(1) +\r\n            ' vs ' +\r\n            serializer.databaseId.projectId);\r\n    }\r\n    if (resource.get(3) !== serializer.databaseId.database) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\r\n            resource.get(3) +\r\n            ' vs ' +\r\n            serializer.databaseId.database);\r\n    }\r\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\r\n}\r\nfunction toQueryPath(serializer, path) {\r\n    return toResourceName(serializer.databaseId, path);\r\n}\r\nfunction fromQueryPath(name) {\r\n    const resourceName = fromResourceName(name);\r\n    // In v1beta1 queries for collections at the root did not have a trailing\r\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\r\n    // ability to read the v1beta1 form for compatibility with queries persisted\r\n    // in the local target cache.\r\n    if (resourceName.length === 4) {\r\n        return ResourcePath.emptyPath();\r\n    }\r\n    return extractLocalPathFromResourceName(resourceName);\r\n}\r\nfunction getEncodedDatabaseId(serializer) {\r\n    const path = new ResourcePath([\r\n        'projects',\r\n        serializer.databaseId.projectId,\r\n        'databases',\r\n        serializer.databaseId.database\r\n    ]);\r\n    return path.canonicalString();\r\n}\r\nfunction fullyQualifiedPrefixPath(databaseId) {\r\n    return new ResourcePath([\r\n        'projects',\r\n        databaseId.projectId,\r\n        'databases',\r\n        databaseId.database\r\n    ]);\r\n}\r\nfunction extractLocalPathFromResourceName(resourceName) {\r\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');\r\n    return resourceName.popFirst(5);\r\n}\r\n/** Creates a Document proto from key and fields (but no create/update time) */\r\nfunction toMutationDocument(serializer, key, fields) {\r\n    return {\r\n        name: toName(serializer, key),\r\n        fields: fields.value.mapValue.fields\r\n    };\r\n}\r\nfunction toDocument(serializer, document) {\r\n    return {\r\n        name: toName(serializer, document.key),\r\n        fields: document.data.value.mapValue.fields,\r\n        updateTime: toTimestamp(serializer, document.version.toTimestamp()),\r\n        createTime: toTimestamp(serializer, document.createTime.toTimestamp())\r\n    };\r\n}\r\nfunction fromDocument(serializer, document, hasCommittedMutations) {\r\n    const key = fromName(serializer, document.name);\r\n    const version = fromVersion(document.updateTime);\r\n    // If we read a document from persistence that is missing createTime, it's due\r\n    // to older SDK versions not storing this information. In such cases, we'll\r\n    // set the createTime to zero. This can be removed in the long term.\r\n    const createTime = document.createTime\r\n        ? fromVersion(document.createTime)\r\n        : SnapshotVersion.min();\r\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\r\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\r\n    if (hasCommittedMutations) {\r\n        result.setHasCommittedMutations();\r\n    }\r\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\r\n}\r\nfunction fromFound(serializer, doc) {\r\n    hardAssert(!!doc.found);\r\n    assertPresent(doc.found.name);\r\n    assertPresent(doc.found.updateTime);\r\n    const key = fromName(serializer, doc.found.name);\r\n    const version = fromVersion(doc.found.updateTime);\r\n    const createTime = doc.found.createTime\r\n        ? fromVersion(doc.found.createTime)\r\n        : SnapshotVersion.min();\r\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\r\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\r\n}\r\nfunction fromMissing(serializer, result) {\r\n    hardAssert(!!result.missing);\r\n    hardAssert(!!result.readTime);\r\n    const key = fromName(serializer, result.missing);\r\n    const version = fromVersion(result.readTime);\r\n    return MutableDocument.newNoDocument(key, version);\r\n}\r\nfunction fromBatchGetDocumentsResponse(serializer, result) {\r\n    if ('found' in result) {\r\n        return fromFound(serializer, result);\r\n    }\r\n    else if ('missing' in result) {\r\n        return fromMissing(serializer, result);\r\n    }\r\n    return fail();\r\n}\r\nfunction fromWatchChange(serializer, change) {\r\n    let watchChange;\r\n    if ('targetChange' in change) {\r\n        assertPresent(change.targetChange);\r\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\r\n        // if unset\r\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\r\n        const targetIds = change.targetChange.targetIds || [];\r\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\r\n        const causeProto = change.targetChange.cause;\r\n        const cause = causeProto && fromRpcStatus(causeProto);\r\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\r\n    }\r\n    else if ('documentChange' in change) {\r\n        assertPresent(change.documentChange);\r\n        const entityChange = change.documentChange;\r\n        assertPresent(entityChange.document);\r\n        assertPresent(entityChange.document.name);\r\n        assertPresent(entityChange.document.updateTime);\r\n        const key = fromName(serializer, entityChange.document.name);\r\n        const version = fromVersion(entityChange.document.updateTime);\r\n        const createTime = entityChange.document.createTime\r\n            ? fromVersion(entityChange.document.createTime)\r\n            : SnapshotVersion.min();\r\n        const data = new ObjectValue({\r\n            mapValue: { fields: entityChange.document.fields }\r\n        });\r\n        const doc = MutableDocument.newFoundDocument(key, version, createTime, data);\r\n        const updatedTargetIds = entityChange.targetIds || [];\r\n        const removedTargetIds = entityChange.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\r\n    }\r\n    else if ('documentDelete' in change) {\r\n        assertPresent(change.documentDelete);\r\n        const docDelete = change.documentDelete;\r\n        assertPresent(docDelete.document);\r\n        const key = fromName(serializer, docDelete.document);\r\n        const version = docDelete.readTime\r\n            ? fromVersion(docDelete.readTime)\r\n            : SnapshotVersion.min();\r\n        const doc = MutableDocument.newNoDocument(key, version);\r\n        const removedTargetIds = docDelete.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\r\n    }\r\n    else if ('documentRemove' in change) {\r\n        assertPresent(change.documentRemove);\r\n        const docRemove = change.documentRemove;\r\n        assertPresent(docRemove.document);\r\n        const key = fromName(serializer, docRemove.document);\r\n        const removedTargetIds = docRemove.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\r\n    }\r\n    else if ('filter' in change) {\r\n        // TODO(dimond): implement existence filter parsing with strategy.\r\n        assertPresent(change.filter);\r\n        const filter = change.filter;\r\n        assertPresent(filter.targetId);\r\n        const { count = 0, unchangedNames } = filter;\r\n        const existenceFilter = new ExistenceFilter(count, unchangedNames);\r\n        const targetId = filter.targetId;\r\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    return watchChange;\r\n}\r\nfunction fromWatchTargetChangeState(state) {\r\n    if (state === 'NO_CHANGE') {\r\n        return 0 /* WatchTargetChangeState.NoChange */;\r\n    }\r\n    else if (state === 'ADD') {\r\n        return 1 /* WatchTargetChangeState.Added */;\r\n    }\r\n    else if (state === 'REMOVE') {\r\n        return 2 /* WatchTargetChangeState.Removed */;\r\n    }\r\n    else if (state === 'CURRENT') {\r\n        return 3 /* WatchTargetChangeState.Current */;\r\n    }\r\n    else if (state === 'RESET') {\r\n        return 4 /* WatchTargetChangeState.Reset */;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction versionFromListenResponse(change) {\r\n    // We have only reached a consistent snapshot for the entire stream if there\r\n    // is a read_time set and it applies to all targets (i.e. the list of\r\n    // targets is empty). The backend is guaranteed to send such responses.\r\n    if (!('targetChange' in change)) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    const targetChange = change.targetChange;\r\n    if (targetChange.targetIds && targetChange.targetIds.length) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    if (!targetChange.readTime) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    return fromVersion(targetChange.readTime);\r\n}\r\nfunction toMutation(serializer, mutation) {\r\n    let result;\r\n    if (mutation instanceof SetMutation) {\r\n        result = {\r\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\r\n        };\r\n    }\r\n    else if (mutation instanceof DeleteMutation) {\r\n        result = { delete: toName(serializer, mutation.key) };\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        result = {\r\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\r\n            updateMask: toDocumentMask(mutation.fieldMask)\r\n        };\r\n    }\r\n    else if (mutation instanceof VerifyMutation) {\r\n        result = {\r\n            verify: toName(serializer, mutation.key)\r\n        };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    if (mutation.fieldTransforms.length > 0) {\r\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\r\n    }\r\n    if (!mutation.precondition.isNone) {\r\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\r\n    }\r\n    return result;\r\n}\r\nfunction fromMutation(serializer, proto) {\r\n    const precondition = proto.currentDocument\r\n        ? fromPrecondition(proto.currentDocument)\r\n        : Precondition.none();\r\n    const fieldTransforms = proto.updateTransforms\r\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\r\n        : [];\r\n    if (proto.update) {\r\n        assertPresent(proto.update.name);\r\n        const key = fromName(serializer, proto.update.name);\r\n        const value = new ObjectValue({\r\n            mapValue: { fields: proto.update.fields }\r\n        });\r\n        if (proto.updateMask) {\r\n            const fieldMask = fromDocumentMask(proto.updateMask);\r\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\r\n        }\r\n        else {\r\n            return new SetMutation(key, value, precondition, fieldTransforms);\r\n        }\r\n    }\r\n    else if (proto.delete) {\r\n        const key = fromName(serializer, proto.delete);\r\n        return new DeleteMutation(key, precondition);\r\n    }\r\n    else if (proto.verify) {\r\n        const key = fromName(serializer, proto.verify);\r\n        return new VerifyMutation(key, precondition);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toPrecondition(serializer, precondition) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return {\r\n            updateTime: toVersion(serializer, precondition.updateTime)\r\n        };\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return { exists: precondition.exists };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction fromPrecondition(precondition) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return Precondition.exists(precondition.exists);\r\n    }\r\n    else {\r\n        return Precondition.none();\r\n    }\r\n}\r\nfunction fromWriteResult(proto, commitTime) {\r\n    // NOTE: Deletes don't have an updateTime.\r\n    let version = proto.updateTime\r\n        ? fromVersion(proto.updateTime)\r\n        : fromVersion(commitTime);\r\n    if (version.isEqual(SnapshotVersion.min())) {\r\n        // The Firestore Emulator currently returns an update time of 0 for\r\n        // deletes of non-existing documents (rather than null). This breaks the\r\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\r\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\r\n        // TODO(#2149): Remove this when Emulator is fixed\r\n        version = fromVersion(commitTime);\r\n    }\r\n    return new MutationResult(version, proto.transformResults || []);\r\n}\r\nfunction fromWriteResults(protos, commitTime) {\r\n    if (protos && protos.length > 0) {\r\n        hardAssert(commitTime !== undefined);\r\n        return protos.map(proto => fromWriteResult(proto, commitTime));\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nfunction toFieldTransform(serializer, fieldTransform) {\r\n    const transform = fieldTransform.transform;\r\n    if (transform instanceof ServerTimestampTransform) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            setToServerValue: 'REQUEST_TIME'\r\n        };\r\n    }\r\n    else if (transform instanceof ArrayUnionTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            appendMissingElements: {\r\n                values: transform.elements\r\n            }\r\n        };\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            removeAllFromArray: {\r\n                values: transform.elements\r\n            }\r\n        };\r\n    }\r\n    else if (transform instanceof NumericIncrementTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            increment: transform.operand\r\n        };\r\n    }\r\n    else {\r\n        throw fail();\r\n    }\r\n}\r\nfunction fromFieldTransform(serializer, proto) {\r\n    let transform = null;\r\n    if ('setToServerValue' in proto) {\r\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME');\r\n        transform = new ServerTimestampTransform();\r\n    }\r\n    else if ('appendMissingElements' in proto) {\r\n        const values = proto.appendMissingElements.values || [];\r\n        transform = new ArrayUnionTransformOperation(values);\r\n    }\r\n    else if ('removeAllFromArray' in proto) {\r\n        const values = proto.removeAllFromArray.values || [];\r\n        transform = new ArrayRemoveTransformOperation(values);\r\n    }\r\n    else if ('increment' in proto) {\r\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\r\n    return new FieldTransform(fieldPath, transform);\r\n}\r\nfunction toDocumentsTarget(serializer, target) {\r\n    return { documents: [toQueryPath(serializer, target.path)] };\r\n}\r\nfunction fromDocumentsTarget(documentsTarget) {\r\n    const count = documentsTarget.documents.length;\r\n    hardAssert(count === 1);\r\n    const name = documentsTarget.documents[0];\r\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\r\n}\r\nfunction toQueryTarget(serializer, target) {\r\n    // Dissect the path into parent, collectionId, and optional key filter.\r\n    const queryTarget = { structuredQuery: {} };\r\n    const path = target.path;\r\n    let parent;\r\n    if (target.collectionGroup !== null) {\r\n        parent = path;\r\n        queryTarget.structuredQuery.from = [\r\n            {\r\n                collectionId: target.collectionGroup,\r\n                allDescendants: true\r\n            }\r\n        ];\r\n    }\r\n    else {\r\n        parent = path.popLast();\r\n        queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];\r\n    }\r\n    queryTarget.parent = toQueryPath(serializer, parent);\r\n    const where = toFilters(target.filters);\r\n    if (where) {\r\n        queryTarget.structuredQuery.where = where;\r\n    }\r\n    const orderBy = toOrder(target.orderBy);\r\n    if (orderBy) {\r\n        queryTarget.structuredQuery.orderBy = orderBy;\r\n    }\r\n    const limit = toInt32Proto(serializer, target.limit);\r\n    if (limit !== null) {\r\n        queryTarget.structuredQuery.limit = limit;\r\n    }\r\n    if (target.startAt) {\r\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\r\n    }\r\n    if (target.endAt) {\r\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\r\n    }\r\n    return { queryTarget, parent };\r\n}\r\nfunction toRunAggregationQueryRequest(serializer, target, aggregates, skipAliasing) {\r\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\r\n    const aliasMap = {};\r\n    const aggregations = [];\r\n    let aggregationNum = 0;\r\n    aggregates.forEach(aggregate => {\r\n        // Map all client-side aliases to a unique short-form\r\n        // alias. This avoids issues with client-side aliases that\r\n        // exceed the 1500-byte string size limit.\r\n        const serverAlias = skipAliasing\r\n            ? aggregate.alias\r\n            : `aggregate_${aggregationNum++}`;\r\n        aliasMap[serverAlias] = aggregate.alias;\r\n        if (aggregate.aggregateType === 'count') {\r\n            aggregations.push({\r\n                alias: serverAlias,\r\n                count: {}\r\n            });\r\n        }\r\n        else if (aggregate.aggregateType === 'avg') {\r\n            aggregations.push({\r\n                alias: serverAlias,\r\n                avg: {\r\n                    field: toFieldPathReference(aggregate.fieldPath)\r\n                }\r\n            });\r\n        }\r\n        else if (aggregate.aggregateType === 'sum') {\r\n            aggregations.push({\r\n                alias: serverAlias,\r\n                sum: {\r\n                    field: toFieldPathReference(aggregate.fieldPath)\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return {\r\n        request: {\r\n            structuredAggregationQuery: {\r\n                aggregations,\r\n                structuredQuery: queryTarget.structuredQuery\r\n            },\r\n            parent: queryTarget.parent\r\n        },\r\n        aliasMap,\r\n        parent\r\n    };\r\n}\r\nfunction convertQueryTargetToQuery(target) {\r\n    let path = fromQueryPath(target.parent);\r\n    const query = target.structuredQuery;\r\n    const fromCount = query.from ? query.from.length : 0;\r\n    let collectionGroup = null;\r\n    if (fromCount > 0) {\r\n        hardAssert(fromCount === 1);\r\n        const from = query.from[0];\r\n        if (from.allDescendants) {\r\n            collectionGroup = from.collectionId;\r\n        }\r\n        else {\r\n            path = path.child(from.collectionId);\r\n        }\r\n    }\r\n    let filterBy = [];\r\n    if (query.where) {\r\n        filterBy = fromFilters(query.where);\r\n    }\r\n    let orderBy = [];\r\n    if (query.orderBy) {\r\n        orderBy = fromOrder(query.orderBy);\r\n    }\r\n    let limit = null;\r\n    if (query.limit) {\r\n        limit = fromInt32Proto(query.limit);\r\n    }\r\n    let startAt = null;\r\n    if (query.startAt) {\r\n        startAt = fromStartAtCursor(query.startAt);\r\n    }\r\n    let endAt = null;\r\n    if (query.endAt) {\r\n        endAt = fromEndAtCursor(query.endAt);\r\n    }\r\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* LimitType.First */, startAt, endAt);\r\n}\r\nfunction fromQueryTarget(target) {\r\n    return queryToTarget(convertQueryTargetToQuery(target));\r\n}\r\nfunction toListenRequestLabels(serializer, targetData) {\r\n    const value = toLabel(targetData.purpose);\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    else {\r\n        return {\r\n            'goog-listen-tags': value\r\n        };\r\n    }\r\n}\r\nfunction toLabel(purpose) {\r\n    switch (purpose) {\r\n        case \"TargetPurposeListen\" /* TargetPurpose.Listen */:\r\n            return null;\r\n        case \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */:\r\n            return 'existence-filter-mismatch';\r\n        case \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */:\r\n            return 'existence-filter-mismatch-bloom';\r\n        case \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */:\r\n            return 'limbo-document';\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toTarget(serializer, targetData) {\r\n    let result;\r\n    const target = targetData.target;\r\n    if (targetIsDocumentTarget(target)) {\r\n        result = { documents: toDocumentsTarget(serializer, target) };\r\n    }\r\n    else {\r\n        result = { query: toQueryTarget(serializer, target).queryTarget };\r\n    }\r\n    result.targetId = targetData.targetId;\r\n    if (targetData.resumeToken.approximateByteSize() > 0) {\r\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\r\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\r\n        if (expectedCount !== null) {\r\n            result.expectedCount = expectedCount;\r\n        }\r\n    }\r\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\r\n        // TODO(wuandy): Consider removing above check because it is most likely true.\r\n        // Right now, many tests depend on this behaviour though (leaving min() out\r\n        // of serialization).\r\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\r\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\r\n        if (expectedCount !== null) {\r\n            result.expectedCount = expectedCount;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction toFilters(filters) {\r\n    if (filters.length === 0) {\r\n        return;\r\n    }\r\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */));\r\n}\r\nfunction fromFilters(filter) {\r\n    const result = fromFilter(filter);\r\n    if (result instanceof CompositeFilter &&\r\n        compositeFilterIsFlatConjunction(result)) {\r\n        return result.getFilters();\r\n    }\r\n    return [result];\r\n}\r\nfunction fromFilter(filter) {\r\n    if (filter.unaryFilter !== undefined) {\r\n        return fromUnaryFilter(filter);\r\n    }\r\n    else if (filter.fieldFilter !== undefined) {\r\n        return fromFieldFilter(filter);\r\n    }\r\n    else if (filter.compositeFilter !== undefined) {\r\n        return fromCompositeFilter(filter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toOrder(orderBys) {\r\n    if (orderBys.length === 0) {\r\n        return;\r\n    }\r\n    return orderBys.map(order => toPropertyOrder(order));\r\n}\r\nfunction fromOrder(orderBys) {\r\n    return orderBys.map(order => fromPropertyOrder(order));\r\n}\r\nfunction toStartAtCursor(cursor) {\r\n    return {\r\n        before: cursor.inclusive,\r\n        values: cursor.position\r\n    };\r\n}\r\nfunction toEndAtCursor(cursor) {\r\n    return {\r\n        before: !cursor.inclusive,\r\n        values: cursor.position\r\n    };\r\n}\r\nfunction fromStartAtCursor(cursor) {\r\n    const inclusive = !!cursor.before;\r\n    const position = cursor.values || [];\r\n    return new Bound(position, inclusive);\r\n}\r\nfunction fromEndAtCursor(cursor) {\r\n    const inclusive = !cursor.before;\r\n    const position = cursor.values || [];\r\n    return new Bound(position, inclusive);\r\n}\r\n// visible for testing\r\nfunction toDirection(dir) {\r\n    return DIRECTIONS[dir];\r\n}\r\n// visible for testing\r\nfunction fromDirection(dir) {\r\n    switch (dir) {\r\n        case 'ASCENDING':\r\n            return \"asc\" /* Direction.ASCENDING */;\r\n        case 'DESCENDING':\r\n            return \"desc\" /* Direction.DESCENDING */;\r\n        default:\r\n            return undefined;\r\n    }\r\n}\r\n// visible for testing\r\nfunction toOperatorName(op) {\r\n    return OPERATORS[op];\r\n}\r\nfunction toCompositeOperatorName(op) {\r\n    return COMPOSITE_OPERATORS[op];\r\n}\r\nfunction fromOperatorName(op) {\r\n    switch (op) {\r\n        case 'EQUAL':\r\n            return \"==\" /* Operator.EQUAL */;\r\n        case 'NOT_EQUAL':\r\n            return \"!=\" /* Operator.NOT_EQUAL */;\r\n        case 'GREATER_THAN':\r\n            return \">\" /* Operator.GREATER_THAN */;\r\n        case 'GREATER_THAN_OR_EQUAL':\r\n            return \">=\" /* Operator.GREATER_THAN_OR_EQUAL */;\r\n        case 'LESS_THAN':\r\n            return \"<\" /* Operator.LESS_THAN */;\r\n        case 'LESS_THAN_OR_EQUAL':\r\n            return \"<=\" /* Operator.LESS_THAN_OR_EQUAL */;\r\n        case 'ARRAY_CONTAINS':\r\n            return \"array-contains\" /* Operator.ARRAY_CONTAINS */;\r\n        case 'IN':\r\n            return \"in\" /* Operator.IN */;\r\n        case 'NOT_IN':\r\n            return \"not-in\" /* Operator.NOT_IN */;\r\n        case 'ARRAY_CONTAINS_ANY':\r\n            return \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\r\n        case 'OPERATOR_UNSPECIFIED':\r\n            return fail();\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction fromCompositeOperatorName(op) {\r\n    switch (op) {\r\n        case 'AND':\r\n            return \"and\" /* CompositeOperator.AND */;\r\n        case 'OR':\r\n            return \"or\" /* CompositeOperator.OR */;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toFieldPathReference(path) {\r\n    return { fieldPath: path.canonicalString() };\r\n}\r\nfunction fromFieldPathReference(fieldReference) {\r\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\r\n}\r\n// visible for testing\r\nfunction toPropertyOrder(orderBy) {\r\n    return {\r\n        field: toFieldPathReference(orderBy.field),\r\n        direction: toDirection(orderBy.dir)\r\n    };\r\n}\r\nfunction fromPropertyOrder(orderBy) {\r\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\r\n}\r\n// visible for testing\r\nfunction toFilter(filter) {\r\n    if (filter instanceof FieldFilter) {\r\n        return toUnaryOrFieldFilter(filter);\r\n    }\r\n    else if (filter instanceof CompositeFilter) {\r\n        return toCompositeFilter(filter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toCompositeFilter(filter) {\r\n    const protos = filter.getFilters().map(filter => toFilter(filter));\r\n    if (protos.length === 1) {\r\n        return protos[0];\r\n    }\r\n    return {\r\n        compositeFilter: {\r\n            op: toCompositeOperatorName(filter.op),\r\n            filters: protos\r\n        }\r\n    };\r\n}\r\nfunction toUnaryOrFieldFilter(filter) {\r\n    if (filter.op === \"==\" /* Operator.EQUAL */) {\r\n        if (isNanValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NAN'\r\n                }\r\n            };\r\n        }\r\n        else if (isNullValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NULL'\r\n                }\r\n            };\r\n        }\r\n    }\r\n    else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */) {\r\n        if (isNanValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NOT_NAN'\r\n                }\r\n            };\r\n        }\r\n        else if (isNullValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NOT_NULL'\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return {\r\n        fieldFilter: {\r\n            field: toFieldPathReference(filter.field),\r\n            op: toOperatorName(filter.op),\r\n            value: filter.value\r\n        }\r\n    };\r\n}\r\nfunction fromUnaryFilter(filter) {\r\n    switch (filter.unaryFilter.op) {\r\n        case 'IS_NAN':\r\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(nanField, \"==\" /* Operator.EQUAL */, {\r\n                doubleValue: NaN\r\n            });\r\n        case 'IS_NULL':\r\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(nullField, \"==\" /* Operator.EQUAL */, {\r\n                nullValue: 'NULL_VALUE'\r\n            });\r\n        case 'IS_NOT_NAN':\r\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(notNanField, \"!=\" /* Operator.NOT_EQUAL */, {\r\n                doubleValue: NaN\r\n            });\r\n        case 'IS_NOT_NULL':\r\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(notNullField, \"!=\" /* Operator.NOT_EQUAL */, {\r\n                nullValue: 'NULL_VALUE'\r\n            });\r\n        case 'OPERATOR_UNSPECIFIED':\r\n            return fail();\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction fromFieldFilter(filter) {\r\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\r\n}\r\nfunction fromCompositeFilter(filter) {\r\n    return CompositeFilter.create(filter.compositeFilter.filters.map(filter => fromFilter(filter)), fromCompositeOperatorName(filter.compositeFilter.op));\r\n}\r\nfunction toDocumentMask(fieldMask) {\r\n    const canonicalFields = [];\r\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\r\n    return {\r\n        fieldPaths: canonicalFields\r\n    };\r\n}\r\nfunction fromDocumentMask(proto) {\r\n    const paths = proto.fieldPaths || [];\r\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\r\n}\r\nfunction isValidResourceName(path) {\r\n    // Resource names have at least 4 components (project ID, database ID)\r\n    return (path.length >= 4 &&\r\n        path.get(0) === 'projects' &&\r\n        path.get(2) === 'databases');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable set of metadata that the local store tracks for each target.\r\n */\r\nclass TargetData {\r\n    constructor(\r\n    /** The target being listened to. */\r\n    target, \r\n    /**\r\n     * The target ID to which the target corresponds; Assigned by the\r\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\r\n     */\r\n    targetId, \r\n    /** The purpose of the target. */\r\n    purpose, \r\n    /**\r\n     * The sequence number of the last transaction during which this target data\r\n     * was modified.\r\n     */\r\n    sequenceNumber, \r\n    /** The latest snapshot version seen for this target. */\r\n    snapshotVersion = SnapshotVersion.min(), \r\n    /**\r\n     * The maximum snapshot version at which the associated view\r\n     * contained no limbo documents.\r\n     */\r\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a target to be\r\n     * resumed after disconnecting without retransmitting all the data that\r\n     * matches the target. The resume token essentially identifies a point in\r\n     * time from which the server should resume sending results.\r\n     */\r\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \r\n    /**\r\n     * The number of documents that last matched the query at the resume token or\r\n     * read time. Documents are counted only when making a listen request with\r\n     * resume token or read time, otherwise, keep it null.\r\n     */\r\n    expectedCount = null) {\r\n        this.target = target;\r\n        this.targetId = targetId;\r\n        this.purpose = purpose;\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.snapshotVersion = snapshotVersion;\r\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\r\n        this.resumeToken = resumeToken;\r\n        this.expectedCount = expectedCount;\r\n    }\r\n    /** Creates a new target data instance with an updated sequence number. */\r\n    withSequenceNumber(sequenceNumber) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated resume token and\r\n     * snapshot version.\r\n     */\r\n    withResumeToken(resumeToken, snapshotVersion) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken, \r\n        /* expectedCount= */ null);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated expected count.\r\n     */\r\n    withExpectedCount(expectedCount) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, expectedCount);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated last limbo free\r\n     * snapshot version number.\r\n     */\r\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Serializer for values stored in the LocalStore. */\r\nclass LocalSerializer {\r\n    constructor(remoteSerializer) {\r\n        this.remoteSerializer = remoteSerializer;\r\n    }\r\n}\r\n/** Decodes a remote document from storage locally to a Document. */\r\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\r\n    let doc;\r\n    if (remoteDoc.document) {\r\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\r\n    }\r\n    else if (remoteDoc.noDocument) {\r\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\r\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\r\n        doc = MutableDocument.newNoDocument(key, version);\r\n        if (remoteDoc.hasCommittedMutations) {\r\n            doc.setHasCommittedMutations();\r\n        }\r\n    }\r\n    else if (remoteDoc.unknownDocument) {\r\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\r\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\r\n        doc = MutableDocument.newUnknownDocument(key, version);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    if (remoteDoc.readTime) {\r\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\r\n    }\r\n    return doc;\r\n}\r\n/** Encodes a document for storage locally. */\r\nfunction toDbRemoteDocument(localSerializer, document) {\r\n    const key = document.key;\r\n    const remoteDoc = {\r\n        prefixPath: key.getCollectionPath().popLast().toArray(),\r\n        collectionGroup: key.collectionGroup,\r\n        documentId: key.path.lastSegment(),\r\n        readTime: toDbTimestampKey(document.readTime),\r\n        hasCommittedMutations: document.hasCommittedMutations\r\n    };\r\n    if (document.isFoundDocument()) {\r\n        remoteDoc.document = toDocument(localSerializer.remoteSerializer, document);\r\n    }\r\n    else if (document.isNoDocument()) {\r\n        remoteDoc.noDocument = {\r\n            path: key.path.toArray(),\r\n            readTime: toDbTimestamp(document.version)\r\n        };\r\n    }\r\n    else if (document.isUnknownDocument()) {\r\n        remoteDoc.unknownDocument = {\r\n            path: key.path.toArray(),\r\n            version: toDbTimestamp(document.version)\r\n        };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    return remoteDoc;\r\n}\r\nfunction toDbTimestampKey(snapshotVersion) {\r\n    const timestamp = snapshotVersion.toTimestamp();\r\n    return [timestamp.seconds, timestamp.nanoseconds];\r\n}\r\nfunction fromDbTimestampKey(dbTimestampKey) {\r\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\r\n    return SnapshotVersion.fromTimestamp(timestamp);\r\n}\r\nfunction toDbTimestamp(snapshotVersion) {\r\n    const timestamp = snapshotVersion.toTimestamp();\r\n    return { seconds: timestamp.seconds, nanoseconds: timestamp.nanoseconds };\r\n}\r\nfunction fromDbTimestamp(dbTimestamp) {\r\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\r\n    return SnapshotVersion.fromTimestamp(timestamp);\r\n}\r\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\r\nfunction toDbMutationBatch(localSerializer, userId, batch) {\r\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\r\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\r\n    return {\r\n        userId,\r\n        batchId: batch.batchId,\r\n        localWriteTimeMs: batch.localWriteTime.toMillis(),\r\n        baseMutations: serializedBaseMutations,\r\n        mutations: serializedMutations\r\n    };\r\n}\r\n/** Decodes a DbMutationBatch into a MutationBatch */\r\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\r\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\r\n    // Squash old transform mutations into existing patch or set mutations.\r\n    // The replacement of representing `transforms` with `update_transforms`\r\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\r\n    // to be updated to `update_transforms`.\r\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\r\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\r\n        const currentMutation = dbBatch.mutations[i];\r\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\r\n            dbBatch.mutations[i + 1].transform !== undefined;\r\n        if (hasTransform) {\r\n            const transformMutation = dbBatch.mutations[i + 1];\r\n            currentMutation.updateTransforms =\r\n                transformMutation.transform.fieldTransforms;\r\n            dbBatch.mutations.splice(i + 1, 1);\r\n            ++i;\r\n        }\r\n    }\r\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\r\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\r\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\r\n}\r\n/** Decodes a DbTarget into TargetData */\r\nfunction fromDbTarget(dbTarget) {\r\n    const version = fromDbTimestamp(dbTarget.readTime);\r\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\r\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\r\n        : SnapshotVersion.min();\r\n    let target;\r\n    if (isDocumentQuery(dbTarget.query)) {\r\n        target = fromDocumentsTarget(dbTarget.query);\r\n    }\r\n    else {\r\n        target = fromQueryTarget(dbTarget.query);\r\n    }\r\n    return new TargetData(target, dbTarget.targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\r\n}\r\n/** Encodes TargetData into a DbTarget for storage locally. */\r\nfunction toDbTarget(localSerializer, targetData) {\r\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\r\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\r\n    let queryProto;\r\n    if (targetIsDocumentTarget(targetData.target)) {\r\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\r\n    }\r\n    else {\r\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target).queryTarget;\r\n    }\r\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\r\n    // convert it to a base64 string for storage.\r\n    const resumeToken = targetData.resumeToken.toBase64();\r\n    // lastListenSequenceNumber is always 0 until we do real GC.\r\n    return {\r\n        targetId: targetData.targetId,\r\n        canonicalId: canonifyTarget(targetData.target),\r\n        readTime: dbTimestamp,\r\n        resumeToken,\r\n        lastListenSequenceNumber: targetData.sequenceNumber,\r\n        lastLimboFreeSnapshotVersion: dbLastLimboFreeTimestamp,\r\n        query: queryProto\r\n    };\r\n}\r\n/**\r\n * A helper function for figuring out what kind of query has been stored.\r\n */\r\nfunction isDocumentQuery(dbQuery) {\r\n    return dbQuery.documents !== undefined;\r\n}\r\n/** Encodes a DbBundle to a BundleMetadata object. */\r\nfunction fromDbBundle(dbBundle) {\r\n    return {\r\n        id: dbBundle.bundleId,\r\n        createTime: fromDbTimestamp(dbBundle.createTime),\r\n        version: dbBundle.version\r\n    };\r\n}\r\n/** Encodes a BundleMetadata to a DbBundle. */\r\nfunction toDbBundle(metadata) {\r\n    return {\r\n        bundleId: metadata.id,\r\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\r\n        version: metadata.version\r\n    };\r\n}\r\n/** Encodes a DbNamedQuery to a NamedQuery. */\r\nfunction fromDbNamedQuery(dbNamedQuery) {\r\n    return {\r\n        name: dbNamedQuery.name,\r\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\r\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\r\n    };\r\n}\r\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\r\nfunction toDbNamedQuery(query) {\r\n    return {\r\n        name: query.name,\r\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\r\n        bundledQuery: query.bundledQuery\r\n    };\r\n}\r\n/**\r\n * Encodes a `BundledQuery` from bundle proto to a Query object.\r\n *\r\n * This reconstructs the original query used to build the bundle being loaded,\r\n * including features exists only in SDKs (for example: limit-to-last).\r\n */\r\nfunction fromBundledQuery(bundledQuery) {\r\n    const query = convertQueryTargetToQuery({\r\n        parent: bundledQuery.parent,\r\n        structuredQuery: bundledQuery.structuredQuery\r\n    });\r\n    if (bundledQuery.limitType === 'LAST') {\r\n        return queryWithLimit(query, query.limit, \"L\" /* LimitType.Last */);\r\n    }\r\n    return query;\r\n}\r\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\r\nfunction fromProtoNamedQuery(namedQuery) {\r\n    return {\r\n        name: namedQuery.name,\r\n        query: fromBundledQuery(namedQuery.bundledQuery),\r\n        readTime: fromVersion(namedQuery.readTime)\r\n    };\r\n}\r\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\r\nfunction fromBundleMetadata(metadata) {\r\n    return {\r\n        id: metadata.id,\r\n        version: metadata.version,\r\n        createTime: fromVersion(metadata.createTime)\r\n    };\r\n}\r\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\r\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\r\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\r\n}\r\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\r\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\r\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\r\n    return {\r\n        userId,\r\n        collectionPath,\r\n        documentId,\r\n        collectionGroup: overlay.mutation.key.getCollectionGroup(),\r\n        largestBatchId: overlay.largestBatchId,\r\n        overlayMutation: toMutation(localSerializer.remoteSerializer, overlay.mutation)\r\n    };\r\n}\r\n/**\r\n * Returns the DbDocumentOverlayKey corresponding to the given user and\r\n * document key.\r\n */\r\nfunction toDbDocumentOverlayKey(userId, docKey) {\r\n    const docId = docKey.path.lastSegment();\r\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\r\n    return [userId, collectionPath, docId];\r\n}\r\nfunction toDbIndexConfiguration(index) {\r\n    return {\r\n        indexId: index.indexId,\r\n        collectionGroup: index.collectionGroup,\r\n        fields: index.fields.map(s => [s.fieldPath.canonicalString(), s.kind])\r\n    };\r\n}\r\nfunction fromDbIndexConfiguration(index, state) {\r\n    const decodedState = state\r\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\r\n        : IndexState.empty();\r\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\r\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\r\n}\r\nfunction toDbIndexState(indexId, uid, sequenceNumber, offset) {\r\n    return {\r\n        indexId,\r\n        uid,\r\n        sequenceNumber,\r\n        readTime: toDbTimestamp(offset.readTime),\r\n        documentKey: encodeResourcePath(offset.documentKey.path),\r\n        largestBatchId: offset.largestBatchId\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbBundleCache {\r\n    getBundleMetadata(transaction, bundleId) {\r\n        return bundlesStore(transaction)\r\n            .get(bundleId)\r\n            .next(bundle => {\r\n            if (bundle) {\r\n                return fromDbBundle(bundle);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n    saveBundleMetadata(transaction, bundleMetadata) {\r\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\r\n    }\r\n    getNamedQuery(transaction, queryName) {\r\n        return namedQueriesStore(transaction)\r\n            .get(queryName)\r\n            .next(query => {\r\n            if (query) {\r\n                return fromDbNamedQuery(query);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n    saveNamedQuery(transaction, query) {\r\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the bundles object store.\r\n */\r\nfunction bundlesStore(txn) {\r\n    return getStore(txn, DbBundleStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\r\n */\r\nfunction namedQueriesStore(txn) {\r\n    return getStore(txn, DbNamedQueryStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Implementation of DocumentOverlayCache using IndexedDb.\r\n */\r\nclass IndexedDbDocumentOverlayCache {\r\n    /**\r\n     * @param serializer - The document serializer.\r\n     * @param userId - The userId for which we are accessing overlays.\r\n     */\r\n    constructor(serializer, userId) {\r\n        this.serializer = serializer;\r\n        this.userId = userId;\r\n    }\r\n    static forUser(serializer, user) {\r\n        const userId = user.uid || '';\r\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\r\n    }\r\n    getOverlay(transaction, key) {\r\n        return documentOverlayStore(transaction)\r\n            .get(toDbDocumentOverlayKey(this.userId, key))\r\n            .next(dbOverlay => {\r\n            if (dbOverlay) {\r\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    getOverlays(transaction, keys) {\r\n        const result = newOverlayMap();\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            return this.getOverlay(transaction, key).next(overlay => {\r\n                if (overlay !== null) {\r\n                    result.set(key, overlay);\r\n                }\r\n            });\r\n        }).next(() => result);\r\n    }\r\n    saveOverlays(transaction, largestBatchId, overlays) {\r\n        const promises = [];\r\n        overlays.forEach((_, mutation) => {\r\n            const overlay = new Overlay(largestBatchId, mutation);\r\n            promises.push(this.saveOverlay(transaction, overlay));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\r\n        const collectionPaths = new Set();\r\n        // Get the set of unique collection paths.\r\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\r\n        const promises = [];\r\n        collectionPaths.forEach(collectionPath => {\r\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \r\n            /*lowerOpen=*/ false, \r\n            /*upperOpen=*/ true);\r\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlayCollectionPathOverlayIndex, range));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\r\n        const result = newOverlayMap();\r\n        const collectionPath = encodeResourcePath(collection);\r\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\r\n        // is not inclusive.\r\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \r\n        /*lowerOpen=*/ true);\r\n        return documentOverlayStore(transaction)\r\n            .loadAll(DbDocumentOverlayCollectionPathOverlayIndex, range)\r\n            .next(dbOverlays => {\r\n            for (const dbOverlay of dbOverlays) {\r\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n                result.set(overlay.getKey(), overlay);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\r\n        const result = newOverlayMap();\r\n        let currentBatchId = undefined;\r\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\r\n        // is not inclusive.\r\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \r\n        /*lowerOpen=*/ true);\r\n        return documentOverlayStore(transaction)\r\n            .iterate({\r\n            index: DbDocumentOverlayCollectionGroupOverlayIndex,\r\n            range\r\n        }, (_, dbOverlay, control) => {\r\n            // We do not want to return partial batch overlays, even if the size\r\n            // of the result set exceeds the given `count` argument. Therefore, we\r\n            // continue to aggregate results even after the result size exceeds\r\n            // `count` if there are more overlays from the `currentBatchId`.\r\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n            if (result.size() < count ||\r\n                overlay.largestBatchId === currentBatchId) {\r\n                result.set(overlay.getKey(), overlay);\r\n                currentBatchId = overlay.largestBatchId;\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => result);\r\n    }\r\n    saveOverlay(transaction, overlay) {\r\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the document overlay object store.\r\n */\r\nfunction documentOverlayStore(txn) {\r\n    return getStore(txn, DbDocumentOverlayStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Note: This code is copied from the backend. Code that is not used by\r\n// Firestore was removed.\r\nconst INDEX_TYPE_NULL = 5;\r\nconst INDEX_TYPE_BOOLEAN = 10;\r\nconst INDEX_TYPE_NAN = 13;\r\nconst INDEX_TYPE_NUMBER = 15;\r\nconst INDEX_TYPE_TIMESTAMP = 20;\r\nconst INDEX_TYPE_STRING = 25;\r\nconst INDEX_TYPE_BLOB = 30;\r\nconst INDEX_TYPE_REFERENCE = 37;\r\nconst INDEX_TYPE_GEOPOINT = 45;\r\nconst INDEX_TYPE_ARRAY = 50;\r\nconst INDEX_TYPE_MAP = 55;\r\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\r\n// A terminator that indicates that a truncatable value was not truncated.\r\n// This must be smaller than all other type labels.\r\nconst NOT_TRUNCATED = 2;\r\n/** Firestore index value writer.  */\r\nclass FirestoreIndexValueWriter {\r\n    constructor() { }\r\n    // The write methods below short-circuit writing terminators for values\r\n    // containing a (terminating) truncated value.\r\n    //\r\n    // As an example, consider the resulting encoding for:\r\n    //\r\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\r\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\r\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\r\n    /** Writes an index value.  */\r\n    writeIndexValue(value, encoder) {\r\n        this.writeIndexValueAux(value, encoder);\r\n        // Write separator to split index values\r\n        // (see go/firestore-storage-format#encodings).\r\n        encoder.writeInfinity();\r\n    }\r\n    writeIndexValueAux(indexValue, encoder) {\r\n        if ('nullValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\r\n        }\r\n        else if ('booleanValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\r\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\r\n        }\r\n        else if ('integerValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\r\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\r\n        }\r\n        else if ('doubleValue' in indexValue) {\r\n            const n = normalizeNumber(indexValue.doubleValue);\r\n            if (isNaN(n)) {\r\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\r\n            }\r\n            else {\r\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\r\n                if (isNegativeZero(n)) {\r\n                    // -0.0, 0 and 0.0 are all considered the same\r\n                    encoder.writeNumber(0.0);\r\n                }\r\n                else {\r\n                    encoder.writeNumber(n);\r\n                }\r\n            }\r\n        }\r\n        else if ('timestampValue' in indexValue) {\r\n            let timestamp = indexValue.timestampValue;\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\r\n            if (typeof timestamp === 'string') {\r\n                timestamp = normalizeTimestamp(timestamp);\r\n            }\r\n            encoder.writeString(`${timestamp.seconds || ''}`);\r\n            encoder.writeNumber(timestamp.nanos || 0);\r\n        }\r\n        else if ('stringValue' in indexValue) {\r\n            this.writeIndexString(indexValue.stringValue, encoder);\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else if ('bytesValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\r\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else if ('referenceValue' in indexValue) {\r\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\r\n        }\r\n        else if ('geoPointValue' in indexValue) {\r\n            const geoPoint = indexValue.geoPointValue;\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\r\n            encoder.writeNumber(geoPoint.latitude || 0);\r\n            encoder.writeNumber(geoPoint.longitude || 0);\r\n        }\r\n        else if ('mapValue' in indexValue) {\r\n            if (isMaxValue(indexValue)) {\r\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\r\n            }\r\n            else {\r\n                this.writeIndexMap(indexValue.mapValue, encoder);\r\n                this.writeTruncationMarker(encoder);\r\n            }\r\n        }\r\n        else if ('arrayValue' in indexValue) {\r\n            this.writeIndexArray(indexValue.arrayValue, encoder);\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else {\r\n            fail();\r\n        }\r\n    }\r\n    writeIndexString(stringIndexValue, encoder) {\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\r\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\r\n    }\r\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\r\n        encoder.writeString(stringIndexValue);\r\n    }\r\n    writeIndexMap(mapIndexValue, encoder) {\r\n        const map = mapIndexValue.fields || {};\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\r\n        for (const key of Object.keys(map)) {\r\n            this.writeIndexString(key, encoder);\r\n            this.writeIndexValueAux(map[key], encoder);\r\n        }\r\n    }\r\n    writeIndexArray(arrayIndexValue, encoder) {\r\n        const values = arrayIndexValue.values || [];\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\r\n        for (const element of values) {\r\n            this.writeIndexValueAux(element, encoder);\r\n        }\r\n    }\r\n    writeIndexEntityRef(referenceValue, encoder) {\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\r\n        const path = DocumentKey.fromName(referenceValue).path;\r\n        path.forEach(segment => {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\r\n            this.writeUnlabeledIndexString(segment, encoder);\r\n        });\r\n    }\r\n    writeValueTypeLabel(encoder, typeOrder) {\r\n        encoder.writeNumber(typeOrder);\r\n    }\r\n    writeTruncationMarker(encoder) {\r\n        // While the SDK does not implement truncation, the truncation marker is\r\n        // used to terminate all variable length values (which are strings, bytes,\r\n        // references, arrays and maps).\r\n        encoder.writeNumber(NOT_TRUNCATED);\r\n    }\r\n}\r\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law | agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** These constants are taken from the backend. */\r\nconst MIN_SURROGATE = '\\uD800';\r\nconst MAX_SURROGATE = '\\uDBFF';\r\nconst ESCAPE1 = 0x00;\r\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\r\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\r\nconst ESCAPE2 = 0xff;\r\nconst INFINITY = 0xff; // Combined with ESCAPE2\r\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\r\nconst LONG_SIZE = 64;\r\nconst BYTE_SIZE = 8;\r\n/**\r\n * The default size of the buffer. This is arbitrary, but likely larger than\r\n * most index values so that less copies of the underlying buffer will be made.\r\n * For large values, a single copy will made to double the buffer length.\r\n */\r\nconst DEFAULT_BUFFER_SIZE = 1024;\r\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\r\nfunction doubleToLongBits(value) {\r\n    const dv = new DataView(new ArrayBuffer(8));\r\n    dv.setFloat64(0, value, /* littleEndian= */ false);\r\n    return new Uint8Array(dv.buffer);\r\n}\r\n/**\r\n * Counts the number of zeros in a byte.\r\n *\r\n * Visible for testing.\r\n */\r\nfunction numberOfLeadingZerosInByte(x) {\r\n    if (x === 0) {\r\n        return 8;\r\n    }\r\n    let zeros = 0;\r\n    if (x >> 4 === 0) {\r\n        // Test if the first four bits are zero.\r\n        zeros += 4;\r\n        x = x << 4;\r\n    }\r\n    if (x >> 6 === 0) {\r\n        // Test if the first two (or next two) bits are zero.\r\n        zeros += 2;\r\n        x = x << 2;\r\n    }\r\n    if (x >> 7 === 0) {\r\n        // Test if the remaining bit is zero.\r\n        zeros += 1;\r\n    }\r\n    return zeros;\r\n}\r\n/** Counts the number of leading zeros in the given byte array. */\r\nfunction numberOfLeadingZeros(bytes) {\r\n    let leadingZeros = 0;\r\n    for (let i = 0; i < 8; ++i) {\r\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\r\n        leadingZeros += zeros;\r\n        if (zeros !== 8) {\r\n            break;\r\n        }\r\n    }\r\n    return leadingZeros;\r\n}\r\n/**\r\n * Returns the number of bytes required to store \"value\". Leading zero bytes\r\n * are skipped.\r\n */\r\nfunction unsignedNumLength(value) {\r\n    // This is just the number of bytes for the unsigned representation of the number.\r\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\r\n    return Math.ceil(numBits / BYTE_SIZE);\r\n}\r\n/**\r\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\r\n * behavior defined by the backend.\r\n *\r\n * The code is ported from its Java counterpart.\r\n */\r\nclass OrderedCodeWriter {\r\n    constructor() {\r\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\r\n        this.position = 0;\r\n    }\r\n    writeBytesAscending(value) {\r\n        const it = value[Symbol.iterator]();\r\n        let byte = it.next();\r\n        while (!byte.done) {\r\n            this.writeByteAscending(byte.value);\r\n            byte = it.next();\r\n        }\r\n        this.writeSeparatorAscending();\r\n    }\r\n    writeBytesDescending(value) {\r\n        const it = value[Symbol.iterator]();\r\n        let byte = it.next();\r\n        while (!byte.done) {\r\n            this.writeByteDescending(byte.value);\r\n            byte = it.next();\r\n        }\r\n        this.writeSeparatorDescending();\r\n    }\r\n    /** Writes utf8 bytes into this byte sequence, ascending. */\r\n    writeUtf8Ascending(sequence) {\r\n        for (const c of sequence) {\r\n            const charCode = c.charCodeAt(0);\r\n            if (charCode < 0x80) {\r\n                this.writeByteAscending(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\r\n                this.writeByteAscending(0x80 | (0x3f & charCode));\r\n            }\r\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\r\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\r\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\r\n                this.writeByteAscending(0x80 | (0x3f & charCode));\r\n            }\r\n            else {\r\n                const codePoint = c.codePointAt(0);\r\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\r\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\r\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\r\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\r\n            }\r\n        }\r\n        this.writeSeparatorAscending();\r\n    }\r\n    /** Writes utf8 bytes into this byte sequence, descending */\r\n    writeUtf8Descending(sequence) {\r\n        for (const c of sequence) {\r\n            const charCode = c.charCodeAt(0);\r\n            if (charCode < 0x80) {\r\n                this.writeByteDescending(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\r\n                this.writeByteDescending(0x80 | (0x3f & charCode));\r\n            }\r\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\r\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\r\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\r\n                this.writeByteDescending(0x80 | (0x3f & charCode));\r\n            }\r\n            else {\r\n                const codePoint = c.codePointAt(0);\r\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\r\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\r\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\r\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\r\n            }\r\n        }\r\n        this.writeSeparatorDescending();\r\n    }\r\n    writeNumberAscending(val) {\r\n        // Values are encoded with a single byte length prefix, followed by the\r\n        // actual value in big-endian format with leading 0 bytes dropped.\r\n        const value = this.toOrderedBits(val);\r\n        const len = unsignedNumLength(value);\r\n        this.ensureAvailable(1 + len);\r\n        this.buffer[this.position++] = len & 0xff; // Write the length\r\n        for (let i = value.length - len; i < value.length; ++i) {\r\n            this.buffer[this.position++] = value[i] & 0xff;\r\n        }\r\n    }\r\n    writeNumberDescending(val) {\r\n        // Values are encoded with a single byte length prefix, followed by the\r\n        // inverted value in big-endian format with leading 0 bytes dropped.\r\n        const value = this.toOrderedBits(val);\r\n        const len = unsignedNumLength(value);\r\n        this.ensureAvailable(1 + len);\r\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\r\n        for (let i = value.length - len; i < value.length; ++i) {\r\n            this.buffer[this.position++] = ~(value[i] & 0xff);\r\n        }\r\n    }\r\n    /**\r\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\r\n     * sequences written in ascending order.\r\n     */\r\n    writeInfinityAscending() {\r\n        this.writeEscapedByteAscending(ESCAPE2);\r\n        this.writeEscapedByteAscending(INFINITY);\r\n    }\r\n    /**\r\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\r\n     * sequences written in descending order.\r\n     */\r\n    writeInfinityDescending() {\r\n        this.writeEscapedByteDescending(ESCAPE2);\r\n        this.writeEscapedByteDescending(INFINITY);\r\n    }\r\n    /**\r\n     * Resets the buffer such that it is the same as when it was newly\r\n     * constructed.\r\n     */\r\n    reset() {\r\n        this.position = 0;\r\n    }\r\n    seed(encodedBytes) {\r\n        this.ensureAvailable(encodedBytes.length);\r\n        this.buffer.set(encodedBytes, this.position);\r\n        this.position += encodedBytes.length;\r\n    }\r\n    /** Makes a copy of the encoded bytes in this buffer.  */\r\n    encodedBytes() {\r\n        return this.buffer.slice(0, this.position);\r\n    }\r\n    /**\r\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\r\n     * floating-point comparison results with the following exceptions:\r\n     *   -0.0 < 0.0\r\n     *   all non-NaN < NaN\r\n     *   NaN = NaN\r\n     */\r\n    toOrderedBits(val) {\r\n        const value = doubleToLongBits(val);\r\n        // Check if the first bit is set. We use a bit mask since value[0] is\r\n        // encoded as a number from 0 to 255.\r\n        const isNegative = (value[0] & 0x80) !== 0;\r\n        // Revert the two complement to get natural ordering\r\n        value[0] ^= isNegative ? 0xff : 0x80;\r\n        for (let i = 1; i < value.length; ++i) {\r\n            value[i] ^= isNegative ? 0xff : 0x00;\r\n        }\r\n        return value;\r\n    }\r\n    /** Writes a single byte ascending to the buffer. */\r\n    writeByteAscending(b) {\r\n        const masked = b & 0xff;\r\n        if (masked === ESCAPE1) {\r\n            this.writeEscapedByteAscending(ESCAPE1);\r\n            this.writeEscapedByteAscending(NULL_BYTE);\r\n        }\r\n        else if (masked === ESCAPE2) {\r\n            this.writeEscapedByteAscending(ESCAPE2);\r\n            this.writeEscapedByteAscending(FF_BYTE);\r\n        }\r\n        else {\r\n            this.writeEscapedByteAscending(masked);\r\n        }\r\n    }\r\n    /** Writes a single byte descending to the buffer.  */\r\n    writeByteDescending(b) {\r\n        const masked = b & 0xff;\r\n        if (masked === ESCAPE1) {\r\n            this.writeEscapedByteDescending(ESCAPE1);\r\n            this.writeEscapedByteDescending(NULL_BYTE);\r\n        }\r\n        else if (masked === ESCAPE2) {\r\n            this.writeEscapedByteDescending(ESCAPE2);\r\n            this.writeEscapedByteDescending(FF_BYTE);\r\n        }\r\n        else {\r\n            this.writeEscapedByteDescending(b);\r\n        }\r\n    }\r\n    writeSeparatorAscending() {\r\n        this.writeEscapedByteAscending(ESCAPE1);\r\n        this.writeEscapedByteAscending(SEPARATOR);\r\n    }\r\n    writeSeparatorDescending() {\r\n        this.writeEscapedByteDescending(ESCAPE1);\r\n        this.writeEscapedByteDescending(SEPARATOR);\r\n    }\r\n    writeEscapedByteAscending(b) {\r\n        this.ensureAvailable(1);\r\n        this.buffer[this.position++] = b;\r\n    }\r\n    writeEscapedByteDescending(b) {\r\n        this.ensureAvailable(1);\r\n        this.buffer[this.position++] = ~b;\r\n    }\r\n    ensureAvailable(bytes) {\r\n        const minCapacity = bytes + this.position;\r\n        if (minCapacity <= this.buffer.length) {\r\n            return;\r\n        }\r\n        // Try doubling.\r\n        let newLength = this.buffer.length * 2;\r\n        // Still not big enough? Just allocate the right size.\r\n        if (newLength < minCapacity) {\r\n            newLength = minCapacity;\r\n        }\r\n        // Create the new buffer.\r\n        const newBuffer = new Uint8Array(newLength);\r\n        newBuffer.set(this.buffer); // copy old data\r\n        this.buffer = newBuffer;\r\n    }\r\n}\n\nclass AscendingIndexByteEncoder {\r\n    constructor(orderedCode) {\r\n        this.orderedCode = orderedCode;\r\n    }\r\n    writeBytes(value) {\r\n        this.orderedCode.writeBytesAscending(value);\r\n    }\r\n    writeString(value) {\r\n        this.orderedCode.writeUtf8Ascending(value);\r\n    }\r\n    writeNumber(value) {\r\n        this.orderedCode.writeNumberAscending(value);\r\n    }\r\n    writeInfinity() {\r\n        this.orderedCode.writeInfinityAscending();\r\n    }\r\n}\r\nclass DescendingIndexByteEncoder {\r\n    constructor(orderedCode) {\r\n        this.orderedCode = orderedCode;\r\n    }\r\n    writeBytes(value) {\r\n        this.orderedCode.writeBytesDescending(value);\r\n    }\r\n    writeString(value) {\r\n        this.orderedCode.writeUtf8Descending(value);\r\n    }\r\n    writeNumber(value) {\r\n        this.orderedCode.writeNumberDescending(value);\r\n    }\r\n    writeInfinity() {\r\n        this.orderedCode.writeInfinityDescending();\r\n    }\r\n}\r\n/**\r\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\r\n * actual encoding.\r\n */\r\nclass IndexByteEncoder {\r\n    constructor() {\r\n        this.orderedCode = new OrderedCodeWriter();\r\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\r\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\r\n    }\r\n    seed(encodedBytes) {\r\n        this.orderedCode.seed(encodedBytes);\r\n    }\r\n    forKind(kind) {\r\n        return kind === 0 /* IndexKind.ASCENDING */ ? this.ascending : this.descending;\r\n    }\r\n    encodedBytes() {\r\n        return this.orderedCode.encodedBytes();\r\n    }\r\n    reset() {\r\n        this.orderedCode.reset();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Represents an index entry saved by the SDK in persisted storage. */\r\nclass IndexEntry {\r\n    constructor(indexId, documentKey, arrayValue, directionalValue) {\r\n        this.indexId = indexId;\r\n        this.documentKey = documentKey;\r\n        this.arrayValue = arrayValue;\r\n        this.directionalValue = directionalValue;\r\n    }\r\n    /**\r\n     * Returns an IndexEntry entry that sorts immediately after the current\r\n     * directional value.\r\n     */\r\n    successor() {\r\n        const currentLength = this.directionalValue.length;\r\n        const newLength = currentLength === 0 || this.directionalValue[currentLength - 1] === 255\r\n            ? currentLength + 1\r\n            : currentLength;\r\n        const successor = new Uint8Array(newLength);\r\n        successor.set(this.directionalValue, 0);\r\n        if (newLength !== currentLength) {\r\n            successor.set([0], this.directionalValue.length);\r\n        }\r\n        else {\r\n            ++successor[successor.length - 1];\r\n        }\r\n        return new IndexEntry(this.indexId, this.documentKey, this.arrayValue, successor);\r\n    }\r\n}\r\nfunction indexEntryComparator(left, right) {\r\n    let cmp = left.indexId - right.indexId;\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = compareByteArrays(left.arrayValue, right.arrayValue);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = compareByteArrays(left.directionalValue, right.directionalValue);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return DocumentKey.comparator(left.documentKey, right.documentKey);\r\n}\r\nfunction compareByteArrays(left, right) {\r\n    for (let i = 0; i < left.length && i < right.length; ++i) {\r\n        const compare = left[i] - right[i];\r\n        if (compare !== 0) {\r\n            return compare;\r\n        }\r\n    }\r\n    return left.length - right.length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A light query planner for Firestore.\r\n *\r\n * This class matches a `FieldIndex` against a Firestore Query `Target`. It\r\n * determines whether a given index can be used to serve the specified target.\r\n *\r\n * The following table showcases some possible index configurations:\r\n *\r\n * Query                                               | Index\r\n * -----------------------------------------------------------------------------\r\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC, b DESC\r\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC\r\n * where('a', '==', 'a').where('b', '==', 'b')         | b DESC\r\n * where('a', '>=', 'a').orderBy('a')                  | a ASC\r\n * where('a', '>=', 'a').orderBy('a', 'desc')          | a DESC\r\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC, b ASC\r\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC\r\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS, b ASCENDING\r\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS\r\n */\r\nclass TargetIndexMatcher {\r\n    constructor(target) {\r\n        // The inequality filters of the target (if it exists).\r\n        // Note: The sort on FieldFilters is not required. Using SortedSet here just to utilize the custom\r\n        // comparator.\r\n        this.inequalityFilters = new SortedSet((lhs, rhs) => FieldPath$1.comparator(lhs.field, rhs.field));\r\n        this.collectionId =\r\n            target.collectionGroup != null\r\n                ? target.collectionGroup\r\n                : target.path.lastSegment();\r\n        this.orderBys = target.orderBy;\r\n        this.equalityFilters = [];\r\n        for (const filter of target.filters) {\r\n            const fieldFilter = filter;\r\n            if (fieldFilter.isInequality()) {\r\n                this.inequalityFilters = this.inequalityFilters.add(fieldFilter);\r\n            }\r\n            else {\r\n                this.equalityFilters.push(fieldFilter);\r\n            }\r\n        }\r\n    }\r\n    get hasMultipleInequality() {\r\n        return this.inequalityFilters.size > 1;\r\n    }\r\n    /**\r\n     * Returns whether the index can be used to serve the TargetIndexMatcher's\r\n     * target.\r\n     *\r\n     * An index is considered capable of serving the target when:\r\n     * - The target uses all index segments for its filters and orderBy clauses.\r\n     *   The target can have additional filter and orderBy clauses, but not\r\n     *   fewer.\r\n     * - If an ArrayContains/ArrayContainsAnyfilter is used, the index must also\r\n     *   have a corresponding `CONTAINS` segment.\r\n     * - All directional index segments can be mapped to the target as a series of\r\n     *   equality filters, a single inequality filter and a series of orderBy\r\n     *   clauses.\r\n     * - The segments that represent the equality filters may appear out of order.\r\n     * - The optional segment for the inequality filter must appear after all\r\n     *   equality segments.\r\n     * - The segments that represent that orderBy clause of the target must appear\r\n     *   in order after all equality and inequality segments. Single orderBy\r\n     *   clauses cannot be skipped, but a continuous orderBy suffix may be\r\n     *   omitted.\r\n     */\r\n    servedByIndex(index) {\r\n        hardAssert(index.collectionGroup === this.collectionId);\r\n        if (this.hasMultipleInequality) {\r\n            // Only single inequality is supported for now.\r\n            // TODO(Add support for multiple inequality query): b/298441043\r\n            return false;\r\n        }\r\n        // If there is an array element, find a matching filter.\r\n        const arraySegment = fieldIndexGetArraySegment(index);\r\n        if (arraySegment !== undefined &&\r\n            !this.hasMatchingEqualityFilter(arraySegment)) {\r\n            return false;\r\n        }\r\n        const segments = fieldIndexGetDirectionalSegments(index);\r\n        let equalitySegments = new Set();\r\n        let segmentIndex = 0;\r\n        let orderBysIndex = 0;\r\n        // Process all equalities first. Equalities can appear out of order.\r\n        for (; segmentIndex < segments.length; ++segmentIndex) {\r\n            // We attempt to greedily match all segments to equality filters. If a\r\n            // filter matches an index segment, we can mark the segment as used.\r\n            if (this.hasMatchingEqualityFilter(segments[segmentIndex])) {\r\n                equalitySegments = equalitySegments.add(segments[segmentIndex].fieldPath.canonicalString());\r\n            }\r\n            else {\r\n                // If we cannot find a matching filter, we need to verify whether the\r\n                // remaining segments map to the target's inequality and its orderBy\r\n                // clauses.\r\n                break;\r\n            }\r\n        }\r\n        // If we already have processed all segments, all segments are used to serve\r\n        // the equality filters and we do not need to map any segments to the\r\n        // target's inequality and orderBy clauses.\r\n        if (segmentIndex === segments.length) {\r\n            return true;\r\n        }\r\n        if (this.inequalityFilters.size > 0) {\r\n            // Only a single inequality is currently supported. Get the only entry in the set.\r\n            const inequalityFilter = this.inequalityFilters.getIterator().getNext();\r\n            // If there is an inequality filter and the field was not in one of the\r\n            // equality filters above, the next segment must match both the filter\r\n            // and the first orderBy clause.\r\n            if (!equalitySegments.has(inequalityFilter.field.canonicalString())) {\r\n                const segment = segments[segmentIndex];\r\n                if (!this.matchesFilter(inequalityFilter, segment) ||\r\n                    !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\r\n                    return false;\r\n                }\r\n            }\r\n            ++segmentIndex;\r\n        }\r\n        // All remaining segments need to represent the prefix of the target's\r\n        // orderBy.\r\n        for (; segmentIndex < segments.length; ++segmentIndex) {\r\n            const segment = segments[segmentIndex];\r\n            if (orderBysIndex >= this.orderBys.length ||\r\n                !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns a full matched field index for this target. Currently multiple\r\n     * inequality query is not supported so function returns null.\r\n     */\r\n    buildTargetIndex() {\r\n        if (this.hasMultipleInequality) {\r\n            return null;\r\n        }\r\n        // We want to make sure only one segment created for one field. For example,\r\n        // in case like a == 3 and a > 2, Index {a ASCENDING} will only be created\r\n        // once.\r\n        let uniqueFields = new SortedSet(FieldPath$1.comparator);\r\n        const segments = [];\r\n        for (const filter of this.equalityFilters) {\r\n            if (filter.field.isKeyField()) {\r\n                continue;\r\n            }\r\n            const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\r\n                filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\r\n            if (isArrayOperator) {\r\n                segments.push(new IndexSegment(filter.field, 2 /* IndexKind.CONTAINS */));\r\n            }\r\n            else {\r\n                if (uniqueFields.has(filter.field)) {\r\n                    continue;\r\n                }\r\n                uniqueFields = uniqueFields.add(filter.field);\r\n                segments.push(new IndexSegment(filter.field, 0 /* IndexKind.ASCENDING */));\r\n            }\r\n        }\r\n        // Note: We do not explicitly check `this.inequalityFilter` but rather rely\r\n        // on the target defining an appropriate \"order by\" to ensure that the\r\n        // required index segment is added. The query engine would reject a query\r\n        // with an inequality filter that lacks the required order-by clause.\r\n        for (const orderBy of this.orderBys) {\r\n            // Stop adding more segments if we see a order-by on key. Typically this\r\n            // is the default implicit order-by which is covered in the index_entry\r\n            // table as a separate column. If it is not the default order-by, the\r\n            // generated index will be missing some segments optimized for order-bys,\r\n            // which is probably fine.\r\n            if (orderBy.field.isKeyField()) {\r\n                continue;\r\n            }\r\n            if (uniqueFields.has(orderBy.field)) {\r\n                continue;\r\n            }\r\n            uniqueFields = uniqueFields.add(orderBy.field);\r\n            segments.push(new IndexSegment(orderBy.field, orderBy.dir === \"asc\" /* Direction.ASCENDING */\r\n                ? 0 /* IndexKind.ASCENDING */\r\n                : 1 /* IndexKind.DESCENDING */));\r\n        }\r\n        return new FieldIndex(FieldIndex.UNKNOWN_ID, this.collectionId, segments, IndexState.empty());\r\n    }\r\n    hasMatchingEqualityFilter(segment) {\r\n        for (const filter of this.equalityFilters) {\r\n            if (this.matchesFilter(filter, segment)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    matchesFilter(filter, segment) {\r\n        if (filter === undefined || !filter.field.isEqual(segment.fieldPath)) {\r\n            return false;\r\n        }\r\n        const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\r\n            filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\r\n        return (segment.kind === 2 /* IndexKind.CONTAINS */) === isArrayOperator;\r\n    }\r\n    matchesOrderBy(orderBy, segment) {\r\n        if (!orderBy.field.isEqual(segment.fieldPath)) {\r\n            return false;\r\n        }\r\n        return ((segment.kind === 0 /* IndexKind.ASCENDING */ &&\r\n            orderBy.dir === \"asc\" /* Direction.ASCENDING */) ||\r\n            (segment.kind === 1 /* IndexKind.DESCENDING */ &&\r\n                orderBy.dir === \"desc\" /* Direction.DESCENDING */));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides utility functions that help with boolean logic transformations needed for handling\r\n * complex filters used in queries.\r\n */\r\n/**\r\n * The `in` filter is only a syntactic sugar over a disjunction of equalities. For instance: `a in\r\n * [1,2,3]` is in fact `a==1 || a==2 || a==3`. This method expands any `in` filter in the given\r\n * input into a disjunction of equality filters and returns the expanded filter.\r\n */\r\nfunction computeInExpansion(filter) {\r\n    var _a, _b;\r\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\r\n    if (filter instanceof FieldFilter) {\r\n        if (filter instanceof InFilter) {\r\n            const expandedFilters = ((_b = (_a = filter.value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map(value => FieldFilter.create(filter.field, \"==\" /* Operator.EQUAL */, value))) || [];\r\n            return CompositeFilter.create(expandedFilters, \"or\" /* CompositeOperator.OR */);\r\n        }\r\n        else {\r\n            // We have reached other kinds of field filters.\r\n            return filter;\r\n        }\r\n    }\r\n    // We have a composite filter.\r\n    const expandedFilters = filter.filters.map(subfilter => computeInExpansion(subfilter));\r\n    return CompositeFilter.create(expandedFilters, filter.op);\r\n}\r\n/**\r\n * Given a composite filter, returns the list of terms in its disjunctive normal form.\r\n *\r\n * <p>Each element in the return value is one term of the resulting DNF. For instance: For the\r\n * input: (A || B) && C, the DNF form is: (A && C) || (B && C), and the return value is a list\r\n * with two elements: a composite filter that performs (A && C), and a composite filter that\r\n * performs (B && C).\r\n *\r\n * @param filter the composite filter to calculate DNF transform for.\r\n * @return the terms in the DNF transform.\r\n */\r\nfunction getDnfTerms(filter) {\r\n    if (filter.getFilters().length === 0) {\r\n        return [];\r\n    }\r\n    const result = computeDistributedNormalForm(computeInExpansion(filter));\r\n    hardAssert(isDisjunctiveNormalForm(result));\r\n    if (isSingleFieldFilter(result) || isFlatConjunction(result)) {\r\n        return [result];\r\n    }\r\n    return result.getFilters();\r\n}\r\n/** Returns true if the given filter is a single field filter. e.g. (a == 10). */\r\nfunction isSingleFieldFilter(filter) {\r\n    return filter instanceof FieldFilter;\r\n}\r\n/**\r\n * Returns true if the given filter is the conjunction of one or more field filters. e.g. (a == 10\r\n * && b == 20)\r\n */\r\nfunction isFlatConjunction(filter) {\r\n    return (filter instanceof CompositeFilter &&\r\n        compositeFilterIsFlatConjunction(filter));\r\n}\r\n/**\r\n * Returns whether or not the given filter is in disjunctive normal form (DNF).\r\n *\r\n * <p>In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical\r\n * formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs.\r\n *\r\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Disjunctive_normal_form\r\n */\r\nfunction isDisjunctiveNormalForm(filter) {\r\n    return (isSingleFieldFilter(filter) ||\r\n        isFlatConjunction(filter) ||\r\n        isDisjunctionOfFieldFiltersAndFlatConjunctions(filter));\r\n}\r\n/**\r\n * Returns true if the given filter is the disjunction of one or more \"flat conjunctions\" and\r\n * field filters. e.g. (a == 10) || (b==20 && c==30)\r\n */\r\nfunction isDisjunctionOfFieldFiltersAndFlatConjunctions(filter) {\r\n    if (filter instanceof CompositeFilter) {\r\n        if (compositeFilterIsDisjunction(filter)) {\r\n            for (const subFilter of filter.getFilters()) {\r\n                if (!isSingleFieldFilter(subFilter) && !isFlatConjunction(subFilter)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction computeDistributedNormalForm(filter) {\r\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\r\n    if (filter instanceof FieldFilter) {\r\n        return filter;\r\n    }\r\n    if (filter.filters.length === 1) {\r\n        return computeDistributedNormalForm(filter.filters[0]);\r\n    }\r\n    // Compute DNF for each of the subfilters first\r\n    const result = filter.filters.map(subfilter => computeDistributedNormalForm(subfilter));\r\n    let newFilter = CompositeFilter.create(result, filter.op);\r\n    newFilter = applyAssociation(newFilter);\r\n    if (isDisjunctiveNormalForm(newFilter)) {\r\n        return newFilter;\r\n    }\r\n    hardAssert(newFilter instanceof CompositeFilter);\r\n    hardAssert(compositeFilterIsConjunction(newFilter));\r\n    hardAssert(newFilter.filters.length > 1);\r\n    return newFilter.filters.reduce((runningResult, filter) => applyDistribution(runningResult, filter));\r\n}\r\nfunction applyDistribution(lhs, rhs) {\r\n    hardAssert(lhs instanceof FieldFilter || lhs instanceof CompositeFilter);\r\n    hardAssert(rhs instanceof FieldFilter || rhs instanceof CompositeFilter);\r\n    let result;\r\n    if (lhs instanceof FieldFilter) {\r\n        if (rhs instanceof FieldFilter) {\r\n            // FieldFilter FieldFilter\r\n            result = applyDistributionFieldFilters(lhs, rhs);\r\n        }\r\n        else {\r\n            // FieldFilter CompositeFilter\r\n            result = applyDistributionFieldAndCompositeFilters(lhs, rhs);\r\n        }\r\n    }\r\n    else {\r\n        if (rhs instanceof FieldFilter) {\r\n            // CompositeFilter FieldFilter\r\n            result = applyDistributionFieldAndCompositeFilters(rhs, lhs);\r\n        }\r\n        else {\r\n            // CompositeFilter CompositeFilter\r\n            result = applyDistributionCompositeFilters(lhs, rhs);\r\n        }\r\n    }\r\n    return applyAssociation(result);\r\n}\r\nfunction applyDistributionFieldFilters(lhs, rhs) {\r\n    // Conjunction distribution for two field filters is the conjunction of them.\r\n    return CompositeFilter.create([lhs, rhs], \"and\" /* CompositeOperator.AND */);\r\n}\r\nfunction applyDistributionCompositeFilters(lhs, rhs) {\r\n    hardAssert(lhs.filters.length > 0 && rhs.filters.length > 0);\r\n    // There are four cases:\r\n    // (A & B) & (C & D) --> (A & B & C & D)\r\n    // (A & B) & (C | D) --> (A & B & C) | (A & B & D)\r\n    // (A | B) & (C & D) --> (C & D & A) | (C & D & B)\r\n    // (A | B) & (C | D) --> (A & C) | (A & D) | (B & C) | (B & D)\r\n    // Case 1 is a merge.\r\n    if (compositeFilterIsConjunction(lhs) && compositeFilterIsConjunction(rhs)) {\r\n        return compositeFilterWithAddedFilters(lhs, rhs.getFilters());\r\n    }\r\n    // Case 2,3,4 all have at least one side (lhs or rhs) that is a disjunction. In all three cases\r\n    // we should take each element of the disjunction and distribute it over the other side, and\r\n    // return the disjunction of the distribution results.\r\n    const disjunctionSide = compositeFilterIsDisjunction(lhs) ? lhs : rhs;\r\n    const otherSide = compositeFilterIsDisjunction(lhs) ? rhs : lhs;\r\n    const results = disjunctionSide.filters.map(subfilter => applyDistribution(subfilter, otherSide));\r\n    return CompositeFilter.create(results, \"or\" /* CompositeOperator.OR */);\r\n}\r\nfunction applyDistributionFieldAndCompositeFilters(fieldFilter, compositeFilter) {\r\n    // There are two cases:\r\n    // A & (B & C) --> (A & B & C)\r\n    // A & (B | C) --> (A & B) | (A & C)\r\n    if (compositeFilterIsConjunction(compositeFilter)) {\r\n        // Case 1\r\n        return compositeFilterWithAddedFilters(compositeFilter, fieldFilter.getFilters());\r\n    }\r\n    else {\r\n        // Case 2\r\n        const newFilters = compositeFilter.filters.map(subfilter => applyDistribution(fieldFilter, subfilter));\r\n        return CompositeFilter.create(newFilters, \"or\" /* CompositeOperator.OR */);\r\n    }\r\n}\r\n/**\r\n * Applies the associativity property to the given filter and returns the resulting filter.\r\n *\r\n * <ul>\r\n *   <li>A | (B | C) == (A | B) | C == (A | B | C)\r\n *   <li>A & (B & C) == (A & B) & C == (A & B & C)\r\n * </ul>\r\n *\r\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Associative_property#Propositional_logic\r\n */\r\nfunction applyAssociation(filter) {\r\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\r\n    if (filter instanceof FieldFilter) {\r\n        return filter;\r\n    }\r\n    const filters = filter.getFilters();\r\n    // If the composite filter only contains 1 filter, apply associativity to it.\r\n    if (filters.length === 1) {\r\n        return applyAssociation(filters[0]);\r\n    }\r\n    // Associativity applied to a flat composite filter results is itself.\r\n    if (compositeFilterIsFlat(filter)) {\r\n        return filter;\r\n    }\r\n    // First apply associativity to all subfilters. This will in turn recursively apply\r\n    // associativity to all nested composite filters and field filters.\r\n    const updatedFilters = filters.map(subfilter => applyAssociation(subfilter));\r\n    // For composite subfilters that perform the same kind of logical operation as `compositeFilter`\r\n    // take out their filters and add them to `compositeFilter`. For example:\r\n    // compositeFilter = (A | (B | C | D))\r\n    // compositeSubfilter = (B | C | D)\r\n    // Result: (A | B | C | D)\r\n    // Note that the `compositeSubfilter` has been eliminated, and its filters (B, C, D) have been\r\n    // added to the top-level \"compositeFilter\".\r\n    const newSubfilters = [];\r\n    updatedFilters.forEach(subfilter => {\r\n        if (subfilter instanceof FieldFilter) {\r\n            newSubfilters.push(subfilter);\r\n        }\r\n        else if (subfilter instanceof CompositeFilter) {\r\n            if (subfilter.op === filter.op) {\r\n                // compositeFilter: (A | (B | C))\r\n                // compositeSubfilter: (B | C)\r\n                // Result: (A | B | C)\r\n                newSubfilters.push(...subfilter.filters);\r\n            }\r\n            else {\r\n                // compositeFilter: (A | (B & C))\r\n                // compositeSubfilter: (B & C)\r\n                // Result: (A | (B & C))\r\n                newSubfilters.push(subfilter);\r\n            }\r\n        }\r\n    });\r\n    if (newSubfilters.length === 1) {\r\n        return newSubfilters[0];\r\n    }\r\n    return CompositeFilter.create(newSubfilters, filter.op);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory implementation of IndexManager.\r\n */\r\nclass MemoryIndexManager {\r\n    constructor() {\r\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\r\n    }\r\n    addToCollectionParentIndex(transaction, collectionPath) {\r\n        this.collectionParentIndex.add(collectionPath);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getCollectionParents(transaction, collectionId) {\r\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\r\n    }\r\n    addFieldIndex(transaction, index) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    deleteFieldIndex(transaction, index) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    deleteAllFieldIndexes(transaction) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    createTargetIndexes(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getDocumentsMatchingTarget(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    getIndexType(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(0 /* IndexType.NONE */);\r\n    }\r\n    getFieldIndexes(transaction, collectionGroup) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve([]);\r\n    }\r\n    getNextCollectionGroupToUpdate(transaction) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    getMinOffset(transaction, target) {\r\n        return PersistencePromise.resolve(IndexOffset.min());\r\n    }\r\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\r\n        return PersistencePromise.resolve(IndexOffset.min());\r\n    }\r\n    updateCollectionGroup(transaction, collectionGroup, offset) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateIndexEntries(transaction, documents) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n}\r\n/**\r\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\r\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\r\n * in indexeddb_schema.ts\r\n */\r\nclass MemoryCollectionParentIndex {\r\n    constructor() {\r\n        this.index = {};\r\n    }\r\n    // Returns false if the entry already existed.\r\n    add(collectionPath) {\r\n        const collectionId = collectionPath.lastSegment();\r\n        const parentPath = collectionPath.popLast();\r\n        const existingParents = this.index[collectionId] ||\r\n            new SortedSet(ResourcePath.comparator);\r\n        const added = !existingParents.has(parentPath);\r\n        this.index[collectionId] = existingParents.add(parentPath);\r\n        return added;\r\n    }\r\n    has(collectionPath) {\r\n        const collectionId = collectionPath.lastSegment();\r\n        const parentPath = collectionPath.popLast();\r\n        const existingParents = this.index[collectionId];\r\n        return existingParents && existingParents.has(parentPath);\r\n    }\r\n    getEntries(collectionId) {\r\n        const parentPaths = this.index[collectionId] ||\r\n            new SortedSet(ResourcePath.comparator);\r\n        return parentPaths.toArray();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$f = 'IndexedDbIndexManager';\r\nconst EMPTY_VALUE = new Uint8Array(0);\r\n/**\r\n * A persisted implementation of IndexManager.\r\n *\r\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\r\n * data as it supports multi-tab access.\r\n */\r\nclass IndexedDbIndexManager {\r\n    constructor(user, databaseId) {\r\n        this.databaseId = databaseId;\r\n        /**\r\n         * An in-memory copy of the index entries we've already written since the SDK\r\n         * launched. Used to avoid re-writing the same entry repeatedly.\r\n         *\r\n         * This is *NOT* a complete cache of what's in persistence and so can never be\r\n         * used to satisfy reads.\r\n         */\r\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\r\n        /**\r\n         * Maps from a target to its equivalent list of sub-targets. Each sub-target\r\n         * contains only one term from the target's disjunctive normal form (DNF).\r\n         */\r\n        this.targetToDnfSubTargets = new ObjectMap(t => canonifyTarget(t), (l, r) => targetEquals(l, r));\r\n        this.uid = user.uid || '';\r\n    }\r\n    /**\r\n     * Adds a new entry to the collection parent index.\r\n     *\r\n     * Repeated calls for the same collectionPath should be avoided within a\r\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\r\n     * has been committed.\r\n     */\r\n    addToCollectionParentIndex(transaction, collectionPath) {\r\n        if (!this.collectionParentsCache.has(collectionPath)) {\r\n            const collectionId = collectionPath.lastSegment();\r\n            const parentPath = collectionPath.popLast();\r\n            transaction.addOnCommittedListener(() => {\r\n                // Add the collection to the in memory cache only if the transaction was\r\n                // successfully committed.\r\n                this.collectionParentsCache.add(collectionPath);\r\n            });\r\n            const collectionParent = {\r\n                collectionId,\r\n                parent: encodeResourcePath(parentPath)\r\n            };\r\n            return collectionParentsStore(transaction).put(collectionParent);\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getCollectionParents(transaction, collectionId) {\r\n        const parentPaths = [];\r\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        return collectionParentsStore(transaction)\r\n            .loadAll(range)\r\n            .next(entries => {\r\n            for (const entry of entries) {\r\n                // This collectionId guard shouldn't be necessary (and isn't as long\r\n                // as we're running in a real browser), but there's a bug in\r\n                // indexeddbshim that breaks our range in our tests running in node:\r\n                // https://github.com/axemclion/IndexedDBShim/issues/334\r\n                if (entry.collectionId !== collectionId) {\r\n                    break;\r\n                }\r\n                parentPaths.push(decodeResourcePath(entry.parent));\r\n            }\r\n            return parentPaths;\r\n        });\r\n    }\r\n    addFieldIndex(transaction, index) {\r\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\r\n        // Safari & Firefox.\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const dbIndex = toDbIndexConfiguration(index);\r\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\r\n        const result = indexes.add(dbIndex);\r\n        if (index.indexState) {\r\n            const states = indexStateStore(transaction);\r\n            return result.next(indexId => {\r\n                states.put(toDbIndexState(indexId, this.uid, index.indexState.sequenceNumber, index.indexState.offset));\r\n            });\r\n        }\r\n        else {\r\n            return result.next();\r\n        }\r\n    }\r\n    deleteFieldIndex(transaction, index) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        const entries = indexEntriesStore(transaction);\r\n        return indexes\r\n            .delete(index.indexId)\r\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true)))\r\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true)));\r\n    }\r\n    deleteAllFieldIndexes(transaction) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const entries = indexEntriesStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return indexes\r\n            .deleteAll()\r\n            .next(() => entries.deleteAll())\r\n            .next(() => states.deleteAll());\r\n    }\r\n    createTargetIndexes(transaction, target) {\r\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\r\n            return this.getIndexType(transaction, subTarget).next(type => {\r\n                if (type === 0 /* IndexType.NONE */ || type === 1 /* IndexType.PARTIAL */) {\r\n                    const targetIndexMatcher = new TargetIndexMatcher(subTarget);\r\n                    const fieldIndex = targetIndexMatcher.buildTargetIndex();\r\n                    if (fieldIndex != null) {\r\n                        return this.addFieldIndex(transaction, fieldIndex);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getDocumentsMatchingTarget(transaction, target) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        let canServeTarget = true;\r\n        const indexes = new Map();\r\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\r\n            return this.getFieldIndex(transaction, subTarget).next(index => {\r\n                canServeTarget && (canServeTarget = !!index);\r\n                indexes.set(subTarget, index);\r\n            });\r\n        }).next(() => {\r\n            if (!canServeTarget) {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n            else {\r\n                let existingKeys = documentKeySet();\r\n                const result = [];\r\n                return PersistencePromise.forEach(indexes, (index, subTarget) => {\r\n                    logDebug(LOG_TAG$f, `Using index ${fieldIndexToString(index)} to execute ${canonifyTarget(target)}`);\r\n                    const arrayValues = targetGetArrayValues(subTarget, index);\r\n                    const notInValues = targetGetNotInValues(subTarget, index);\r\n                    const lowerBound = targetGetLowerBound(subTarget, index);\r\n                    const upperBound = targetGetUpperBound(subTarget, index);\r\n                    const lowerBoundEncoded = this.encodeBound(index, subTarget, lowerBound);\r\n                    const upperBoundEncoded = this.encodeBound(index, subTarget, upperBound);\r\n                    const notInEncoded = this.encodeValues(index, subTarget, notInValues);\r\n                    const indexRanges = this.generateIndexRanges(index.indexId, arrayValues, lowerBoundEncoded, lowerBound.inclusive, upperBoundEncoded, upperBound.inclusive, notInEncoded);\r\n                    return PersistencePromise.forEach(indexRanges, (indexRange) => {\r\n                        return indexEntries\r\n                            .loadFirst(indexRange, target.limit)\r\n                            .next(entries => {\r\n                            entries.forEach(entry => {\r\n                                const documentKey = DocumentKey.fromSegments(entry.documentKey);\r\n                                if (!existingKeys.has(documentKey)) {\r\n                                    existingKeys = existingKeys.add(documentKey);\r\n                                    result.push(documentKey);\r\n                                }\r\n                            });\r\n                        });\r\n                    });\r\n                }).next(() => result);\r\n            }\r\n        });\r\n    }\r\n    getSubTargets(target) {\r\n        let subTargets = this.targetToDnfSubTargets.get(target);\r\n        if (subTargets) {\r\n            return subTargets;\r\n        }\r\n        if (target.filters.length === 0) {\r\n            subTargets = [target];\r\n        }\r\n        else {\r\n            // There is an implicit AND operation between all the filters stored in the target\r\n            const dnf = getDnfTerms(CompositeFilter.create(target.filters, \"and\" /* CompositeOperator.AND */));\r\n            subTargets = dnf.map(term => newTarget(target.path, target.collectionGroup, target.orderBy, term.getFilters(), target.limit, target.startAt, target.endAt));\r\n        }\r\n        this.targetToDnfSubTargets.set(target, subTargets);\r\n        return subTargets;\r\n    }\r\n    /**\r\n     * Constructs a key range query on `DbIndexEntryStore` that unions all\r\n     * bounds.\r\n     */\r\n    generateIndexRanges(indexId, arrayValues, lowerBounds, lowerBoundInclusive, upperBounds, upperBoundInclusive, notInValues) {\r\n        // The number of total index scans we union together. This is similar to a\r\n        // distributed normal form, but adapted for array values. We create a single\r\n        // index range per value in an ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filter\r\n        // combined with the values from the query bounds.\r\n        const totalScans = (arrayValues != null ? arrayValues.length : 1) *\r\n            Math.max(lowerBounds.length, upperBounds.length);\r\n        const scansPerArrayElement = totalScans / (arrayValues != null ? arrayValues.length : 1);\r\n        const indexRanges = [];\r\n        for (let i = 0; i < totalScans; ++i) {\r\n            const arrayValue = arrayValues\r\n                ? this.encodeSingleElement(arrayValues[i / scansPerArrayElement])\r\n                : EMPTY_VALUE;\r\n            const lowerBound = this.generateLowerBound(indexId, arrayValue, lowerBounds[i % scansPerArrayElement], lowerBoundInclusive);\r\n            const upperBound = this.generateUpperBound(indexId, arrayValue, upperBounds[i % scansPerArrayElement], upperBoundInclusive);\r\n            const notInBound = notInValues.map(notIn => this.generateLowerBound(indexId, arrayValue, notIn, \r\n            /* inclusive= */ true));\r\n            indexRanges.push(...this.createRange(lowerBound, upperBound, notInBound));\r\n        }\r\n        return indexRanges;\r\n    }\r\n    /** Generates the lower bound for `arrayValue` and `directionalValue`. */\r\n    generateLowerBound(indexId, arrayValue, directionalValue, inclusive) {\r\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\r\n        return inclusive ? entry : entry.successor();\r\n    }\r\n    /** Generates the upper bound for `arrayValue` and `directionalValue`. */\r\n    generateUpperBound(indexId, arrayValue, directionalValue, inclusive) {\r\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\r\n        return inclusive ? entry.successor() : entry;\r\n    }\r\n    getFieldIndex(transaction, target) {\r\n        const targetIndexMatcher = new TargetIndexMatcher(target);\r\n        const collectionGroup = target.collectionGroup != null\r\n            ? target.collectionGroup\r\n            : target.path.lastSegment();\r\n        return this.getFieldIndexes(transaction, collectionGroup).next(indexes => {\r\n            // Return the index with the most number of segments.\r\n            let index = null;\r\n            for (const candidate of indexes) {\r\n                const matches = targetIndexMatcher.servedByIndex(candidate);\r\n                if (matches &&\r\n                    (!index || candidate.fields.length > index.fields.length)) {\r\n                    index = candidate;\r\n                }\r\n            }\r\n            return index;\r\n        });\r\n    }\r\n    getIndexType(transaction, target) {\r\n        let indexType = 2 /* IndexType.FULL */;\r\n        const subTargets = this.getSubTargets(target);\r\n        return PersistencePromise.forEach(subTargets, (target) => {\r\n            return this.getFieldIndex(transaction, target).next(index => {\r\n                if (!index) {\r\n                    indexType = 0 /* IndexType.NONE */;\r\n                }\r\n                else if (indexType !== 0 /* IndexType.NONE */ &&\r\n                    index.fields.length < targetGetSegmentCount(target)) {\r\n                    indexType = 1 /* IndexType.PARTIAL */;\r\n                }\r\n            });\r\n        }).next(() => {\r\n            // OR queries have more than one sub-target (one sub-target per DNF term). We currently consider\r\n            // OR queries that have a `limit` to have a partial index. For such queries we perform sorting\r\n            // and apply the limit in memory as a post-processing step.\r\n            if (targetHasLimit(target) &&\r\n                subTargets.length > 1 &&\r\n                indexType === 2 /* IndexType.FULL */) {\r\n                return 1 /* IndexType.PARTIAL */;\r\n            }\r\n            return indexType;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the byte encoded form of the directional values in the field index.\r\n     * Returns `null` if the document does not have all fields specified in the\r\n     * index.\r\n     */\r\n    encodeDirectionalElements(fieldIndex, document) {\r\n        const encoder = new IndexByteEncoder();\r\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n            const field = document.data.field(segment.fieldPath);\r\n            if (field == null) {\r\n                return null;\r\n            }\r\n            const directionalEncoder = encoder.forKind(segment.kind);\r\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\r\n        }\r\n        return encoder.encodedBytes();\r\n    }\r\n    /** Encodes a single value to the ascending index format. */\r\n    encodeSingleElement(value) {\r\n        const encoder = new IndexByteEncoder();\r\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* IndexKind.ASCENDING */));\r\n        return encoder.encodedBytes();\r\n    }\r\n    /**\r\n     * Returns an encoded form of the document key that sorts based on the key\r\n     * ordering of the field index.\r\n     */\r\n    encodeDirectionalKey(fieldIndex, documentKey) {\r\n        const encoder = new IndexByteEncoder();\r\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(refValue(this.databaseId, documentKey), encoder.forKind(fieldIndexGetKeyOrder(fieldIndex)));\r\n        return encoder.encodedBytes();\r\n    }\r\n    /**\r\n     * Encodes the given field values according to the specification in `target`.\r\n     * For IN queries, a list of possible values is returned.\r\n     */\r\n    encodeValues(fieldIndex, target, values) {\r\n        if (values === null) {\r\n            return [];\r\n        }\r\n        let encoders = [];\r\n        encoders.push(new IndexByteEncoder());\r\n        let valueIdx = 0;\r\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n            const value = values[valueIdx++];\r\n            for (const encoder of encoders) {\r\n                if (this.isInFilter(target, segment.fieldPath) && isArray(value)) {\r\n                    encoders = this.expandIndexValues(encoders, segment, value);\r\n                }\r\n                else {\r\n                    const directionalEncoder = encoder.forKind(segment.kind);\r\n                    FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, directionalEncoder);\r\n                }\r\n            }\r\n        }\r\n        return this.getEncodedBytes(encoders);\r\n    }\r\n    /**\r\n     * Encodes the given bounds according to the specification in `target`. For IN\r\n     * queries, a list of possible values is returned.\r\n     */\r\n    encodeBound(fieldIndex, target, bound) {\r\n        return this.encodeValues(fieldIndex, target, bound.position);\r\n    }\r\n    /** Returns the byte representation for the provided encoders. */\r\n    getEncodedBytes(encoders) {\r\n        const result = [];\r\n        for (let i = 0; i < encoders.length; ++i) {\r\n            result[i] = encoders[i].encodedBytes();\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a separate encoder for each element of an array.\r\n     *\r\n     * The method appends each value to all existing encoders (e.g. filter(\"a\",\r\n     * \"==\", \"a1\").filter(\"b\", \"in\", [\"b1\", \"b2\"]) becomes [\"a1,b1\", \"a1,b2\"]). A\r\n     * list of new encoders is returned.\r\n     */\r\n    expandIndexValues(encoders, segment, value) {\r\n        const prefixes = [...encoders];\r\n        const results = [];\r\n        for (const arrayElement of value.arrayValue.values || []) {\r\n            for (const prefix of prefixes) {\r\n                const clonedEncoder = new IndexByteEncoder();\r\n                clonedEncoder.seed(prefix.encodedBytes());\r\n                FirestoreIndexValueWriter.INSTANCE.writeIndexValue(arrayElement, clonedEncoder.forKind(segment.kind));\r\n                results.push(clonedEncoder);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    isInFilter(target, fieldPath) {\r\n        return !!target.filters.find(f => f instanceof FieldFilter &&\r\n            f.field.isEqual(fieldPath) &&\r\n            (f.op === \"in\" /* Operator.IN */ || f.op === \"not-in\" /* Operator.NOT_IN */));\r\n    }\r\n    getFieldIndexes(transaction, collectionGroup) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return (collectionGroup\r\n            ? indexes.loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\r\n            : indexes.loadAll()).next(indexConfigs => {\r\n            const result = [];\r\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\r\n                return states\r\n                    .get([indexConfig.indexId, this.uid])\r\n                    .next(indexState => {\r\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\r\n                });\r\n            }).next(() => result);\r\n        });\r\n    }\r\n    getNextCollectionGroupToUpdate(transaction) {\r\n        return this.getFieldIndexes(transaction).next(indexes => {\r\n            if (indexes.length === 0) {\r\n                return null;\r\n            }\r\n            indexes.sort((l, r) => {\r\n                const cmp = l.indexState.sequenceNumber - r.indexState.sequenceNumber;\r\n                return cmp !== 0\r\n                    ? cmp\r\n                    : primitiveComparator(l.collectionGroup, r.collectionGroup);\r\n            });\r\n            return indexes[0].collectionGroup;\r\n        });\r\n    }\r\n    updateCollectionGroup(transaction, collectionGroup, offset) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\r\n            .loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\r\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.uid, nextSequenceNumber, offset)))));\r\n    }\r\n    updateIndexEntries(transaction, documents) {\r\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\r\n        // it could be used across different IndexedDB transactions. As any cached\r\n        // data might be invalidated by other multi-tab clients, we can only trust\r\n        // data within a single IndexedDB transaction. We therefore add a cache\r\n        // here.\r\n        const memoizedIndexes = new Map();\r\n        return PersistencePromise.forEach(documents, (key, doc) => {\r\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\r\n            const fieldIndexes = memoizedCollectionIndexes\r\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\r\n                : this.getFieldIndexes(transaction, key.collectionGroup);\r\n            return fieldIndexes.next(fieldIndexes => {\r\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\r\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\r\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\r\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\r\n                        if (!existingEntries.isEqual(newEntries)) {\r\n                            return this.updateEntries(transaction, doc, fieldIndex, existingEntries, newEntries);\r\n                        }\r\n                        return PersistencePromise.resolve();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    addIndexEntry(transaction, document, fieldIndex, indexEntry) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        return indexEntries.put({\r\n            indexId: indexEntry.indexId,\r\n            uid: this.uid,\r\n            arrayValue: indexEntry.arrayValue,\r\n            directionalValue: indexEntry.directionalValue,\r\n            orderedDocumentKey: this.encodeDirectionalKey(fieldIndex, document.key),\r\n            documentKey: document.key.path.toArray()\r\n        });\r\n    }\r\n    deleteIndexEntry(transaction, document, fieldIndex, indexEntry) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        return indexEntries.delete([\r\n            indexEntry.indexId,\r\n            this.uid,\r\n            indexEntry.arrayValue,\r\n            indexEntry.directionalValue,\r\n            this.encodeDirectionalKey(fieldIndex, document.key),\r\n            document.key.path.toArray()\r\n        ]);\r\n    }\r\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        let results = new SortedSet(indexEntryComparator);\r\n        return indexEntries\r\n            .iterate({\r\n            index: DbIndexEntryDocumentKeyIndex,\r\n            range: IDBKeyRange.only([\r\n                fieldIndex.indexId,\r\n                this.uid,\r\n                this.encodeDirectionalKey(fieldIndex, documentKey)\r\n            ])\r\n        }, (_, entry) => {\r\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, entry.arrayValue, entry.directionalValue));\r\n        })\r\n            .next(() => results);\r\n    }\r\n    /** Creates the index entries for the given document. */\r\n    computeIndexEntries(document, fieldIndex) {\r\n        let results = new SortedSet(indexEntryComparator);\r\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\r\n        if (directionalValue == null) {\r\n            return results;\r\n        }\r\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\r\n        if (arraySegment != null) {\r\n            const value = document.data.field(arraySegment.fieldPath);\r\n            if (isArray(value)) {\r\n                for (const arrayValue of value.arrayValue.values || []) {\r\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, EMPTY_VALUE, directionalValue));\r\n        }\r\n        return results;\r\n    }\r\n    /**\r\n     * Updates the index entries for the provided document by deleting entries\r\n     * that are no longer referenced in `newEntries` and adding all newly added\r\n     * entries.\r\n     */\r\n    updateEntries(transaction, document, fieldIndex, existingEntries, newEntries) {\r\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\r\n        const promises = [];\r\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \r\n        /* onAdd= */ entry => {\r\n            promises.push(this.addIndexEntry(transaction, document, fieldIndex, entry));\r\n        }, \r\n        /* onRemove= */ entry => {\r\n            promises.push(this.deleteIndexEntry(transaction, document, fieldIndex, entry));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getNextSequenceNumber(transaction) {\r\n        let nextSequenceNumber = 1;\r\n        const states = indexStateStore(transaction);\r\n        return states\r\n            .iterate({\r\n            index: DbIndexStateSequenceNumberIndex,\r\n            reverse: true,\r\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\r\n        }, (_, state, controller) => {\r\n            controller.done();\r\n            nextSequenceNumber = state.sequenceNumber + 1;\r\n        })\r\n            .next(() => nextSequenceNumber);\r\n    }\r\n    /**\r\n     * Returns a new set of IDB ranges that splits the existing range and excludes\r\n     * any values that match the `notInValue` from these ranges. As an example,\r\n     * '[foo > 2 && foo != 3]` becomes  `[foo > 2 && < 3, foo > 3]`.\r\n     */\r\n    createRange(lower, upper, notInValues) {\r\n        // The notIn values need to be sorted and unique so that we can return a\r\n        // sorted set of non-overlapping ranges.\r\n        notInValues = notInValues\r\n            .sort((l, r) => indexEntryComparator(l, r))\r\n            .filter((el, i, values) => !i || indexEntryComparator(el, values[i - 1]) !== 0);\r\n        const bounds = [];\r\n        bounds.push(lower);\r\n        for (const notInValue of notInValues) {\r\n            const cmpToLower = indexEntryComparator(notInValue, lower);\r\n            const cmpToUpper = indexEntryComparator(notInValue, upper);\r\n            if (cmpToLower === 0) {\r\n                // `notInValue` is the lower bound. We therefore need to raise the bound\r\n                // to the next value.\r\n                bounds[0] = lower.successor();\r\n            }\r\n            else if (cmpToLower > 0 && cmpToUpper < 0) {\r\n                // `notInValue` is in the middle of the range\r\n                bounds.push(notInValue);\r\n                bounds.push(notInValue.successor());\r\n            }\r\n            else if (cmpToUpper > 0) {\r\n                // `notInValue` (and all following values) are out of the range\r\n                break;\r\n            }\r\n        }\r\n        bounds.push(upper);\r\n        const ranges = [];\r\n        for (let i = 0; i < bounds.length; i += 2) {\r\n            // If we encounter two bounds that will create an unmatchable key range,\r\n            // then we return an empty set of key ranges.\r\n            if (this.isRangeMatchable(bounds[i], bounds[i + 1])) {\r\n                return [];\r\n            }\r\n            const lowerBound = [\r\n                bounds[i].indexId,\r\n                this.uid,\r\n                bounds[i].arrayValue,\r\n                bounds[i].directionalValue,\r\n                EMPTY_VALUE,\r\n                []\r\n            ];\r\n            const upperBound = [\r\n                bounds[i + 1].indexId,\r\n                this.uid,\r\n                bounds[i + 1].arrayValue,\r\n                bounds[i + 1].directionalValue,\r\n                EMPTY_VALUE,\r\n                []\r\n            ];\r\n            ranges.push(IDBKeyRange.bound(lowerBound, upperBound));\r\n        }\r\n        return ranges;\r\n    }\r\n    isRangeMatchable(lowerBound, upperBound) {\r\n        // If lower bound is greater than the upper bound, then the key\r\n        // range can never be matched.\r\n        return indexEntryComparator(lowerBound, upperBound) > 0;\r\n    }\r\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\r\n        return this.getFieldIndexes(transaction, collectionGroup).next(getMinOffsetFromFieldIndexes);\r\n    }\r\n    getMinOffset(transaction, target) {\r\n        return PersistencePromise.mapArray(this.getSubTargets(target), (subTarget) => this.getFieldIndex(transaction, subTarget).next(index => index ? index : fail())).next(getMinOffsetFromFieldIndexes);\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the collectionParents\r\n * document store.\r\n */\r\nfunction collectionParentsStore(txn) {\r\n    return getStore(txn, DbCollectionParentStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index entry object store.\r\n */\r\nfunction indexEntriesStore(txn) {\r\n    return getStore(txn, DbIndexEntryStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index configuration object store.\r\n */\r\nfunction indexConfigurationStore(txn) {\r\n    return getStore(txn, DbIndexConfigurationStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index state object store.\r\n */\r\nfunction indexStateStore(txn) {\r\n    return getStore(txn, DbIndexStateStore);\r\n}\r\nfunction getMinOffsetFromFieldIndexes(fieldIndexes) {\r\n    hardAssert(fieldIndexes.length !== 0);\r\n    let minOffset = fieldIndexes[0].indexState.offset;\r\n    let maxBatchId = minOffset.largestBatchId;\r\n    for (let i = 1; i < fieldIndexes.length; i++) {\r\n        const newOffset = fieldIndexes[i].indexState.offset;\r\n        if (indexOffsetComparator(newOffset, minOffset) < 0) {\r\n            minOffset = newOffset;\r\n        }\r\n        if (maxBatchId < newOffset.largestBatchId) {\r\n            maxBatchId = newOffset.largestBatchId;\r\n        }\r\n    }\r\n    return new IndexOffset(minOffset.readTime, minOffset.documentKey, maxBatchId);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Delete a mutation batch and the associated document mutations.\r\n * @returns A PersistencePromise of the document mutations that were removed.\r\n */\r\nfunction removeMutationBatch(txn, userId, batch) {\r\n    const mutationStore = txn.store(DbMutationBatchStore);\r\n    const indexTxn = txn.store(DbDocumentMutationStore);\r\n    const promises = [];\r\n    const range = IDBKeyRange.only(batch.batchId);\r\n    let numDeleted = 0;\r\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\r\n        numDeleted++;\r\n        return control.delete();\r\n    });\r\n    promises.push(removePromise.next(() => {\r\n        hardAssert(numDeleted === 1);\r\n    }));\r\n    const removedDocuments = [];\r\n    for (const mutation of batch.mutations) {\r\n        const indexKey = newDbDocumentMutationKey(userId, mutation.key.path, batch.batchId);\r\n        promises.push(indexTxn.delete(indexKey));\r\n        removedDocuments.push(mutation.key);\r\n    }\r\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\r\n}\r\n/**\r\n * Returns an approximate size for the given document.\r\n */\r\nfunction dbDocumentSize(doc) {\r\n    if (!doc) {\r\n        return 0;\r\n    }\r\n    let value;\r\n    if (doc.document) {\r\n        value = doc.document;\r\n    }\r\n    else if (doc.unknownDocument) {\r\n        value = doc.unknownDocument;\r\n    }\r\n    else if (doc.noDocument) {\r\n        value = doc.noDocument;\r\n    }\r\n    else {\r\n        throw fail();\r\n    }\r\n    return JSON.stringify(value).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** A mutation queue for a specific user, backed by IndexedDB. */\r\nclass IndexedDbMutationQueue {\r\n    constructor(\r\n    /**\r\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\r\n     * retrieve mutations.\r\n     */\r\n    userId, serializer, indexManager, referenceDelegate) {\r\n        this.userId = userId;\r\n        this.serializer = serializer;\r\n        this.indexManager = indexManager;\r\n        this.referenceDelegate = referenceDelegate;\r\n        /**\r\n         * Caches the document keys for pending mutation batches. If the mutation\r\n         * has been removed from IndexedDb, the cached value may continue to\r\n         * be used to retrieve the batch's document keys. To remove a cached value\r\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\r\n         * or through `removeMutationBatches()`.\r\n         *\r\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\r\n         * this cache is used by secondary clients to invalidate the local\r\n         * view of the documents that were previously affected by the mutation.\r\n         */\r\n        // PORTING NOTE: Multi-tab only.\r\n        this.documentKeysByBatchId = {};\r\n    }\r\n    /**\r\n     * Creates a new mutation queue for the given user.\r\n     * @param user - The user for which to create a mutation queue.\r\n     * @param serializer - The serializer to use when persisting to IndexedDb.\r\n     */\r\n    static forUser(user, serializer, indexManager, referenceDelegate) {\r\n        // TODO(mcg): Figure out what constraints there are on userIDs\r\n        // In particular, are there any reserved characters? are empty ids allowed?\r\n        // For the moment store these together in the same mutations table assuming\r\n        // that empty userIDs aren't allowed.\r\n        hardAssert(user.uid !== '');\r\n        const userId = user.isAuthenticated() ? user.uid : '';\r\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\r\n    }\r\n    checkEmpty(transaction) {\r\n        let empty = true;\r\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, value, control) => {\r\n            empty = false;\r\n            control.done();\r\n        })\r\n            .next(() => empty);\r\n    }\r\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\r\n        const documentStore = documentMutationsStore(transaction);\r\n        const mutationStore = mutationsStore(transaction);\r\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\r\n        // compound indices that include auto-generated keys correctly. To ensure\r\n        // that the index entry is added correctly in all browsers, we perform two\r\n        // writes: The first write is used to retrieve the next auto-generated Batch\r\n        // ID, and the second write populates the index and stores the actual\r\n        // mutation batch.\r\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\r\n        // We write an empty object to obtain key\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return mutationStore.add({}).next(batchId => {\r\n            hardAssert(typeof batchId === 'number');\r\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\r\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\r\n            const promises = [];\r\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\r\n            for (const mutation of mutations) {\r\n                const indexKey = newDbDocumentMutationKey(this.userId, mutation.key.path, batchId);\r\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\r\n                promises.push(mutationStore.put(dbBatch));\r\n                promises.push(documentStore.put(indexKey, DbDocumentMutationPlaceholder));\r\n            }\r\n            collectionParents.forEach(parent => {\r\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\r\n            });\r\n            transaction.addOnCommittedListener(() => {\r\n                this.documentKeysByBatchId[batchId] = batch.keys();\r\n            });\r\n            return PersistencePromise.waitFor(promises).next(() => batch);\r\n        });\r\n    }\r\n    lookupMutationBatch(transaction, batchId) {\r\n        return mutationsStore(transaction)\r\n            .get(batchId)\r\n            .next(dbBatch => {\r\n            if (dbBatch) {\r\n                hardAssert(dbBatch.userId === this.userId);\r\n                return fromDbMutationBatch(this.serializer, dbBatch);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the document keys for the mutation batch with the given batchId.\r\n     * For primary clients, this method returns `null` after\r\n     * `removeMutationBatches()` has been called. Secondary clients return a\r\n     * cached result until `removeCachedMutationKeys()` is invoked.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    lookupMutationKeys(transaction, batchId) {\r\n        if (this.documentKeysByBatchId[batchId]) {\r\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\r\n        }\r\n        else {\r\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\r\n                if (batch) {\r\n                    const keys = batch.keys();\r\n                    this.documentKeysByBatchId[batchId] = keys;\r\n                    return keys;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\r\n        const nextBatchId = batchId + 1;\r\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\r\n        let foundBatch = null;\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, dbBatch, control) => {\r\n            if (dbBatch.userId === this.userId) {\r\n                hardAssert(dbBatch.batchId >= nextBatchId);\r\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\r\n            }\r\n            control.done();\r\n        })\r\n            .next(() => foundBatch);\r\n    }\r\n    getHighestUnacknowledgedBatchId(transaction) {\r\n        const range = IDBKeyRange.upperBound([\r\n            this.userId,\r\n            Number.POSITIVE_INFINITY\r\n        ]);\r\n        let batchId = BATCHID_UNKNOWN;\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\r\n            batchId = dbBatch.batchId;\r\n            control.done();\r\n        })\r\n            .next(() => batchId);\r\n    }\r\n    getAllMutationBatches(transaction) {\r\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\r\n        return mutationsStore(transaction)\r\n            .loadAll(DbMutationBatchUserMutationsIndex, range)\r\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\r\n        // Scan the document-mutation index starting with a prefix starting with\r\n        // the given documentKey.\r\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\r\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\r\n        const results = [];\r\n        return documentMutationsStore(transaction)\r\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\r\n            const [userID, encodedPath, batchId] = indexKey;\r\n            // Only consider rows matching exactly the specific key of\r\n            // interest. Note that because we order by path first, and we\r\n            // order terminators before path separators, we'll encounter all\r\n            // the index rows for documentKey contiguously. In particular, all\r\n            // the rows for documentKey will occur before any rows for\r\n            // documents nested in a subcollection beneath documentKey so we\r\n            // can stop as soon as we hit any such row.\r\n            const path = decodeResourcePath(encodedPath);\r\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\r\n                control.done();\r\n                return;\r\n            }\r\n            // Look up the mutation batch in the store.\r\n            return mutationsStore(transaction)\r\n                .get(batchId)\r\n                .next(mutation => {\r\n                if (!mutation) {\r\n                    throw fail();\r\n                }\r\n                hardAssert(mutation.userId === this.userId);\r\n                results.push(fromDbMutationBatch(this.serializer, mutation));\r\n            });\r\n        })\r\n            .next(() => results);\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        const promises = [];\r\n        documentKeys.forEach(documentKey => {\r\n            const indexStart = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\r\n            const range = IDBKeyRange.lowerBound(indexStart);\r\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\r\n                const [userID, encodedPath, batchID] = indexKey;\r\n                // Only consider rows matching exactly the specific key of\r\n                // interest. Note that because we order by path first, and we\r\n                // order terminators before path separators, we'll encounter all\r\n                // the index rows for documentKey contiguously. In particular, all\r\n                // the rows for documentKey will occur before any rows for\r\n                // documents nested in a subcollection beneath documentKey so we\r\n                // can stop as soon as we hit any such row.\r\n                const path = decodeResourcePath(encodedPath);\r\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\r\n                    control.done();\r\n                    return;\r\n                }\r\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\r\n            });\r\n            promises.push(promise);\r\n        });\r\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\r\n    }\r\n    getAllMutationBatchesAffectingQuery(transaction, query) {\r\n        const queryPath = query.path;\r\n        const immediateChildrenLength = queryPath.length + 1;\r\n        // TODO(mcg): Actually implement a single-collection query\r\n        //\r\n        // This is actually executing an ancestor query, traversing the whole\r\n        // subtree below the collection which can be horrifically inefficient for\r\n        // some structures. The right way to solve this is to implement the full\r\n        // value index, but that's not in the cards in the near future so this is\r\n        // the best we can do for the moment.\r\n        //\r\n        // Since we don't yet index the actual properties in the mutations, our\r\n        // current approach is to just return all mutation batches that affect\r\n        // documents in the collection being queried.\r\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, queryPath);\r\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\r\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\r\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\r\n        // scan of the main table.\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        return documentMutationsStore(transaction)\r\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\r\n            const [userID, encodedPath, batchID] = indexKey;\r\n            const path = decodeResourcePath(encodedPath);\r\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\r\n                control.done();\r\n                return;\r\n            }\r\n            // Rows with document keys more than one segment longer than the\r\n            // query path can't be matches. For example, a query on 'rooms'\r\n            // can't match the document /rooms/abc/messages/xyx.\r\n            // TODO(mcg): we'll need a different scanner when we implement\r\n            // ancestor queries.\r\n            if (path.length !== immediateChildrenLength) {\r\n                return;\r\n            }\r\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\r\n        })\r\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\r\n    }\r\n    lookupMutationBatches(transaction, batchIDs) {\r\n        const results = [];\r\n        const promises = [];\r\n        // TODO(rockwood): Implement this using iterate.\r\n        batchIDs.forEach(batchId => {\r\n            promises.push(mutationsStore(transaction)\r\n                .get(batchId)\r\n                .next(mutation => {\r\n                if (mutation === null) {\r\n                    throw fail();\r\n                }\r\n                hardAssert(mutation.userId === this.userId);\r\n                results.push(fromDbMutationBatch(this.serializer, mutation));\r\n            }));\r\n        });\r\n        return PersistencePromise.waitFor(promises).next(() => results);\r\n    }\r\n    removeMutationBatch(transaction, batch) {\r\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\r\n            transaction.addOnCommittedListener(() => {\r\n                this.removeCachedMutationKeys(batch.batchId);\r\n            });\r\n            return PersistencePromise.forEach(removedDocuments, (key) => {\r\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Clears the cached keys for a mutation batch. This method should be\r\n     * called by secondary clients after they process mutation updates.\r\n     *\r\n     * Note that this method does not have to be called from primary clients as\r\n     * the corresponding cache entries are cleared when an acknowledged or\r\n     * rejected batch is removed from the mutation queue.\r\n     */\r\n    // PORTING NOTE: Multi-tab only\r\n    removeCachedMutationKeys(batchId) {\r\n        delete this.documentKeysByBatchId[batchId];\r\n    }\r\n    performConsistencyCheck(txn) {\r\n        return this.checkEmpty(txn).next(empty => {\r\n            if (!empty) {\r\n                return PersistencePromise.resolve();\r\n            }\r\n            // Verify that there are no entries in the documentMutations index if\r\n            // the queue is empty.\r\n            const startRange = IDBKeyRange.lowerBound(newDbDocumentMutationPrefixForUser(this.userId));\r\n            const danglingMutationReferences = [];\r\n            return documentMutationsStore(txn)\r\n                .iterate({ range: startRange }, (key, _, control) => {\r\n                const userID = key[0];\r\n                if (userID !== this.userId) {\r\n                    control.done();\r\n                    return;\r\n                }\r\n                else {\r\n                    const path = decodeResourcePath(key[1]);\r\n                    danglingMutationReferences.push(path);\r\n                }\r\n            })\r\n                .next(() => {\r\n                hardAssert(danglingMutationReferences.length === 0);\r\n            });\r\n        });\r\n    }\r\n    containsKey(txn, key) {\r\n        return mutationQueueContainsKey(txn, this.userId, key);\r\n    }\r\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\r\n    /** Returns the mutation queue's metadata from IndexedDb. */\r\n    getMutationQueueMetadata(transaction) {\r\n        return mutationQueuesStore(transaction)\r\n            .get(this.userId)\r\n            .next((metadata) => {\r\n            return (metadata || {\r\n                userId: this.userId,\r\n                lastAcknowledgedBatchId: BATCHID_UNKNOWN,\r\n                lastStreamToken: ''\r\n            });\r\n        });\r\n    }\r\n}\r\n/**\r\n * @returns true if the mutation queue for the given user contains a pending\r\n *         mutation for the given key.\r\n */\r\nfunction mutationQueueContainsKey(txn, userId, key) {\r\n    const indexKey = newDbDocumentMutationPrefixForPath(userId, key.path);\r\n    const encodedPath = indexKey[1];\r\n    const startRange = IDBKeyRange.lowerBound(indexKey);\r\n    let containsKey = false;\r\n    return documentMutationsStore(txn)\r\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\r\n        const [userID, keyPath, /*batchID*/ _] = key;\r\n        if (userID === userId && keyPath === encodedPath) {\r\n            containsKey = true;\r\n        }\r\n        control.done();\r\n    })\r\n        .next(() => containsKey);\r\n}\r\n/** Returns true if any mutation queue contains the given document. */\r\nfunction mutationQueuesContainKey(txn, docKey) {\r\n    let found = false;\r\n    return mutationQueuesStore(txn)\r\n        .iterateSerial(userId => {\r\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\r\n            if (containsKey) {\r\n                found = true;\r\n            }\r\n            return PersistencePromise.resolve(!containsKey);\r\n        });\r\n    })\r\n        .next(() => found);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutations object store.\r\n */\r\nfunction mutationsStore(txn) {\r\n    return getStore(txn, DbMutationBatchStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\r\n */\r\nfunction documentMutationsStore(txn) {\r\n    return getStore(txn, DbDocumentMutationStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\r\n */\r\nfunction mutationQueuesStore(txn) {\r\n    return getStore(txn, DbMutationQueueStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Offset to ensure non-overlapping target ids. */\r\nconst OFFSET = 2;\r\n/**\r\n * Generates monotonically increasing target IDs for sending targets to the\r\n * watch stream.\r\n *\r\n * The client constructs two generators, one for the target cache, and one for\r\n * for the sync engine (to generate limbo documents targets). These\r\n * generators produce non-overlapping IDs (by using even and odd IDs\r\n * respectively).\r\n *\r\n * By separating the target ID space, the query cache can generate target IDs\r\n * that persist across client restarts, while sync engine can independently\r\n * generate in-memory target IDs that are transient and can be reused after a\r\n * restart.\r\n */\r\nclass TargetIdGenerator {\r\n    constructor(lastId) {\r\n        this.lastId = lastId;\r\n    }\r\n    next() {\r\n        this.lastId += OFFSET;\r\n        return this.lastId;\r\n    }\r\n    static forTargetCache() {\r\n        // The target cache generator must return '2' in its first call to `next()`\r\n        // as there is no differentiation in the protocol layer between an unset\r\n        // number and the number '0'. If we were to sent a target with target ID\r\n        // '0', the backend would consider it unset and replace it with its own ID.\r\n        return new TargetIdGenerator(2 - OFFSET);\r\n    }\r\n    static forSyncEngine() {\r\n        // Sync engine assigns target IDs for limbo document detection.\r\n        return new TargetIdGenerator(1 - OFFSET);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbTargetCache {\r\n    constructor(referenceDelegate, serializer) {\r\n        this.referenceDelegate = referenceDelegate;\r\n        this.serializer = serializer;\r\n    }\r\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\r\n    // some of it (in particular `highestTargetId`) can be modified by secondary\r\n    // tabs. We could perhaps be more granular (and e.g. still cache\r\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\r\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\r\n    // out to have a meaningful performance impact.\r\n    allocateTargetId(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\r\n            metadata.highestTargetId = targetIdGenerator.next();\r\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\r\n        });\r\n    }\r\n    getLastRemoteSnapshotVersion(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\r\n        });\r\n    }\r\n    getHighestSequenceNumber(transaction) {\r\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\r\n    }\r\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\r\n            if (lastRemoteSnapshotVersion) {\r\n                metadata.lastRemoteSnapshotVersion =\r\n                    lastRemoteSnapshotVersion.toTimestamp();\r\n            }\r\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\r\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\r\n            }\r\n            return this.saveMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    addTargetData(transaction, targetData) {\r\n        return this.saveTargetData(transaction, targetData).next(() => {\r\n            return this.retrieveMetadata(transaction).next(metadata => {\r\n                metadata.targetCount += 1;\r\n                this.updateMetadataFromTargetData(targetData, metadata);\r\n                return this.saveMetadata(transaction, metadata);\r\n            });\r\n        });\r\n    }\r\n    updateTargetData(transaction, targetData) {\r\n        return this.saveTargetData(transaction, targetData);\r\n    }\r\n    removeTargetData(transaction, targetData) {\r\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\r\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\r\n            .next(() => this.retrieveMetadata(transaction))\r\n            .next(metadata => {\r\n            hardAssert(metadata.targetCount > 0);\r\n            metadata.targetCount -= 1;\r\n            return this.saveMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    /**\r\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\r\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\r\n     * Returns the number of targets removed.\r\n     */\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        let count = 0;\r\n        const promises = [];\r\n        return targetsStore(txn)\r\n            .iterate((key, value) => {\r\n            const targetData = fromDbTarget(value);\r\n            if (targetData.sequenceNumber <= upperBound &&\r\n                activeTargetIds.get(targetData.targetId) === null) {\r\n                count++;\r\n                promises.push(this.removeTargetData(txn, targetData));\r\n            }\r\n        })\r\n            .next(() => PersistencePromise.waitFor(promises))\r\n            .next(() => count);\r\n    }\r\n    /**\r\n     * Call provided function with each `TargetData` that we have cached.\r\n     */\r\n    forEachTarget(txn, f) {\r\n        return targetsStore(txn).iterate((key, value) => {\r\n            const targetData = fromDbTarget(value);\r\n            f(targetData);\r\n        });\r\n    }\r\n    retrieveMetadata(transaction) {\r\n        return globalTargetStore(transaction)\r\n            .get(DbTargetGlobalKey)\r\n            .next(metadata => {\r\n            hardAssert(metadata !== null);\r\n            return metadata;\r\n        });\r\n    }\r\n    saveMetadata(transaction, metadata) {\r\n        return globalTargetStore(transaction).put(DbTargetGlobalKey, metadata);\r\n    }\r\n    saveTargetData(transaction, targetData) {\r\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\r\n    }\r\n    /**\r\n     * In-place updates the provided metadata to account for values in the given\r\n     * TargetData. Saving is done separately. Returns true if there were any\r\n     * changes to the metadata.\r\n     */\r\n    updateMetadataFromTargetData(targetData, metadata) {\r\n        let updated = false;\r\n        if (targetData.targetId > metadata.highestTargetId) {\r\n            metadata.highestTargetId = targetData.targetId;\r\n            updated = true;\r\n        }\r\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\r\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\r\n            updated = true;\r\n        }\r\n        return updated;\r\n    }\r\n    getTargetCount(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\r\n    }\r\n    getTargetData(transaction, target) {\r\n        // Iterating by the canonicalId may yield more than one result because\r\n        // canonicalId values are not required to be unique per target. This query\r\n        // depends on the queryTargets index to be efficient.\r\n        const canonicalId = canonifyTarget(target);\r\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\r\n        let result = null;\r\n        return targetsStore(transaction)\r\n            .iterate({ range, index: DbTargetQueryTargetsIndexName }, (key, value, control) => {\r\n            const found = fromDbTarget(value);\r\n            // After finding a potential match, check that the target is\r\n            // actually equal to the requested target.\r\n            if (targetEquals(target, found.target)) {\r\n                result = found;\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => result);\r\n    }\r\n    addMatchingKeys(txn, keys, targetId) {\r\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\r\n        // IndexedDb.\r\n        const promises = [];\r\n        const store = documentTargetStore(txn);\r\n        keys.forEach(key => {\r\n            const path = encodeResourcePath(key.path);\r\n            promises.push(store.put({ targetId, path }));\r\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeMatchingKeys(txn, keys, targetId) {\r\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\r\n        // IndexedDb.\r\n        const store = documentTargetStore(txn);\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            const path = encodeResourcePath(key.path);\r\n            return PersistencePromise.waitFor([\r\n                store.delete([targetId, path]),\r\n                this.referenceDelegate.removeReference(txn, targetId, key)\r\n            ]);\r\n        });\r\n    }\r\n    removeMatchingKeysForTargetId(txn, targetId) {\r\n        const store = documentTargetStore(txn);\r\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        return store.delete(range);\r\n    }\r\n    getMatchingKeysForTargetId(txn, targetId) {\r\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        const store = documentTargetStore(txn);\r\n        let result = documentKeySet();\r\n        return store\r\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\r\n            const path = decodeResourcePath(key[1]);\r\n            const docKey = new DocumentKey(path);\r\n            result = result.add(docKey);\r\n        })\r\n            .next(() => result);\r\n    }\r\n    containsKey(txn, key) {\r\n        const path = encodeResourcePath(key.path);\r\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        let count = 0;\r\n        return documentTargetStore(txn)\r\n            .iterate({\r\n            index: DbTargetDocumentDocumentTargetsIndex,\r\n            keysOnly: true,\r\n            range\r\n        }, ([targetId, path], _, control) => {\r\n            // Having a sentinel row for a document does not count as containing that document;\r\n            // For the target cache, containing the document means the document is part of some\r\n            // target.\r\n            if (targetId !== 0) {\r\n                count++;\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => count > 0);\r\n    }\r\n    /**\r\n     * Looks up a TargetData entry by target ID.\r\n     *\r\n     * @param targetId - The target ID of the TargetData entry to look up.\r\n     * @returns The cached TargetData entry, or null if the cache has no entry for\r\n     * the target.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    getTargetDataForTarget(transaction, targetId) {\r\n        return targetsStore(transaction)\r\n            .get(targetId)\r\n            .next(found => {\r\n            if (found) {\r\n                return fromDbTarget(found);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the queries object store.\r\n */\r\nfunction targetsStore(txn) {\r\n    return getStore(txn, DbTargetStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the target globals object store.\r\n */\r\nfunction globalTargetStore(txn) {\r\n    return getStore(txn, DbTargetGlobalStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the document target object store.\r\n */\r\nfunction documentTargetStore(txn) {\r\n    return getStore(txn, DbTargetDocumentStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst GC_DID_NOT_RUN = {\r\n    didRun: false,\r\n    sequenceNumbersCollected: 0,\r\n    targetsRemoved: 0,\r\n    documentsRemoved: 0\r\n};\r\nconst LRU_COLLECTION_DISABLED = -1;\r\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\r\nclass LruParams {\r\n    constructor(\r\n    // When we attempt to collect, we will only do so if the cache size is greater than this\r\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\r\n    cacheSizeCollectionThreshold, \r\n    // The percentage of sequence numbers that we will attempt to collect\r\n    percentileToCollect, \r\n    // A cap on the total number of sequence numbers that will be collected. This prevents\r\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\r\n    maximumSequenceNumbersToCollect) {\r\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\r\n        this.percentileToCollect = percentileToCollect;\r\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\r\n    }\r\n    static withCacheSize(cacheSize) {\r\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\r\n    }\r\n}\r\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\r\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\r\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\r\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$e = 'LruGarbageCollector';\r\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\r\n/** How long we wait to try running LRU GC after SDK initialization. */\r\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\r\n/** Minimum amount of time between GC checks, after the first one. */\r\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\r\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\r\n    const seqCmp = primitiveComparator(aSequence, bSequence);\r\n    if (seqCmp === 0) {\r\n        // This order doesn't matter, but we can bias against churn by sorting\r\n        // entries created earlier as less than newer entries.\r\n        return primitiveComparator(aIndex, bIndex);\r\n    }\r\n    else {\r\n        return seqCmp;\r\n    }\r\n}\r\n/**\r\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\r\n * lowest n values passed to `addElement`, and finally reports the largest of\r\n * them in `maxValue`.\r\n */\r\nclass RollingSequenceNumberBuffer {\r\n    constructor(maxElements) {\r\n        this.maxElements = maxElements;\r\n        this.buffer = new SortedSet(bufferEntryComparator);\r\n        this.previousIndex = 0;\r\n    }\r\n    nextIndex() {\r\n        return ++this.previousIndex;\r\n    }\r\n    addElement(sequenceNumber) {\r\n        const entry = [sequenceNumber, this.nextIndex()];\r\n        if (this.buffer.size < this.maxElements) {\r\n            this.buffer = this.buffer.add(entry);\r\n        }\r\n        else {\r\n            const highestValue = this.buffer.last();\r\n            if (bufferEntryComparator(entry, highestValue) < 0) {\r\n                this.buffer = this.buffer.delete(highestValue).add(entry);\r\n            }\r\n        }\r\n    }\r\n    get maxValue() {\r\n        // Guaranteed to be non-empty. If we decide we are not collecting any\r\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\r\n        // decided that we are collecting n sequence numbers, it's because n is some\r\n        // percentage of the existing sequence numbers. That means we should never\r\n        // be in a situation where we are collecting sequence numbers but don't\r\n        // actually have any.\r\n        return this.buffer.last()[0];\r\n    }\r\n}\r\n/**\r\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\r\n * whether or not GC is enabled, as well as which delay to use before the next run.\r\n */\r\nclass LruScheduler {\r\n    constructor(garbageCollector, asyncQueue, localStore) {\r\n        this.garbageCollector = garbageCollector;\r\n        this.asyncQueue = asyncQueue;\r\n        this.localStore = localStore;\r\n        this.gcTask = null;\r\n    }\r\n    start() {\r\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\r\n            LRU_COLLECTION_DISABLED) {\r\n            this.scheduleGC(INITIAL_GC_DELAY_MS);\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.gcTask) {\r\n            this.gcTask.cancel();\r\n            this.gcTask = null;\r\n        }\r\n    }\r\n    get started() {\r\n        return this.gcTask !== null;\r\n    }\r\n    scheduleGC(delay) {\r\n        logDebug(LOG_TAG$e, `Garbage collection scheduled in ${delay}ms`);\r\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* TimerId.LruGarbageCollection */, delay, async () => {\r\n            this.gcTask = null;\r\n            try {\r\n                await this.localStore.collectGarbage(this.garbageCollector);\r\n            }\r\n            catch (e) {\r\n                if (isIndexedDbTransactionError(e)) {\r\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\r\n                }\r\n                else {\r\n                    await ignoreIfPrimaryLeaseLoss(e);\r\n                }\r\n            }\r\n            await this.scheduleGC(REGULAR_GC_DELAY_MS);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Implements the steps for LRU garbage collection.\r\n */\r\nclass LruGarbageCollectorImpl {\r\n    constructor(delegate, params) {\r\n        this.delegate = delegate;\r\n        this.params = params;\r\n    }\r\n    calculateTargetCount(txn, percentile) {\r\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\r\n            return Math.floor((percentile / 100.0) * targetCount);\r\n        });\r\n    }\r\n    nthSequenceNumber(txn, n) {\r\n        if (n === 0) {\r\n            return PersistencePromise.resolve(ListenSequence.INVALID);\r\n        }\r\n        const buffer = new RollingSequenceNumberBuffer(n);\r\n        return this.delegate\r\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\r\n            .next(() => {\r\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\r\n        })\r\n            .next(() => buffer.maxValue);\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\r\n    }\r\n    collect(txn, activeTargetIds) {\r\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\r\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\r\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\r\n        }\r\n        return this.getCacheSize(txn).next(cacheSize => {\r\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\r\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\r\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\r\n                return GC_DID_NOT_RUN;\r\n            }\r\n            else {\r\n                return this.runGarbageCollection(txn, activeTargetIds);\r\n            }\r\n        });\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.delegate.getCacheSize(txn);\r\n    }\r\n    runGarbageCollection(txn, activeTargetIds) {\r\n        let upperBoundSequenceNumber;\r\n        let sequenceNumbersToCollect, targetsRemoved;\r\n        // Timestamps for various pieces of the process\r\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\r\n        const startTs = Date.now();\r\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\r\n            .next(sequenceNumbers => {\r\n            // Cap at the configured max\r\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\r\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\r\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\r\n                    `from ${sequenceNumbers}`);\r\n                sequenceNumbersToCollect =\r\n                    this.params.maximumSequenceNumbersToCollect;\r\n            }\r\n            else {\r\n                sequenceNumbersToCollect = sequenceNumbers;\r\n            }\r\n            countedTargetsTs = Date.now();\r\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\r\n        })\r\n            .next(upperBound => {\r\n            upperBoundSequenceNumber = upperBound;\r\n            foundUpperBoundTs = Date.now();\r\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\r\n        })\r\n            .next(numTargetsRemoved => {\r\n            targetsRemoved = numTargetsRemoved;\r\n            removedTargetsTs = Date.now();\r\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\r\n        })\r\n            .next(documentsRemoved => {\r\n            removedDocumentsTs = Date.now();\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                const desc = 'LRU Garbage Collection\\n' +\r\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\r\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\r\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\r\n                    `\\tRemoved ${targetsRemoved} targets in ` +\r\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\r\n                    `\\tRemoved ${documentsRemoved} documents in ` +\r\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\r\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\r\n                logDebug('LruGarbageCollector', desc);\r\n            }\r\n            return PersistencePromise.resolve({\r\n                didRun: true,\r\n                sequenceNumbersCollected: sequenceNumbersToCollect,\r\n                targetsRemoved,\r\n                documentsRemoved\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction newLruGarbageCollector(delegate, params) {\r\n    return new LruGarbageCollectorImpl(delegate, params);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Provides LRU functionality for IndexedDB persistence. */\r\nclass IndexedDbLruDelegateImpl {\r\n    constructor(db, params) {\r\n        this.db = db;\r\n        this.garbageCollector = newLruGarbageCollector(this, params);\r\n    }\r\n    getSequenceNumberCount(txn) {\r\n        const docCountPromise = this.orphanedDocumentCount(txn);\r\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\r\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\r\n    }\r\n    orphanedDocumentCount(txn) {\r\n        let orphanedCount = 0;\r\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\r\n            orphanedCount++;\r\n        }).next(() => orphanedCount);\r\n    }\r\n    forEachTarget(txn, f) {\r\n        return this.db.getTargetCache().forEachTarget(txn, f);\r\n    }\r\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\r\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    /**\r\n     * Returns true if anything would prevent this document from being garbage\r\n     * collected, given that the document in question is not present in any\r\n     * targets and has a sequence number less than or equal to the upper bound for\r\n     * the collection run.\r\n     */\r\n    isPinned(txn, docKey) {\r\n        return mutationQueuesContainKey(txn, docKey);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        const documentCache = this.db.getRemoteDocumentCache();\r\n        const changeBuffer = documentCache.newChangeBuffer();\r\n        const promises = [];\r\n        let documentCount = 0;\r\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\r\n            if (sequenceNumber <= upperBound) {\r\n                const p = this.isPinned(txn, docKey).next(isPinned => {\r\n                    if (!isPinned) {\r\n                        documentCount++;\r\n                        // Our size accounting requires us to read all documents before\r\n                        // removing them.\r\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\r\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\r\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\r\n                        });\r\n                    }\r\n                });\r\n                promises.push(p);\r\n            }\r\n        });\r\n        return iteration\r\n            .next(() => PersistencePromise.waitFor(promises))\r\n            .next(() => changeBuffer.apply(txn))\r\n            .next(() => documentCount);\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\r\n        return this.db.getTargetCache().updateTargetData(txn, updated);\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    /**\r\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\r\n     * means not a part of any target, so the only entry in the target-document index for\r\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\r\n     * number for the last time the document was accessed.\r\n     */\r\n    forEachOrphanedDocument(txn, f) {\r\n        const store = documentTargetStore(txn);\r\n        let nextToReport = ListenSequence.INVALID;\r\n        let nextPath;\r\n        return store\r\n            .iterate({\r\n            index: DbTargetDocumentDocumentTargetsIndex\r\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\r\n            if (targetId === 0) {\r\n                // if nextToReport is valid, report it, this is a new key so the\r\n                // last one must not be a member of any targets.\r\n                if (nextToReport !== ListenSequence.INVALID) {\r\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\r\n                }\r\n                // set nextToReport to be this sequence number. It's the next one we\r\n                // might report, if we don't find any targets for this document.\r\n                // Note that the sequence number must be defined when the targetId\r\n                // is 0.\r\n                nextToReport = sequenceNumber;\r\n                nextPath = path;\r\n            }\r\n            else {\r\n                // set nextToReport to be invalid, we know we don't need to report\r\n                // this one since we found a target for it.\r\n                nextToReport = ListenSequence.INVALID;\r\n            }\r\n        })\r\n            .next(() => {\r\n            // Since we report sequence numbers after getting to the next key, we\r\n            // need to check if the last key we iterated over was an orphaned\r\n            // document and report it.\r\n            if (nextToReport !== ListenSequence.INVALID) {\r\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\r\n            }\r\n        });\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.db.getRemoteDocumentCache().getSize(txn);\r\n    }\r\n}\r\nfunction sentinelKey$1(key) {\r\n    return [0, encodeResourcePath(key.path)];\r\n}\r\n/**\r\n * @returns A value suitable for writing a sentinel row in the target-document\r\n * store.\r\n */\r\nfunction sentinelRow(key, sequenceNumber) {\r\n    return { targetId: 0, path: encodeResourcePath(key.path), sequenceNumber };\r\n}\r\nfunction writeSentinelKey(txn, key) {\r\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\r\n * It can be used to batch up a set of changes to be written to the cache, but\r\n * additionally supports reading entries back with the `getEntry()` method,\r\n * falling back to the underlying RemoteDocumentCache if no entry is\r\n * buffered.\r\n *\r\n * Entries added to the cache *must* be read first. This is to facilitate\r\n * calculating the size delta of the pending changes.\r\n *\r\n * PORTING NOTE: This class was implemented then removed from other platforms.\r\n * If byte-counting ends up being needed on the other platforms, consider\r\n * porting this class as part of that implementation work.\r\n */\r\nclass RemoteDocumentChangeBuffer {\r\n    constructor() {\r\n        // A mapping of document key to the new cache entry that should be written.\r\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n        this.changesApplied = false;\r\n    }\r\n    /**\r\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\r\n     *\r\n     * You can only modify documents that have already been retrieved via\r\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\r\n     */\r\n    addEntry(document) {\r\n        this.assertNotApplied();\r\n        this.changes.set(document.key, document);\r\n    }\r\n    /**\r\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\r\n     *\r\n     * You can only remove documents that have already been retrieved via\r\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\r\n     */\r\n    removeEntry(key, readTime) {\r\n        this.assertNotApplied();\r\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\r\n    }\r\n    /**\r\n     * Looks up an entry in the cache. The buffered changes will first be checked,\r\n     * and if no buffered change applies, this will forward to\r\n     * `RemoteDocumentCache.getEntry()`.\r\n     *\r\n     * @param transaction - The transaction in which to perform any persistence\r\n     *     operations.\r\n     * @param documentKey - The key of the entry to look up.\r\n     * @returns The cached document or an invalid document if we have nothing\r\n     * cached.\r\n     */\r\n    getEntry(transaction, documentKey) {\r\n        this.assertNotApplied();\r\n        const bufferedEntry = this.changes.get(documentKey);\r\n        if (bufferedEntry !== undefined) {\r\n            return PersistencePromise.resolve(bufferedEntry);\r\n        }\r\n        else {\r\n            return this.getFromCache(transaction, documentKey);\r\n        }\r\n    }\r\n    /**\r\n     * Looks up several entries in the cache, forwarding to\r\n     * `RemoteDocumentCache.getEntry()`.\r\n     *\r\n     * @param transaction - The transaction in which to perform any persistence\r\n     *     operations.\r\n     * @param documentKeys - The keys of the entries to look up.\r\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\r\n     *     found, the corresponding key will be mapped to an invalid document.\r\n     */\r\n    getEntries(transaction, documentKeys) {\r\n        return this.getAllFromCache(transaction, documentKeys);\r\n    }\r\n    /**\r\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\r\n     * the provided transaction.\r\n     */\r\n    apply(transaction) {\r\n        this.assertNotApplied();\r\n        this.changesApplied = true;\r\n        return this.applyChanges(transaction);\r\n    }\r\n    /** Helper to assert this.changes is not null  */\r\n    assertNotApplied() {\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\r\n * `newIndexedDbRemoteDocumentCache()`.\r\n */\r\nclass IndexedDbRemoteDocumentCacheImpl {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    setIndexManager(indexManager) {\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Adds the supplied entries to the cache.\r\n     *\r\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\r\n     */\r\n    addEntry(transaction, key, doc) {\r\n        const documentStore = remoteDocumentsStore(transaction);\r\n        return documentStore.put(doc);\r\n    }\r\n    /**\r\n     * Removes a document from the cache.\r\n     *\r\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\r\n     */\r\n    removeEntry(transaction, documentKey, readTime) {\r\n        const store = remoteDocumentsStore(transaction);\r\n        return store.delete(dbReadTimeKey(documentKey, readTime));\r\n    }\r\n    /**\r\n     * Updates the current cache size.\r\n     *\r\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\r\n     * cache's metadata.\r\n     */\r\n    updateMetadata(transaction, sizeDelta) {\r\n        return this.getMetadata(transaction).next(metadata => {\r\n            metadata.byteSize += sizeDelta;\r\n            return this.setMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    getEntry(transaction, documentKey) {\r\n        let doc = MutableDocument.newInvalidDocument(documentKey);\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({\r\n            index: DbRemoteDocumentDocumentKeyIndex,\r\n            range: IDBKeyRange.only(dbKey(documentKey))\r\n        }, (_, dbRemoteDoc) => {\r\n            doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\r\n        })\r\n            .next(() => doc);\r\n    }\r\n    /**\r\n     * Looks up an entry in the cache.\r\n     *\r\n     * @param documentKey - The key of the entry to look up.\r\n     * @returns The cached document entry and its size.\r\n     */\r\n    getSizedEntry(transaction, documentKey) {\r\n        let result = {\r\n            size: 0,\r\n            document: MutableDocument.newInvalidDocument(documentKey)\r\n        };\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({\r\n            index: DbRemoteDocumentDocumentKeyIndex,\r\n            range: IDBKeyRange.only(dbKey(documentKey))\r\n        }, (_, dbRemoteDoc) => {\r\n            result = {\r\n                document: this.maybeDecodeDocument(documentKey, dbRemoteDoc),\r\n                size: dbDocumentSize(dbRemoteDoc)\r\n            };\r\n        })\r\n            .next(() => result);\r\n    }\r\n    getEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\r\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\r\n            results = results.insert(key, doc);\r\n        }).next(() => results);\r\n    }\r\n    /**\r\n     * Looks up several entries in the cache.\r\n     *\r\n     * @param documentKeys - The set of keys entries to look up.\r\n     * @returns A map of documents indexed by key and a map of sizes indexed by\r\n     *     key (zero if the document does not exist).\r\n     */\r\n    getSizedEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        let sizeMap = new SortedMap(DocumentKey.comparator);\r\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\r\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\r\n            results = results.insert(key, doc);\r\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\r\n        }).next(() => {\r\n            return { documents: results, sizeMap };\r\n        });\r\n    }\r\n    forEachDbEntry(transaction, documentKeys, callback) {\r\n        if (documentKeys.isEmpty()) {\r\n            return PersistencePromise.resolve();\r\n        }\r\n        let sortedKeys = new SortedSet(dbKeyComparator);\r\n        documentKeys.forEach(e => (sortedKeys = sortedKeys.add(e)));\r\n        const range = IDBKeyRange.bound(dbKey(sortedKeys.first()), dbKey(sortedKeys.last()));\r\n        const keyIter = sortedKeys.getIterator();\r\n        let nextKey = keyIter.getNext();\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({ index: DbRemoteDocumentDocumentKeyIndex, range }, (_, dbRemoteDoc, control) => {\r\n            const potentialKey = DocumentKey.fromSegments([\r\n                ...dbRemoteDoc.prefixPath,\r\n                dbRemoteDoc.collectionGroup,\r\n                dbRemoteDoc.documentId\r\n            ]);\r\n            // Go through keys not found in cache.\r\n            while (nextKey && dbKeyComparator(nextKey, potentialKey) < 0) {\r\n                callback(nextKey, null);\r\n                nextKey = keyIter.getNext();\r\n            }\r\n            if (nextKey && nextKey.isEqual(potentialKey)) {\r\n                // Key found in cache.\r\n                callback(nextKey, dbRemoteDoc);\r\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\r\n            }\r\n            // Skip to the next key (if there is one).\r\n            if (nextKey) {\r\n                control.skip(dbKey(nextKey));\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => {\r\n            // The rest of the keys are not in the cache. One case where `iterate`\r\n            // above won't go through them is when the cache is empty.\r\n            while (nextKey) {\r\n                callback(nextKey, null);\r\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\r\n            }\r\n        });\r\n    }\r\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs, context) {\r\n        const collection = query.path;\r\n        const startKey = [\r\n            collection.popLast().toArray(),\r\n            collection.lastSegment(),\r\n            toDbTimestampKey(offset.readTime),\r\n            offset.documentKey.path.isEmpty()\r\n                ? ''\r\n                : offset.documentKey.path.lastSegment()\r\n        ];\r\n        const endKey = [\r\n            collection.popLast().toArray(),\r\n            collection.lastSegment(),\r\n            [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\r\n            ''\r\n        ];\r\n        return remoteDocumentsStore(transaction)\r\n            .loadAll(IDBKeyRange.bound(startKey, endKey, true))\r\n            .next(dbRemoteDocs => {\r\n            context === null || context === void 0 ? void 0 : context.incrementDocumentReadCount(dbRemoteDocs.length);\r\n            let results = mutableDocumentMap();\r\n            for (const dbRemoteDoc of dbRemoteDocs) {\r\n                const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\r\n                if (document.isFoundDocument() &&\r\n                    (queryMatches(query, document) || mutatedDocs.has(document.key))) {\r\n                    // Either the document matches the given query, or it is mutated.\r\n                    results = results.insert(document.key, document);\r\n                }\r\n            }\r\n            return results;\r\n        });\r\n    }\r\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\r\n        let results = mutableDocumentMap();\r\n        const startKey = dbCollectionGroupKey(collectionGroup, offset);\r\n        const endKey = dbCollectionGroupKey(collectionGroup, IndexOffset.max());\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({\r\n            index: DbRemoteDocumentCollectionGroupIndex,\r\n            range: IDBKeyRange.bound(startKey, endKey, true)\r\n        }, (_, dbRemoteDoc, control) => {\r\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\r\n            results = results.insert(document.key, document);\r\n            if (results.size === limit) {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => results);\r\n    }\r\n    newChangeBuffer(options) {\r\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\r\n    }\r\n    getSize(txn) {\r\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\r\n    }\r\n    getMetadata(txn) {\r\n        return documentGlobalStore(txn)\r\n            .get(DbRemoteDocumentGlobalKey)\r\n            .next(metadata => {\r\n            hardAssert(!!metadata);\r\n            return metadata;\r\n        });\r\n    }\r\n    setMetadata(txn, metadata) {\r\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobalKey, metadata);\r\n    }\r\n    /**\r\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\r\n     * the document corresponds to the format used for sentinel deletes).\r\n     */\r\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\r\n        if (dbRemoteDoc) {\r\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\r\n            // Whether the document is a sentinel removal and should only be used in the\r\n            // `getNewDocumentChanges()`\r\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\r\n            if (!isSentinelRemoval) {\r\n                return doc;\r\n            }\r\n        }\r\n        return MutableDocument.newInvalidDocument(documentKey);\r\n    }\r\n}\r\n/** Creates a new IndexedDbRemoteDocumentCache. */\r\nfunction newIndexedDbRemoteDocumentCache(serializer) {\r\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\r\n}\r\n/**\r\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\r\n *\r\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\r\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\r\n * when we apply the changes.\r\n */\r\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\r\n    /**\r\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\r\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\r\n     * `getNewDocumentChanges()`.\r\n     */\r\n    constructor(documentCache, trackRemovals) {\r\n        super();\r\n        this.documentCache = documentCache;\r\n        this.trackRemovals = trackRemovals;\r\n        // A map of document sizes and read times prior to applying the changes in\r\n        // this buffer.\r\n        this.documentStates = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n    }\r\n    applyChanges(transaction) {\r\n        const promises = [];\r\n        let sizeDelta = 0;\r\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\r\n        this.changes.forEach((key, documentChange) => {\r\n            const previousDoc = this.documentStates.get(key);\r\n            promises.push(this.documentCache.removeEntry(transaction, key, previousDoc.readTime));\r\n            if (documentChange.isValidDocument()) {\r\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\r\n                collectionParents = collectionParents.add(key.path.popLast());\r\n                const size = dbDocumentSize(doc);\r\n                sizeDelta += size - previousDoc.size;\r\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\r\n            }\r\n            else {\r\n                sizeDelta -= previousDoc.size;\r\n                if (this.trackRemovals) {\r\n                    // In order to track removals, we store a \"sentinel delete\" in the\r\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\r\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\r\n                    // preserved in `getNewDocumentChanges()`.\r\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\r\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\r\n                }\r\n            }\r\n        });\r\n        collectionParents.forEach(parent => {\r\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\r\n        });\r\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getFromCache(transaction, documentKey) {\r\n        // Record the size of everything we load from the cache so we can compute a delta later.\r\n        return this.documentCache\r\n            .getSizedEntry(transaction, documentKey)\r\n            .next(getResult => {\r\n            this.documentStates.set(documentKey, {\r\n                size: getResult.size,\r\n                readTime: getResult.document.readTime\r\n            });\r\n            return getResult.document;\r\n        });\r\n    }\r\n    getAllFromCache(transaction, documentKeys) {\r\n        // Record the size of everything we load from the cache so we can compute\r\n        // a delta later.\r\n        return this.documentCache\r\n            .getSizedEntries(transaction, documentKeys)\r\n            .next(({ documents, sizeMap }) => {\r\n            // Note: `getAllFromCache` returns two maps instead of a single map from\r\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\r\n            // `MutableDocumentMap` directly, without a conversion.\r\n            sizeMap.forEach((documentKey, size) => {\r\n                this.documentStates.set(documentKey, {\r\n                    size,\r\n                    readTime: documents.get(documentKey).readTime\r\n                });\r\n            });\r\n            return documents;\r\n        });\r\n    }\r\n}\r\nfunction documentGlobalStore(txn) {\r\n    return getStore(txn, DbRemoteDocumentGlobalStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\r\n */\r\nfunction remoteDocumentsStore(txn) {\r\n    return getStore(txn, DbRemoteDocumentStore);\r\n}\r\n/**\r\n * Returns a key that can be used for document lookups on the\r\n * `DbRemoteDocumentDocumentKeyIndex` index.\r\n */\r\nfunction dbKey(documentKey) {\r\n    const path = documentKey.path.toArray();\r\n    return [\r\n        /* prefix path */ path.slice(0, path.length - 2),\r\n        /* collection id */ path[path.length - 2],\r\n        /* document id */ path[path.length - 1]\r\n    ];\r\n}\r\n/**\r\n * Returns a key that can be used for document lookups via the primary key of\r\n * the DbRemoteDocument object store.\r\n */\r\nfunction dbReadTimeKey(documentKey, readTime) {\r\n    const path = documentKey.path.toArray();\r\n    return [\r\n        /* prefix path */ path.slice(0, path.length - 2),\r\n        /* collection id */ path[path.length - 2],\r\n        toDbTimestampKey(readTime),\r\n        /* document id */ path[path.length - 1]\r\n    ];\r\n}\r\n/**\r\n * Returns a key that can be used for document lookups on the\r\n * `DbRemoteDocumentDocumentCollectionGroupIndex` index.\r\n */\r\nfunction dbCollectionGroupKey(collectionGroup, offset) {\r\n    const path = offset.documentKey.path.toArray();\r\n    return [\r\n        /* collection id */ collectionGroup,\r\n        toDbTimestampKey(offset.readTime),\r\n        /* prefix path */ path.slice(0, path.length - 2),\r\n        /* document id */ path.length > 0 ? path[path.length - 1] : ''\r\n    ];\r\n}\r\n/**\r\n * Comparator that compares document keys according to the primary key sorting\r\n * used by the `DbRemoteDocumentDocument` store (by prefix path, collection id\r\n * and then document ID).\r\n *\r\n * Visible for testing.\r\n */\r\nfunction dbKeyComparator(l, r) {\r\n    const left = l.path.toArray();\r\n    const right = r.path.toArray();\r\n    // The ordering is based on https://chromium.googlesource.com/chromium/blink/+/fe5c21fef94dae71c1c3344775b8d8a7f7e6d9ec/Source/modules/indexeddb/IDBKey.cpp#74\r\n    let cmp = 0;\r\n    for (let i = 0; i < left.length - 2 && i < right.length - 2; ++i) {\r\n        cmp = primitiveComparator(left[i], right[i]);\r\n        if (cmp) {\r\n            return cmp;\r\n        }\r\n    }\r\n    cmp = primitiveComparator(left.length, right.length);\r\n    if (cmp) {\r\n        return cmp;\r\n    }\r\n    cmp = primitiveComparator(left[left.length - 2], right[right.length - 2]);\r\n    if (cmp) {\r\n        return cmp;\r\n    }\r\n    return primitiveComparator(left[left.length - 1], right[right.length - 1]);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Schema Version for the Web client:\r\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\r\n *     Document Cache\r\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\r\n *     longer required because migration 3 unconditionally clears it.\r\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\r\n *     to limbo resolution. Addresses\r\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\r\n * 4.  Multi-Tab Support.\r\n * 5.  Removal of held write acks.\r\n * 6.  Create document global for tracking document cache size.\r\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\r\n * 8.  Add collection-parent index for Collection Group queries.\r\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\r\n *     an auto-incrementing ID. This is required for Index-Free queries.\r\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\r\n * 11. Add bundles and named_queries for bundle support.\r\n * 12. Add document overlays.\r\n * 13. Rewrite the keys of the remote document cache to allow for efficient\r\n *     document lookup via `getAll()`.\r\n * 14. Add overlays.\r\n * 15. Add indexing support.\r\n * 16. Parse timestamp strings before creating index entries.\r\n */\r\nconst SCHEMA_VERSION = 16;\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a local view (overlay) of a document, and the fields that are\r\n * locally mutated.\r\n */\r\nclass OverlayedDocument {\r\n    constructor(overlayedDocument, \r\n    /**\r\n     * The fields that are locally mutated by patch mutations.\r\n     *\r\n     * If the overlayed\tdocument is from set or delete mutations, this is `null`.\r\n     * If there is no overlay (mutation) for the document, this is an empty `FieldMask`.\r\n     */\r\n    mutatedFields) {\r\n        this.overlayedDocument = overlayedDocument;\r\n        this.mutatedFields = mutatedFields;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A readonly view of the local state of all documents we're tracking (i.e. we\r\n * have a cached version in remoteDocumentCache or local mutations for the\r\n * document). The view is computed by applying the mutations in the\r\n * MutationQueue to the RemoteDocumentCache.\r\n */\r\nclass LocalDocumentsView {\r\n    constructor(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager) {\r\n        this.remoteDocumentCache = remoteDocumentCache;\r\n        this.mutationQueue = mutationQueue;\r\n        this.documentOverlayCache = documentOverlayCache;\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Get the local view of the document identified by `key`.\r\n     *\r\n     * @returns Local view of the document or null if we don't have any cached\r\n     * state for it.\r\n     */\r\n    getDocument(transaction, key) {\r\n        let overlay = null;\r\n        return this.documentOverlayCache\r\n            .getOverlay(transaction, key)\r\n            .next(value => {\r\n            overlay = value;\r\n            return this.remoteDocumentCache.getEntry(transaction, key);\r\n        })\r\n            .next(document => {\r\n            if (overlay !== null) {\r\n                mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\r\n            }\r\n            return document;\r\n        });\r\n    }\r\n    /**\r\n     * Gets the local view of the documents identified by `keys`.\r\n     *\r\n     * If we don't have cached state for a document in `keys`, a NoDocument will\r\n     * be stored for that key in the resulting set.\r\n     */\r\n    getDocuments(transaction, keys) {\r\n        return this.remoteDocumentCache\r\n            .getEntries(transaction, keys)\r\n            .next(docs => this.getLocalViewOfDocuments(transaction, docs, documentKeySet()).next(() => docs));\r\n    }\r\n    /**\r\n     * Similar to `getDocuments`, but creates the local view from the given\r\n     * `baseDocs` without retrieving documents from the local store.\r\n     *\r\n     * @param transaction - The transaction this operation is scoped to.\r\n     * @param docs - The documents to apply local mutations to get the local views.\r\n     * @param existenceStateChanged - The set of document keys whose existence state\r\n     *   is changed. This is useful to determine if some documents overlay needs\r\n     *   to be recalculated.\r\n     */\r\n    getLocalViewOfDocuments(transaction, docs, existenceStateChanged = documentKeySet()) {\r\n        const overlays = newOverlayMap();\r\n        return this.populateOverlays(transaction, overlays, docs).next(() => {\r\n            return this.computeViews(transaction, docs, overlays, existenceStateChanged).next(computeViewsResult => {\r\n                let result = documentMap();\r\n                computeViewsResult.forEach((documentKey, overlayedDocument) => {\r\n                    result = result.insert(documentKey, overlayedDocument.overlayedDocument);\r\n                });\r\n                return result;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Gets the overlayed documents for the given document map, which will include\r\n     * the local view of those documents and a `FieldMask` indicating which fields\r\n     * are mutated locally, `null` if overlay is a Set or Delete mutation.\r\n     */\r\n    getOverlayedDocuments(transaction, docs) {\r\n        const overlays = newOverlayMap();\r\n        return this.populateOverlays(transaction, overlays, docs).next(() => this.computeViews(transaction, docs, overlays, documentKeySet()));\r\n    }\r\n    /**\r\n     * Fetches the overlays for {@code docs} and adds them to provided overlay map\r\n     * if the map does not already contain an entry for the given document key.\r\n     */\r\n    populateOverlays(transaction, overlays, docs) {\r\n        const missingOverlays = [];\r\n        docs.forEach(key => {\r\n            if (!overlays.has(key)) {\r\n                missingOverlays.push(key);\r\n            }\r\n        });\r\n        return this.documentOverlayCache\r\n            .getOverlays(transaction, missingOverlays)\r\n            .next(result => {\r\n            result.forEach((key, val) => {\r\n                overlays.set(key, val);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Computes the local view for the given documents.\r\n     *\r\n     * @param docs - The documents to compute views for. It also has the base\r\n     *   version of the documents.\r\n     * @param overlays - The overlays that need to be applied to the given base\r\n     *   version of the documents.\r\n     * @param existenceStateChanged - A set of documents whose existence states\r\n     *   might have changed. This is used to determine if we need to re-calculate\r\n     *   overlays from mutation queues.\r\n     * @return A map represents the local documents view.\r\n     */\r\n    computeViews(transaction, docs, overlays, existenceStateChanged) {\r\n        let recalculateDocuments = mutableDocumentMap();\r\n        const mutatedFields = newDocumentKeyMap();\r\n        const results = newOverlayedDocumentMap();\r\n        docs.forEach((_, doc) => {\r\n            const overlay = overlays.get(doc.key);\r\n            // Recalculate an overlay if the document's existence state changed due to\r\n            // a remote event *and* the overlay is a PatchMutation. This is because\r\n            // document existence state can change if some patch mutation's\r\n            // preconditions are met.\r\n            // NOTE: we recalculate when `overlay` is undefined as well, because there\r\n            // might be a patch mutation whose precondition does not match before the\r\n            // change (hence overlay is undefined), but would now match.\r\n            if (existenceStateChanged.has(doc.key) &&\r\n                (overlay === undefined || overlay.mutation instanceof PatchMutation)) {\r\n                recalculateDocuments = recalculateDocuments.insert(doc.key, doc);\r\n            }\r\n            else if (overlay !== undefined) {\r\n                mutatedFields.set(doc.key, overlay.mutation.getFieldMask());\r\n                mutationApplyToLocalView(overlay.mutation, doc, overlay.mutation.getFieldMask(), Timestamp.now());\r\n            }\r\n            else {\r\n                // no overlay exists\r\n                // Using EMPTY to indicate there is no overlay for the document.\r\n                mutatedFields.set(doc.key, FieldMask.empty());\r\n            }\r\n        });\r\n        return this.recalculateAndSaveOverlays(transaction, recalculateDocuments).next(recalculatedFields => {\r\n            recalculatedFields.forEach((documentKey, mask) => mutatedFields.set(documentKey, mask));\r\n            docs.forEach((documentKey, document) => {\r\n                var _a;\r\n                return results.set(documentKey, new OverlayedDocument(document, (_a = mutatedFields.get(documentKey)) !== null && _a !== void 0 ? _a : null));\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n    recalculateAndSaveOverlays(transaction, docs) {\r\n        const masks = newDocumentKeyMap();\r\n        // A reverse lookup map from batch id to the documents within that batch.\r\n        let documentsByBatchId = new SortedMap((key1, key2) => key1 - key2);\r\n        let processed = documentKeySet();\r\n        return this.mutationQueue\r\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, docs)\r\n            .next(batches => {\r\n            for (const batch of batches) {\r\n                batch.keys().forEach(key => {\r\n                    const baseDoc = docs.get(key);\r\n                    if (baseDoc === null) {\r\n                        return;\r\n                    }\r\n                    let mask = masks.get(key) || FieldMask.empty();\r\n                    mask = batch.applyToLocalView(baseDoc, mask);\r\n                    masks.set(key, mask);\r\n                    const newSet = (documentsByBatchId.get(batch.batchId) || documentKeySet()).add(key);\r\n                    documentsByBatchId = documentsByBatchId.insert(batch.batchId, newSet);\r\n                });\r\n            }\r\n        })\r\n            .next(() => {\r\n            const promises = [];\r\n            // Iterate in descending order of batch IDs, and skip documents that are\r\n            // already saved.\r\n            const iter = documentsByBatchId.getReverseIterator();\r\n            while (iter.hasNext()) {\r\n                const entry = iter.getNext();\r\n                const batchId = entry.key;\r\n                const keys = entry.value;\r\n                const overlays = newMutationMap();\r\n                keys.forEach(key => {\r\n                    if (!processed.has(key)) {\r\n                        const overlayMutation = calculateOverlayMutation(docs.get(key), masks.get(key));\r\n                        if (overlayMutation !== null) {\r\n                            overlays.set(key, overlayMutation);\r\n                        }\r\n                        processed = processed.add(key);\r\n                    }\r\n                });\r\n                promises.push(this.documentOverlayCache.saveOverlays(transaction, batchId, overlays));\r\n            }\r\n            return PersistencePromise.waitFor(promises);\r\n        })\r\n            .next(() => masks);\r\n    }\r\n    /**\r\n     * Recalculates overlays by reading the documents from remote document cache\r\n     * first, and saves them after they are calculated.\r\n     */\r\n    recalculateAndSaveOverlaysForDocumentKeys(transaction, documentKeys) {\r\n        return this.remoteDocumentCache\r\n            .getEntries(transaction, documentKeys)\r\n            .next(docs => this.recalculateAndSaveOverlays(transaction, docs));\r\n    }\r\n    /**\r\n     * Performs a query against the local view of all documents.\r\n     *\r\n     * @param transaction - The persistence transaction.\r\n     * @param query - The query to match documents against.\r\n     * @param offset - Read time and key to start scanning by (exclusive).\r\n     * @param context - A optional tracker to keep a record of important details\r\n     *   during database local query execution.\r\n     */\r\n    getDocumentsMatchingQuery(transaction, query, offset, context) {\r\n        if (isDocumentQuery$1(query)) {\r\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\r\n        }\r\n        else if (isCollectionGroupQuery(query)) {\r\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context);\r\n        }\r\n        else {\r\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, offset, context);\r\n        }\r\n    }\r\n    /**\r\n     * Given a collection group, returns the next documents that follow the provided offset, along\r\n     * with an updated batch ID.\r\n     *\r\n     * <p>The documents returned by this method are ordered by remote version from the provided\r\n     * offset. If there are no more remote documents after the provided offset, documents with\r\n     * mutations in order of batch id from the offset are returned. Since all documents in a batch are\r\n     * returned together, the total number of documents returned can exceed {@code count}.\r\n     *\r\n     * @param transaction\r\n     * @param collectionGroup The collection group for the documents.\r\n     * @param offset The offset to index into.\r\n     * @param count The number of documents to return\r\n     * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.\r\n     */\r\n    getNextDocuments(transaction, collectionGroup, offset, count) {\r\n        return this.remoteDocumentCache\r\n            .getAllFromCollectionGroup(transaction, collectionGroup, offset, count)\r\n            .next((originalDocs) => {\r\n            const overlaysPromise = count - originalDocs.size > 0\r\n                ? this.documentOverlayCache.getOverlaysForCollectionGroup(transaction, collectionGroup, offset.largestBatchId, count - originalDocs.size)\r\n                : PersistencePromise.resolve(newOverlayMap());\r\n            // The callsite will use the largest batch ID together with the latest read time to create\r\n            // a new index offset. Since we only process batch IDs if all remote documents have been read,\r\n            // no overlay will increase the overall read time. This is why we only need to special case\r\n            // the batch id.\r\n            let largestBatchId = INITIAL_LARGEST_BATCH_ID;\r\n            let modifiedDocs = originalDocs;\r\n            return overlaysPromise.next(overlays => {\r\n                return PersistencePromise.forEach(overlays, (key, overlay) => {\r\n                    if (largestBatchId < overlay.largestBatchId) {\r\n                        largestBatchId = overlay.largestBatchId;\r\n                    }\r\n                    if (originalDocs.get(key)) {\r\n                        return PersistencePromise.resolve();\r\n                    }\r\n                    return this.remoteDocumentCache\r\n                        .getEntry(transaction, key)\r\n                        .next(doc => {\r\n                        modifiedDocs = modifiedDocs.insert(key, doc);\r\n                    });\r\n                })\r\n                    .next(() => this.populateOverlays(transaction, overlays, originalDocs))\r\n                    .next(() => this.computeViews(transaction, modifiedDocs, overlays, documentKeySet()))\r\n                    .next(localDocs => ({\r\n                    batchId: largestBatchId,\r\n                    changes: convertOverlayedDocumentMapToDocumentMap(localDocs)\r\n                }));\r\n            });\r\n        });\r\n    }\r\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\r\n        // Just do a simple document lookup.\r\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\r\n            let result = documentMap();\r\n            if (document.isFoundDocument()) {\r\n                result = result.insert(document.key, document);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context) {\r\n        const collectionId = query.collectionGroup;\r\n        let results = documentMap();\r\n        return this.indexManager\r\n            .getCollectionParents(transaction, collectionId)\r\n            .next(parents => {\r\n            // Perform a collection query against each parent that contains the\r\n            // collectionId and aggregate the results.\r\n            return PersistencePromise.forEach(parents, (parent) => {\r\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\r\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, offset, context).next(r => {\r\n                    r.forEach((key, doc) => {\r\n                        results = results.insert(key, doc);\r\n                    });\r\n                });\r\n            }).next(() => results);\r\n        });\r\n    }\r\n    getDocumentsMatchingCollectionQuery(transaction, query, offset, context) {\r\n        // Query the remote documents and overlay mutations.\r\n        let overlays;\r\n        return this.documentOverlayCache\r\n            .getOverlaysForCollection(transaction, query.path, offset.largestBatchId)\r\n            .next(result => {\r\n            overlays = result;\r\n            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query, offset, overlays, context);\r\n        })\r\n            .next(remoteDocuments => {\r\n            // As documents might match the query because of their overlay we need to\r\n            // include documents for all overlays in the initial document set.\r\n            overlays.forEach((_, overlay) => {\r\n                const key = overlay.getKey();\r\n                if (remoteDocuments.get(key) === null) {\r\n                    remoteDocuments = remoteDocuments.insert(key, MutableDocument.newInvalidDocument(key));\r\n                }\r\n            });\r\n            // Apply the overlays and match against the query.\r\n            let results = documentMap();\r\n            remoteDocuments.forEach((key, document) => {\r\n                const overlay = overlays.get(key);\r\n                if (overlay !== undefined) {\r\n                    mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\r\n                }\r\n                // Finally, insert the documents that still match the query\r\n                if (queryMatches(query, document)) {\r\n                    results = results.insert(key, document);\r\n                }\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryBundleCache {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n        this.bundles = new Map();\r\n        this.namedQueries = new Map();\r\n    }\r\n    getBundleMetadata(transaction, bundleId) {\r\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\r\n    }\r\n    saveBundleMetadata(transaction, bundleMetadata) {\r\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getNamedQuery(transaction, queryName) {\r\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\r\n    }\r\n    saveNamedQuery(transaction, query) {\r\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\r\n        return PersistencePromise.resolve();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory implementation of DocumentOverlayCache.\r\n */\r\nclass MemoryDocumentOverlayCache {\r\n    constructor() {\r\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\r\n        // for the overlay and the overlay itself.\r\n        this.overlays = new SortedMap(DocumentKey.comparator);\r\n        this.overlayByBatchId = new Map();\r\n    }\r\n    getOverlay(transaction, key) {\r\n        return PersistencePromise.resolve(this.overlays.get(key));\r\n    }\r\n    getOverlays(transaction, keys) {\r\n        const result = newOverlayMap();\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            return this.getOverlay(transaction, key).next(overlay => {\r\n                if (overlay !== null) {\r\n                    result.set(key, overlay);\r\n                }\r\n            });\r\n        }).next(() => result);\r\n    }\r\n    saveOverlays(transaction, largestBatchId, overlays) {\r\n        overlays.forEach((_, mutation) => {\r\n            this.saveOverlay(transaction, largestBatchId, mutation);\r\n        });\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\r\n        const keys = this.overlayByBatchId.get(batchId);\r\n        if (keys !== undefined) {\r\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\r\n            this.overlayByBatchId.delete(batchId);\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\r\n        const result = newOverlayMap();\r\n        const immediateChildrenPathLength = collection.length + 1;\r\n        const prefix = new DocumentKey(collection.child(''));\r\n        const iter = this.overlays.getIteratorFrom(prefix);\r\n        while (iter.hasNext()) {\r\n            const entry = iter.getNext();\r\n            const overlay = entry.value;\r\n            const key = overlay.getKey();\r\n            if (!collection.isPrefixOf(key.path)) {\r\n                break;\r\n            }\r\n            // Documents from sub-collections\r\n            if (key.path.length !== immediateChildrenPathLength) {\r\n                continue;\r\n            }\r\n            if (overlay.largestBatchId > sinceBatchId) {\r\n                result.set(overlay.getKey(), overlay);\r\n            }\r\n        }\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\r\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\r\n        const iter = this.overlays.getIterator();\r\n        while (iter.hasNext()) {\r\n            const entry = iter.getNext();\r\n            const overlay = entry.value;\r\n            const key = overlay.getKey();\r\n            if (key.getCollectionGroup() !== collectionGroup) {\r\n                continue;\r\n            }\r\n            if (overlay.largestBatchId > sinceBatchId) {\r\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\r\n                if (overlaysForBatchId === null) {\r\n                    overlaysForBatchId = newOverlayMap();\r\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\r\n                }\r\n                overlaysForBatchId.set(overlay.getKey(), overlay);\r\n            }\r\n        }\r\n        const result = newOverlayMap();\r\n        const batchIter = batchIdToOverlays.getIterator();\r\n        while (batchIter.hasNext()) {\r\n            const entry = batchIter.getNext();\r\n            const overlays = entry.value;\r\n            overlays.forEach((key, overlay) => result.set(key, overlay));\r\n            if (result.size() >= count) {\r\n                break;\r\n            }\r\n        }\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    saveOverlay(transaction, largestBatchId, mutation) {\r\n        // Remove the association of the overlay to its batch id.\r\n        const existing = this.overlays.get(mutation.key);\r\n        if (existing !== null) {\r\n            const newSet = this.overlayByBatchId\r\n                .get(existing.largestBatchId)\r\n                .delete(mutation.key);\r\n            this.overlayByBatchId.set(existing.largestBatchId, newSet);\r\n        }\r\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\r\n        // Create the association of this overlay to the given largestBatchId.\r\n        let batch = this.overlayByBatchId.get(largestBatchId);\r\n        if (batch === undefined) {\r\n            batch = documentKeySet();\r\n            this.overlayByBatchId.set(largestBatchId, batch);\r\n        }\r\n        this.overlayByBatchId.set(largestBatchId, batch.add(mutation.key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A collection of references to a document from some kind of numbered entity\r\n * (either a target ID or batch ID). As references are added to or removed from\r\n * the set corresponding events are emitted to a registered garbage collector.\r\n *\r\n * Each reference is represented by a DocumentReference object. Each of them\r\n * contains enough information to uniquely identify the reference. They are all\r\n * stored primarily in a set sorted by key. A document is considered garbage if\r\n * there's no references in that set (this can be efficiently checked thanks to\r\n * sorting by key).\r\n *\r\n * ReferenceSet also keeps a secondary set that contains references sorted by\r\n * IDs. This one is used to efficiently implement removal of all references by\r\n * some target ID.\r\n */\r\nclass ReferenceSet {\r\n    constructor() {\r\n        // A set of outstanding references to a document sorted by key.\r\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\r\n        // A set of outstanding references to a document sorted by target id.\r\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\r\n    }\r\n    /** Returns true if the reference set contains no references. */\r\n    isEmpty() {\r\n        return this.refsByKey.isEmpty();\r\n    }\r\n    /** Adds a reference to the given document key for the given ID. */\r\n    addReference(key, id) {\r\n        const ref = new DocReference(key, id);\r\n        this.refsByKey = this.refsByKey.add(ref);\r\n        this.refsByTarget = this.refsByTarget.add(ref);\r\n    }\r\n    /** Add references to the given document keys for the given ID. */\r\n    addReferences(keys, id) {\r\n        keys.forEach(key => this.addReference(key, id));\r\n    }\r\n    /**\r\n     * Removes a reference to the given document key for the given\r\n     * ID.\r\n     */\r\n    removeReference(key, id) {\r\n        this.removeRef(new DocReference(key, id));\r\n    }\r\n    removeReferences(keys, id) {\r\n        keys.forEach(key => this.removeReference(key, id));\r\n    }\r\n    /**\r\n     * Clears all references with a given ID. Calls removeRef() for each key\r\n     * removed.\r\n     */\r\n    removeReferencesForId(id) {\r\n        const emptyKey = new DocumentKey(new ResourcePath([]));\r\n        const startRef = new DocReference(emptyKey, id);\r\n        const endRef = new DocReference(emptyKey, id + 1);\r\n        const keys = [];\r\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\r\n            this.removeRef(ref);\r\n            keys.push(ref.key);\r\n        });\r\n        return keys;\r\n    }\r\n    removeAllReferences() {\r\n        this.refsByKey.forEach(ref => this.removeRef(ref));\r\n    }\r\n    removeRef(ref) {\r\n        this.refsByKey = this.refsByKey.delete(ref);\r\n        this.refsByTarget = this.refsByTarget.delete(ref);\r\n    }\r\n    referencesForId(id) {\r\n        const emptyKey = new DocumentKey(new ResourcePath([]));\r\n        const startRef = new DocReference(emptyKey, id);\r\n        const endRef = new DocReference(emptyKey, id + 1);\r\n        let keys = documentKeySet();\r\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\r\n            keys = keys.add(ref.key);\r\n        });\r\n        return keys;\r\n    }\r\n    containsKey(key) {\r\n        const ref = new DocReference(key, 0);\r\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\r\n        return firstRef !== null && key.isEqual(firstRef.key);\r\n    }\r\n}\r\nclass DocReference {\r\n    constructor(key, targetOrBatchId) {\r\n        this.key = key;\r\n        this.targetOrBatchId = targetOrBatchId;\r\n    }\r\n    /** Compare by key then by ID */\r\n    static compareByKey(left, right) {\r\n        return (DocumentKey.comparator(left.key, right.key) ||\r\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\r\n    }\r\n    /** Compare by ID then by key */\r\n    static compareByTargetId(left, right) {\r\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\r\n            DocumentKey.comparator(left.key, right.key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryMutationQueue {\r\n    constructor(indexManager, referenceDelegate) {\r\n        this.indexManager = indexManager;\r\n        this.referenceDelegate = referenceDelegate;\r\n        /**\r\n         * The set of all mutations that have been sent but not yet been applied to\r\n         * the backend.\r\n         */\r\n        this.mutationQueue = [];\r\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\r\n        this.nextBatchId = 1;\r\n        /** An ordered mapping between documents and the mutations batch IDs. */\r\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\r\n    }\r\n    checkEmpty(transaction) {\r\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\r\n    }\r\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\r\n        const batchId = this.nextBatchId;\r\n        this.nextBatchId++;\r\n        if (this.mutationQueue.length > 0) {\r\n            this.mutationQueue[this.mutationQueue.length - 1];\r\n        }\r\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\r\n        this.mutationQueue.push(batch);\r\n        // Track references by document key and index collection parents.\r\n        for (const mutation of mutations) {\r\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\r\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\r\n        }\r\n        return PersistencePromise.resolve(batch);\r\n    }\r\n    lookupMutationBatch(transaction, batchId) {\r\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\r\n    }\r\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\r\n        const nextBatchId = batchId + 1;\r\n        // The requested batchId may still be out of range so normalize it to the\r\n        // start of the queue.\r\n        const rawIndex = this.indexOfBatchId(nextBatchId);\r\n        const index = rawIndex < 0 ? 0 : rawIndex;\r\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\r\n    }\r\n    getHighestUnacknowledgedBatchId() {\r\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\r\n    }\r\n    getAllMutationBatches(transaction) {\r\n        return PersistencePromise.resolve(this.mutationQueue.slice());\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\r\n        const start = new DocReference(documentKey, 0);\r\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\r\n        const result = [];\r\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\r\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\r\n            result.push(batch);\r\n        });\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        documentKeys.forEach(documentKey => {\r\n            const start = new DocReference(documentKey, 0);\r\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\r\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\r\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\r\n            });\r\n        });\r\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\r\n    }\r\n    getAllMutationBatchesAffectingQuery(transaction, query) {\r\n        // Use the query path as a prefix for testing if a document matches the\r\n        // query.\r\n        const prefix = query.path;\r\n        const immediateChildrenPathLength = prefix.length + 1;\r\n        // Construct a document reference for actually scanning the index. Unlike\r\n        // the prefix the document key in this reference must have an even number of\r\n        // segments. The empty segment can be used a suffix of the query path\r\n        // because it precedes all other segments in an ordered traversal.\r\n        let startPath = prefix;\r\n        if (!DocumentKey.isDocumentKey(startPath)) {\r\n            startPath = startPath.child('');\r\n        }\r\n        const start = new DocReference(new DocumentKey(startPath), 0);\r\n        // Find unique batchIDs referenced by all documents potentially matching the\r\n        // query.\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        this.batchesByDocumentKey.forEachWhile(ref => {\r\n            const rowKeyPath = ref.key.path;\r\n            if (!prefix.isPrefixOf(rowKeyPath)) {\r\n                return false;\r\n            }\r\n            else {\r\n                // Rows with document keys more than one segment longer than the query\r\n                // path can't be matches. For example, a query on 'rooms' can't match\r\n                // the document /rooms/abc/messages/xyx.\r\n                // TODO(mcg): we'll need a different scanner when we implement\r\n                // ancestor queries.\r\n                if (rowKeyPath.length === immediateChildrenPathLength) {\r\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\r\n                }\r\n                return true;\r\n            }\r\n        }, start);\r\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\r\n    }\r\n    findMutationBatches(batchIDs) {\r\n        // Construct an array of matching batches, sorted by batchID to ensure that\r\n        // multiple mutations affecting the same document key are applied in order.\r\n        const result = [];\r\n        batchIDs.forEach(batchId => {\r\n            const batch = this.findMutationBatch(batchId);\r\n            if (batch !== null) {\r\n                result.push(batch);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    removeMutationBatch(transaction, batch) {\r\n        // Find the position of the first batch for removal.\r\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\r\n        hardAssert(batchIndex === 0);\r\n        this.mutationQueue.shift();\r\n        let references = this.batchesByDocumentKey;\r\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\r\n            const ref = new DocReference(mutation.key, batch.batchId);\r\n            references = references.delete(ref);\r\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\r\n        }).next(() => {\r\n            this.batchesByDocumentKey = references;\r\n        });\r\n    }\r\n    removeCachedMutationKeys(batchId) {\r\n        // No-op since the memory mutation queue does not maintain a separate cache.\r\n    }\r\n    containsKey(txn, key) {\r\n        const ref = new DocReference(key, 0);\r\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\r\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\r\n    }\r\n    performConsistencyCheck(txn) {\r\n        if (this.mutationQueue.length === 0) ;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    /**\r\n     * Finds the index of the given batchId in the mutation queue and asserts that\r\n     * the resulting index is within the bounds of the queue.\r\n     *\r\n     * @param batchId - The batchId to search for\r\n     * @param action - A description of what the caller is doing, phrased in passive\r\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\r\n     */\r\n    indexOfExistingBatchId(batchId, action) {\r\n        const index = this.indexOfBatchId(batchId);\r\n        return index;\r\n    }\r\n    /**\r\n     * Finds the index of the given batchId in the mutation queue. This operation\r\n     * is O(1).\r\n     *\r\n     * @returns The computed index of the batch with the given batchId, based on\r\n     * the state of the queue. Note this index can be negative if the requested\r\n     * batchId has already been remvoed from the queue or past the end of the\r\n     * queue if the batchId is larger than the last added batch.\r\n     */\r\n    indexOfBatchId(batchId) {\r\n        if (this.mutationQueue.length === 0) {\r\n            // As an index this is past the end of the queue\r\n            return 0;\r\n        }\r\n        // Examine the front of the queue to figure out the difference between the\r\n        // batchId and indexes in the array. Note that since the queue is ordered\r\n        // by batchId, if the first batch has a larger batchId then the requested\r\n        // batchId doesn't exist in the queue.\r\n        const firstBatchId = this.mutationQueue[0].batchId;\r\n        return batchId - firstBatchId;\r\n    }\r\n    /**\r\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\r\n     * other functions that uses this code easier to read and more efficent.\r\n     */\r\n    findMutationBatch(batchId) {\r\n        const index = this.indexOfBatchId(batchId);\r\n        if (index < 0 || index >= this.mutationQueue.length) {\r\n            return null;\r\n        }\r\n        const batch = this.mutationQueue[index];\r\n        return batch;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction documentEntryMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\n/**\r\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\r\n * `newMemoryRemoteDocumentCache()`.\r\n */\r\nclass MemoryRemoteDocumentCacheImpl {\r\n    /**\r\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\r\n     * expected to just return 0 to avoid unnecessarily doing the work of\r\n     * calculating the size.\r\n     */\r\n    constructor(sizer) {\r\n        this.sizer = sizer;\r\n        /** Underlying cache of documents and their read times. */\r\n        this.docs = documentEntryMap();\r\n        /** Size of all cached documents. */\r\n        this.size = 0;\r\n    }\r\n    setIndexManager(indexManager) {\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\r\n     *\r\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()`.\r\n     */\r\n    addEntry(transaction, doc) {\r\n        const key = doc.key;\r\n        const entry = this.docs.get(key);\r\n        const previousSize = entry ? entry.size : 0;\r\n        const currentSize = this.sizer(doc);\r\n        this.docs = this.docs.insert(key, {\r\n            document: doc.mutableCopy(),\r\n            size: currentSize\r\n        });\r\n        this.size += currentSize - previousSize;\r\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\r\n    }\r\n    /**\r\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\r\n     *\r\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()`.\r\n     */\r\n    removeEntry(documentKey) {\r\n        const entry = this.docs.get(documentKey);\r\n        if (entry) {\r\n            this.docs = this.docs.remove(documentKey);\r\n            this.size -= entry.size;\r\n        }\r\n    }\r\n    getEntry(transaction, documentKey) {\r\n        const entry = this.docs.get(documentKey);\r\n        return PersistencePromise.resolve(entry\r\n            ? entry.document.mutableCopy()\r\n            : MutableDocument.newInvalidDocument(documentKey));\r\n    }\r\n    getEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        documentKeys.forEach(documentKey => {\r\n            const entry = this.docs.get(documentKey);\r\n            results = results.insert(documentKey, entry\r\n                ? entry.document.mutableCopy()\r\n                : MutableDocument.newInvalidDocument(documentKey));\r\n        });\r\n        return PersistencePromise.resolve(results);\r\n    }\r\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs) {\r\n        let results = mutableDocumentMap();\r\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\r\n        // the documents we need to match the query against.\r\n        const collectionPath = query.path;\r\n        const prefix = new DocumentKey(collectionPath.child(''));\r\n        const iterator = this.docs.getIteratorFrom(prefix);\r\n        while (iterator.hasNext()) {\r\n            const { key, value: { document } } = iterator.getNext();\r\n            if (!collectionPath.isPrefixOf(key.path)) {\r\n                break;\r\n            }\r\n            if (key.path.length > collectionPath.length + 1) {\r\n                // Exclude entries from subcollections.\r\n                continue;\r\n            }\r\n            if (indexOffsetComparator(newIndexOffsetFromDocument(document), offset) <= 0) {\r\n                // The document sorts before the offset.\r\n                continue;\r\n            }\r\n            if (!mutatedDocs.has(document.key) && !queryMatches(query, document)) {\r\n                // The document cannot possibly match the query.\r\n                continue;\r\n            }\r\n            results = results.insert(document.key, document.mutableCopy());\r\n        }\r\n        return PersistencePromise.resolve(results);\r\n    }\r\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limti) {\r\n        // This method should only be called from the IndexBackfiller if persistence\r\n        // is enabled.\r\n        fail();\r\n    }\r\n    forEachDocumentKey(transaction, f) {\r\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\r\n    }\r\n    newChangeBuffer(options) {\r\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\r\n        // a separate changelog and does not need special handling for removals.\r\n        return new MemoryRemoteDocumentChangeBuffer(this);\r\n    }\r\n    getSize(txn) {\r\n        return PersistencePromise.resolve(this.size);\r\n    }\r\n}\r\n/**\r\n * Creates a new memory-only RemoteDocumentCache.\r\n *\r\n * @param sizer - Used to assess the size of a document. For eager GC, this is\r\n * expected to just return 0 to avoid unnecessarily doing the work of\r\n * calculating the size.\r\n */\r\nfunction newMemoryRemoteDocumentCache(sizer) {\r\n    return new MemoryRemoteDocumentCacheImpl(sizer);\r\n}\r\n/**\r\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\r\n */\r\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\r\n    constructor(documentCache) {\r\n        super();\r\n        this.documentCache = documentCache;\r\n    }\r\n    applyChanges(transaction) {\r\n        const promises = [];\r\n        this.changes.forEach((key, doc) => {\r\n            if (doc.isValidDocument()) {\r\n                promises.push(this.documentCache.addEntry(transaction, doc));\r\n            }\r\n            else {\r\n                this.documentCache.removeEntry(key);\r\n            }\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getFromCache(transaction, documentKey) {\r\n        return this.documentCache.getEntry(transaction, documentKey);\r\n    }\r\n    getAllFromCache(transaction, documentKeys) {\r\n        return this.documentCache.getEntries(transaction, documentKeys);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryTargetCache {\r\n    constructor(persistence) {\r\n        this.persistence = persistence;\r\n        /**\r\n         * Maps a target to the data about that target\r\n         */\r\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\r\n        /** The last received snapshot version. */\r\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\r\n        /** The highest numbered target ID encountered. */\r\n        this.highestTargetId = 0;\r\n        /** The highest sequence number encountered. */\r\n        this.highestSequenceNumber = 0;\r\n        /**\r\n         * A ordered bidirectional mapping between documents and the remote target\r\n         * IDs.\r\n         */\r\n        this.references = new ReferenceSet();\r\n        this.targetCount = 0;\r\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\r\n    }\r\n    forEachTarget(txn, f) {\r\n        this.targets.forEach((_, targetData) => f(targetData));\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getLastRemoteSnapshotVersion(transaction) {\r\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\r\n    }\r\n    getHighestSequenceNumber(transaction) {\r\n        return PersistencePromise.resolve(this.highestSequenceNumber);\r\n    }\r\n    allocateTargetId(transaction) {\r\n        this.highestTargetId = this.targetIdGenerator.next();\r\n        return PersistencePromise.resolve(this.highestTargetId);\r\n    }\r\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\r\n        if (lastRemoteSnapshotVersion) {\r\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\r\n        }\r\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\r\n            this.highestSequenceNumber = highestListenSequenceNumber;\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    saveTargetData(targetData) {\r\n        this.targets.set(targetData.target, targetData);\r\n        const targetId = targetData.targetId;\r\n        if (targetId > this.highestTargetId) {\r\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\r\n            this.highestTargetId = targetId;\r\n        }\r\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\r\n            this.highestSequenceNumber = targetData.sequenceNumber;\r\n        }\r\n    }\r\n    addTargetData(transaction, targetData) {\r\n        this.saveTargetData(targetData);\r\n        this.targetCount += 1;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateTargetData(transaction, targetData) {\r\n        this.saveTargetData(targetData);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTargetData(transaction, targetData) {\r\n        this.targets.delete(targetData.target);\r\n        this.references.removeReferencesForId(targetData.targetId);\r\n        this.targetCount -= 1;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTargets(transaction, upperBound, activeTargetIds) {\r\n        let count = 0;\r\n        const removals = [];\r\n        this.targets.forEach((key, targetData) => {\r\n            if (targetData.sequenceNumber <= upperBound &&\r\n                activeTargetIds.get(targetData.targetId) === null) {\r\n                this.targets.delete(key);\r\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\r\n                count++;\r\n            }\r\n        });\r\n        return PersistencePromise.waitFor(removals).next(() => count);\r\n    }\r\n    getTargetCount(transaction) {\r\n        return PersistencePromise.resolve(this.targetCount);\r\n    }\r\n    getTargetData(transaction, target) {\r\n        const targetData = this.targets.get(target) || null;\r\n        return PersistencePromise.resolve(targetData);\r\n    }\r\n    addMatchingKeys(txn, keys, targetId) {\r\n        this.references.addReferences(keys, targetId);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeMatchingKeys(txn, keys, targetId) {\r\n        this.references.removeReferences(keys, targetId);\r\n        const referenceDelegate = this.persistence.referenceDelegate;\r\n        const promises = [];\r\n        if (referenceDelegate) {\r\n            keys.forEach(key => {\r\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\r\n            });\r\n        }\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeMatchingKeysForTargetId(txn, targetId) {\r\n        this.references.removeReferencesForId(targetId);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getMatchingKeysForTargetId(txn, targetId) {\r\n        const matchingKeys = this.references.referencesForId(targetId);\r\n        return PersistencePromise.resolve(matchingKeys);\r\n    }\r\n    containsKey(txn, key) {\r\n        return PersistencePromise.resolve(this.references.containsKey(key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$d = 'MemoryPersistence';\r\n/**\r\n * A memory-backed instance of Persistence. Data is stored only in RAM and\r\n * not persisted across sessions.\r\n */\r\nclass MemoryPersistence {\r\n    /**\r\n     * The constructor accepts a factory for creating a reference delegate. This\r\n     * allows both the delegate and this instance to have strong references to\r\n     * each other without having nullable fields that would then need to be\r\n     * checked or asserted on every access.\r\n     */\r\n    constructor(referenceDelegateFactory, serializer) {\r\n        this.mutationQueues = {};\r\n        this.overlays = {};\r\n        this.listenSequence = new ListenSequence(0);\r\n        this._started = false;\r\n        this._started = true;\r\n        this.referenceDelegate = referenceDelegateFactory(this);\r\n        this.targetCache = new MemoryTargetCache(this);\r\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\r\n        this.indexManager = new MemoryIndexManager();\r\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\r\n        this.serializer = new LocalSerializer(serializer);\r\n        this.bundleCache = new MemoryBundleCache(this.serializer);\r\n    }\r\n    start() {\r\n        return Promise.resolve();\r\n    }\r\n    shutdown() {\r\n        // No durable state to ensure is closed on shutdown.\r\n        this._started = false;\r\n        return Promise.resolve();\r\n    }\r\n    get started() {\r\n        return this._started;\r\n    }\r\n    setDatabaseDeletedListener() {\r\n        // No op.\r\n    }\r\n    setNetworkEnabled() {\r\n        // No op.\r\n    }\r\n    getIndexManager(user) {\r\n        // We do not currently support indices for memory persistence, so we can\r\n        // return the same shared instance of the memory index manager.\r\n        return this.indexManager;\r\n    }\r\n    getDocumentOverlayCache(user) {\r\n        let overlay = this.overlays[user.toKey()];\r\n        if (!overlay) {\r\n            overlay = new MemoryDocumentOverlayCache();\r\n            this.overlays[user.toKey()] = overlay;\r\n        }\r\n        return overlay;\r\n    }\r\n    getMutationQueue(user, indexManager) {\r\n        let queue = this.mutationQueues[user.toKey()];\r\n        if (!queue) {\r\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\r\n            this.mutationQueues[user.toKey()] = queue;\r\n        }\r\n        return queue;\r\n    }\r\n    getTargetCache() {\r\n        return this.targetCache;\r\n    }\r\n    getRemoteDocumentCache() {\r\n        return this.remoteDocumentCache;\r\n    }\r\n    getBundleCache() {\r\n        return this.bundleCache;\r\n    }\r\n    runTransaction(action, mode, transactionOperation) {\r\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\r\n        const txn = new MemoryTransaction(this.listenSequence.next());\r\n        this.referenceDelegate.onTransactionStarted();\r\n        return transactionOperation(txn)\r\n            .next(result => {\r\n            return this.referenceDelegate\r\n                .onTransactionCommitted(txn)\r\n                .next(() => result);\r\n        })\r\n            .toPromise()\r\n            .then(result => {\r\n            txn.raiseOnCommittedEvent();\r\n            return result;\r\n        });\r\n    }\r\n    mutationQueuesContainKey(transaction, key) {\r\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\r\n    }\r\n}\r\n/**\r\n * Memory persistence is not actually transactional, but future implementations\r\n * may have transaction-scoped state.\r\n */\r\nclass MemoryTransaction extends PersistenceTransaction {\r\n    constructor(currentSequenceNumber) {\r\n        super();\r\n        this.currentSequenceNumber = currentSequenceNumber;\r\n    }\r\n}\r\nclass MemoryEagerDelegate {\r\n    constructor(persistence) {\r\n        this.persistence = persistence;\r\n        /** Tracks all documents that are active in Query views. */\r\n        this.localViewReferences = new ReferenceSet();\r\n        /** The list of documents that are potentially GCed after each transaction. */\r\n        this._orphanedDocuments = null;\r\n    }\r\n    static factory(persistence) {\r\n        return new MemoryEagerDelegate(persistence);\r\n    }\r\n    get orphanedDocuments() {\r\n        if (!this._orphanedDocuments) {\r\n            throw fail();\r\n        }\r\n        else {\r\n            return this._orphanedDocuments;\r\n        }\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        this.localViewReferences.addReference(key, targetId);\r\n        this.orphanedDocuments.delete(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        this.localViewReferences.removeReference(key, targetId);\r\n        this.orphanedDocuments.add(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        this.orphanedDocuments.add(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\r\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\r\n        const cache = this.persistence.getTargetCache();\r\n        return cache\r\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\r\n            .next(keys => {\r\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\r\n        })\r\n            .next(() => cache.removeTargetData(txn, targetData));\r\n    }\r\n    onTransactionStarted() {\r\n        this._orphanedDocuments = new Set();\r\n    }\r\n    onTransactionCommitted(txn) {\r\n        // Remove newly orphaned documents.\r\n        const cache = this.persistence.getRemoteDocumentCache();\r\n        const changeBuffer = cache.newChangeBuffer();\r\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\r\n            const key = DocumentKey.fromPath(path);\r\n            return this.isReferenced(txn, key).next(isReferenced => {\r\n                if (!isReferenced) {\r\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\r\n                }\r\n            });\r\n        }).next(() => {\r\n            this._orphanedDocuments = null;\r\n            return changeBuffer.apply(txn);\r\n        });\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        return this.isReferenced(txn, key).next(isReferenced => {\r\n            if (isReferenced) {\r\n                this.orphanedDocuments.delete(key.toString());\r\n            }\r\n            else {\r\n                this.orphanedDocuments.add(key.toString());\r\n            }\r\n        });\r\n    }\r\n    documentSize(doc) {\r\n        // For eager GC, we don't care about the document size, there are no size thresholds.\r\n        return 0;\r\n    }\r\n    isReferenced(txn, key) {\r\n        return PersistencePromise.or([\r\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\r\n            () => this.persistence.getTargetCache().containsKey(txn, key),\r\n            () => this.persistence.mutationQueuesContainKey(txn, key)\r\n        ]);\r\n    }\r\n}\r\nclass MemoryLruDelegate {\r\n    constructor(persistence, lruParams) {\r\n        this.persistence = persistence;\r\n        this.orphanedSequenceNumbers = new ObjectMap(k => encodeResourcePath(k.path), (l, r) => l.isEqual(r));\r\n        this.garbageCollector = newLruGarbageCollector(this, lruParams);\r\n    }\r\n    static factory(persistence, lruParams) {\r\n        return new MemoryLruDelegate(persistence, lruParams);\r\n    }\r\n    // No-ops, present so memory persistence doesn't have to care which delegate\r\n    // it has.\r\n    onTransactionStarted() { }\r\n    onTransactionCommitted(txn) {\r\n        return PersistencePromise.resolve();\r\n    }\r\n    forEachTarget(txn, f) {\r\n        return this.persistence.getTargetCache().forEachTarget(txn, f);\r\n    }\r\n    getSequenceNumberCount(txn) {\r\n        const docCountPromise = this.orphanedDocumentCount(txn);\r\n        const targetCountPromise = this.persistence\r\n            .getTargetCache()\r\n            .getTargetCount(txn);\r\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\r\n    }\r\n    orphanedDocumentCount(txn) {\r\n        let orphanedCount = 0;\r\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\r\n            orphanedCount++;\r\n        }).next(() => orphanedCount);\r\n    }\r\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\r\n        return PersistencePromise.forEach(this.orphanedSequenceNumbers, (key, sequenceNumber) => {\r\n            // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\r\n            // being too recent.\r\n            return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\r\n                if (!isPinned) {\r\n                    return f(sequenceNumber);\r\n                }\r\n                else {\r\n                    return PersistencePromise.resolve();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.persistence\r\n            .getTargetCache()\r\n            .removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        let count = 0;\r\n        const cache = this.persistence.getRemoteDocumentCache();\r\n        const changeBuffer = cache.newChangeBuffer();\r\n        const p = cache.forEachDocumentKey(txn, key => {\r\n            return this.isPinned(txn, key, upperBound).next(isPinned => {\r\n                if (!isPinned) {\r\n                    count++;\r\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\r\n                }\r\n            });\r\n        });\r\n        return p.next(() => changeBuffer.apply(txn)).next(() => count);\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\r\n        return this.persistence.getTargetCache().updateTargetData(txn, updated);\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    documentSize(document) {\r\n        let documentSize = document.key.toString().length;\r\n        if (document.isFoundDocument()) {\r\n            documentSize += estimateByteSize(document.data.value);\r\n        }\r\n        return documentSize;\r\n    }\r\n    isPinned(txn, key, upperBound) {\r\n        return PersistencePromise.or([\r\n            () => this.persistence.mutationQueuesContainKey(txn, key),\r\n            () => this.persistence.getTargetCache().containsKey(txn, key),\r\n            () => {\r\n                const orphanedAt = this.orphanedSequenceNumbers.get(key);\r\n                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);\r\n            }\r\n        ]);\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.persistence.getRemoteDocumentCache().getSize(txn);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Performs database creation and schema upgrades. */\r\nclass SchemaConverter {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    /**\r\n     * Performs database creation and schema upgrades.\r\n     *\r\n     * Note that in production, this method is only ever used to upgrade the schema\r\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\r\n     * and local feature development.\r\n     */\r\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\r\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\r\n        if (fromVersion < 1 && toVersion >= 1) {\r\n            createPrimaryClientStore(db);\r\n            createMutationQueue(db);\r\n            createQueryCache(db);\r\n            createLegacyRemoteDocumentCache(db);\r\n        }\r\n        // Migration 2 to populate the targetGlobal object no longer needed since\r\n        // migration 3 unconditionally clears it.\r\n        let p = PersistencePromise.resolve();\r\n        if (fromVersion < 3 && toVersion >= 3) {\r\n            // Brand new clients don't need to drop and recreate--only clients that\r\n            // potentially have corrupt data.\r\n            if (fromVersion !== 0) {\r\n                dropQueryCache(db);\r\n                createQueryCache(db);\r\n            }\r\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 4 && toVersion >= 4) {\r\n            if (fromVersion !== 0) {\r\n                // Schema version 3 uses auto-generated keys to generate globally unique\r\n                // mutation batch IDs (this was previously ensured internally by the\r\n                // client). To migrate to the new schema, we have to read all mutations\r\n                // and write them back out. We preserve the existing batch IDs to guarantee\r\n                // consistency with other object stores. Any further mutation batch IDs will\r\n                // be auto-generated.\r\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\r\n            }\r\n            p = p.next(() => {\r\n                createClientMetadataStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 5 && toVersion >= 5) {\r\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 6 && toVersion >= 6) {\r\n            p = p.next(() => {\r\n                createDocumentGlobalStore(db);\r\n                return this.addDocumentGlobal(simpleDbTransaction);\r\n            });\r\n        }\r\n        if (fromVersion < 7 && toVersion >= 7) {\r\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 8 && toVersion >= 8) {\r\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 9 && toVersion >= 9) {\r\n            p = p.next(() => {\r\n                // Multi-Tab used to manage its own changelog, but this has been moved\r\n                // to the DbRemoteDocument object store itself. Since the previous change\r\n                // log only contained transient data, we can drop its object store.\r\n                dropRemoteDocumentChangesStore(db);\r\n                // Note: Schema version 9 used to create a read time index for the\r\n                // RemoteDocumentCache. This is now done with schema version 13.\r\n            });\r\n        }\r\n        if (fromVersion < 10 && toVersion >= 10) {\r\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 11 && toVersion >= 11) {\r\n            p = p.next(() => {\r\n                createBundlesStore(db);\r\n                createNamedQueriesStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 12 && toVersion >= 12) {\r\n            p = p.next(() => {\r\n                createDocumentOverlayStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 13 && toVersion >= 13) {\r\n            p = p\r\n                .next(() => createRemoteDocumentCache(db))\r\n                .next(() => this.rewriteRemoteDocumentCache(db, simpleDbTransaction))\r\n                .next(() => db.deleteObjectStore(DbRemoteDocumentStore$1));\r\n        }\r\n        if (fromVersion < 14 && toVersion >= 14) {\r\n            p = p.next(() => this.runOverlayMigration(db, simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 15 && toVersion >= 15) {\r\n            p = p.next(() => createFieldIndex(db));\r\n        }\r\n        if (fromVersion < 16 && toVersion >= 16) {\r\n            // Clear the object stores to remove possibly corrupted index entries\r\n            p = p\r\n                .next(() => {\r\n                const indexStateStore = txn.objectStore(DbIndexStateStore);\r\n                indexStateStore.clear();\r\n            })\r\n                .next(() => {\r\n                const indexEntryStore = txn.objectStore(DbIndexEntryStore);\r\n                indexEntryStore.clear();\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n    addDocumentGlobal(txn) {\r\n        let byteSize = 0;\r\n        return txn\r\n            .store(DbRemoteDocumentStore$1)\r\n            .iterate((_, doc) => {\r\n            byteSize += dbDocumentSize(doc);\r\n        })\r\n            .next(() => {\r\n            const metadata = { byteSize };\r\n            return txn\r\n                .store(DbRemoteDocumentGlobalStore)\r\n                .put(DbRemoteDocumentGlobalKey, metadata);\r\n        });\r\n    }\r\n    removeAcknowledgedMutations(txn) {\r\n        const queuesStore = txn.store(DbMutationQueueStore);\r\n        const mutationsStore = txn.store(DbMutationBatchStore);\r\n        return queuesStore.loadAll().next(queues => {\r\n            return PersistencePromise.forEach(queues, (queue) => {\r\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\r\n                return mutationsStore\r\n                    .loadAll(DbMutationBatchUserMutationsIndex, range)\r\n                    .next(dbBatches => {\r\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\r\n                        hardAssert(dbBatch.userId === queue.userId);\r\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\r\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\r\n     * with a sequence number. Missing rows are given the most recently used sequence number.\r\n     */\r\n    ensureSequenceNumbers(txn) {\r\n        const documentTargetStore = txn.store(DbTargetDocumentStore);\r\n        const documentsStore = txn.store(DbRemoteDocumentStore$1);\r\n        const globalTargetStore = txn.store(DbTargetGlobalStore);\r\n        return globalTargetStore.get(DbTargetGlobalKey).next(metadata => {\r\n            const writeSentinelKey = (path) => {\r\n                return documentTargetStore.put({\r\n                    targetId: 0,\r\n                    path: encodeResourcePath(path),\r\n                    sequenceNumber: metadata.highestListenSequenceNumber\r\n                });\r\n            };\r\n            const promises = [];\r\n            return documentsStore\r\n                .iterate((key, doc) => {\r\n                const path = new ResourcePath(key);\r\n                const docSentinelKey = sentinelKey(path);\r\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\r\n                    if (!maybeSentinel) {\r\n                        return writeSentinelKey(path);\r\n                    }\r\n                    else {\r\n                        return PersistencePromise.resolve();\r\n                    }\r\n                }));\r\n            })\r\n                .next(() => PersistencePromise.waitFor(promises));\r\n        });\r\n    }\r\n    createCollectionParentIndex(db, txn) {\r\n        // Create the index.\r\n        db.createObjectStore(DbCollectionParentStore, {\r\n            keyPath: DbCollectionParentKeyPath\r\n        });\r\n        const collectionParentsStore = txn.store(DbCollectionParentStore);\r\n        // Helper to add an index entry iff we haven't already written it.\r\n        const cache = new MemoryCollectionParentIndex();\r\n        const addEntry = (collectionPath) => {\r\n            if (cache.add(collectionPath)) {\r\n                const collectionId = collectionPath.lastSegment();\r\n                const parentPath = collectionPath.popLast();\r\n                return collectionParentsStore.put({\r\n                    collectionId,\r\n                    parent: encodeResourcePath(parentPath)\r\n                });\r\n            }\r\n        };\r\n        // Index existing remote documents.\r\n        return txn\r\n            .store(DbRemoteDocumentStore$1)\r\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\r\n            const path = new ResourcePath(pathSegments);\r\n            return addEntry(path.popLast());\r\n        })\r\n            .next(() => {\r\n            // Index existing mutations.\r\n            return txn\r\n                .store(DbDocumentMutationStore)\r\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\r\n                const path = decodeResourcePath(encodedPath);\r\n                return addEntry(path.popLast());\r\n            });\r\n        });\r\n    }\r\n    rewriteCanonicalIds(txn) {\r\n        const targetStore = txn.store(DbTargetStore);\r\n        return targetStore.iterate((key, originalDbTarget) => {\r\n            const originalTargetData = fromDbTarget(originalDbTarget);\r\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\r\n            return targetStore.put(updatedDbTarget);\r\n        });\r\n    }\r\n    rewriteRemoteDocumentCache(db, transaction) {\r\n        const legacyRemoteDocumentStore = transaction.store(DbRemoteDocumentStore$1);\r\n        const writes = [];\r\n        return legacyRemoteDocumentStore\r\n            .iterate((_, legacyDocument) => {\r\n            const remoteDocumentStore = transaction.store(DbRemoteDocumentStore);\r\n            const path = extractKey(legacyDocument).path.toArray();\r\n            const dbRemoteDocument = {\r\n                prefixPath: path.slice(0, path.length - 2),\r\n                collectionGroup: path[path.length - 2],\r\n                documentId: path[path.length - 1],\r\n                readTime: legacyDocument.readTime || [0, 0],\r\n                unknownDocument: legacyDocument.unknownDocument,\r\n                noDocument: legacyDocument.noDocument,\r\n                document: legacyDocument.document,\r\n                hasCommittedMutations: !!legacyDocument.hasCommittedMutations\r\n            };\r\n            writes.push(remoteDocumentStore.put(dbRemoteDocument));\r\n        })\r\n            .next(() => PersistencePromise.waitFor(writes));\r\n    }\r\n    runOverlayMigration(db, transaction) {\r\n        const mutationsStore = transaction.store(DbMutationBatchStore);\r\n        const remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\r\n        const memoryPersistence = new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer.remoteSerializer);\r\n        return mutationsStore.loadAll().next(dbBatches => {\r\n            const userToDocumentSet = new Map();\r\n            dbBatches.forEach(dbBatch => {\r\n                var _a;\r\n                let documentSet = (_a = userToDocumentSet.get(dbBatch.userId)) !== null && _a !== void 0 ? _a : documentKeySet();\r\n                const batch = fromDbMutationBatch(this.serializer, dbBatch);\r\n                batch.keys().forEach(key => (documentSet = documentSet.add(key)));\r\n                userToDocumentSet.set(dbBatch.userId, documentSet);\r\n            });\r\n            return PersistencePromise.forEach(userToDocumentSet, (allDocumentKeysForUser, userId) => {\r\n                const user = new User(userId);\r\n                const documentOverlayCache = IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\r\n                // NOTE: The index manager and the reference delegate are\r\n                // irrelevant for the purpose of recalculating and saving\r\n                // overlays. We can therefore simply use the memory\r\n                // implementation.\r\n                const indexManager = memoryPersistence.getIndexManager(user);\r\n                const mutationQueue = IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, memoryPersistence.referenceDelegate);\r\n                const localDocumentsView = new LocalDocumentsView(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager);\r\n                return localDocumentsView\r\n                    .recalculateAndSaveOverlaysForDocumentKeys(new IndexedDbTransaction(transaction, ListenSequence.INVALID), allDocumentKeysForUser)\r\n                    .next();\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction sentinelKey(path) {\r\n    return [0, encodeResourcePath(path)];\r\n}\r\nfunction createPrimaryClientStore(db) {\r\n    db.createObjectStore(DbPrimaryClientStore);\r\n}\r\nfunction createMutationQueue(db) {\r\n    db.createObjectStore(DbMutationQueueStore, {\r\n        keyPath: DbMutationQueueKeyPath\r\n    });\r\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatchStore, {\r\n        keyPath: DbMutationBatchKeyPath,\r\n        autoIncrement: true\r\n    });\r\n    mutationBatchesStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\r\n    db.createObjectStore(DbDocumentMutationStore);\r\n}\r\n/**\r\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\r\n * and rewrites all data.\r\n */\r\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\r\n    const v1MutationsStore = txn.store(DbMutationBatchStore);\r\n    return v1MutationsStore.loadAll().next(existingMutations => {\r\n        db.deleteObjectStore(DbMutationBatchStore);\r\n        const mutationsStore = db.createObjectStore(DbMutationBatchStore, {\r\n            keyPath: DbMutationBatchKeyPath,\r\n            autoIncrement: true\r\n        });\r\n        mutationsStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\r\n        const v3MutationsStore = txn.store(DbMutationBatchStore);\r\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\r\n        return PersistencePromise.waitFor(writeAll);\r\n    });\r\n}\r\nfunction createLegacyRemoteDocumentCache(db) {\r\n    db.createObjectStore(DbRemoteDocumentStore$1);\r\n}\r\nfunction createRemoteDocumentCache(db) {\r\n    const remoteDocumentStore = db.createObjectStore(DbRemoteDocumentStore, {\r\n        keyPath: DbRemoteDocumentKeyPath\r\n    });\r\n    remoteDocumentStore.createIndex(DbRemoteDocumentDocumentKeyIndex, DbRemoteDocumentDocumentKeyIndexPath);\r\n    remoteDocumentStore.createIndex(DbRemoteDocumentCollectionGroupIndex, DbRemoteDocumentCollectionGroupIndexPath);\r\n}\r\nfunction createDocumentGlobalStore(db) {\r\n    db.createObjectStore(DbRemoteDocumentGlobalStore);\r\n}\r\nfunction createQueryCache(db) {\r\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocumentStore, {\r\n        keyPath: DbTargetDocumentKeyPath\r\n    });\r\n    targetDocumentsStore.createIndex(DbTargetDocumentDocumentTargetsIndex, DbTargetDocumentDocumentTargetsKeyPath, { unique: true });\r\n    const targetStore = db.createObjectStore(DbTargetStore, {\r\n        keyPath: DbTargetKeyPath\r\n    });\r\n    // NOTE: This is unique only because the TargetId is the suffix.\r\n    targetStore.createIndex(DbTargetQueryTargetsIndexName, DbTargetQueryTargetsKeyPath, { unique: true });\r\n    db.createObjectStore(DbTargetGlobalStore);\r\n}\r\nfunction dropQueryCache(db) {\r\n    db.deleteObjectStore(DbTargetDocumentStore);\r\n    db.deleteObjectStore(DbTargetStore);\r\n    db.deleteObjectStore(DbTargetGlobalStore);\r\n}\r\nfunction dropRemoteDocumentChangesStore(db) {\r\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\r\n        db.deleteObjectStore('remoteDocumentChanges');\r\n    }\r\n}\r\n/**\r\n * Creates the target global singleton row.\r\n *\r\n * @param txn - The version upgrade transaction for indexeddb\r\n */\r\nfunction writeEmptyTargetGlobalEntry(txn) {\r\n    const globalStore = txn.store(DbTargetGlobalStore);\r\n    const metadata = {\r\n        highestTargetId: 0,\r\n        highestListenSequenceNumber: 0,\r\n        lastRemoteSnapshotVersion: SnapshotVersion.min().toTimestamp(),\r\n        targetCount: 0\r\n    };\r\n    return globalStore.put(DbTargetGlobalKey, metadata);\r\n}\r\nfunction createClientMetadataStore(db) {\r\n    db.createObjectStore(DbClientMetadataStore, {\r\n        keyPath: DbClientMetadataKeyPath\r\n    });\r\n}\r\nfunction createBundlesStore(db) {\r\n    db.createObjectStore(DbBundleStore, {\r\n        keyPath: DbBundleKeyPath\r\n    });\r\n}\r\nfunction createNamedQueriesStore(db) {\r\n    db.createObjectStore(DbNamedQueryStore, {\r\n        keyPath: DbNamedQueryKeyPath\r\n    });\r\n}\r\nfunction createFieldIndex(db) {\r\n    const indexConfigurationStore = db.createObjectStore(DbIndexConfigurationStore, {\r\n        keyPath: DbIndexConfigurationKeyPath,\r\n        autoIncrement: true\r\n    });\r\n    indexConfigurationStore.createIndex(DbIndexConfigurationCollectionGroupIndex, DbIndexConfigurationCollectionGroupIndexPath, { unique: false });\r\n    const indexStateStore = db.createObjectStore(DbIndexStateStore, {\r\n        keyPath: DbIndexStateKeyPath\r\n    });\r\n    indexStateStore.createIndex(DbIndexStateSequenceNumberIndex, DbIndexStateSequenceNumberIndexPath, { unique: false });\r\n    const indexEntryStore = db.createObjectStore(DbIndexEntryStore, {\r\n        keyPath: DbIndexEntryKeyPath\r\n    });\r\n    indexEntryStore.createIndex(DbIndexEntryDocumentKeyIndex, DbIndexEntryDocumentKeyIndexPath, { unique: false });\r\n}\r\nfunction createDocumentOverlayStore(db) {\r\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlayStore, {\r\n        keyPath: DbDocumentOverlayKeyPath\r\n    });\r\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionPathOverlayIndex, DbDocumentOverlayCollectionPathOverlayIndexPath, { unique: false });\r\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionGroupOverlayIndex, DbDocumentOverlayCollectionGroupOverlayIndexPath, { unique: false });\r\n}\r\nfunction extractKey(remoteDoc) {\r\n    if (remoteDoc.document) {\r\n        return new DocumentKey(ResourcePath.fromString(remoteDoc.document.name).popFirst(5));\r\n    }\r\n    else if (remoteDoc.noDocument) {\r\n        return DocumentKey.fromSegments(remoteDoc.noDocument.path);\r\n    }\r\n    else if (remoteDoc.unknownDocument) {\r\n        return DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$c = 'IndexedDbPersistence';\r\n/**\r\n * Oldest acceptable age in milliseconds for client metadata before the client\r\n * is considered inactive and its associated data is garbage collected.\r\n */\r\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\r\n/**\r\n * Oldest acceptable metadata age for clients that may participate in the\r\n * primary lease election. Clients that have not updated their client metadata\r\n * within 5 seconds are not eligible to receive a primary lease.\r\n */\r\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\r\n/**\r\n * The interval at which clients will update their metadata, including\r\n * refreshing their primary lease if held or potentially trying to acquire it if\r\n * not held.\r\n *\r\n * Primary clients may opportunistically refresh their metadata earlier\r\n * if they're already performing an IndexedDB operation.\r\n */\r\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\r\n/** User-facing error when the primary lease is required but not available. */\r\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\r\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\r\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\r\n    'one tab has persistence enabled at any given time.';\r\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\r\n    'an incomplete implementation. Offline persistence has been disabled.';\r\n// The format of the LocalStorage key that stores zombied client is:\r\n//     firestore_zombie_<persistence_prefix>_<instance_key>\r\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\r\n/**\r\n * The name of the main (and currently only) IndexedDB database. This name is\r\n * appended to the prefix provided to the IndexedDbPersistence constructor.\r\n */\r\nconst MAIN_DATABASE = 'main';\r\n/**\r\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\r\n * across sessions.\r\n *\r\n * On Web only, the Firestore SDKs support shared access to its persistence\r\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\r\n * to synchronize state even without network connectivity. Shared access is\r\n * currently optional and not enabled unless all clients invoke\r\n * `enablePersistence()` with `{synchronizeTabs:true}`.\r\n *\r\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\r\n * will designate one client as the “primary client”. An effort is made to pick\r\n * a visible, network-connected and active client, and this client is\r\n * responsible for letting other clients know about its presence. The primary\r\n * client writes a unique client-generated identifier (the client ID) to\r\n * IndexedDb’s “owner” store every 4 seconds. If the primary client fails to\r\n * update this entry, another client can acquire the lease and take over as\r\n * primary.\r\n *\r\n * Some persistence operations in the SDK are designated as primary-client only\r\n * operations. This includes the acknowledgment of mutations and all updates of\r\n * remote documents. The effects of these operations are written to persistence\r\n * and then broadcast to other tabs via LocalStorage (see\r\n * `WebStorageSharedClientState`), which then refresh their state from\r\n * persistence.\r\n *\r\n * Similarly, the primary client listens to notifications sent by secondary\r\n * clients to discover persistence changes written by secondary clients, such as\r\n * the addition of new mutations and query targets.\r\n *\r\n * If multi-tab is not enabled and another tab already obtained the primary\r\n * lease, IndexedDbPersistence enters a failed state and all subsequent\r\n * operations will automatically fail.\r\n *\r\n * Additionally, there is an optimization so that when a tab is closed, the\r\n * primary lease is released immediately (this is especially important to make\r\n * sure that a refreshed tab is able to immediately re-acquire the primary\r\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\r\n * since it is an asynchronous API. So in addition to attempting to give up the\r\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\r\n * LocalStorage which acts as an indicator that another tab should go ahead and\r\n * take the primary lease immediately regardless of the current lease timestamp.\r\n *\r\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\r\n * longer optional.\r\n */\r\nclass IndexedDbPersistence {\r\n    constructor(\r\n    /**\r\n     * Whether to synchronize the in-memory state of multiple tabs and share\r\n     * access to local persistence.\r\n     */\r\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \r\n    /**\r\n     * If set to true, forcefully obtains database access. Existing tabs will\r\n     * no longer be able to access IndexedDB.\r\n     */\r\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\r\n        this.allowTabSynchronization = allowTabSynchronization;\r\n        this.persistenceKey = persistenceKey;\r\n        this.clientId = clientId;\r\n        this.queue = queue;\r\n        this.window = window;\r\n        this.document = document;\r\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\r\n        this.forceOwningTab = forceOwningTab;\r\n        this.schemaVersion = schemaVersion;\r\n        this.listenSequence = null;\r\n        this._started = false;\r\n        this.isPrimary = false;\r\n        this.networkEnabled = true;\r\n        /** Our window.unload handler, if registered. */\r\n        this.windowUnloadHandler = null;\r\n        this.inForeground = false;\r\n        /** Our 'visibilitychange' listener if registered. */\r\n        this.documentVisibilityHandler = null;\r\n        /** The client metadata refresh task. */\r\n        this.clientMetadataRefresher = null;\r\n        /** The last time we garbage collected the client metadata object store. */\r\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\r\n        /** A listener to notify on primary state changes. */\r\n        this.primaryStateListener = _ => Promise.resolve();\r\n        if (!IndexedDbPersistence.isAvailable()) {\r\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\r\n        }\r\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\r\n        this.dbName = persistenceKey + MAIN_DATABASE;\r\n        this.serializer = new LocalSerializer(serializer);\r\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\r\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\r\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\r\n        this.bundleCache = new IndexedDbBundleCache();\r\n        if (this.window && this.window.localStorage) {\r\n            this.webStorage = this.window.localStorage;\r\n        }\r\n        else {\r\n            this.webStorage = null;\r\n            if (forceOwningTab === false) {\r\n                logError(LOG_TAG$c, 'LocalStorage is unavailable. As a result, persistence may not work ' +\r\n                    'reliably. In particular enablePersistence() could fail immediately ' +\r\n                    'after refreshing the page.');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempt to start IndexedDb persistence.\r\n     *\r\n     * @returns Whether persistence was enabled.\r\n     */\r\n    start() {\r\n        // NOTE: This is expected to fail sometimes (in the case of another tab\r\n        // already having the persistence lock), so it's the first thing we should\r\n        // do.\r\n        return this.updateClientMetadataAndTryBecomePrimary()\r\n            .then(() => {\r\n            if (!this.isPrimary && !this.allowTabSynchronization) {\r\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\r\n                // obtain the primary lease.\r\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n            }\r\n            this.attachVisibilityHandler();\r\n            this.attachWindowUnloadHook();\r\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\r\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\r\n        })\r\n            .then(highestListenSequenceNumber => {\r\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\r\n        })\r\n            .then(() => {\r\n            this._started = true;\r\n        })\r\n            .catch(reason => {\r\n            this.simpleDb && this.simpleDb.close();\r\n            return Promise.reject(reason);\r\n        });\r\n    }\r\n    /**\r\n     * Registers a listener that gets called when the primary state of the\r\n     * instance changes. Upon registering, this listener is invoked immediately\r\n     * with the current primary state.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setPrimaryStateListener(primaryStateListener) {\r\n        this.primaryStateListener = async (primaryState) => {\r\n            if (this.started) {\r\n                return primaryStateListener(primaryState);\r\n            }\r\n        };\r\n        return primaryStateListener(this.isPrimary);\r\n    }\r\n    /**\r\n     * Registers a listener that gets called when the database receives a\r\n     * version change event indicating that it has deleted.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setDatabaseDeletedListener(databaseDeletedListener) {\r\n        this.simpleDb.setVersionChangeListener(async (event) => {\r\n            // Check if an attempt is made to delete IndexedDB.\r\n            if (event.newVersion === null) {\r\n                await databaseDeletedListener();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Adjusts the current network state in the client's metadata, potentially\r\n     * affecting the primary lease.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setNetworkEnabled(networkEnabled) {\r\n        if (this.networkEnabled !== networkEnabled) {\r\n            this.networkEnabled = networkEnabled;\r\n            // Schedule a primary lease refresh for immediate execution. The eventual\r\n            // lease update will be propagated via `primaryStateListener`.\r\n            this.queue.enqueueAndForget(async () => {\r\n                if (this.started) {\r\n                    await this.updateClientMetadataAndTryBecomePrimary();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\r\n     * extend the primary lease for the local client. Asynchronously notifies the\r\n     * primary state listener if the client either newly obtained or released its\r\n     * primary lease.\r\n     */\r\n    updateClientMetadataAndTryBecomePrimary() {\r\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\r\n            const metadataStore = clientMetadataStore(txn);\r\n            return metadataStore\r\n                .put({\r\n                clientId: this.clientId,\r\n                updateTimeMs: Date.now(),\r\n                networkEnabled: this.networkEnabled,\r\n                inForeground: this.inForeground\r\n            })\r\n                .next(() => {\r\n                if (this.isPrimary) {\r\n                    return this.verifyPrimaryLease(txn).next(success => {\r\n                        if (!success) {\r\n                            this.isPrimary = false;\r\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\r\n                        }\r\n                    });\r\n                }\r\n            })\r\n                .next(() => this.canActAsPrimary(txn))\r\n                .next(canActAsPrimary => {\r\n                if (this.isPrimary && !canActAsPrimary) {\r\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\r\n                }\r\n                else if (canActAsPrimary) {\r\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\r\n                }\r\n                else {\r\n                    return /* canActAsPrimary= */ false;\r\n                }\r\n            });\r\n        })\r\n            .catch(e => {\r\n            if (isIndexedDbTransactionError(e)) {\r\n                logDebug(LOG_TAG$c, 'Failed to extend owner lease: ', e);\r\n                // Proceed with the existing state. Any subsequent access to\r\n                // IndexedDB will verify the lease.\r\n                return this.isPrimary;\r\n            }\r\n            if (!this.allowTabSynchronization) {\r\n                throw e;\r\n            }\r\n            logDebug(LOG_TAG$c, 'Releasing owner lease after error during lease refresh', e);\r\n            return /* isPrimary= */ false;\r\n        })\r\n            .then(isPrimary => {\r\n            if (this.isPrimary !== isPrimary) {\r\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\r\n            }\r\n            this.isPrimary = isPrimary;\r\n        });\r\n    }\r\n    verifyPrimaryLease(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\r\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\r\n        });\r\n    }\r\n    removeClientMetadata(txn) {\r\n        const metadataStore = clientMetadataStore(txn);\r\n        return metadataStore.delete(this.clientId);\r\n    }\r\n    /**\r\n     * If the garbage collection threshold has passed, prunes the\r\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\r\n     * time of all clients.\r\n     */\r\n    async maybeGarbageCollectMultiClientState() {\r\n        if (this.isPrimary &&\r\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\r\n            this.lastGarbageCollectionTime = Date.now();\r\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\r\n                const metadataStore = getStore(txn, DbClientMetadataStore);\r\n                return metadataStore.loadAll().next(existingClients => {\r\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\r\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\r\n                    // Delete metadata for clients that are no longer considered active.\r\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\r\n                });\r\n            }).catch(() => {\r\n                // Ignore primary lease violations or any other type of error. The next\r\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\r\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\r\n                // on LocalStore.\r\n                return [];\r\n            });\r\n            // Delete potential leftover entries that may continue to mark the\r\n            // inactive clients as zombied in LocalStorage.\r\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\r\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\r\n            // entries first to avoid potentially reviving a zombied client.\r\n            if (this.webStorage) {\r\n                for (const inactiveClient of inactiveClients) {\r\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Schedules a recurring timer to update the client metadata and to either\r\n     * extend or acquire the primary lease if the client is eligible.\r\n     */\r\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\r\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* TimerId.ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\r\n            return this.updateClientMetadataAndTryBecomePrimary()\r\n                .then(() => this.maybeGarbageCollectMultiClientState())\r\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\r\n        });\r\n    }\r\n    /** Checks whether `client` is the local client. */\r\n    isLocalClient(client) {\r\n        return client ? client.ownerId === this.clientId : false;\r\n    }\r\n    /**\r\n     * Evaluate the state of all active clients and determine whether the local\r\n     * client is or can act as the holder of the primary lease. Returns whether\r\n     * the client is eligible for the lease, but does not actually acquire it.\r\n     * May return 'false' even if there is no active leaseholder and another\r\n     * (foreground) client should become leaseholder instead.\r\n     */\r\n    canActAsPrimary(txn) {\r\n        if (this.forceOwningTab) {\r\n            return PersistencePromise.resolve(true);\r\n        }\r\n        const store = primaryClientStore(txn);\r\n        return store\r\n            .get(DbPrimaryClientKey)\r\n            .next(currentPrimary => {\r\n            const currentLeaseIsValid = currentPrimary !== null &&\r\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\r\n                !this.isClientZombied(currentPrimary.ownerId);\r\n            // A client is eligible for the primary lease if:\r\n            // - its network is enabled and the client's tab is in the foreground.\r\n            // - its network is enabled and no other client's tab is in the\r\n            //   foreground.\r\n            // - every clients network is disabled and the client's tab is in the\r\n            //   foreground.\r\n            // - every clients network is disabled and no other client's tab is in\r\n            //   the foreground.\r\n            // - the `forceOwningTab` setting was passed in.\r\n            if (currentLeaseIsValid) {\r\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\r\n                    return true;\r\n                }\r\n                if (!this.isLocalClient(currentPrimary)) {\r\n                    if (!currentPrimary.allowTabSynchronization) {\r\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\r\n                        // not opted into multi-tab synchronization. If this happens at\r\n                        // client startup, we reject the Promise returned by\r\n                        // `enablePersistence()` and the user can continue to use Firestore\r\n                        // with in-memory persistence.\r\n                        // If this fails during a lease refresh, we will instead block the\r\n                        // AsyncQueue from executing further operations. Note that this is\r\n                        // acceptable since mixing & matching different `synchronizeTabs`\r\n                        // settings is not supported.\r\n                        //\r\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\r\n                        // no longer be turned off.\r\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            if (this.networkEnabled && this.inForeground) {\r\n                return true;\r\n            }\r\n            return clientMetadataStore(txn)\r\n                .loadAll()\r\n                .next(existingClients => {\r\n                // Process all existing clients and determine whether at least one of\r\n                // them is better suited to obtain the primary lease.\r\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\r\n                    if (this.clientId !== otherClient.clientId) {\r\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\r\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\r\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\r\n                        if (otherClientHasBetterNetworkState ||\r\n                            (otherClientHasBetterVisibility &&\r\n                                otherClientHasSameNetworkState)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                });\r\n                return preferredCandidate === undefined;\r\n            });\r\n        })\r\n            .next(canActAsPrimary => {\r\n            if (this.isPrimary !== canActAsPrimary) {\r\n                logDebug(LOG_TAG$c, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\r\n            }\r\n            return canActAsPrimary;\r\n        });\r\n    }\r\n    async shutdown() {\r\n        // The shutdown() operations are idempotent and can be called even when\r\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\r\n        this._started = false;\r\n        this.markClientZombied();\r\n        if (this.clientMetadataRefresher) {\r\n            this.clientMetadataRefresher.cancel();\r\n            this.clientMetadataRefresher = null;\r\n        }\r\n        this.detachVisibilityHandler();\r\n        this.detachWindowUnloadHook();\r\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\r\n        // has obtained the primary lease.\r\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClientStore, DbClientMetadataStore], simpleDbTxn => {\r\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\r\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\r\n        });\r\n        this.simpleDb.close();\r\n        // Remove the entry marking the client as zombied from LocalStorage since\r\n        // we successfully deleted its metadata from IndexedDb.\r\n        this.removeClientZombiedEntry();\r\n    }\r\n    /**\r\n     * Returns clients that are not zombied and have an updateTime within the\r\n     * provided threshold.\r\n     */\r\n    filterActiveClients(clients, activityThresholdMs) {\r\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\r\n            !this.isClientZombied(client.clientId));\r\n    }\r\n    /**\r\n     * Returns the IDs of the clients that are currently active. If multi-tab\r\n     * is not supported, returns an array that only contains the local client's\r\n     * ID.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    getActiveClients() {\r\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\r\n            return clientMetadataStore(txn)\r\n                .loadAll()\r\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\r\n        });\r\n    }\r\n    get started() {\r\n        return this._started;\r\n    }\r\n    getMutationQueue(user, indexManager) {\r\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\r\n    }\r\n    getTargetCache() {\r\n        return this.targetCache;\r\n    }\r\n    getRemoteDocumentCache() {\r\n        return this.remoteDocumentCache;\r\n    }\r\n    getIndexManager(user) {\r\n        return new IndexedDbIndexManager(user, this.serializer.remoteSerializer.databaseId);\r\n    }\r\n    getDocumentOverlayCache(user) {\r\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\r\n    }\r\n    getBundleCache() {\r\n        return this.bundleCache;\r\n    }\r\n    runTransaction(action, mode, transactionOperation) {\r\n        logDebug(LOG_TAG$c, 'Starting transaction:', action);\r\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\r\n        const objectStores = getObjectStores(this.schemaVersion);\r\n        let persistenceTransaction;\r\n        // Do all transactions as readwrite against all object stores, since we\r\n        // are the only reader/writer.\r\n        return this.simpleDb\r\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\r\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\r\n                ? this.listenSequence.next()\r\n                : ListenSequence.INVALID);\r\n            if (mode === 'readwrite-primary') {\r\n                // While we merely verify that we have (or can acquire) the lease\r\n                // immediately, we wait to extend the primary lease until after\r\n                // executing transactionOperation(). This ensures that even if the\r\n                // transactionOperation takes a long time, we'll use a recent\r\n                // leaseTimestampMs in the extended (or newly acquired) lease.\r\n                return this.verifyPrimaryLease(persistenceTransaction)\r\n                    .next(holdsPrimaryLease => {\r\n                    if (holdsPrimaryLease) {\r\n                        return /* holdsPrimaryLease= */ true;\r\n                    }\r\n                    return this.canActAsPrimary(persistenceTransaction);\r\n                })\r\n                    .next(holdsPrimaryLease => {\r\n                    if (!holdsPrimaryLease) {\r\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\r\n                        this.isPrimary = false;\r\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\r\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\r\n                    }\r\n                    return transactionOperation(persistenceTransaction);\r\n                })\r\n                    .next(result => {\r\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\r\n                });\r\n            }\r\n            else {\r\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\r\n            }\r\n        })\r\n            .then(result => {\r\n            persistenceTransaction.raiseOnCommittedEvent();\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies that the current tab is the primary leaseholder or alternatively\r\n     * that the leaseholder has opted into multi-tab synchronization.\r\n     */\r\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\r\n    // be turned off.\r\n    verifyAllowTabSynchronization(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClientKey).next(currentPrimary => {\r\n            const currentLeaseIsValid = currentPrimary !== null &&\r\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\r\n                !this.isClientZombied(currentPrimary.ownerId);\r\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\r\n                if (!this.forceOwningTab &&\r\n                    (!this.allowTabSynchronization ||\r\n                        !currentPrimary.allowTabSynchronization)) {\r\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Obtains or extends the new primary lease for the local client. This\r\n     * method does not verify that the client is eligible for this lease.\r\n     */\r\n    acquireOrExtendPrimaryLease(txn) {\r\n        const newPrimary = {\r\n            ownerId: this.clientId,\r\n            allowTabSynchronization: this.allowTabSynchronization,\r\n            leaseTimestampMs: Date.now()\r\n        };\r\n        return primaryClientStore(txn).put(DbPrimaryClientKey, newPrimary);\r\n    }\r\n    static isAvailable() {\r\n        return SimpleDb.isAvailable();\r\n    }\r\n    /** Checks the primary lease and removes it if we are the current primary. */\r\n    releasePrimaryLeaseIfHeld(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\r\n            if (this.isLocalClient(primaryClient)) {\r\n                logDebug(LOG_TAG$c, 'Releasing primary lease.');\r\n                return store.delete(DbPrimaryClientKey);\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve();\r\n            }\r\n        });\r\n    }\r\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\r\n    isWithinAge(updateTimeMs, maxAgeMs) {\r\n        const now = Date.now();\r\n        const minAcceptable = now - maxAgeMs;\r\n        const maxAcceptable = now;\r\n        if (updateTimeMs < minAcceptable) {\r\n            return false;\r\n        }\r\n        else if (updateTimeMs > maxAcceptable) {\r\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    attachVisibilityHandler() {\r\n        if (this.document !== null &&\r\n            typeof this.document.addEventListener === 'function') {\r\n            this.documentVisibilityHandler = () => {\r\n                this.queue.enqueueAndForget(() => {\r\n                    this.inForeground = this.document.visibilityState === 'visible';\r\n                    return this.updateClientMetadataAndTryBecomePrimary();\r\n                });\r\n            };\r\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\r\n            this.inForeground = this.document.visibilityState === 'visible';\r\n        }\r\n    }\r\n    detachVisibilityHandler() {\r\n        if (this.documentVisibilityHandler) {\r\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\r\n            this.documentVisibilityHandler = null;\r\n        }\r\n    }\r\n    /**\r\n     * Attaches a window.unload handler that will synchronously write our\r\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\r\n     * by tabs trying to acquire the primary lease to determine that the lease\r\n     * is no longer valid even if the timestamp is recent. This is particularly\r\n     * important for the refresh case (so the tab correctly re-acquires the\r\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\r\n     * it is a synchronous API and so can be used reliably from  an unload\r\n     * handler.\r\n     */\r\n    attachWindowUnloadHook() {\r\n        var _a;\r\n        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === 'function') {\r\n            this.windowUnloadHandler = () => {\r\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\r\n                // accesses internal state. We execute this code directly during shutdown\r\n                // to make sure it gets a chance to run.\r\n                this.markClientZombied();\r\n                const safariIndexdbBugVersionRegex = /(?:Version|Mobile)\\/1[456]/;\r\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)() &&\r\n                    (navigator.appVersion.match(safariIndexdbBugVersionRegex) ||\r\n                        navigator.userAgent.match(safariIndexdbBugVersionRegex))) {\r\n                    // On Safari 14, 15, and 16, we do not run any cleanup actions as it might\r\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\r\n                    // the next page load.\r\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\r\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\r\n                }\r\n                this.queue.enqueueAndForget(() => {\r\n                    // Attempt graceful shutdown (including releasing our primary lease),\r\n                    // but there's no guarantee it will complete.\r\n                    return this.shutdown();\r\n                });\r\n            };\r\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\r\n        }\r\n    }\r\n    detachWindowUnloadHook() {\r\n        if (this.windowUnloadHandler) {\r\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\r\n            this.windowUnloadHandler = null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\r\n     * Clients become zombied when their tab closes without running all of the\r\n     * cleanup logic in `shutdown()`.\r\n     */\r\n    isClientZombied(clientId) {\r\n        var _a;\r\n        try {\r\n            const isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;\r\n            logDebug(LOG_TAG$c, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\r\n            return isZombied;\r\n        }\r\n        catch (e) {\r\n            // Gracefully handle if LocalStorage isn't working.\r\n            logError(LOG_TAG$c, 'Failed to get zombied client id.', e);\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Record client as zombied (a client that had its tab closed). Zombied\r\n     * clients are ignored during primary tab selection.\r\n     */\r\n    markClientZombied() {\r\n        if (!this.webStorage) {\r\n            return;\r\n        }\r\n        try {\r\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\r\n        }\r\n        catch (e) {\r\n            // Gracefully handle if LocalStorage isn't available / working.\r\n            logError('Failed to set zombie client id.', e);\r\n        }\r\n    }\r\n    /** Removes the zombied client entry if it exists. */\r\n    removeClientZombiedEntry() {\r\n        if (!this.webStorage) {\r\n            return;\r\n        }\r\n        try {\r\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\r\n        }\r\n        catch (e) {\r\n            // Ignore\r\n        }\r\n    }\r\n    zombiedClientLocalStorageKey(clientId) {\r\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the primary client object store.\r\n */\r\nfunction primaryClientStore(txn) {\r\n    return getStore(txn, DbPrimaryClientStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the client metadata object store.\r\n */\r\nfunction clientMetadataStore(txn) {\r\n    return getStore(txn, DbClientMetadataStore);\r\n}\r\n/**\r\n * Generates a string used as a prefix when storing data in IndexedDB and\r\n * LocalStorage.\r\n */\r\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\r\n    // Use two different prefix formats:\r\n    //\r\n    //   * firestore / persistenceKey / projectID . databaseID / ...\r\n    //   * firestore / persistenceKey / projectID / ...\r\n    //\r\n    // projectIDs are DNS-compatible names and cannot contain dots\r\n    // so there's no danger of collisions.\r\n    let database = databaseId.projectId;\r\n    if (!databaseId.isDefaultDatabase) {\r\n        database += '.' + databaseId.database;\r\n    }\r\n    return 'firestore/' + persistenceKey + '/' + database + '/';\r\n}\r\nasync function indexedDbClearPersistence(persistenceKey) {\r\n    if (!SimpleDb.isAvailable()) {\r\n        return Promise.resolve();\r\n    }\r\n    const dbName = persistenceKey + MAIN_DATABASE;\r\n    await SimpleDb.delete(dbName);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Compares two array for equality using comparator. The method computes the\r\n * intersection and invokes `onAdd` for every element that is in `after` but not\r\n * `before`. `onRemove` is invoked for every element in `before` but missing\r\n * from `after`.\r\n *\r\n * The method creates a copy of both `before` and `after` and runs in O(n log\r\n * n), where n is the size of the two lists.\r\n *\r\n * @param before - The elements that exist in the original array.\r\n * @param after - The elements to diff against the original array.\r\n * @param comparator - The comparator for the elements in before and after.\r\n * @param onAdd - A function to invoke for every element that is part of `\r\n * after` but not `before`.\r\n * @param onRemove - A function to invoke for every element that is part of\r\n * `before` but not `after`.\r\n */\r\nfunction diffArrays(before, after, comparator, onAdd, onRemove) {\r\n    before = [...before];\r\n    after = [...after];\r\n    before.sort(comparator);\r\n    after.sort(comparator);\r\n    const bLen = before.length;\r\n    const aLen = after.length;\r\n    let a = 0;\r\n    let b = 0;\r\n    while (a < aLen && b < bLen) {\r\n        const cmp = comparator(before[b], after[a]);\r\n        if (cmp < 0) {\r\n            // The element was removed if the next element in our ordered\r\n            // walkthrough is only in `before`.\r\n            onRemove(before[b++]);\r\n        }\r\n        else if (cmp > 0) {\r\n            // The element was added if the next element in our ordered walkthrough\r\n            // is only in `after`.\r\n            onAdd(after[a++]);\r\n        }\r\n        else {\r\n            a++;\r\n            b++;\r\n        }\r\n    }\r\n    while (a < aLen) {\r\n        onAdd(after[a++]);\r\n    }\r\n    while (b < bLen) {\r\n        onRemove(before[b++]);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$b = 'LocalStore';\r\n/**\r\n * The maximum time to leave a resume token buffered without writing it out.\r\n * This value is arbitrary: it's long enough to avoid several writes\r\n * (possibly indefinitely if updates come more frequently than this) but\r\n * short enough that restarting after crashing will still have a pretty\r\n * recent resume token.\r\n */\r\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\r\n/**\r\n * Implements `LocalStore` interface.\r\n *\r\n * Note: some field defined in this class might have public access level, but\r\n * the class is not exported so they are only accessible from this module.\r\n * This is useful to implement optional features (like bundles) in free\r\n * functions, such that they are tree-shakeable.\r\n */\r\nclass LocalStoreImpl {\r\n    constructor(\r\n    /** Manages our in-memory or durable persistence. */\r\n    persistence, queryEngine, initialUser, serializer) {\r\n        this.persistence = persistence;\r\n        this.queryEngine = queryEngine;\r\n        this.serializer = serializer;\r\n        /**\r\n         * Maps a targetID to data about its target.\r\n         *\r\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\r\n         * of `applyRemoteEvent()` idempotent.\r\n         */\r\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\r\n        /** Maps a target to its targetID. */\r\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\r\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\r\n        /**\r\n         * A per collection group index of the last read time processed by\r\n         * `getNewDocumentChanges()`.\r\n         *\r\n         * PORTING NOTE: This is only used for multi-tab synchronization.\r\n         */\r\n        this.collectionGroupReadTime = new Map();\r\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\r\n        this.targetCache = persistence.getTargetCache();\r\n        this.bundleCache = persistence.getBundleCache();\r\n        this.initializeUserComponents(initialUser);\r\n    }\r\n    initializeUserComponents(user) {\r\n        // TODO(indexing): Add spec tests that test these components change after a\r\n        // user change\r\n        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(user);\r\n        this.indexManager = this.persistence.getIndexManager(user);\r\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\r\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.documentOverlayCache, this.indexManager);\r\n        this.remoteDocuments.setIndexManager(this.indexManager);\r\n        this.queryEngine.initialize(this.localDocuments, this.indexManager);\r\n    }\r\n    collectGarbage(garbageCollector) {\r\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\r\n    }\r\n}\r\nfunction newLocalStore(\r\n/** Manages our in-memory or durable persistence. */\r\npersistence, queryEngine, initialUser, serializer) {\r\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\r\n}\r\n/**\r\n * Tells the LocalStore that the currently authenticated user has changed.\r\n *\r\n * In response the local store switches the mutation queue to the new user and\r\n * returns any resulting document changes.\r\n */\r\n// PORTING NOTE: Android and iOS only return the documents affected by the\r\n// change.\r\nasync function localStoreHandleUserChange(localStore, user) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\r\n        // Swap out the mutation queue, grabbing the pending mutation batches\r\n        // before and after.\r\n        let oldBatches;\r\n        return localStoreImpl.mutationQueue\r\n            .getAllMutationBatches(txn)\r\n            .next(promisedOldBatches => {\r\n            oldBatches = promisedOldBatches;\r\n            localStoreImpl.initializeUserComponents(user);\r\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\r\n        })\r\n            .next(newBatches => {\r\n            const removedBatchIds = [];\r\n            const addedBatchIds = [];\r\n            // Union the old/new changed keys.\r\n            let changedKeys = documentKeySet();\r\n            for (const batch of oldBatches) {\r\n                removedBatchIds.push(batch.batchId);\r\n                for (const mutation of batch.mutations) {\r\n                    changedKeys = changedKeys.add(mutation.key);\r\n                }\r\n            }\r\n            for (const batch of newBatches) {\r\n                addedBatchIds.push(batch.batchId);\r\n                for (const mutation of batch.mutations) {\r\n                    changedKeys = changedKeys.add(mutation.key);\r\n                }\r\n            }\r\n            // Return the set of all (potentially) changed documents and the list\r\n            // of mutation batch IDs that were affected by change.\r\n            return localStoreImpl.localDocuments\r\n                .getDocuments(txn, changedKeys)\r\n                .next(affectedDocuments => {\r\n                return {\r\n                    affectedDocuments,\r\n                    removedBatchIds,\r\n                    addedBatchIds\r\n                };\r\n            });\r\n        });\r\n    });\r\n    return result;\r\n}\r\n/* Accepts locally generated Mutations and commit them to storage. */\r\nfunction localStoreWriteLocally(localStore, mutations) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const localWriteTime = Timestamp.now();\r\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\r\n    let overlayedDocuments;\r\n    let mutationBatch;\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\r\n        // Figure out which keys do not have a remote version in the cache, this\r\n        // is needed to create the right overlay mutation: if no remote version\r\n        // presents, we do not need to create overlays as patch mutations.\r\n        // TODO(Overlay): Is there a better way to determine this? Using the\r\n        //  document version does not work because local mutations set them back\r\n        //  to 0.\r\n        let remoteDocs = mutableDocumentMap();\r\n        let docsWithoutRemoteVersion = documentKeySet();\r\n        return localStoreImpl.remoteDocuments\r\n            .getEntries(txn, keys)\r\n            .next(docs => {\r\n            remoteDocs = docs;\r\n            remoteDocs.forEach((key, doc) => {\r\n                if (!doc.isValidDocument()) {\r\n                    docsWithoutRemoteVersion = docsWithoutRemoteVersion.add(key);\r\n                }\r\n            });\r\n        })\r\n            .next(() => {\r\n            // Load and apply all existing mutations. This lets us compute the\r\n            // current base state for all non-idempotent transforms before applying\r\n            // any additional user-provided writes.\r\n            return localStoreImpl.localDocuments.getOverlayedDocuments(txn, remoteDocs);\r\n        })\r\n            .next((docs) => {\r\n            overlayedDocuments = docs;\r\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\r\n            // we record the base state in a separate patch mutation. This is\r\n            // later used to guarantee consistent values and prevents flicker\r\n            // even if the backend sends us an update that already includes our\r\n            // transform.\r\n            const baseMutations = [];\r\n            for (const mutation of mutations) {\r\n                const baseValue = mutationExtractBaseValue(mutation, overlayedDocuments.get(mutation.key).overlayedDocument);\r\n                if (baseValue != null) {\r\n                    // NOTE: The base state should only be applied if there's some\r\n                    // existing document to override, so use a Precondition of\r\n                    // exists=true\r\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\r\n                }\r\n            }\r\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\r\n        })\r\n            .next(batch => {\r\n            mutationBatch = batch;\r\n            const overlays = batch.applyToLocalDocumentSet(overlayedDocuments, docsWithoutRemoteVersion);\r\n            return localStoreImpl.documentOverlayCache.saveOverlays(txn, batch.batchId, overlays);\r\n        });\r\n    })\r\n        .then(() => ({\r\n        batchId: mutationBatch.batchId,\r\n        changes: convertOverlayedDocumentMapToDocumentMap(overlayedDocuments)\r\n    }));\r\n}\r\n/**\r\n * Acknowledges the given batch.\r\n *\r\n * On the happy path when a batch is acknowledged, the local store will\r\n *\r\n *  + remove the batch from the mutation queue;\r\n *  + apply the changes to the remote document cache;\r\n *  + recalculate the latency compensated view implied by those changes (there\r\n *    may be mutations in the queue that affect the documents but haven't been\r\n *    acknowledged yet); and\r\n *  + give the changed documents back the sync engine\r\n *\r\n * @returns The resulting (modified) documents.\r\n */\r\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\r\n        const affected = batchResult.batch.keys();\r\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n        });\r\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\r\n            .next(() => documentBuffer.apply(txn))\r\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\r\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affected, batchResult.batch.batchId))\r\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, getKeysWithTransformResults(batchResult)))\r\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\r\n    });\r\n}\r\nfunction getKeysWithTransformResults(batchResult) {\r\n    let result = documentKeySet();\r\n    for (let i = 0; i < batchResult.mutationResults.length; ++i) {\r\n        const mutationResult = batchResult.mutationResults[i];\r\n        if (mutationResult.transformResults.length > 0) {\r\n            result = result.add(batchResult.batch.mutations[i].key);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Removes mutations from the MutationQueue for the specified batch;\r\n * LocalDocuments will be recalculated.\r\n *\r\n * @returns The resulting modified documents.\r\n */\r\nfunction localStoreRejectBatch(localStore, batchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\r\n        let affectedKeys;\r\n        return localStoreImpl.mutationQueue\r\n            .lookupMutationBatch(txn, batchId)\r\n            .next((batch) => {\r\n            hardAssert(batch !== null);\r\n            affectedKeys = batch.keys();\r\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\r\n        })\r\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\r\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affectedKeys, batchId))\r\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, affectedKeys))\r\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\r\n    });\r\n}\r\n/**\r\n * Returns the largest (latest) batch id in mutation queue that is pending\r\n * server response.\r\n *\r\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\r\n */\r\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\r\n}\r\n/**\r\n * Returns the last consistent snapshot processed (used by the RemoteStore to\r\n * determine whether to buffer incoming snapshots from the backend).\r\n */\r\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\r\n}\r\n/**\r\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\r\n * event reflects any write batches that have been acknowledged or rejected\r\n * (i.e. we do not re-apply local mutations to updates from this event).\r\n *\r\n * LocalDocuments are re-calculated if there are remaining mutations in the\r\n * queue.\r\n */\r\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const remoteVersion = remoteEvent.snapshotVersion;\r\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\r\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n        });\r\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\r\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\r\n        const promises = [];\r\n        remoteEvent.targetChanges.forEach((change, targetId) => {\r\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\r\n            if (!oldTargetData) {\r\n                return;\r\n            }\r\n            // Only update the remote keys if the target is still active. This\r\n            // ensures that we can persist the updated target data along with\r\n            // the updated assignment.\r\n            promises.push(localStoreImpl.targetCache\r\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\r\n                .next(() => {\r\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\r\n            }));\r\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\r\n            if (remoteEvent.targetMismatches.get(targetId) !== null) {\r\n                newTargetData = newTargetData\r\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\r\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\r\n            }\r\n            else if (change.resumeToken.approximateByteSize() > 0) {\r\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\r\n            }\r\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\r\n            // Update the target data if there are target changes (or if\r\n            // sufficient time has passed since the last update).\r\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\r\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\r\n            }\r\n        });\r\n        let changedDocs = mutableDocumentMap();\r\n        let existenceChangedKeys = documentKeySet();\r\n        remoteEvent.documentUpdates.forEach(key => {\r\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\r\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\r\n            }\r\n        });\r\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all\r\n        // the remote documents in advance in a single call.\r\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\r\n            changedDocs = result.changedDocuments;\r\n            existenceChangedKeys = result.existenceChangedKeys;\r\n        }));\r\n        // HACK: The only reason we allow a null snapshot version is so that we\r\n        // can synthesize remote events when we get permission denied errors while\r\n        // trying to resolve the state of a locally cached document that is in\r\n        // limbo.\r\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\r\n            const updateRemoteVersion = localStoreImpl.targetCache\r\n                .getLastRemoteSnapshotVersion(txn)\r\n                .next(lastRemoteSnapshotVersion => {\r\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\r\n            });\r\n            promises.push(updateRemoteVersion);\r\n        }\r\n        return PersistencePromise.waitFor(promises)\r\n            .next(() => documentBuffer.apply(txn))\r\n            .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, changedDocs, existenceChangedKeys))\r\n            .next(() => changedDocs);\r\n    })\r\n        .then(changedDocs => {\r\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\r\n        return changedDocs;\r\n    });\r\n}\r\n/**\r\n * Populates document change buffer with documents from backend or a bundle.\r\n * Returns the document changes resulting from applying those documents, and\r\n * also a set of documents whose existence state are changed as a result.\r\n *\r\n * @param txn - Transaction to use to read existing documents from storage.\r\n * @param documentBuffer - Document buffer to collect the resulted changes to be\r\n *        applied to storage.\r\n * @param documents - Documents to be applied.\r\n */\r\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\r\n    let updatedKeys = documentKeySet();\r\n    let existenceChangedKeys = documentKeySet();\r\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\r\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\r\n        let changedDocuments = mutableDocumentMap();\r\n        documents.forEach((key, doc) => {\r\n            const existingDoc = existingDocs.get(key);\r\n            // Check if see if there is a existence state change for this document.\r\n            if (doc.isFoundDocument() !== existingDoc.isFoundDocument()) {\r\n                existenceChangedKeys = existenceChangedKeys.add(key);\r\n            }\r\n            // Note: The order of the steps below is important, since we want\r\n            // to ensure that rejected limbo resolutions (which fabricate\r\n            // NoDocuments with SnapshotVersion.min()) never add documents to\r\n            // cache.\r\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\r\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\r\n                // events. We remove these documents from cache since we lost\r\n                // access.\r\n                documentBuffer.removeEntry(key, doc.readTime);\r\n                changedDocuments = changedDocuments.insert(key, doc);\r\n            }\r\n            else if (!existingDoc.isValidDocument() ||\r\n                doc.version.compareTo(existingDoc.version) > 0 ||\r\n                (doc.version.compareTo(existingDoc.version) === 0 &&\r\n                    existingDoc.hasPendingWrites)) {\r\n                documentBuffer.addEntry(doc);\r\n                changedDocuments = changedDocuments.insert(key, doc);\r\n            }\r\n            else {\r\n                logDebug(LOG_TAG$b, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\r\n            }\r\n        });\r\n        return { changedDocuments, existenceChangedKeys };\r\n    });\r\n}\r\n/**\r\n * Returns true if the newTargetData should be persisted during an update of\r\n * an active target. TargetData should always be persisted when a target is\r\n * being released and should not call this function.\r\n *\r\n * While the target is active, TargetData updates can be omitted when nothing\r\n * about the target has changed except metadata like the resume token or\r\n * snapshot version. Occasionally it's worth the extra write to prevent these\r\n * values from getting too stale after a crash, but this doesn't have to be\r\n * too frequent.\r\n */\r\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\r\n    // Always persist target data if we don't already have a resume token.\r\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\r\n        return true;\r\n    }\r\n    // Don't allow resume token changes to be buffered indefinitely. This\r\n    // allows us to be reasonably up-to-date after a crash and avoids needing\r\n    // to loop over all active queries on shutdown. Especially in the browser\r\n    // we may not get time to do anything interesting while the current tab is\r\n    // closing.\r\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\r\n        oldTargetData.snapshotVersion.toMicroseconds();\r\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\r\n        return true;\r\n    }\r\n    // Otherwise if the only thing that has changed about a target is its resume\r\n    // token it's not worth persisting. Note that the RemoteStore keeps an\r\n    // in-memory view of the currently active targets which includes the current\r\n    // resume token, so stream failure or user changes will still use an\r\n    // up-to-date resume token regardless of what we do here.\r\n    const changes = change.addedDocuments.size +\r\n        change.modifiedDocuments.size +\r\n        change.removedDocuments.size;\r\n    return changes > 0;\r\n}\r\n/**\r\n * Notifies local store of the changed views to locally pin documents.\r\n */\r\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    try {\r\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\r\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\r\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\r\n            });\r\n        });\r\n    }\r\n    catch (e) {\r\n        if (isIndexedDbTransactionError(e)) {\r\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\r\n            // number for the documents that were included in this transaction.\r\n            // This might trigger them to be deleted earlier than they otherwise\r\n            // would have, but it should not invalidate the integrity of the data.\r\n            logDebug(LOG_TAG$b, 'Failed to update sequence numbers: ' + e);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    for (const viewChange of viewChanges) {\r\n        const targetId = viewChange.targetId;\r\n        if (!viewChange.fromCache) {\r\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n            // Advance the last limbo free snapshot version\r\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\r\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\r\n            localStoreImpl.targetDataByTarget =\r\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\r\n            // TODO(b/272564316): Apply the optimization done on other platforms.\r\n            // This is a problem for web because saving the updated targetData from\r\n            // non-primary client conflicts with what primary client saved.\r\n        }\r\n    }\r\n}\r\n/**\r\n * Gets the mutation batch after the passed in batchId in the mutation queue\r\n * or null if empty.\r\n * @param afterBatchId - If provided, the batch to search after.\r\n * @returns The next mutation or null if there wasn't one.\r\n */\r\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\r\n        if (afterBatchId === undefined) {\r\n            afterBatchId = BATCHID_UNKNOWN;\r\n        }\r\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\r\n    });\r\n}\r\n/**\r\n * Reads the current value of a Document with a given key or null if not\r\n * found - used for testing.\r\n */\r\nfunction localStoreReadDocument(localStore, key) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\r\n}\r\n/**\r\n * Assigns the given target an internal ID so that its results can be pinned so\r\n * they don't get GC'd. A target must be allocated in the local store before\r\n * the store can be used to manage its view.\r\n *\r\n * Allocating an already allocated `Target` will return the existing `TargetData`\r\n * for that `Target`.\r\n */\r\nfunction localStoreAllocateTarget(localStore, target) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Allocate target', 'readwrite', txn => {\r\n        let targetData;\r\n        return localStoreImpl.targetCache\r\n            .getTargetData(txn, target)\r\n            .next((cached) => {\r\n            if (cached) {\r\n                // This target has been listened to previously, so reuse the\r\n                // previous targetID.\r\n                // TODO(mcg): freshen last accessed date?\r\n                targetData = cached;\r\n                return PersistencePromise.resolve(targetData);\r\n            }\r\n            else {\r\n                return localStoreImpl.targetCache\r\n                    .allocateTargetId(txn)\r\n                    .next(targetId => {\r\n                    targetData = new TargetData(target, targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, txn.currentSequenceNumber);\r\n                    return localStoreImpl.targetCache\r\n                        .addTargetData(txn, targetData)\r\n                        .next(() => targetData);\r\n                });\r\n            }\r\n        });\r\n    })\r\n        .then(targetData => {\r\n        // If Multi-Tab is enabled, the existing target data may be newer than\r\n        // the in-memory data\r\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\r\n        if (cachedTargetData === null ||\r\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\r\n                0) {\r\n            localStoreImpl.targetDataByTarget =\r\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\r\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\r\n        }\r\n        return targetData;\r\n    });\r\n}\r\n/**\r\n * Returns the TargetData as seen by the LocalStore, including updates that may\r\n * have not yet been persisted to the TargetCache.\r\n */\r\n// Visible for testing.\r\nfunction localStoreGetTargetData(localStore, transaction, target) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\r\n    if (targetId !== undefined) {\r\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\r\n    }\r\n    else {\r\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\r\n    }\r\n}\r\n/**\r\n * Unpins all the documents associated with the given target. If\r\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\r\n * directly removes the associated target data from the target cache.\r\n *\r\n * Releasing a non-existing `Target` is a no-op.\r\n */\r\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\r\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\r\n    try {\r\n        if (!keepPersistedTargetData) {\r\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\r\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\r\n            });\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (isIndexedDbTransactionError(e)) {\r\n            // All `releaseTarget` does is record the final metadata state for the\r\n            // target, but we've been recording this periodically during target\r\n            // activity. If we lose this write this could cause a very slight\r\n            // difference in the order of target deletion during GC, but we\r\n            // don't define exact LRU semantics so this is acceptable.\r\n            logDebug(LOG_TAG$b, `Failed to update sequence numbers for target ${targetId}: ${e}`);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    localStoreImpl.targetDataByTarget =\r\n        localStoreImpl.targetDataByTarget.remove(targetId);\r\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\r\n}\r\n/**\r\n * Runs the specified query against the local store and returns the results,\r\n * potentially taking advantage of query data from previous executions (such\r\n * as the set of remote keys).\r\n *\r\n * @param usePreviousResults - Whether results from previous executions can\r\n * be used to optimize this query execution.\r\n */\r\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\r\n    let remoteKeys = documentKeySet();\r\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readwrite', // Use readwrite instead of readonly so indexes can be created\r\n    // Use readwrite instead of readonly so indexes can be created\r\n    txn => {\r\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\r\n            .next(targetData => {\r\n            if (targetData) {\r\n                lastLimboFreeSnapshotVersion =\r\n                    targetData.lastLimboFreeSnapshotVersion;\r\n                return localStoreImpl.targetCache\r\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\r\n                    .next(result => {\r\n                    remoteKeys = result;\r\n                });\r\n            }\r\n        })\r\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\r\n            ? lastLimboFreeSnapshotVersion\r\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\r\n            .next(documents => {\r\n            setMaxReadTime(localStoreImpl, queryCollectionGroup(query), documents);\r\n            return { documents, remoteKeys };\r\n        });\r\n    });\r\n}\r\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\r\n    const batch = batchResult.batch;\r\n    const docKeys = batch.keys();\r\n    let promiseChain = PersistencePromise.resolve();\r\n    docKeys.forEach(docKey => {\r\n        promiseChain = promiseChain\r\n            .next(() => documentBuffer.getEntry(txn, docKey))\r\n            .next(doc => {\r\n            const ackVersion = batchResult.docVersions.get(docKey);\r\n            hardAssert(ackVersion !== null);\r\n            if (doc.version.compareTo(ackVersion) < 0) {\r\n                batch.applyToRemoteDocument(doc, batchResult);\r\n                if (doc.isValidDocument()) {\r\n                    // We use the commitVersion as the readTime rather than the\r\n                    // document's updateTime since the updateTime is not advanced\r\n                    // for updates that do not modify the underlying document.\r\n                    doc.setReadTime(batchResult.commitVersion);\r\n                    documentBuffer.addEntry(doc);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\r\n}\r\n/** Returns the local view of the documents affected by a mutation batch. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\r\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\r\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\r\n            if (keys) {\r\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n        });\r\n    });\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\r\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\r\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetActiveClients(localStore) {\r\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\r\n    return persistenceImpl.getActiveClients();\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetCachedTarget(localStore, targetId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\r\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n    if (cachedTargetData) {\r\n        return Promise.resolve(cachedTargetData.target);\r\n    }\r\n    else {\r\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\r\n            return targetCacheImpl\r\n                .getTargetDataForTarget(txn, targetId)\r\n                .next(targetData => (targetData ? targetData.target : null));\r\n        });\r\n    }\r\n}\r\n/**\r\n * Returns the set of documents that have been updated since the last call.\r\n * If this is the first call, returns the set of changes since client\r\n * initialization. Further invocations will return document that have changed\r\n * since the prior call.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetNewDocumentChanges(localStore, collectionGroup) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    // Get the current maximum read time for the collection. This should always\r\n    // exist, but to reduce the chance for regressions we default to\r\n    // SnapshotVersion.Min()\r\n    // TODO(indexing): Consider removing the default value.\r\n    const readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\r\n        SnapshotVersion.min();\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Get new document changes', 'readonly', txn => localStoreImpl.remoteDocuments.getAllFromCollectionGroup(txn, collectionGroup, newIndexOffsetSuccessorFromReadTime(readTime, INITIAL_LARGEST_BATCH_ID), \r\n    /* limit= */ Number.MAX_SAFE_INTEGER))\r\n        .then(changedDocs => {\r\n        setMaxReadTime(localStoreImpl, collectionGroup, changedDocs);\r\n        return changedDocs;\r\n    });\r\n}\r\n/** Sets the collection group's maximum read time from the given documents. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction setMaxReadTime(localStoreImpl, collectionGroup, changedDocs) {\r\n    let readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\r\n        SnapshotVersion.min();\r\n    changedDocs.forEach((_, doc) => {\r\n        if (doc.readTime.compareTo(readTime) > 0) {\r\n            readTime = doc.readTime;\r\n        }\r\n    });\r\n    localStoreImpl.collectionGroupReadTime.set(collectionGroup, readTime);\r\n}\r\n/**\r\n * Creates a new target using the given bundle name, which will be used to\r\n * hold the keys of all documents from the bundle in query-document mappings.\r\n * This ensures that the loaded documents do not get garbage collected\r\n * right away.\r\n */\r\nfunction umbrellaTarget(bundleName) {\r\n    // It is OK that the path used for the query is not valid, because this will\r\n    // not be read and queried.\r\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\r\n}\r\n/**\r\n * Applies the documents from a bundle to the \"ground-state\" (remote)\r\n * documents.\r\n *\r\n * LocalDocuments are re-calculated if there are remaining mutations in the\r\n * queue.\r\n */\r\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    let documentKeys = documentKeySet();\r\n    let documentMap = mutableDocumentMap();\r\n    for (const bundleDoc of documents) {\r\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\r\n        if (bundleDoc.document) {\r\n            documentKeys = documentKeys.add(documentKey);\r\n        }\r\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\r\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\r\n        documentMap = documentMap.insert(documentKey, doc);\r\n    }\r\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n    });\r\n    // Allocates a target to hold all document keys from the bundle, such that\r\n    // they will not get garbage collected right away.\r\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\r\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\r\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\r\n            .next(documentChangeResult => {\r\n            documentBuffer.apply(txn);\r\n            return documentChangeResult;\r\n        })\r\n            .next(documentChangeResult => {\r\n            return localStoreImpl.targetCache\r\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\r\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\r\n                .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, documentChangeResult.changedDocuments, documentChangeResult.existenceChangedKeys))\r\n                .next(() => documentChangeResult.changedDocuments);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns a promise of a boolean to indicate if the given bundle has already\r\n * been loaded and the create time is newer than the current loading bundle.\r\n */\r\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\r\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\r\n    })\r\n        .then(cached => {\r\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\r\n    });\r\n}\r\n/**\r\n * Saves the given `BundleMetadata` to local persistence.\r\n */\r\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\r\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\r\n    });\r\n}\r\n/**\r\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\r\n * resolves to undefined if no persisted data can be found.\r\n */\r\nfunction localStoreGetNamedQuery(localStore, queryName) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\r\n}\r\n/**\r\n * Saves the given `NamedQuery` to local persistence.\r\n */\r\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\r\n    // Allocate a target for the named query such that it can be resumed\r\n    // from associated read time if users use it to listen.\r\n    // NOTE: this also means if no corresponding target exists, the new target\r\n    // will remain active and will not get collected, unless users happen to\r\n    // unlisten the query somehow.\r\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\r\n        const readTime = fromVersion(query.readTime);\r\n        // Simply save the query itself if it is older than what the SDK already\r\n        // has.\r\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\r\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\r\n        }\r\n        // Update existing target data because the query from the bundle is newer.\r\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\r\n        localStoreImpl.targetDataByTarget =\r\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\r\n        return localStoreImpl.targetCache\r\n            .updateTargetData(transaction, newTargetData)\r\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\r\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\r\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\r\n    });\r\n}\r\nasync function localStoreConfigureFieldIndexes(localStore, newFieldIndexes) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const indexManager = localStoreImpl.indexManager;\r\n    const promises = [];\r\n    return localStoreImpl.persistence.runTransaction('Configure indexes', 'readwrite', transaction => indexManager\r\n        .getFieldIndexes(transaction)\r\n        .next(oldFieldIndexes => diffArrays(oldFieldIndexes, newFieldIndexes, fieldIndexSemanticComparator, fieldIndex => {\r\n        promises.push(indexManager.addFieldIndex(transaction, fieldIndex));\r\n    }, fieldIndex => {\r\n        promises.push(indexManager.deleteFieldIndex(transaction, fieldIndex));\r\n    }))\r\n        .next(() => PersistencePromise.waitFor(promises)));\r\n}\r\nfunction localStoreSetIndexAutoCreationEnabled(localStore, isEnabled) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    localStoreImpl.queryEngine.indexAutoCreationEnabled = isEnabled;\r\n}\r\nfunction localStoreDeleteAllFieldIndexes(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const indexManager = localStoreImpl.indexManager;\r\n    return localStoreImpl.persistence.runTransaction('Delete All Indexes', 'readwrite', transaction => indexManager.deleteAllFieldIndexes(transaction));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A tracker to keep a record of important details during database local query\r\n * execution.\r\n */\r\nclass QueryContext {\r\n    constructor() {\r\n        /**\r\n         * Counts the number of documents passed through during local query execution.\r\n         */\r\n        this._documentReadCount = 0;\r\n    }\r\n    get documentReadCount() {\r\n        return this._documentReadCount;\r\n    }\r\n    incrementDocumentReadCount(amount) {\r\n        this._documentReadCount += amount;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE = 100;\r\n/**\r\n * This cost represents the evaluation result of\r\n * (([index, docKey] + [docKey, docContent]) per document in the result set)\r\n * / ([docKey, docContent] per documents in full collection scan) coming from\r\n * experiment [enter PR experiment URL here].\r\n */\r\nfunction getDefaultRelativeIndexReadCostPerDocument() {\r\n    // These values were derived from an experiment where several members of the\r\n    // Firestore SDK team ran a performance test in various environments.\r\n    // Googlers can see b/299284287 for details.\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)()) {\r\n        return 8;\r\n    }\r\n    else if (getAndroidVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) > 0) {\r\n        return 6;\r\n    }\r\n    else {\r\n        return 4;\r\n    }\r\n}\r\n/**\r\n * The Firestore query engine.\r\n *\r\n * Firestore queries can be executed in three modes. The Query Engine determines\r\n * what mode to use based on what data is persisted. The mode only determines\r\n * the runtime complexity of the query - the result set is equivalent across all\r\n * implementations.\r\n *\r\n * The Query engine will use indexed-based execution if a user has configured\r\n * any index that can be used to execute query (via `setIndexConfiguration()`).\r\n * Otherwise, the engine will try to optimize the query by re-using a previously\r\n * persisted query result. If that is not possible, the query will be executed\r\n * via a full collection scan.\r\n *\r\n * Index-based execution is the default when available. The query engine\r\n * supports partial indexed execution and merges the result from the index\r\n * lookup with documents that have not yet been indexed. The index evaluation\r\n * matches the backend's format and as such, the SDK can use indexing for all\r\n * queries that the backend supports.\r\n *\r\n * If no index exists, the query engine tries to take advantage of the target\r\n * document mapping in the TargetCache. These mappings exists for all queries\r\n * that have been synced with the backend at least once and allow the query\r\n * engine to only read documents that previously matched a query plus any\r\n * documents that were edited after the query was last listened to.\r\n *\r\n * There are some cases when this optimization is not guaranteed to produce\r\n * the same results as full collection scans. In these cases, query\r\n * processing falls back to full scans. These cases are:\r\n *\r\n * - Limit queries where a document that matched the query previously no longer\r\n *   matches the query.\r\n *\r\n * - Limit queries where a document edit may cause the document to sort below\r\n *   another document that is in the local cache.\r\n *\r\n * - Queries that have never been CURRENT or free of limbo documents.\r\n */\r\nclass QueryEngine {\r\n    constructor() {\r\n        this.initialized = false;\r\n        this.indexAutoCreationEnabled = false;\r\n        /**\r\n         * SDK only decides whether it should create index when collection size is\r\n         * larger than this.\r\n         */\r\n        this.indexAutoCreationMinCollectionSize = DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE;\r\n        this.relativeIndexReadCostPerDocument = getDefaultRelativeIndexReadCostPerDocument();\r\n    }\r\n    /** Sets the document view to query against. */\r\n    initialize(localDocuments, indexManager) {\r\n        this.localDocumentsView = localDocuments;\r\n        this.indexManager = indexManager;\r\n        this.initialized = true;\r\n    }\r\n    /** Returns all local documents matching the specified query. */\r\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\r\n        // Stores the result from executing the query; using this object is more\r\n        // convenient than passing the result between steps of the persistence\r\n        // transaction and improves readability comparatively.\r\n        const queryResult = { result: null };\r\n        return this.performQueryUsingIndex(transaction, query)\r\n            .next(result => {\r\n            queryResult.result = result;\r\n        })\r\n            .next(() => {\r\n            if (queryResult.result) {\r\n                return;\r\n            }\r\n            return this.performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion).next(result => {\r\n                queryResult.result = result;\r\n            });\r\n        })\r\n            .next(() => {\r\n            if (queryResult.result) {\r\n                return;\r\n            }\r\n            const context = new QueryContext();\r\n            return this.executeFullCollectionScan(transaction, query, context).next(result => {\r\n                queryResult.result = result;\r\n                if (this.indexAutoCreationEnabled) {\r\n                    return this.createCacheIndexes(transaction, query, context, result.size);\r\n                }\r\n            });\r\n        })\r\n            .next(() => queryResult.result);\r\n    }\r\n    createCacheIndexes(transaction, query, context, resultSize) {\r\n        if (context.documentReadCount < this.indexAutoCreationMinCollectionSize) {\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'SDK will not create cache indexes for query:', stringifyQuery(query), 'since it only creates cache indexes for collection contains', 'more than or equal to', this.indexAutoCreationMinCollectionSize, 'documents');\r\n            }\r\n            return PersistencePromise.resolve();\r\n        }\r\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n            logDebug('QueryEngine', 'Query:', stringifyQuery(query), 'scans', context.documentReadCount, 'local documents and returns', resultSize, 'documents as results.');\r\n        }\r\n        if (context.documentReadCount >\r\n            this.relativeIndexReadCostPerDocument * resultSize) {\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'The SDK decides to create cache indexes for query:', stringifyQuery(query), 'as using cache indexes may help improve performance.');\r\n            }\r\n            return this.indexManager.createTargetIndexes(transaction, queryToTarget(query));\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    /**\r\n     * Performs an indexed query that evaluates the query based on a collection's\r\n     * persisted index values. Returns `null` if an index is not available.\r\n     */\r\n    performQueryUsingIndex(transaction, query) {\r\n        if (queryMatchesAllDocuments(query)) {\r\n            // Queries that match all documents don't benefit from using\r\n            // key-based lookups. It is more efficient to scan all documents in a\r\n            // collection, rather than to perform individual lookups.\r\n            return PersistencePromise.resolve(null);\r\n        }\r\n        let target = queryToTarget(query);\r\n        return this.indexManager\r\n            .getIndexType(transaction, target)\r\n            .next(indexType => {\r\n            if (indexType === 0 /* IndexType.NONE */) {\r\n                // The target cannot be served from any index.\r\n                return null;\r\n            }\r\n            if (query.limit !== null && indexType === 1 /* IndexType.PARTIAL */) {\r\n                // We cannot apply a limit for targets that are served using a partial\r\n                // index. If a partial index will be used to serve the target, the\r\n                // query may return a superset of documents that match the target\r\n                // (e.g. if the index doesn't include all the target's filters), or\r\n                // may return the correct set of documents in the wrong order (e.g. if\r\n                // the index doesn't include a segment for one of the orderBys).\r\n                // Therefore, a limit should not be applied in such cases.\r\n                query = queryWithLimit(query, null, \"F\" /* LimitType.First */);\r\n                target = queryToTarget(query);\r\n            }\r\n            return this.indexManager\r\n                .getDocumentsMatchingTarget(transaction, target)\r\n                .next(keys => {\r\n                const sortedKeys = documentKeySet(...keys);\r\n                return this.localDocumentsView\r\n                    .getDocuments(transaction, sortedKeys)\r\n                    .next(indexedDocuments => {\r\n                    return this.indexManager\r\n                        .getMinOffset(transaction, target)\r\n                        .next(offset => {\r\n                        const previousResults = this.applyQuery(query, indexedDocuments);\r\n                        if (this.needsRefill(query, previousResults, sortedKeys, offset.readTime)) {\r\n                            // A limit query whose boundaries change due to local\r\n                            // edits can be re-run against the cache by excluding the\r\n                            // limit. This ensures that all documents that match the\r\n                            // query's filters are included in the result set. The SDK\r\n                            // can then apply the limit once all local edits are\r\n                            // incorporated.\r\n                            return this.performQueryUsingIndex(transaction, queryWithLimit(query, null, \"F\" /* LimitType.First */));\r\n                        }\r\n                        return this.appendRemainingResults(transaction, previousResults, query, offset);\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Performs a query based on the target's persisted query mapping. Returns\r\n     * `null` if the mapping is not available or cannot be used.\r\n     */\r\n    performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion) {\r\n        if (queryMatchesAllDocuments(query)) {\r\n            // Queries that match all documents don't benefit from using\r\n            // key-based lookups. It is more efficient to scan all documents in a\r\n            // collection, rather than to perform individual lookups.\r\n            return PersistencePromise.resolve(null);\r\n        }\r\n        // Queries that have never seen a snapshot without limbo free documents\r\n        // should also be run as a full collection scan.\r\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\r\n            return PersistencePromise.resolve(null);\r\n        }\r\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\r\n            const previousResults = this.applyQuery(query, documents);\r\n            if (this.needsRefill(query, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\r\n            }\r\n            // Retrieve all results for documents that were updated since the last\r\n            // limbo-document free remote snapshot.\r\n            return this.appendRemainingResults(transaction, previousResults, query, newIndexOffsetSuccessorFromReadTime(lastLimboFreeSnapshotVersion, INITIAL_LARGEST_BATCH_ID)).next(results => results);\r\n        });\r\n    }\r\n    /** Applies the query filter and sorting to the provided documents.  */\r\n    applyQuery(query, documents) {\r\n        // Sort the documents and re-apply the query filter since previously\r\n        // matching documents do not necessarily still match the query.\r\n        let queryResults = new SortedSet(newQueryComparator(query));\r\n        documents.forEach((_, maybeDoc) => {\r\n            if (queryMatches(query, maybeDoc)) {\r\n                queryResults = queryResults.add(maybeDoc);\r\n            }\r\n        });\r\n        return queryResults;\r\n    }\r\n    /**\r\n     * Determines if a limit query needs to be refilled from cache, making it\r\n     * ineligible for index-free execution.\r\n     *\r\n     * @param query - The query.\r\n     * @param sortedPreviousResults - The documents that matched the query when it\r\n     * was last synchronized, sorted by the query's comparator.\r\n     * @param remoteKeys - The document keys that matched the query at the last\r\n     * snapshot.\r\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\r\n     * query was last synchronized.\r\n     */\r\n    needsRefill(query, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\r\n        if (query.limit === null) {\r\n            // Queries without limits do not need to be refilled.\r\n            return false;\r\n        }\r\n        if (remoteKeys.size !== sortedPreviousResults.size) {\r\n            // The query needs to be refilled if a previously matching document no\r\n            // longer matches.\r\n            return true;\r\n        }\r\n        // Limit queries are not eligible for index-free query execution if there is\r\n        // a potential that an older document from cache now sorts before a document\r\n        // that was previously part of the limit. This, however, can only happen if\r\n        // the document at the edge of the limit goes out of limit.\r\n        // If a document that is not the limit boundary sorts differently,\r\n        // the boundary of the limit itself did not change and documents from cache\r\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\r\n        // any modifications that don't affect the last document.\r\n        const docAtLimitEdge = query.limitType === \"F\" /* LimitType.First */\r\n            ? sortedPreviousResults.last()\r\n            : sortedPreviousResults.first();\r\n        if (!docAtLimitEdge) {\r\n            // We don't need to refill the query if there were already no documents.\r\n            return false;\r\n        }\r\n        return (docAtLimitEdge.hasPendingWrites ||\r\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\r\n    }\r\n    executeFullCollectionScan(transaction, query, context) {\r\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\r\n        }\r\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, IndexOffset.min(), context);\r\n    }\r\n    /**\r\n     * Combines the results from an indexed execution with the remaining documents\r\n     * that have not yet been indexed.\r\n     */\r\n    appendRemainingResults(transaction, indexedResults, query, offset) {\r\n        // Retrieve all results for documents that were updated since the offset.\r\n        return this.localDocumentsView\r\n            .getDocumentsMatchingQuery(transaction, query, offset)\r\n            .next(remainingResults => {\r\n            // Merge with existing results\r\n            indexedResults.forEach(d => {\r\n                remainingResults = remainingResults.insert(d.key, d);\r\n            });\r\n            return remainingResults;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The format of the LocalStorage key that stores the client state is:\r\n//     firestore_clients_<persistence_prefix>_<instance_key>\r\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\r\n/** Assembles the key for a client state in WebStorage */\r\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\r\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\r\n}\r\n// The format of the WebStorage key that stores the mutation state is:\r\n//     firestore_mutations_<persistence_prefix>_<batch_id>\r\n//     (for unauthenticated users)\r\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\r\n//\r\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\r\n// contain.\r\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\r\n/** Assembles the key for a mutation batch in WebStorage */\r\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\r\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\r\n    if (user.isAuthenticated()) {\r\n        mutationKey += `_${user.uid}`;\r\n    }\r\n    return mutationKey;\r\n}\r\n// The format of the WebStorage key that stores a query target's metadata is:\r\n//     firestore_targets_<persistence_prefix>_<target_id>\r\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\r\n/** Assembles the key for a query state in WebStorage */\r\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\r\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\r\n}\r\n// The WebStorage prefix that stores the primary tab's online state. The\r\n// format of the key is:\r\n//     firestore_online_state_<persistence_prefix>\r\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\r\n/** Assembles the key for the online state of the primary tab. */\r\nfunction createWebStorageOnlineStateKey(persistenceKey) {\r\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\r\n}\r\n// The WebStorage prefix that plays as a event to indicate the remote documents\r\n// might have changed due to some secondary tabs loading a bundle.\r\n// format of the key is:\r\n//     firestore_bundle_loaded_v2_<persistenceKey>\r\n// The version ending with \"v2\" stores the list of modified collection groups.\r\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded_v2';\r\nfunction createBundleLoadedKey(persistenceKey) {\r\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\r\n}\r\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\r\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\r\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\r\n/** Assembles the key for the current sequence number. */\r\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\r\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$a = 'SharedClientState';\r\n/**\r\n * Holds the state of a mutation batch, including its user ID, batch ID and\r\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\r\n */\r\n// Visible for testing\r\nclass MutationMetadata {\r\n    constructor(user, batchId, state, error) {\r\n        this.user = user;\r\n        this.batchId = batchId;\r\n        this.state = state;\r\n        this.error = error;\r\n    }\r\n    /**\r\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(user, batchId, value) {\r\n        const mutationBatch = JSON.parse(value);\r\n        let validData = typeof mutationBatch === 'object' &&\r\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\r\n                -1 &&\r\n            (mutationBatch.error === undefined ||\r\n                typeof mutationBatch.error === 'object');\r\n        let firestoreError = undefined;\r\n        if (validData && mutationBatch.error) {\r\n            validData =\r\n                typeof mutationBatch.error.message === 'string' &&\r\n                    typeof mutationBatch.error.code === 'string';\r\n            if (validData) {\r\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\r\n            }\r\n        }\r\n        if (validData) {\r\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n    toWebStorageJSON() {\r\n        const batchMetadata = {\r\n            state: this.state,\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        if (this.error) {\r\n            batchMetadata.error = {\r\n                code: this.error.code,\r\n                message: this.error.message\r\n            };\r\n        }\r\n        return JSON.stringify(batchMetadata);\r\n    }\r\n}\r\n/**\r\n * Holds the state of a query target, including its target ID and whether the\r\n * target is 'not-current', 'current' or 'rejected'.\r\n */\r\n// Visible for testing\r\nclass QueryTargetMetadata {\r\n    constructor(targetId, state, error) {\r\n        this.targetId = targetId;\r\n        this.state = state;\r\n        this.error = error;\r\n    }\r\n    /**\r\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(targetId, value) {\r\n        const targetState = JSON.parse(value);\r\n        let validData = typeof targetState === 'object' &&\r\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\r\n                -1 &&\r\n            (targetState.error === undefined ||\r\n                typeof targetState.error === 'object');\r\n        let firestoreError = undefined;\r\n        if (validData && targetState.error) {\r\n            validData =\r\n                typeof targetState.error.message === 'string' &&\r\n                    typeof targetState.error.code === 'string';\r\n            if (validData) {\r\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\r\n            }\r\n        }\r\n        if (validData) {\r\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n    toWebStorageJSON() {\r\n        const targetState = {\r\n            state: this.state,\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        if (this.error) {\r\n            targetState.error = {\r\n                code: this.error.code,\r\n                message: this.error.message\r\n            };\r\n        }\r\n        return JSON.stringify(targetState);\r\n    }\r\n}\r\n/**\r\n * This class represents the immutable ClientState for a client read from\r\n * WebStorage, containing the list of active query targets.\r\n */\r\nclass RemoteClientState {\r\n    constructor(clientId, activeTargetIds) {\r\n        this.clientId = clientId;\r\n        this.activeTargetIds = activeTargetIds;\r\n    }\r\n    /**\r\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(clientId, value) {\r\n        const clientState = JSON.parse(value);\r\n        let validData = typeof clientState === 'object' &&\r\n            clientState.activeTargetIds instanceof Array;\r\n        let activeTargetIdsSet = targetIdSet();\r\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\r\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\r\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\r\n        }\r\n        if (validData) {\r\n            return new RemoteClientState(clientId, activeTargetIdsSet);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * This class represents the online state for all clients participating in\r\n * multi-tab. The online state is only written to by the primary client, and\r\n * used in secondary clients to update their query views.\r\n */\r\nclass SharedOnlineState {\r\n    constructor(clientId, onlineState) {\r\n        this.clientId = clientId;\r\n        this.onlineState = onlineState;\r\n    }\r\n    /**\r\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(value) {\r\n        const onlineState = JSON.parse(value);\r\n        const validData = typeof onlineState === 'object' &&\r\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\r\n                -1 &&\r\n            typeof onlineState.clientId === 'string';\r\n        if (validData) {\r\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\r\n * mutable and keeps track of all pending mutations, which allows us to\r\n * update the range of pending mutation batch IDs as new mutations are added or\r\n * removed.\r\n *\r\n * The data in `LocalClientState` is not read from WebStorage and instead\r\n * updated via its instance methods. The updated state can be serialized via\r\n * `toWebStorageJSON()`.\r\n */\r\n// Visible for testing.\r\nclass LocalClientState {\r\n    constructor() {\r\n        this.activeTargetIds = targetIdSet();\r\n    }\r\n    addQueryTarget(targetId) {\r\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\r\n    }\r\n    removeQueryTarget(targetId) {\r\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\r\n    }\r\n    /**\r\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\r\n     * Does not encode `clientId` as it is part of the key in WebStorage.\r\n     */\r\n    toWebStorageJSON() {\r\n        const data = {\r\n            activeTargetIds: this.activeTargetIds.toArray(),\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        return JSON.stringify(data);\r\n    }\r\n}\r\n/**\r\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\r\n * backing store for the SharedClientState. It keeps track of all active\r\n * clients and supports modifications of the local client's data.\r\n */\r\nclass WebStorageSharedClientState {\r\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\r\n        this.window = window;\r\n        this.queue = queue;\r\n        this.persistenceKey = persistenceKey;\r\n        this.localClientId = localClientId;\r\n        this.syncEngine = null;\r\n        this.onlineStateHandler = null;\r\n        this.sequenceNumberHandler = null;\r\n        this.storageListener = this.handleWebStorageEvent.bind(this);\r\n        this.activeClients = new SortedMap(primitiveComparator);\r\n        this.started = false;\r\n        /**\r\n         * Captures WebStorage events that occur before `start()` is called. These\r\n         * events are replayed once `WebStorageSharedClientState` is started.\r\n         */\r\n        this.earlyEvents = [];\r\n        // Escape the special characters mentioned here:\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n        this.storage = this.window.localStorage;\r\n        this.currentUser = initialUser;\r\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\r\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\r\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\r\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\r\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\r\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\r\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\r\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\r\n        // Rather than adding the storage observer during start(), we add the\r\n        // storage observer during initialization. This ensures that we collect\r\n        // events before other components populate their initial state (during their\r\n        // respective start() calls). Otherwise, we might for example miss a\r\n        // mutation that is added after LocalStore's start() processed the existing\r\n        // mutations but before we observe WebStorage events.\r\n        this.window.addEventListener('storage', this.storageListener);\r\n    }\r\n    /** Returns 'true' if WebStorage is available in the current environment. */\r\n    static isAvailable(window) {\r\n        return !!(window && window.localStorage);\r\n    }\r\n    async start() {\r\n        // Retrieve the list of existing clients to backfill the data in\r\n        // SharedClientState.\r\n        const existingClients = await this.syncEngine.getActiveClients();\r\n        for (const clientId of existingClients) {\r\n            if (clientId === this.localClientId) {\r\n                continue;\r\n            }\r\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\r\n            if (storageItem) {\r\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\r\n                if (clientState) {\r\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\r\n                }\r\n            }\r\n        }\r\n        this.persistClientState();\r\n        // Check if there is an existing online state and call the callback handler\r\n        // if applicable.\r\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\r\n        if (onlineStateJSON) {\r\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\r\n            if (onlineState) {\r\n                this.handleOnlineStateEvent(onlineState);\r\n            }\r\n        }\r\n        for (const event of this.earlyEvents) {\r\n            this.handleWebStorageEvent(event);\r\n        }\r\n        this.earlyEvents = [];\r\n        // Register a window unload hook to remove the client metadata entry from\r\n        // WebStorage even if `shutdown()` was not called.\r\n        this.window.addEventListener('pagehide', () => this.shutdown());\r\n        this.started = true;\r\n    }\r\n    writeSequenceNumber(sequenceNumber) {\r\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\r\n    }\r\n    getAllActiveQueryTargets() {\r\n        return this.extractActiveQueryTargets(this.activeClients);\r\n    }\r\n    isActiveQueryTarget(targetId) {\r\n        let found = false;\r\n        this.activeClients.forEach((key, value) => {\r\n            if (value.activeTargetIds.has(targetId)) {\r\n                found = true;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n    addPendingMutation(batchId) {\r\n        this.persistMutationState(batchId, 'pending');\r\n    }\r\n    updateMutationState(batchId, state, error) {\r\n        this.persistMutationState(batchId, state, error);\r\n        // Once a final mutation result is observed by other clients, they no longer\r\n        // access the mutation's metadata entry. Since WebStorage replays events\r\n        // in order, it is safe to delete the entry right after updating it.\r\n        this.removeMutationState(batchId);\r\n    }\r\n    addLocalQueryTarget(targetId) {\r\n        let queryState = 'not-current';\r\n        // Lookup an existing query state if the target ID was already registered\r\n        // by another tab\r\n        if (this.isActiveQueryTarget(targetId)) {\r\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\r\n            if (storageItem) {\r\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\r\n                if (metadata) {\r\n                    queryState = metadata.state;\r\n                }\r\n            }\r\n        }\r\n        this.localClientState.addQueryTarget(targetId);\r\n        this.persistClientState();\r\n        return queryState;\r\n    }\r\n    removeLocalQueryTarget(targetId) {\r\n        this.localClientState.removeQueryTarget(targetId);\r\n        this.persistClientState();\r\n    }\r\n    isLocalQueryTarget(targetId) {\r\n        return this.localClientState.activeTargetIds.has(targetId);\r\n    }\r\n    clearQueryState(targetId) {\r\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\r\n    }\r\n    updateQueryState(targetId, state, error) {\r\n        this.persistQueryTargetState(targetId, state, error);\r\n    }\r\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\r\n        removedBatchIds.forEach(batchId => {\r\n            this.removeMutationState(batchId);\r\n        });\r\n        this.currentUser = user;\r\n        addedBatchIds.forEach(batchId => {\r\n            this.addPendingMutation(batchId);\r\n        });\r\n    }\r\n    setOnlineState(onlineState) {\r\n        this.persistOnlineState(onlineState);\r\n    }\r\n    notifyBundleLoaded(collectionGroups) {\r\n        this.persistBundleLoadedState(collectionGroups);\r\n    }\r\n    shutdown() {\r\n        if (this.started) {\r\n            this.window.removeEventListener('storage', this.storageListener);\r\n            this.removeItem(this.localClientStorageKey);\r\n            this.started = false;\r\n        }\r\n    }\r\n    getItem(key) {\r\n        const value = this.storage.getItem(key);\r\n        logDebug(LOG_TAG$a, 'READ', key, value);\r\n        return value;\r\n    }\r\n    setItem(key, value) {\r\n        logDebug(LOG_TAG$a, 'SET', key, value);\r\n        this.storage.setItem(key, value);\r\n    }\r\n    removeItem(key) {\r\n        logDebug(LOG_TAG$a, 'REMOVE', key);\r\n        this.storage.removeItem(key);\r\n    }\r\n    handleWebStorageEvent(event) {\r\n        // Note: The function is typed to take Event to be interface-compatible with\r\n        // `Window.addEventListener`.\r\n        const storageEvent = event;\r\n        if (storageEvent.storageArea === this.storage) {\r\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\r\n            if (storageEvent.key === this.localClientStorageKey) {\r\n                logError('Received WebStorage notification for local change. Another client might have ' +\r\n                    'garbage-collected our state');\r\n                return;\r\n            }\r\n            this.queue.enqueueRetryable(async () => {\r\n                if (!this.started) {\r\n                    this.earlyEvents.push(storageEvent);\r\n                    return;\r\n                }\r\n                if (storageEvent.key === null) {\r\n                    return;\r\n                }\r\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue != null) {\r\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\r\n                        if (clientState) {\r\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\r\n                        }\r\n                    }\r\n                    else {\r\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\r\n                        return this.handleClientStateEvent(clientId, null);\r\n                    }\r\n                }\r\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\r\n                        if (mutationMetadata) {\r\n                            return this.handleMutationBatchEvent(mutationMetadata);\r\n                        }\r\n                    }\r\n                }\r\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\r\n                        if (queryTargetMetadata) {\r\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\r\n                        }\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.onlineStateKey) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\r\n                        if (onlineState) {\r\n                            return this.handleOnlineStateEvent(onlineState);\r\n                        }\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.sequenceNumberKey) {\r\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\r\n                    if (sequenceNumber !== ListenSequence.INVALID) {\r\n                        this.sequenceNumberHandler(sequenceNumber);\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.bundleLoadedKey) {\r\n                    const collectionGroups = this.fromWebStoreBundleLoadedState(storageEvent.newValue);\r\n                    await Promise.all(collectionGroups.map(cg => this.syncEngine.synchronizeWithChangedDocuments(cg)));\r\n                }\r\n            });\r\n        }\r\n    }\r\n    get localClientState() {\r\n        return this.activeClients.get(this.localClientId);\r\n    }\r\n    persistClientState() {\r\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\r\n    }\r\n    persistMutationState(batchId, state, error) {\r\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\r\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\r\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\r\n    }\r\n    removeMutationState(batchId) {\r\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\r\n        this.removeItem(mutationKey);\r\n    }\r\n    persistOnlineState(onlineState) {\r\n        const entry = {\r\n            clientId: this.localClientId,\r\n            onlineState\r\n        };\r\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\r\n    }\r\n    persistQueryTargetState(targetId, state, error) {\r\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\r\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\r\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\r\n    }\r\n    persistBundleLoadedState(collectionGroups) {\r\n        const json = JSON.stringify(Array.from(collectionGroups));\r\n        this.setItem(this.bundleLoadedKey, json);\r\n    }\r\n    /**\r\n     * Parses a client state key in WebStorage. Returns null if the key does not\r\n     * match the expected key format.\r\n     */\r\n    fromWebStorageClientStateKey(key) {\r\n        const match = this.clientStateKeyRe.exec(key);\r\n        return match ? match[1] : null;\r\n    }\r\n    /**\r\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\r\n     * be parsed.\r\n     */\r\n    fromWebStorageClientState(key, value) {\r\n        const clientId = this.fromWebStorageClientStateKey(key);\r\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\r\n    }\r\n    /**\r\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageMutationMetadata(key, value) {\r\n        const match = this.mutationBatchKeyRe.exec(key);\r\n        const batchId = Number(match[1]);\r\n        const userId = match[2] !== undefined ? match[2] : null;\r\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\r\n    }\r\n    /**\r\n     * Parses a query target state from WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageQueryTargetMetadata(key, value) {\r\n        const match = this.queryTargetKeyRe.exec(key);\r\n        const targetId = Number(match[1]);\r\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\r\n    }\r\n    /**\r\n     * Parses an online state from WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageOnlineState(value) {\r\n        return SharedOnlineState.fromWebStorageEntry(value);\r\n    }\r\n    fromWebStoreBundleLoadedState(value) {\r\n        return JSON.parse(value);\r\n    }\r\n    async handleMutationBatchEvent(mutationBatch) {\r\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\r\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\r\n            return;\r\n        }\r\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\r\n    }\r\n    handleQueryTargetEvent(targetMetadata) {\r\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\r\n    }\r\n    handleClientStateEvent(clientId, clientState) {\r\n        const updatedClients = clientState\r\n            ? this.activeClients.insert(clientId, clientState)\r\n            : this.activeClients.remove(clientId);\r\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\r\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\r\n        const addedTargets = [];\r\n        const removedTargets = [];\r\n        newTargets.forEach(targetId => {\r\n            if (!existingTargets.has(targetId)) {\r\n                addedTargets.push(targetId);\r\n            }\r\n        });\r\n        existingTargets.forEach(targetId => {\r\n            if (!newTargets.has(targetId)) {\r\n                removedTargets.push(targetId);\r\n            }\r\n        });\r\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\r\n            this.activeClients = updatedClients;\r\n        });\r\n    }\r\n    handleOnlineStateEvent(onlineState) {\r\n        // We check whether the client that wrote this online state is still active\r\n        // by comparing its client ID to the list of clients kept active in\r\n        // IndexedDb. If a client does not update their IndexedDb client state\r\n        // within 5 seconds, it is considered inactive and we don't emit an online\r\n        // state event.\r\n        if (this.activeClients.get(onlineState.clientId)) {\r\n            this.onlineStateHandler(onlineState.onlineState);\r\n        }\r\n    }\r\n    extractActiveQueryTargets(clients) {\r\n        let activeTargets = targetIdSet();\r\n        clients.forEach((kev, value) => {\r\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\r\n        });\r\n        return activeTargets;\r\n    }\r\n}\r\nfunction fromWebStorageSequenceNumber(seqString) {\r\n    let sequenceNumber = ListenSequence.INVALID;\r\n    if (seqString != null) {\r\n        try {\r\n            const parsed = JSON.parse(seqString);\r\n            hardAssert(typeof parsed === 'number');\r\n            sequenceNumber = parsed;\r\n        }\r\n        catch (e) {\r\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\r\n        }\r\n    }\r\n    return sequenceNumber;\r\n}\r\n/**\r\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\r\n * clients using memory persistence. The state in this class remains fully\r\n * isolated and no synchronization is performed.\r\n */\r\nclass MemorySharedClientState {\r\n    constructor() {\r\n        this.localState = new LocalClientState();\r\n        this.queryState = {};\r\n        this.onlineStateHandler = null;\r\n        this.sequenceNumberHandler = null;\r\n    }\r\n    addPendingMutation(batchId) {\r\n        // No op.\r\n    }\r\n    updateMutationState(batchId, state, error) {\r\n        // No op.\r\n    }\r\n    addLocalQueryTarget(targetId) {\r\n        this.localState.addQueryTarget(targetId);\r\n        return this.queryState[targetId] || 'not-current';\r\n    }\r\n    updateQueryState(targetId, state, error) {\r\n        this.queryState[targetId] = state;\r\n    }\r\n    removeLocalQueryTarget(targetId) {\r\n        this.localState.removeQueryTarget(targetId);\r\n    }\r\n    isLocalQueryTarget(targetId) {\r\n        return this.localState.activeTargetIds.has(targetId);\r\n    }\r\n    clearQueryState(targetId) {\r\n        delete this.queryState[targetId];\r\n    }\r\n    getAllActiveQueryTargets() {\r\n        return this.localState.activeTargetIds;\r\n    }\r\n    isActiveQueryTarget(targetId) {\r\n        return this.localState.activeTargetIds.has(targetId);\r\n    }\r\n    start() {\r\n        this.localState = new LocalClientState();\r\n        return Promise.resolve();\r\n    }\r\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\r\n        // No op.\r\n    }\r\n    setOnlineState(onlineState) {\r\n        // No op.\r\n    }\r\n    shutdown() { }\r\n    writeSequenceNumber(sequenceNumber) { }\r\n    notifyBundleLoaded(collectionGroups) {\r\n        // No op.\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass NoopConnectivityMonitor {\r\n    addCallback(callback) {\r\n        // No-op.\r\n    }\r\n    shutdown() {\r\n        // No-op.\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides a simple helper class that implements the Stream interface to\r\n * bridge to other implementations that are streams but do not implement the\r\n * interface. The stream callbacks are invoked with the callOn... methods.\r\n */\r\nclass StreamBridge {\r\n    constructor(args) {\r\n        this.sendFn = args.sendFn;\r\n        this.closeFn = args.closeFn;\r\n    }\r\n    onConnected(callback) {\r\n        this.wrappedOnConnected = callback;\r\n    }\r\n    onOpen(callback) {\r\n        this.wrappedOnOpen = callback;\r\n    }\r\n    onClose(callback) {\r\n        this.wrappedOnClose = callback;\r\n    }\r\n    onMessage(callback) {\r\n        this.wrappedOnMessage = callback;\r\n    }\r\n    close() {\r\n        this.closeFn();\r\n    }\r\n    send(msg) {\r\n        this.sendFn(msg);\r\n    }\r\n    callOnConnected() {\r\n        this.wrappedOnConnected();\r\n    }\r\n    callOnOpen() {\r\n        this.wrappedOnOpen();\r\n    }\r\n    callOnClose(err) {\r\n        this.wrappedOnClose(err);\r\n    }\r\n    callOnMessage(msg) {\r\n        this.wrappedOnMessage(msg);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The value returned from the most recent invocation of\r\n * `generateUniqueDebugId()`, or null if it has never been invoked.\r\n */\r\nlet lastUniqueDebugId = null;\r\n/**\r\n * Generates and returns an initial value for `lastUniqueDebugId`.\r\n *\r\n * The returned value is randomly selected from a range of integers that are\r\n * represented as 8 hexadecimal digits. This means that (within reason) any\r\n * numbers generated by incrementing the returned number by 1 will also be\r\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\r\n * length when converted to a hexadecimal string, making reading logs containing\r\n * these IDs easier to follow. And since the return value is randomly selected\r\n * it will help to differentiate between logs from different executions.\r\n */\r\nfunction generateInitialUniqueDebugId() {\r\n    const minResult = 0x10000000;\r\n    const maxResult = 0x90000000;\r\n    const resultRange = maxResult - minResult;\r\n    const resultOffset = Math.round(resultRange * Math.random());\r\n    return minResult + resultOffset;\r\n}\r\n/**\r\n * Generates and returns a unique ID as a hexadecimal string.\r\n *\r\n * The returned ID is intended to be used in debug logging messages to help\r\n * correlate log messages that may be spatially separated in the logs, but\r\n * logically related. For example, a network connection could include the same\r\n * \"debug ID\" string in all of its log messages to help trace a specific\r\n * connection over time.\r\n *\r\n * @return the 10-character generated ID (e.g. \"0xa1b2c3d4\").\r\n */\r\nfunction generateUniqueDebugId() {\r\n    if (lastUniqueDebugId === null) {\r\n        lastUniqueDebugId = generateInitialUniqueDebugId();\r\n    }\r\n    else {\r\n        lastUniqueDebugId++;\r\n    }\r\n    return '0x' + lastUniqueDebugId.toString(16);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\r\n * details.\r\n */\r\n/**\r\n * Creates a node-style callback that resolves or rejects a new Promise. The\r\n * callback is passed to the given action which can then use the callback as\r\n * a parameter to a node-style function.\r\n *\r\n * The intent is to directly bridge a node-style function (which takes a\r\n * callback) into a Promise without manually converting between the node-style\r\n * callback and the promise at each call.\r\n *\r\n * In effect it allows you to convert:\r\n *\r\n * @example\r\n * new Promise((resolve: (value?: fs.Stats) => void,\r\n *              reject: (error?: any) => void) => {\r\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\r\n *     if (error) {\r\n *       reject(error);\r\n *     } else {\r\n *       resolve(stat);\r\n *     }\r\n *   });\r\n * });\r\n *\r\n * Into\r\n * @example\r\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\r\n *   fs.stat(path, callback);\r\n * });\r\n *\r\n * @param action - a function that takes a node-style callback as an argument\r\n *     and then uses that callback to invoke some node-style API.\r\n * @returns a new Promise which will be rejected if the callback is given the\r\n *     first Error parameter or will resolve to the value given otherwise.\r\n */\r\nfunction nodePromise(action) {\r\n    return new Promise((resolve, reject) => {\r\n        action((error, value) => {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(value);\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: Fetch runtime version from grpc-js/package.json instead\r\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\r\nconst grpcVersion = '1.9.1';\r\nconst LOG_TAG$9 = 'GrpcConnection';\r\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\r\nfunction createMetadata(databasePath, authToken, appCheckToken, appId) {\r\n    hardAssert(authToken === null || authToken.type === 'OAuth');\r\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.Metadata();\r\n    if (authToken) {\r\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\r\n    }\r\n    if (appCheckToken) {\r\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\r\n    }\r\n    if (appId) {\r\n        metadata.set('X-Firebase-GMPID', appId);\r\n    }\r\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\r\n    // These headers are used to improve routing and project isolation by the\r\n    // backend.\r\n    // TODO(b/199767712): We are keeping 'Google-Cloud-Resource-Prefix' until Emulators can be\r\n    // released with cl/428820046. Currently blocked because Emulators are now built with Java\r\n    // 11 from Google3.\r\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\r\n    metadata.set('x-goog-request-params', databasePath);\r\n    return metadata;\r\n}\r\n/**\r\n * A Connection implemented by GRPC-Node.\r\n */\r\nclass GrpcConnection {\r\n    constructor(protos, databaseInfo) {\r\n        this.databaseInfo = databaseInfo;\r\n        // We cache stubs for the most-recently-used token.\r\n        this.cachedStub = null;\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        this.firestore = protos['google']['firestore']['v1'];\r\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\r\n    }\r\n    get shouldResourcePathBeIncludedInRequest() {\r\n        // Both `invokeRPC()` and `invokeStreamingRPC()` ignore their `path` arguments, and expect\r\n        // the \"path\" to be part of the given `request`.\r\n        return true;\r\n    }\r\n    ensureActiveStub() {\r\n        if (!this.cachedStub) {\r\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\r\n            const credentials = this.databaseInfo.ssl\r\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createSsl()\r\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createInsecure();\r\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\r\n        }\r\n        return this.cachedStub;\r\n    }\r\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\r\n        const streamId = generateUniqueDebugId();\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const jsonRequest = Object.assign({ database: this.databasePath }, request);\r\n        return nodePromise((callback) => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked with request:`, request);\r\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\r\n                if (grpcError) {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\r\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed with response:`, value);\r\n                    callback(undefined, value);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\r\n        const streamId = generateUniqueDebugId();\r\n        const results = [];\r\n        const responseDeferred = new Deferred();\r\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked (streaming) with request:`, request);\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });\r\n        const stream = stub[rpcName](jsonRequest, metadata);\r\n        let callbackFired = false;\r\n        stream.on('data', (response) => {\r\n            logDebug(LOG_TAG$9, `RPC ${rpcName} ${streamId} received result:`, response);\r\n            results.push(response);\r\n            if (expectedResponseCount !== undefined &&\r\n                results.length === expectedResponseCount) {\r\n                callbackFired = true;\r\n                responseDeferred.resolve(results);\r\n            }\r\n        });\r\n        stream.on('end', () => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed.`);\r\n            if (!callbackFired) {\r\n                callbackFired = true;\r\n                responseDeferred.resolve(results);\r\n            }\r\n        });\r\n        stream.on('error', (grpcError) => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\r\n            const code = mapCodeFromRpcCode(grpcError.code);\r\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\r\n        });\r\n        return responseDeferred.promise;\r\n    }\r\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\r\n    openStream(rpcName, authToken, appCheckToken) {\r\n        const streamId = generateUniqueDebugId();\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const grpcStream = stub[rpcName](metadata);\r\n        let closed = false;\r\n        const close = (err) => {\r\n            if (!closed) {\r\n                closed = true;\r\n                stream.callOnClose(err);\r\n                grpcStream.end();\r\n            }\r\n        };\r\n        const stream = new StreamBridge({\r\n            sendFn: (msg) => {\r\n                if (!closed) {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} sending:`, msg);\r\n                    try {\r\n                        grpcStream.write(msg);\r\n                    }\r\n                    catch (e) {\r\n                        // This probably means we didn't conform to the proto.  Make sure to\r\n                        // log the message we sent.\r\n                        logError('Failure sending:', msg);\r\n                        logError('Error:', e);\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ` +\r\n                        'not sending because gRPC stream is closed:', msg);\r\n                }\r\n            },\r\n            closeFn: () => {\r\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} closed locally via close().`);\r\n                close();\r\n            }\r\n        });\r\n        let onConnectedSent = false;\r\n        grpcStream.on('data', (msg) => {\r\n            if (!closed) {\r\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} received:`, msg);\r\n                // Emulate the \"onConnected\" event that WebChannelConnection sends.\r\n                if (!onConnectedSent) {\r\n                    stream.callOnConnected();\r\n                    onConnectedSent = true;\r\n                }\r\n                stream.callOnMessage(msg);\r\n            }\r\n        });\r\n        grpcStream.on('end', () => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ended.`);\r\n            close();\r\n        });\r\n        grpcStream.on('error', (grpcError) => {\r\n            if (!closed) {\r\n                logWarn(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} error. Code:`, grpcError.code, 'Message:', grpcError.message);\r\n                const code = mapCodeFromRpcCode(grpcError.code);\r\n                close(new FirestoreError(code, grpcError.message));\r\n            }\r\n        });\r\n        logDebug(LOG_TAG$9, `Opening RPC '${rpcName}' stream ${streamId} ` +\r\n            `to ${this.databaseInfo.host}`);\r\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\r\n        // simulate an onOpen in the next loop after the stream had it's listeners\r\n        // registered\r\n        setTimeout(() => {\r\n            stream.callOnOpen();\r\n        }, 0);\r\n        return stream;\r\n    }\r\n    /**\r\n     * Closes and cleans up any resources associated with the GrpcConnection.\r\n     * If a gRPC client has been generated for this connection, the gRPC client\r\n     * is closed. Failure to call terminate on a GrpcConnection can result\r\n     * in leaked resources of the gRPC client.\r\n     */\r\n    terminate() {\r\n        if (this.cachedStub) {\r\n            this.cachedStub.close();\r\n            this.cachedStub = undefined;\r\n        }\r\n    }\r\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.WellKnownTypes\",\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/ptypes/wrappers\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"WrappersProto\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttypeUrl: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"WriteProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAggregationResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\taggregateFields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBitSequence: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbitmap: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpadding: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBloomFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbits: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BitSequence\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\thashCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunAggregationQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunAggregationQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredAggregationQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\ttype: \"AggregationResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpectedCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOR: 2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredAggregationQuery: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taggregations: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Aggregation\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tAggregation: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperator: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"count\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"sum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"avg\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Count\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Sum\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tavg: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Avg\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\talias: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tCount: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tupTo: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int64Value\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tSum: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tAvg: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tunchangedNames: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BloomFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api/annotations;annotations\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"HttpProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Used by tests so we can match @grpc/proto-loader behavior. */\r\nconst protoLoaderOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    defaults: true,\r\n    oneofs: false\r\n};\r\n/**\r\n * Loads the protocol buffer definitions for Firestore.\r\n *\r\n * @returns The GrpcObject representing our protos.\r\n */\r\nfunction loadProtos() {\r\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__.fromJSON(protos$1, protoLoaderOptions);\r\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.loadPackageDefinition(packageDefinition);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Loads the GRPC stack */\r\nfunction newConnection(databaseInfo) {\r\n    const protos = loadProtos();\r\n    return new GrpcConnection(protos, databaseInfo);\r\n}\r\n/** Return the Platform-specific connectivity monitor. */\r\nfunction newConnectivityMonitor() {\r\n    return new NoopConnectivityMonitor();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** The Platform's 'window' implementation or null if not available. */\r\nfunction getWindow() {\r\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\r\n        // eslint-disable-next-line no-restricted-globals\r\n        return window;\r\n    }\r\n    return null;\r\n}\r\n/** The Platform's 'document' implementation or null if not available. */\r\nfunction getDocument() {\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newSerializer(databaseId) {\r\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$8 = 'ExponentialBackoff';\r\n/**\r\n * Initial backoff time in milliseconds after an error.\r\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\r\n */\r\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\r\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\r\n/** Maximum backoff time in milliseconds */\r\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\r\n/**\r\n * A helper for running delayed tasks following an exponential backoff curve\r\n * between attempts.\r\n *\r\n * Each delay is made up of a \"base\" delay which follows the exponential\r\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\r\n * base delay. This prevents clients from accidentally synchronizing their\r\n * delays causing spikes of load to the backend.\r\n */\r\nclass ExponentialBackoff {\r\n    constructor(\r\n    /**\r\n     * The AsyncQueue to run backoff operations on.\r\n     */\r\n    queue, \r\n    /**\r\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\r\n     */\r\n    timerId, \r\n    /**\r\n     * The initial delay (used as the base delay on the first retry attempt).\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * little as 0.5*initialDelayMs.\r\n     */\r\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \r\n    /**\r\n     * The multiplier to use to determine the extended base delay after each\r\n     * attempt.\r\n     */\r\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \r\n    /**\r\n     * The maximum base delay after which no further backoff is performed.\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * much as 1.5*maxDelayMs.\r\n     */\r\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\r\n        this.queue = queue;\r\n        this.timerId = timerId;\r\n        this.initialDelayMs = initialDelayMs;\r\n        this.backoffFactor = backoffFactor;\r\n        this.maxDelayMs = maxDelayMs;\r\n        this.currentBaseMs = 0;\r\n        this.timerPromise = null;\r\n        /** The last backoff attempt, as epoch milliseconds. */\r\n        this.lastAttemptTime = Date.now();\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Resets the backoff delay.\r\n     *\r\n     * The very next backoffAndWait() will have no delay. If it is called again\r\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\r\n     * subsequent ones will increase according to the backoffFactor.\r\n     */\r\n    reset() {\r\n        this.currentBaseMs = 0;\r\n    }\r\n    /**\r\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\r\n     * RESOURCE_EXHAUSTED error).\r\n     */\r\n    resetToMax() {\r\n        this.currentBaseMs = this.maxDelayMs;\r\n    }\r\n    /**\r\n     * Returns a promise that resolves after currentDelayMs, and increases the\r\n     * delay for any subsequent attempts. If there was a pending backoff operation\r\n     * already, it will be canceled.\r\n     */\r\n    backoffAndRun(op) {\r\n        // Cancel any pending backoff operation.\r\n        this.cancel();\r\n        // First schedule using the current base (which may be 0 and should be\r\n        // honored as such).\r\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\r\n        // Guard against lastAttemptTime being in the future due to a clock change.\r\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\r\n        // Guard against the backoff delay already being past.\r\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\r\n        if (remainingDelayMs > 0) {\r\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\r\n                `(base delay: ${this.currentBaseMs} ms, ` +\r\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\r\n                `last attempt: ${delaySoFarMs} ms ago)`);\r\n        }\r\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\r\n            this.lastAttemptTime = Date.now();\r\n            return op();\r\n        });\r\n        // Apply backoff factor to determine next delay and ensure it is within\r\n        // bounds.\r\n        this.currentBaseMs *= this.backoffFactor;\r\n        if (this.currentBaseMs < this.initialDelayMs) {\r\n            this.currentBaseMs = this.initialDelayMs;\r\n        }\r\n        if (this.currentBaseMs > this.maxDelayMs) {\r\n            this.currentBaseMs = this.maxDelayMs;\r\n        }\r\n    }\r\n    skipBackoff() {\r\n        if (this.timerPromise !== null) {\r\n            this.timerPromise.skipDelay();\r\n            this.timerPromise = null;\r\n        }\r\n    }\r\n    cancel() {\r\n        if (this.timerPromise !== null) {\r\n            this.timerPromise.cancel();\r\n            this.timerPromise = null;\r\n        }\r\n    }\r\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\r\n    jitterDelayMs() {\r\n        return (Math.random() - 0.5) * this.currentBaseMs;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$7 = 'PersistentStream';\r\n/** The time a stream stays open after it is marked idle. */\r\nconst IDLE_TIMEOUT_MS = 60 * 1000;\r\n/** The time a stream stays open until we consider it healthy. */\r\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\r\n/**\r\n * A PersistentStream is an abstract base class that represents a streaming RPC\r\n * to the Firestore backend. It's built on top of the connections own support\r\n * for streaming RPCs, and adds several critical features for our clients:\r\n *\r\n *   - Exponential backoff on failure\r\n *   - Authentication via CredentialsProvider\r\n *   - Dispatching all callbacks into the shared worker queue\r\n *   - Closing idle streams after 60 seconds of inactivity\r\n *\r\n * Subclasses of PersistentStream implement serialization of models to and\r\n * from the JSON representation of the protocol buffers for a specific\r\n * streaming RPC.\r\n *\r\n * ## Starting and Stopping\r\n *\r\n * Streaming RPCs are stateful and need to be start()ed before messages can\r\n * be sent and received. The PersistentStream will call the onOpen() function\r\n * of the listener once the stream is ready to accept requests.\r\n *\r\n * Should a start() fail, PersistentStream will call the registered onClose()\r\n * listener with a FirestoreError indicating what went wrong.\r\n *\r\n * A PersistentStream can be started and stopped repeatedly.\r\n *\r\n * Generic types:\r\n *  SendType: The type of the outgoing message of the underlying\r\n *    connection stream\r\n *  ReceiveType: The type of the incoming message of the underlying\r\n *    connection stream\r\n *  ListenerType: The type of the listener that will be used for callbacks\r\n */\r\nclass PersistentStream {\r\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\r\n        this.queue = queue;\r\n        this.idleTimerId = idleTimerId;\r\n        this.healthTimerId = healthTimerId;\r\n        this.connection = connection;\r\n        this.authCredentialsProvider = authCredentialsProvider;\r\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\r\n        this.listener = listener;\r\n        this.state = 0 /* PersistentStreamState.Initial */;\r\n        /**\r\n         * A close count that's incremented every time the stream is closed; used by\r\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\r\n         * close.\r\n         */\r\n        this.closeCount = 0;\r\n        this.idleTimer = null;\r\n        this.healthCheck = null;\r\n        this.stream = null;\r\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\r\n    }\r\n    /**\r\n     * Returns true if start() has been called and no error has occurred. True\r\n     * indicates the stream is open or in the process of opening (which\r\n     * encompasses respecting backoff, getting auth tokens, and starting the\r\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\r\n     * outbound requests.\r\n     */\r\n    isStarted() {\r\n        return (this.state === 1 /* PersistentStreamState.Starting */ ||\r\n            this.state === 5 /* PersistentStreamState.Backoff */ ||\r\n            this.isOpen());\r\n    }\r\n    /**\r\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\r\n     * called) and the stream is ready for outbound requests.\r\n     */\r\n    isOpen() {\r\n        return (this.state === 2 /* PersistentStreamState.Open */ ||\r\n            this.state === 3 /* PersistentStreamState.Healthy */);\r\n    }\r\n    /**\r\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\r\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\r\n     * ready for outbound requests, at which point isOpen() will return true.\r\n     *\r\n     * When start returns, isStarted() will return true.\r\n     */\r\n    start() {\r\n        if (this.state === 4 /* PersistentStreamState.Error */) {\r\n            this.performBackoff();\r\n            return;\r\n        }\r\n        this.auth();\r\n    }\r\n    /**\r\n     * Stops the RPC. This call is idempotent and allowed regardless of the\r\n     * current isStarted() state.\r\n     *\r\n     * When stop returns, isStarted() and isOpen() will both return false.\r\n     */\r\n    async stop() {\r\n        if (this.isStarted()) {\r\n            await this.close(0 /* PersistentStreamState.Initial */);\r\n        }\r\n    }\r\n    /**\r\n     * After an error the stream will usually back off on the next attempt to\r\n     * start it. If the error warrants an immediate restart of the stream, the\r\n     * sender can use this to indicate that the receiver should not back off.\r\n     *\r\n     * Each error will call the onClose() listener. That function can decide to\r\n     * inhibit backoff if required.\r\n     */\r\n    inhibitBackoff() {\r\n        this.state = 0 /* PersistentStreamState.Initial */;\r\n        this.backoff.reset();\r\n    }\r\n    /**\r\n     * Marks this stream as idle. If no further actions are performed on the\r\n     * stream for one minute, the stream will automatically close itself and\r\n     * notify the stream's onClose() handler with Status.OK. The stream will then\r\n     * be in a !isStarted() state, requiring the caller to start the stream again\r\n     * before further use.\r\n     *\r\n     * Only streams that are in state 'Open' can be marked idle, as all other\r\n     * states imply pending network operations.\r\n     */\r\n    markIdle() {\r\n        // Starts the idle time if we are in state 'Open' and are not yet already\r\n        // running a timer (in which case the previous idle timeout still applies).\r\n        if (this.isOpen() && this.idleTimer === null) {\r\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\r\n        }\r\n    }\r\n    /** Sends a message to the underlying stream. */\r\n    sendRequest(msg) {\r\n        this.cancelIdleCheck();\r\n        this.stream.send(msg);\r\n    }\r\n    /** Called by the idle timer when the stream should close due to inactivity. */\r\n    async handleIdleCloseTimer() {\r\n        if (this.isOpen()) {\r\n            // When timing out an idle stream there's no reason to force the stream into backoff when\r\n            // it restarts so set the stream state to Initial instead of Error.\r\n            return this.close(0 /* PersistentStreamState.Initial */);\r\n        }\r\n    }\r\n    /** Marks the stream as active again. */\r\n    cancelIdleCheck() {\r\n        if (this.idleTimer) {\r\n            this.idleTimer.cancel();\r\n            this.idleTimer = null;\r\n        }\r\n    }\r\n    /** Cancels the health check delayed operation. */\r\n    cancelHealthCheck() {\r\n        if (this.healthCheck) {\r\n            this.healthCheck.cancel();\r\n            this.healthCheck = null;\r\n        }\r\n    }\r\n    /**\r\n     * Closes the stream and cleans up as necessary:\r\n     *\r\n     * * closes the underlying GRPC stream;\r\n     * * calls the onClose handler with the given 'error';\r\n     * * sets internal stream state to 'finalState';\r\n     * * adjusts the backoff timer based on the error\r\n     *\r\n     * A new stream can be opened by calling start().\r\n     *\r\n     * @param finalState - the intended state of the stream after closing.\r\n     * @param error - the error the connection was closed with.\r\n     */\r\n    async close(finalState, error) {\r\n        // Cancel any outstanding timers (they're guaranteed not to execute).\r\n        this.cancelIdleCheck();\r\n        this.cancelHealthCheck();\r\n        this.backoff.cancel();\r\n        // Invalidates any stream-related callbacks (e.g. from auth or the\r\n        // underlying stream), guaranteeing they won't execute.\r\n        this.closeCount++;\r\n        if (finalState !== 4 /* PersistentStreamState.Error */) {\r\n            // If this is an intentional close ensure we don't delay our next connection attempt.\r\n            this.backoff.reset();\r\n        }\r\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\r\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\r\n            logError(error.toString());\r\n            logError('Using maximum backoff delay to prevent overloading the backend.');\r\n            this.backoff.resetToMax();\r\n        }\r\n        else if (error &&\r\n            error.code === Code.UNAUTHENTICATED &&\r\n            this.state !== 3 /* PersistentStreamState.Healthy */) {\r\n            // \"unauthenticated\" error means the token was rejected. This should rarely\r\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\r\n            // request a token. If a user manually resets their system clock this can\r\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\r\n            // before we received the first message and we need to invalidate the token\r\n            // to ensure that we fetch a new token.\r\n            this.authCredentialsProvider.invalidateToken();\r\n            this.appCheckCredentialsProvider.invalidateToken();\r\n        }\r\n        // Clean up the underlying stream because we are no longer interested in events.\r\n        if (this.stream !== null) {\r\n            this.tearDown();\r\n            this.stream.close();\r\n            this.stream = null;\r\n        }\r\n        // This state must be assigned before calling onClose() to allow the callback to\r\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\r\n        this.state = finalState;\r\n        // Notify the listener that the stream closed.\r\n        await this.listener.onClose(error);\r\n    }\r\n    /**\r\n     * Can be overridden to perform additional cleanup before the stream is closed.\r\n     * Calling super.tearDown() is not required.\r\n     */\r\n    tearDown() { }\r\n    auth() {\r\n        this.state = 1 /* PersistentStreamState.Starting */;\r\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\r\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\r\n        const closeCount = this.closeCount;\r\n        Promise.all([\r\n            this.authCredentialsProvider.getToken(),\r\n            this.appCheckCredentialsProvider.getToken()\r\n        ]).then(([authToken, appCheckToken]) => {\r\n            // Stream can be stopped while waiting for authentication.\r\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\r\n            // and let this dispatch onto the queue, but that opened a spec test can\r\n            // of worms that I don't want to deal with in this PR.\r\n            if (this.closeCount === closeCount) {\r\n                // Normally we'd have to schedule the callback on the AsyncQueue.\r\n                // However, the following calls are safe to be called outside the\r\n                // AsyncQueue since they don't chain asynchronous calls\r\n                this.startStream(authToken, appCheckToken);\r\n            }\r\n        }, (error) => {\r\n            dispatchIfNotClosed(() => {\r\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\r\n                return this.handleStreamClose(rpcError);\r\n            });\r\n        });\r\n    }\r\n    startStream(authToken, appCheckToken) {\r\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\r\n        this.stream = this.startRpc(authToken, appCheckToken);\r\n        this.stream.onConnected(() => {\r\n            dispatchIfNotClosed(() => this.listener.onConnected());\r\n        });\r\n        this.stream.onOpen(() => {\r\n            dispatchIfNotClosed(() => {\r\n                this.state = 2 /* PersistentStreamState.Open */;\r\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\r\n                    if (this.isOpen()) {\r\n                        this.state = 3 /* PersistentStreamState.Healthy */;\r\n                    }\r\n                    return Promise.resolve();\r\n                });\r\n                return this.listener.onOpen();\r\n            });\r\n        });\r\n        this.stream.onClose((error) => {\r\n            dispatchIfNotClosed(() => {\r\n                return this.handleStreamClose(error);\r\n            });\r\n        });\r\n        this.stream.onMessage((msg) => {\r\n            dispatchIfNotClosed(() => {\r\n                return this.onMessage(msg);\r\n            });\r\n        });\r\n    }\r\n    performBackoff() {\r\n        this.state = 5 /* PersistentStreamState.Backoff */;\r\n        this.backoff.backoffAndRun(async () => {\r\n            this.state = 0 /* PersistentStreamState.Initial */;\r\n            this.start();\r\n        });\r\n    }\r\n    // Visible for tests\r\n    handleStreamClose(error) {\r\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\r\n        this.stream = null;\r\n        // In theory the stream could close cleanly, however, in our current model\r\n        // we never expect this to happen because if we stop a stream ourselves,\r\n        // this callback will never be called. To prevent cases where we retry\r\n        // without a backoff accidentally, we set the stream to error in all cases.\r\n        return this.close(4 /* PersistentStreamState.Error */, error);\r\n    }\r\n    /**\r\n     * Returns a \"dispatcher\" function that dispatches operations onto the\r\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\r\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\r\n     * re-opened, etc.\r\n     */\r\n    getCloseGuardedDispatcher(startCloseCount) {\r\n        return (fn) => {\r\n            this.queue.enqueueAndForget(() => {\r\n                if (this.closeCount === startCloseCount) {\r\n                    return fn();\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\r\n                    return Promise.resolve();\r\n                }\r\n            });\r\n        };\r\n    }\r\n}\r\n/**\r\n * A PersistentStream that implements the Listen RPC.\r\n *\r\n * Once the Listen stream has called the onOpen() listener, any number of\r\n * listen() and unlisten() calls can be made to control what changes will be\r\n * sent from the server for ListenResponses.\r\n */\r\nclass PersistentListenStream extends PersistentStream {\r\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\r\n        super(queue, \"listen_stream_connection_backoff\" /* TimerId.ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* TimerId.ListenStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\r\n        this.serializer = serializer;\r\n    }\r\n    startRpc(authToken, appCheckToken) {\r\n        return this.connection.openStream('Listen', authToken, appCheckToken);\r\n    }\r\n    onMessage(watchChangeProto) {\r\n        // A successful response means the stream is healthy\r\n        this.backoff.reset();\r\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\r\n        const snapshot = versionFromListenResponse(watchChangeProto);\r\n        return this.listener.onWatchChange(watchChange, snapshot);\r\n    }\r\n    /**\r\n     * Registers interest in the results of the given target. If the target\r\n     * includes a resumeToken it will be included in the request. Results that\r\n     * affect the target will be streamed back as WatchChange messages that\r\n     * reference the targetId.\r\n     */\r\n    watch(targetData) {\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        request.addTarget = toTarget(this.serializer, targetData);\r\n        const labels = toListenRequestLabels(this.serializer, targetData);\r\n        if (labels) {\r\n            request.labels = labels;\r\n        }\r\n        this.sendRequest(request);\r\n    }\r\n    /**\r\n     * Unregisters interest in the results of the target associated with the\r\n     * given targetId.\r\n     */\r\n    unwatch(targetId) {\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        request.removeTarget = targetId;\r\n        this.sendRequest(request);\r\n    }\r\n}\r\n/**\r\n * A Stream that implements the Write RPC.\r\n *\r\n * The Write RPC requires the caller to maintain special streamToken\r\n * state in between calls, to help the server understand which responses the\r\n * client has processed by the time the next request is made. Every response\r\n * will contain a streamToken; this value must be passed to the next\r\n * request.\r\n *\r\n * After calling start() on this stream, the next request must be a handshake,\r\n * containing whatever streamToken is on hand. Once a response to this\r\n * request is received, all pending mutations may be submitted. When\r\n * submitting multiple batches of mutations at the same time, it's\r\n * okay to use the same streamToken for the calls to writeMutations.\r\n *\r\n * TODO(b/33271235): Use proto types\r\n */\r\nclass PersistentWriteStream extends PersistentStream {\r\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\r\n        super(queue, \"write_stream_connection_backoff\" /* TimerId.WriteStreamConnectionBackoff */, \"write_stream_idle\" /* TimerId.WriteStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\r\n        this.serializer = serializer;\r\n        this.handshakeComplete_ = false;\r\n    }\r\n    /**\r\n     * Tracks whether or not a handshake has been successfully exchanged and\r\n     * the stream is ready to accept mutations.\r\n     */\r\n    get handshakeComplete() {\r\n        return this.handshakeComplete_;\r\n    }\r\n    // Override of PersistentStream.start\r\n    start() {\r\n        this.handshakeComplete_ = false;\r\n        this.lastStreamToken = undefined;\r\n        super.start();\r\n    }\r\n    tearDown() {\r\n        if (this.handshakeComplete_) {\r\n            this.writeMutations([]);\r\n        }\r\n    }\r\n    startRpc(authToken, appCheckToken) {\r\n        return this.connection.openStream('Write', authToken, appCheckToken);\r\n    }\r\n    onMessage(responseProto) {\r\n        // Always capture the last stream token.\r\n        hardAssert(!!responseProto.streamToken);\r\n        this.lastStreamToken = responseProto.streamToken;\r\n        if (!this.handshakeComplete_) {\r\n            // The first response is always the handshake response\r\n            hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);\r\n            this.handshakeComplete_ = true;\r\n            return this.listener.onHandshakeComplete();\r\n        }\r\n        else {\r\n            // A successful first write response means the stream is healthy,\r\n            // Note, that we could consider a successful handshake healthy, however,\r\n            // the write itself might be causing an error we want to back off from.\r\n            this.backoff.reset();\r\n            const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\r\n            const commitVersion = fromVersion(responseProto.commitTime);\r\n            return this.listener.onMutationResult(commitVersion, results);\r\n        }\r\n    }\r\n    /**\r\n     * Sends an initial streamToken to the server, performing the handshake\r\n     * required to make the StreamingWrite RPC work. Subsequent\r\n     * calls should wait until onHandshakeComplete was called.\r\n     */\r\n    writeHandshake() {\r\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\r\n        // stream token on the handshake, ignoring any stream token we might have.\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        this.sendRequest(request);\r\n    }\r\n    /** Sends a group of mutations to the Firestore backend to apply. */\r\n    writeMutations(mutations) {\r\n        const request = {\r\n            streamToken: this.lastStreamToken,\r\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\r\n        };\r\n        this.sendRequest(request);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Datastore and its related methods are a wrapper around the external Google\r\n * Cloud Datastore grpc API, which provides an interface that is more convenient\r\n * for the rest of the client SDK architecture to consume.\r\n */\r\nclass Datastore {\r\n}\r\n/**\r\n * An implementation of Datastore that exposes additional state for internal\r\n * consumption.\r\n */\r\nclass DatastoreImpl extends Datastore {\r\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\r\n        super();\r\n        this.authCredentials = authCredentials;\r\n        this.appCheckCredentials = appCheckCredentials;\r\n        this.connection = connection;\r\n        this.serializer = serializer;\r\n        this.terminated = false;\r\n    }\r\n    verifyInitialized() {\r\n        if (this.terminated) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\r\n        }\r\n    }\r\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\r\n    invokeRPC(rpcName, databaseId, resourcePath, request) {\r\n        this.verifyInitialized();\r\n        return Promise.all([\r\n            this.authCredentials.getToken(),\r\n            this.appCheckCredentials.getToken()\r\n        ])\r\n            .then(([authToken, appCheckToken]) => {\r\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\r\n        })\r\n            .catch((error) => {\r\n            if (error.name === 'FirebaseError') {\r\n                if (error.code === Code.UNAUTHENTICATED) {\r\n                    this.authCredentials.invalidateToken();\r\n                    this.appCheckCredentials.invalidateToken();\r\n                }\r\n                throw error;\r\n            }\r\n            else {\r\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\r\n            }\r\n        });\r\n    }\r\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\r\n    invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\r\n        this.verifyInitialized();\r\n        return Promise.all([\r\n            this.authCredentials.getToken(),\r\n            this.appCheckCredentials.getToken()\r\n        ])\r\n            .then(([authToken, appCheckToken]) => {\r\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\r\n        })\r\n            .catch((error) => {\r\n            if (error.name === 'FirebaseError') {\r\n                if (error.code === Code.UNAUTHENTICATED) {\r\n                    this.authCredentials.invalidateToken();\r\n                    this.appCheckCredentials.invalidateToken();\r\n                }\r\n                throw error;\r\n            }\r\n            else {\r\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\r\n            }\r\n        });\r\n    }\r\n    terminate() {\r\n        this.terminated = true;\r\n        this.connection.terminate();\r\n    }\r\n}\r\n// TODO(firestorexp): Make sure there is only one Datastore instance per\r\n// firestore-exp client.\r\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\r\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\r\n}\r\nasync function invokeCommitRpc(datastore, mutations) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    const request = {\r\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\r\n    };\r\n    await datastoreImpl.invokeRPC('Commit', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\r\n}\r\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    const request = {\r\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\r\n    };\r\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\r\n    const docs = new Map();\r\n    response.forEach(proto => {\r\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\r\n        docs.set(doc.key.toString(), doc);\r\n    });\r\n    const result = [];\r\n    keys.forEach(key => {\r\n        const doc = docs.get(key.toString());\r\n        hardAssert(!!doc);\r\n        result.push(doc);\r\n    });\r\n    return result;\r\n}\r\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\r\n    var _a;\r\n    const datastoreImpl = debugCast(datastore);\r\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\r\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\r\n        delete request.parent;\r\n    }\r\n    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', datastoreImpl.serializer.databaseId, parent, request, \r\n    /*expectedResponseCount=*/ 1);\r\n    // Omit RunAggregationQueryResponse that only contain readTimes.\r\n    const filteredResult = response.filter(proto => !!proto.result);\r\n    hardAssert(filteredResult.length === 1);\r\n    // Remap the short-form aliases that were sent to the server\r\n    // to the client-side aliases. Users will access the results\r\n    // using the client-side alias.\r\n    const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;\r\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {\r\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\r\n        return accumulator;\r\n    }, {});\r\n    return remappedFields;\r\n}\r\nfunction newPersistentWriteStream(datastore, queue, listener) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    datastoreImpl.verifyInitialized();\r\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\r\n}\r\nfunction newPersistentWatchStream(datastore, queue, listener) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    datastoreImpl.verifyInitialized();\r\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$6 = 'OnlineStateTracker';\r\n// To deal with transient failures, we allow multiple stream attempts before\r\n// giving up and transitioning from OnlineState.Unknown to Offline.\r\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\r\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\r\n// to 1. If that works okay, we could potentially remove this logic entirely.\r\nconst MAX_WATCH_STREAM_FAILURES = 1;\r\n// To deal with stream attempts that don't succeed or fail in a timely manner,\r\n// we have a timeout for OnlineState to reach Online or Offline.\r\n// If the timeout is reached, we transition to Offline rather than waiting\r\n// indefinitely.\r\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\r\n/**\r\n * A component used by the RemoteStore to track the OnlineState (that is,\r\n * whether or not the client as a whole should be considered to be online or\r\n * offline), implementing the appropriate heuristics.\r\n *\r\n * In particular, when the client is trying to connect to the backend, we\r\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\r\n * a connection to succeed. If we have too many failures or the timeout elapses,\r\n * then we set the OnlineState to Offline, and the client will behave as if\r\n * it is offline (get()s will return cached data, etc.).\r\n */\r\nclass OnlineStateTracker {\r\n    constructor(asyncQueue, onlineStateHandler) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.onlineStateHandler = onlineStateHandler;\r\n        /** The current OnlineState. */\r\n        this.state = \"Unknown\" /* OnlineState.Unknown */;\r\n        /**\r\n         * A count of consecutive failures to open the stream. If it reaches the\r\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\r\n         * Offline.\r\n         */\r\n        this.watchStreamFailures = 0;\r\n        /**\r\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\r\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\r\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\r\n         */\r\n        this.onlineStateTimer = null;\r\n        /**\r\n         * Whether the client should log a warning message if it fails to connect to\r\n         * the backend (initially true, cleared after a successful stream, or if we've\r\n         * logged the message already).\r\n         */\r\n        this.shouldWarnClientIsOffline = true;\r\n    }\r\n    /**\r\n     * Called by RemoteStore when a watch stream is started (including on each\r\n     * backoff attempt).\r\n     *\r\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\r\n     * the onlineStateTimer.\r\n     */\r\n    handleWatchStreamStart() {\r\n        if (this.watchStreamFailures === 0) {\r\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\r\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* TimerId.OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\r\n                this.onlineStateTimer = null;\r\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\r\n                    `seconds.`);\r\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\r\n                // NOTE: handleWatchStreamFailure() will continue to increment\r\n                // watchStreamFailures even though we are already marked Offline,\r\n                // but this is non-harmful.\r\n                return Promise.resolve();\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates our OnlineState as appropriate after the watch stream reports a\r\n     * failure. The first failure moves us to the 'Unknown' state. We then may\r\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\r\n     * actually transition to the 'Offline' state.\r\n     */\r\n    handleWatchStreamFailure(error) {\r\n        if (this.state === \"Online\" /* OnlineState.Online */) {\r\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\r\n        }\r\n        else {\r\n            this.watchStreamFailures++;\r\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\r\n                this.clearOnlineStateTimer();\r\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\r\n                    `times. Most recent error: ${error.toString()}`);\r\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Explicitly sets the OnlineState to the specified state.\r\n     *\r\n     * Note that this resets our timers / failure counters, etc. used by our\r\n     * Offline heuristics, so must not be used in place of\r\n     * handleWatchStreamStart() and handleWatchStreamFailure().\r\n     */\r\n    set(newState) {\r\n        this.clearOnlineStateTimer();\r\n        this.watchStreamFailures = 0;\r\n        if (newState === \"Online\" /* OnlineState.Online */) {\r\n            // We've connected to watch at least once. Don't warn the developer\r\n            // about being offline going forward.\r\n            this.shouldWarnClientIsOffline = false;\r\n        }\r\n        this.setAndBroadcast(newState);\r\n    }\r\n    setAndBroadcast(newState) {\r\n        if (newState !== this.state) {\r\n            this.state = newState;\r\n            this.onlineStateHandler(newState);\r\n        }\r\n    }\r\n    logClientOfflineWarningIfNecessary(details) {\r\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\r\n            `This typically indicates that your device does not have a healthy ` +\r\n            `Internet connection at the moment. The client will operate in offline ` +\r\n            `mode until it is able to successfully connect to the backend.`;\r\n        if (this.shouldWarnClientIsOffline) {\r\n            logError(message);\r\n            this.shouldWarnClientIsOffline = false;\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$6, message);\r\n        }\r\n    }\r\n    clearOnlineStateTimer() {\r\n        if (this.onlineStateTimer !== null) {\r\n            this.onlineStateTimer.cancel();\r\n            this.onlineStateTimer = null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$5 = 'RemoteStore';\r\n// TODO(b/35853402): Negotiate this with the stream.\r\nconst MAX_PENDING_WRITES = 10;\r\nclass RemoteStoreImpl {\r\n    constructor(\r\n    /**\r\n     * The local store, used to fill the write pipeline with outbound mutations.\r\n     */\r\n    localStore, \r\n    /** The client-side proxy for interacting with the backend. */\r\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\r\n        this.localStore = localStore;\r\n        this.datastore = datastore;\r\n        this.asyncQueue = asyncQueue;\r\n        this.remoteSyncer = {};\r\n        /**\r\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\r\n         * LocalStore via fillWritePipeline() and have or will send to the write\r\n         * stream.\r\n         *\r\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\r\n         * restart the write stream. When the stream is established the writes in the\r\n         * pipeline will be sent in order.\r\n         *\r\n         * Writes remain in writePipeline until they are acknowledged by the backend\r\n         * and thus will automatically be re-sent if the stream is interrupted /\r\n         * restarted before they're acknowledged.\r\n         *\r\n         * Write responses from the backend are linked to their originating request\r\n         * purely based on order, and so we can just shift() writes from the front of\r\n         * the writePipeline as we receive responses.\r\n         */\r\n        this.writePipeline = [];\r\n        /**\r\n         * A mapping of watched targets that the client cares about tracking and the\r\n         * user has explicitly called a 'listen' for this target.\r\n         *\r\n         * These targets may or may not have been sent to or acknowledged by the\r\n         * server. On re-establishing the listen stream, these targets should be sent\r\n         * to the server. The targets removed with unlistens are removed eagerly\r\n         * without waiting for confirmation from the listen stream.\r\n         */\r\n        this.listenTargets = new Map();\r\n        /**\r\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\r\n         * RemoteStore may start its network connections.\r\n         */\r\n        this.offlineCauses = new Set();\r\n        /**\r\n         * Event handlers that get called when the network is disabled or enabled.\r\n         *\r\n         * PORTING NOTE: These functions are used on the Web client to create the\r\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\r\n         * the streams are created during construction of RemoteStore.\r\n         */\r\n        this.onNetworkStatusChange = [];\r\n        this.connectivityMonitor = connectivityMonitor;\r\n        this.connectivityMonitor.addCallback((_) => {\r\n            asyncQueue.enqueueAndForget(async () => {\r\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\r\n                // network becomes unreachable as we don't have any other way to tear\r\n                // down our streams.\r\n                if (canUseNetwork(this)) {\r\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\r\n                    await restartNetwork(this);\r\n                }\r\n            });\r\n        });\r\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\r\n    }\r\n}\r\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\r\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\r\n}\r\n/** Re-enables the network. Idempotent. */\r\nfunction remoteStoreEnableNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.delete(0 /* OfflineCause.UserDisabled */);\r\n    return enableNetworkInternal(remoteStoreImpl);\r\n}\r\nasync function enableNetworkInternal(remoteStoreImpl) {\r\n    if (canUseNetwork(remoteStoreImpl)) {\r\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\r\n            await networkStatusHandler(/* enabled= */ true);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Temporarily disables the network. The network can be re-enabled using\r\n * enableNetwork().\r\n */\r\nasync function remoteStoreDisableNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.add(0 /* OfflineCause.UserDisabled */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    // Set the OnlineState to Offline so get()s return from cache, etc.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\r\n}\r\nasync function disableNetworkInternal(remoteStoreImpl) {\r\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\r\n        await networkStatusHandler(/* enabled= */ false);\r\n    }\r\n}\r\nasync function remoteStoreShutdown(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\r\n    remoteStoreImpl.offlineCauses.add(5 /* OfflineCause.Shutdown */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    remoteStoreImpl.connectivityMonitor.shutdown();\r\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\r\n    // triggering spurious listener events with cached data, etc.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n}\r\n/**\r\n * Starts new listen for the given target. Uses resume token if provided. It\r\n * is a no-op if the target of given `TargetData` is already being listened to.\r\n */\r\nfunction remoteStoreListen(remoteStore, targetData) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\r\n        return;\r\n    }\r\n    // Mark this as something the client is currently listening for.\r\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\r\n    if (shouldStartWatchStream(remoteStoreImpl)) {\r\n        // The listen will be sent in onWatchStreamOpen\r\n        startWatchStream(remoteStoreImpl);\r\n    }\r\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\r\n        sendWatchRequest(remoteStoreImpl, targetData);\r\n    }\r\n}\r\n/**\r\n * Removes the listen from server. It is a no-op if the given target id is\r\n * not being listened to.\r\n */\r\nfunction remoteStoreUnlisten(remoteStore, targetId) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    const watchStream = ensureWatchStream(remoteStoreImpl);\r\n    remoteStoreImpl.listenTargets.delete(targetId);\r\n    if (watchStream.isOpen()) {\r\n        sendUnwatchRequest(remoteStoreImpl, targetId);\r\n    }\r\n    if (remoteStoreImpl.listenTargets.size === 0) {\r\n        if (watchStream.isOpen()) {\r\n            watchStream.markIdle();\r\n        }\r\n        else if (canUseNetwork(remoteStoreImpl)) {\r\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\r\n            // have no listeners, since without any listens to send we cannot\r\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\r\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n        }\r\n    }\r\n}\r\n/**\r\n * We need to increment the the expected number of pending responses we're due\r\n * from watch so we wait for the ack to process any messages from this target.\r\n */\r\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\r\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\r\n    if (targetData.resumeToken.approximateByteSize() > 0 ||\r\n        targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\r\n        const expectedCount = remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetData.targetId).size;\r\n        targetData = targetData.withExpectedCount(expectedCount);\r\n    }\r\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\r\n}\r\n/**\r\n * We need to increment the expected number of pending responses we're due\r\n * from watch so we wait for the removal on the server before we process any\r\n * messages from this target.\r\n */\r\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\r\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\r\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\r\n}\r\nfunction startWatchStream(remoteStoreImpl) {\r\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\r\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\r\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null,\r\n        getDatabaseId: () => remoteStoreImpl.datastore.serializer.databaseId\r\n    });\r\n    ensureWatchStream(remoteStoreImpl).start();\r\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\r\n}\r\n/**\r\n * Returns whether the watch stream should be started because it's necessary\r\n * and has not yet been started.\r\n */\r\nfunction shouldStartWatchStream(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\r\n        remoteStoreImpl.listenTargets.size > 0);\r\n}\r\nfunction canUseNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    return remoteStoreImpl.offlineCauses.size === 0;\r\n}\r\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\r\n    remoteStoreImpl.watchChangeAggregator = undefined;\r\n}\r\nasync function onWatchStreamConnected(remoteStoreImpl) {\r\n    // Mark the client as online since we got a \"connected\" notification.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\r\n}\r\nasync function onWatchStreamOpen(remoteStoreImpl) {\r\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\r\n        sendWatchRequest(remoteStoreImpl, targetData);\r\n    });\r\n}\r\nasync function onWatchStreamClose(remoteStoreImpl, error) {\r\n    cleanUpWatchStreamState(remoteStoreImpl);\r\n    // If we still need the watch stream, retry the connection.\r\n    if (shouldStartWatchStream(remoteStoreImpl)) {\r\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\r\n        startWatchStream(remoteStoreImpl);\r\n    }\r\n    else {\r\n        // No need to restart watch stream because there are no active targets.\r\n        // The online state is set to unknown because there is no active attempt\r\n        // at establishing a connection\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    }\r\n}\r\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\r\n    // Mark the client as online since we got a message from the server\r\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\r\n    if (watchChange instanceof WatchTargetChange &&\r\n        watchChange.state === 2 /* WatchTargetChangeState.Removed */ &&\r\n        watchChange.cause) {\r\n        // There was an error on a target, don't wait for a consistent snapshot\r\n        // to raise events\r\n        try {\r\n            await handleTargetError(remoteStoreImpl, watchChange);\r\n        }\r\n        catch (e) {\r\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n        return;\r\n    }\r\n    if (watchChange instanceof DocumentWatchChange) {\r\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\r\n    }\r\n    else if (watchChange instanceof ExistenceFilterChange) {\r\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\r\n    }\r\n    else {\r\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\r\n    }\r\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\r\n        try {\r\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\r\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\r\n                // We have received a target change with a global snapshot if the snapshot\r\n                // version is not equal to SnapshotVersion.min().\r\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Recovery logic for IndexedDB errors that takes the network offline until\r\n * `op` succeeds. Retries are scheduled with backoff using\r\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\r\n * validated via a generic operation.\r\n *\r\n * The returned Promise is resolved once the network is disabled and before\r\n * any retry attempt.\r\n */\r\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\r\n    if (isIndexedDbTransactionError(e)) {\r\n        remoteStoreImpl.offlineCauses.add(1 /* OfflineCause.IndexedDbFailed */);\r\n        // Disable network and raise offline snapshots\r\n        await disableNetworkInternal(remoteStoreImpl);\r\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\r\n        if (!op) {\r\n            // Use a simple read operation to determine if IndexedDB recovered.\r\n            // Ideally, we would expose a health check directly on SimpleDb, but\r\n            // RemoteStore only has access to persistence through LocalStore.\r\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\r\n        }\r\n        // Probe IndexedDB periodically and re-enable network\r\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\r\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\r\n            await op();\r\n            remoteStoreImpl.offlineCauses.delete(1 /* OfflineCause.IndexedDbFailed */);\r\n            await enableNetworkInternal(remoteStoreImpl);\r\n        });\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\r\n/**\r\n * Executes `op`. If `op` fails, takes the network offline until `op`\r\n * succeeds. Returns after the first attempt.\r\n */\r\nfunction executeWithRecovery(remoteStoreImpl, op) {\r\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\r\n}\r\n/**\r\n * Takes a batch of changes from the Datastore, repackages them as a\r\n * RemoteEvent, and passes that on to the listener, which is typically the\r\n * SyncEngine.\r\n */\r\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\r\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\r\n    // Update in-memory resume tokens. LocalStore will update the\r\n    // persistent view of these when applying the completed RemoteEvent.\r\n    remoteEvent.targetChanges.forEach((change, targetId) => {\r\n        if (change.resumeToken.approximateByteSize() > 0) {\r\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\r\n            // A watched target might have been removed already.\r\n            if (targetData) {\r\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\r\n            }\r\n        }\r\n    });\r\n    // Re-establish listens for the targets that have been invalidated by\r\n    // existence filter mismatches.\r\n    remoteEvent.targetMismatches.forEach((targetId, targetPurpose) => {\r\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\r\n        if (!targetData) {\r\n            // A watched target might have been removed already.\r\n            return;\r\n        }\r\n        // Clear the resume token for the target, since we're in a known mismatch\r\n        // state.\r\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\r\n        // Cause a hard reset by unwatching and rewatching immediately, but\r\n        // deliberately don't send a resume token so that we get a full update.\r\n        sendUnwatchRequest(remoteStoreImpl, targetId);\r\n        // Mark the target we send as being on behalf of an existence filter\r\n        // mismatch, but don't actually retain that in listenTargets. This ensures\r\n        // that we flag the first re-listen this way without impacting future\r\n        // listens of this target (that might happen e.g. on reconnect).\r\n        const requestTargetData = new TargetData(targetData.target, targetId, targetPurpose, targetData.sequenceNumber);\r\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\r\n    });\r\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\r\n}\r\n/** Handles an error on a target */\r\nasync function handleTargetError(remoteStoreImpl, watchChange) {\r\n    const error = watchChange.cause;\r\n    for (const targetId of watchChange.targetIds) {\r\n        // A watched target might have been removed already.\r\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\r\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\r\n            remoteStoreImpl.listenTargets.delete(targetId);\r\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Attempts to fill our write pipeline with writes from the LocalStore.\r\n *\r\n * Called internally to bootstrap or refill the write pipeline and by\r\n * SyncEngine whenever there are new mutations to process.\r\n *\r\n * Starts the write stream if necessary.\r\n */\r\nasync function fillWritePipeline(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\r\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\r\n            .batchId\r\n        : BATCHID_UNKNOWN;\r\n    while (canAddToWritePipeline(remoteStoreImpl)) {\r\n        try {\r\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\r\n            if (batch === null) {\r\n                if (remoteStoreImpl.writePipeline.length === 0) {\r\n                    writeStream.markIdle();\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                lastBatchIdRetrieved = batch.batchId;\r\n                addToWritePipeline(remoteStoreImpl, batch);\r\n            }\r\n        }\r\n        catch (e) {\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n    }\r\n    if (shouldStartWriteStream(remoteStoreImpl)) {\r\n        startWriteStream(remoteStoreImpl);\r\n    }\r\n}\r\n/**\r\n * Returns true if we can add to the write pipeline (i.e. the network is\r\n * enabled and the write pipeline is not full).\r\n */\r\nfunction canAddToWritePipeline(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\r\n}\r\n/**\r\n * Queues additional writes to be sent to the write stream, sending them\r\n * immediately if the write stream is established.\r\n */\r\nfunction addToWritePipeline(remoteStoreImpl, batch) {\r\n    remoteStoreImpl.writePipeline.push(batch);\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\r\n        writeStream.writeMutations(batch.mutations);\r\n    }\r\n}\r\nfunction shouldStartWriteStream(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\r\n        remoteStoreImpl.writePipeline.length > 0);\r\n}\r\nfunction startWriteStream(remoteStoreImpl) {\r\n    ensureWriteStream(remoteStoreImpl).start();\r\n}\r\nasync function onWriteStreamOpen(remoteStoreImpl) {\r\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\r\n}\r\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    // Send the write pipeline now that the stream is established.\r\n    for (const batch of remoteStoreImpl.writePipeline) {\r\n        writeStream.writeMutations(batch.mutations);\r\n    }\r\n}\r\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\r\n    const batch = remoteStoreImpl.writePipeline.shift();\r\n    const success = MutationBatchResult.from(batch, commitVersion, results);\r\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\r\n    // It's possible that with the completion of this mutation another\r\n    // slot has freed up.\r\n    await fillWritePipeline(remoteStoreImpl);\r\n}\r\nasync function onWriteStreamClose(remoteStoreImpl, error) {\r\n    // If the write stream closed after the write handshake completes, a write\r\n    // operation failed and we fail the pending operation.\r\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\r\n        // This error affects the actual write.\r\n        await handleWriteError(remoteStoreImpl, error);\r\n    }\r\n    // The write stream might have been started by refilling the write\r\n    // pipeline for failed writes\r\n    if (shouldStartWriteStream(remoteStoreImpl)) {\r\n        startWriteStream(remoteStoreImpl);\r\n    }\r\n}\r\nasync function handleWriteError(remoteStoreImpl, error) {\r\n    // Only handle permanent errors here. If it's transient, just let the retry\r\n    // logic kick in.\r\n    if (isPermanentWriteError(error.code)) {\r\n        // This was a permanent error, the request itself was the problem\r\n        // so it's not going to succeed if we resend it.\r\n        const batch = remoteStoreImpl.writePipeline.shift();\r\n        // In this case it's also unlikely that the server itself is melting\r\n        // down -- this was just a bad request so inhibit backoff on the next\r\n        // restart.\r\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\r\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\r\n        // It's possible that with the completion of this mutation\r\n        // another slot has freed up.\r\n        await fillWritePipeline(remoteStoreImpl);\r\n    }\r\n}\r\nasync function restartNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.add(4 /* OfflineCause.ConnectivityChange */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    remoteStoreImpl.offlineCauses.delete(4 /* OfflineCause.ConnectivityChange */);\r\n    await enableNetworkInternal(remoteStoreImpl);\r\n}\r\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\r\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\r\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\r\n    // Tear down and re-create our network streams. This will ensure we get a\r\n    // fresh auth token for the new user and re-fill the write pipeline with\r\n    // new mutations from the LocalStore (since mutations are per-user).\r\n    remoteStoreImpl.offlineCauses.add(3 /* OfflineCause.CredentialChange */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    if (usesNetwork) {\r\n        // Don't set the network status to Unknown if we are offline.\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    }\r\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\r\n    remoteStoreImpl.offlineCauses.delete(3 /* OfflineCause.CredentialChange */);\r\n    await enableNetworkInternal(remoteStoreImpl);\r\n}\r\n/**\r\n * Toggles the network state when the client gains or loses its primary lease.\r\n */\r\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    if (isPrimary) {\r\n        remoteStoreImpl.offlineCauses.delete(2 /* OfflineCause.IsSecondary */);\r\n        await enableNetworkInternal(remoteStoreImpl);\r\n    }\r\n    else if (!isPrimary) {\r\n        remoteStoreImpl.offlineCauses.add(2 /* OfflineCause.IsSecondary */);\r\n        await disableNetworkInternal(remoteStoreImpl);\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    }\r\n}\r\n/**\r\n * If not yet initialized, registers the WatchStream and its network state\r\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\r\n * already available.\r\n *\r\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\r\n * This is not done on Web to allow it to be tree-shaken.\r\n */\r\nfunction ensureWatchStream(remoteStoreImpl) {\r\n    if (!remoteStoreImpl.watchStream) {\r\n        // Create stream (but note that it is not started yet).\r\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\r\n            onConnected: onWatchStreamConnected.bind(null, remoteStoreImpl),\r\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\r\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\r\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\r\n        });\r\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\r\n            if (enabled) {\r\n                remoteStoreImpl.watchStream.inhibitBackoff();\r\n                if (shouldStartWatchStream(remoteStoreImpl)) {\r\n                    startWatchStream(remoteStoreImpl);\r\n                }\r\n                else {\r\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n                }\r\n            }\r\n            else {\r\n                await remoteStoreImpl.watchStream.stop();\r\n                cleanUpWatchStreamState(remoteStoreImpl);\r\n            }\r\n        });\r\n    }\r\n    return remoteStoreImpl.watchStream;\r\n}\r\n/**\r\n * If not yet initialized, registers the WriteStream and its network state\r\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\r\n * already available.\r\n *\r\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\r\n * This is not done on Web to allow it to be tree-shaken.\r\n */\r\nfunction ensureWriteStream(remoteStoreImpl) {\r\n    if (!remoteStoreImpl.writeStream) {\r\n        // Create stream (but note that it is not started yet).\r\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\r\n            onConnected: () => Promise.resolve(),\r\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\r\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\r\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\r\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\r\n        });\r\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\r\n            if (enabled) {\r\n                remoteStoreImpl.writeStream.inhibitBackoff();\r\n                // This will start the write stream if necessary.\r\n                await fillWritePipeline(remoteStoreImpl);\r\n            }\r\n            else {\r\n                await remoteStoreImpl.writeStream.stop();\r\n                if (remoteStoreImpl.writePipeline.length > 0) {\r\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\r\n                    remoteStoreImpl.writePipeline = [];\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return remoteStoreImpl.writeStream;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$4 = 'AsyncQueue';\r\n/**\r\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\r\n *\r\n * It is created via DelayedOperation.createAndSchedule().\r\n *\r\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\r\n *\r\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\r\n * in newer versions of TypeScript defines `finally`, which is not available in\r\n * IE.\r\n */\r\nclass DelayedOperation {\r\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.timerId = timerId;\r\n        this.targetTimeMs = targetTimeMs;\r\n        this.op = op;\r\n        this.removalCallback = removalCallback;\r\n        this.deferred = new Deferred();\r\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\r\n        // It's normal for the deferred promise to be canceled (due to cancellation)\r\n        // and so we attach a dummy catch callback to avoid\r\n        // 'UnhandledPromiseRejectionWarning' log spam.\r\n        this.deferred.promise.catch(err => { });\r\n    }\r\n    get promise() {\r\n        return this.deferred.promise;\r\n    }\r\n    /**\r\n     * Creates and returns a DelayedOperation that has been scheduled to be\r\n     * executed on the provided asyncQueue after the provided delayMs.\r\n     *\r\n     * @param asyncQueue - The queue to schedule the operation on.\r\n     * @param id - A Timer ID identifying the type of operation this is.\r\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\r\n     * @param op - The operation to run.\r\n     * @param removalCallback - A callback to be called synchronously once the\r\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\r\n     *   from its delayedOperations list.\r\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\r\n     *   the DelayedOperation class public.\r\n     */\r\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\r\n        const targetTime = Date.now() + delayMs;\r\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\r\n        delayedOp.start(delayMs);\r\n        return delayedOp;\r\n    }\r\n    /**\r\n     * Starts the timer. This is called immediately after construction by\r\n     * createAndSchedule().\r\n     */\r\n    start(delayMs) {\r\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\r\n    }\r\n    /**\r\n     * Queues the operation to run immediately (if it hasn't already been run or\r\n     * canceled).\r\n     */\r\n    skipDelay() {\r\n        return this.handleDelayElapsed();\r\n    }\r\n    /**\r\n     * Cancels the operation if it hasn't already been executed or canceled. The\r\n     * promise will be rejected.\r\n     *\r\n     * As long as the operation has not yet been run, calling cancel() provides a\r\n     * guarantee that the operation will not be run.\r\n     */\r\n    cancel(reason) {\r\n        if (this.timerHandle !== null) {\r\n            this.clearTimeout();\r\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\r\n        }\r\n    }\r\n    handleDelayElapsed() {\r\n        this.asyncQueue.enqueueAndForget(() => {\r\n            if (this.timerHandle !== null) {\r\n                this.clearTimeout();\r\n                return this.op().then(result => {\r\n                    return this.deferred.resolve(result);\r\n                });\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n    clearTimeout() {\r\n        if (this.timerHandle !== null) {\r\n            this.removalCallback(this);\r\n            clearTimeout(this.timerHandle);\r\n            this.timerHandle = null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a FirestoreError that can be surfaced to the user if the provided\r\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\r\n */\r\nfunction wrapInUserErrorIfRecoverable(e, msg) {\r\n    logError(LOG_TAG$4, `${msg}: ${e}`);\r\n    if (isIndexedDbTransactionError(e)) {\r\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\r\n * in order specified by the provided comparator. We always add a document key\r\n * comparator on top of what is provided to guarantee document equality based on\r\n * the key.\r\n */\r\nclass DocumentSet {\r\n    /** The default ordering is by key if the comparator is omitted */\r\n    constructor(comp) {\r\n        // We are adding document key comparator to the end as it's the only\r\n        // guaranteed unique property of a document.\r\n        if (comp) {\r\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\r\n        }\r\n        else {\r\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\r\n        }\r\n        this.keyedMap = documentMap();\r\n        this.sortedSet = new SortedMap(this.comparator);\r\n    }\r\n    /**\r\n     * Returns an empty copy of the existing DocumentSet, using the same\r\n     * comparator.\r\n     */\r\n    static emptySet(oldSet) {\r\n        return new DocumentSet(oldSet.comparator);\r\n    }\r\n    has(key) {\r\n        return this.keyedMap.get(key) != null;\r\n    }\r\n    get(key) {\r\n        return this.keyedMap.get(key);\r\n    }\r\n    first() {\r\n        return this.sortedSet.minKey();\r\n    }\r\n    last() {\r\n        return this.sortedSet.maxKey();\r\n    }\r\n    isEmpty() {\r\n        return this.sortedSet.isEmpty();\r\n    }\r\n    /**\r\n     * Returns the index of the provided key in the document set, or -1 if the\r\n     * document key is not present in the set;\r\n     */\r\n    indexOf(key) {\r\n        const doc = this.keyedMap.get(key);\r\n        return doc ? this.sortedSet.indexOf(doc) : -1;\r\n    }\r\n    get size() {\r\n        return this.sortedSet.size;\r\n    }\r\n    /** Iterates documents in order defined by \"comparator\" */\r\n    forEach(cb) {\r\n        this.sortedSet.inorderTraversal((k, v) => {\r\n            cb(k);\r\n            return false;\r\n        });\r\n    }\r\n    /** Inserts or updates a document with the same key */\r\n    add(doc) {\r\n        // First remove the element if we have it.\r\n        const set = this.delete(doc.key);\r\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\r\n    }\r\n    /** Deletes a document with a given key */\r\n    delete(key) {\r\n        const doc = this.get(key);\r\n        if (!doc) {\r\n            return this;\r\n        }\r\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\r\n    }\r\n    isEqual(other) {\r\n        if (!(other instanceof DocumentSet)) {\r\n            return false;\r\n        }\r\n        if (this.size !== other.size) {\r\n            return false;\r\n        }\r\n        const thisIt = this.sortedSet.getIterator();\r\n        const otherIt = other.sortedSet.getIterator();\r\n        while (thisIt.hasNext()) {\r\n            const thisDoc = thisIt.getNext().key;\r\n            const otherDoc = otherIt.getNext().key;\r\n            if (!thisDoc.isEqual(otherDoc)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    toString() {\r\n        const docStrings = [];\r\n        this.forEach(doc => {\r\n            docStrings.push(doc.toString());\r\n        });\r\n        if (docStrings.length === 0) {\r\n            return 'DocumentSet ()';\r\n        }\r\n        else {\r\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\r\n        }\r\n    }\r\n    copy(keyedMap, sortedSet) {\r\n        const newSet = new DocumentSet();\r\n        newSet.comparator = this.comparator;\r\n        newSet.keyedMap = keyedMap;\r\n        newSet.sortedSet = sortedSet;\r\n        return newSet;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\r\n * duplicate events for the same doc.\r\n */\r\nclass DocumentChangeSet {\r\n    constructor() {\r\n        this.changeMap = new SortedMap(DocumentKey.comparator);\r\n    }\r\n    track(change) {\r\n        const key = change.doc.key;\r\n        const oldChange = this.changeMap.get(key);\r\n        if (!oldChange) {\r\n            this.changeMap = this.changeMap.insert(key, change);\r\n            return;\r\n        }\r\n        // Merge the new change with the existing change.\r\n        if (change.type !== 0 /* ChangeType.Added */ &&\r\n            oldChange.type === 3 /* ChangeType.Metadata */) {\r\n            this.changeMap = this.changeMap.insert(key, change);\r\n        }\r\n        else if (change.type === 3 /* ChangeType.Metadata */ &&\r\n            oldChange.type !== 1 /* ChangeType.Removed */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: oldChange.type,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 2 /* ChangeType.Modified */ &&\r\n            oldChange.type === 2 /* ChangeType.Modified */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 2 /* ChangeType.Modified */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 2 /* ChangeType.Modified */ &&\r\n            oldChange.type === 0 /* ChangeType.Added */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 0 /* ChangeType.Added */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 1 /* ChangeType.Removed */ &&\r\n            oldChange.type === 0 /* ChangeType.Added */) {\r\n            this.changeMap = this.changeMap.remove(key);\r\n        }\r\n        else if (change.type === 1 /* ChangeType.Removed */ &&\r\n            oldChange.type === 2 /* ChangeType.Modified */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 1 /* ChangeType.Removed */,\r\n                doc: oldChange.doc\r\n            });\r\n        }\r\n        else if (change.type === 0 /* ChangeType.Added */ &&\r\n            oldChange.type === 1 /* ChangeType.Removed */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 2 /* ChangeType.Modified */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else {\r\n            // This includes these cases, which don't make sense:\r\n            // Added->Added\r\n            // Removed->Removed\r\n            // Modified->Added\r\n            // Removed->Modified\r\n            // Metadata->Added\r\n            // Removed->Metadata\r\n            fail();\r\n        }\r\n    }\r\n    getChanges() {\r\n        const changes = [];\r\n        this.changeMap.inorderTraversal((key, change) => {\r\n            changes.push(change);\r\n        });\r\n        return changes;\r\n    }\r\n}\r\nclass ViewSnapshot {\r\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges, hasCachedResults) {\r\n        this.query = query;\r\n        this.docs = docs;\r\n        this.oldDocs = oldDocs;\r\n        this.docChanges = docChanges;\r\n        this.mutatedKeys = mutatedKeys;\r\n        this.fromCache = fromCache;\r\n        this.syncStateChanged = syncStateChanged;\r\n        this.excludesMetadataChanges = excludesMetadataChanges;\r\n        this.hasCachedResults = hasCachedResults;\r\n    }\r\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\r\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache, hasCachedResults) {\r\n        const changes = [];\r\n        documents.forEach(doc => {\r\n            changes.push({ type: 0 /* ChangeType.Added */, doc });\r\n        });\r\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \r\n        /* syncStateChanged= */ true, \r\n        /* excludesMetadataChanges= */ false, hasCachedResults);\r\n    }\r\n    get hasPendingWrites() {\r\n        return !this.mutatedKeys.isEmpty();\r\n    }\r\n    isEqual(other) {\r\n        if (this.fromCache !== other.fromCache ||\r\n            this.hasCachedResults !== other.hasCachedResults ||\r\n            this.syncStateChanged !== other.syncStateChanged ||\r\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\r\n            !queryEquals(this.query, other.query) ||\r\n            !this.docs.isEqual(other.docs) ||\r\n            !this.oldDocs.isEqual(other.oldDocs)) {\r\n            return false;\r\n        }\r\n        const changes = this.docChanges;\r\n        const otherChanges = other.docChanges;\r\n        if (changes.length !== otherChanges.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < changes.length; i++) {\r\n            if (changes[i].type !== otherChanges[i].type ||\r\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Holds the listeners and the last received ViewSnapshot for a query being\r\n * tracked by EventManager.\r\n */\r\nclass QueryListenersInfo {\r\n    constructor() {\r\n        this.viewSnap = undefined;\r\n        this.listeners = [];\r\n    }\r\n    // Helper methods that checks if the query has listeners that listening to remote store\r\n    hasRemoteListeners() {\r\n        return this.listeners.some(listener => listener.listensToRemoteStore());\r\n    }\r\n}\r\nfunction newEventManager() {\r\n    return new EventManagerImpl();\r\n}\r\nclass EventManagerImpl {\r\n    constructor() {\r\n        this.queries = new ObjectMap(q => canonifyQuery(q), queryEquals);\r\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\r\n        this.snapshotsInSyncListeners = new Set();\r\n    }\r\n}\r\nasync function eventManagerListen(eventManager, listener) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    let listenerAction = 3 /* ListenerSetupAction.NoActionRequired */;\r\n    const query = listener.query;\r\n    let queryInfo = eventManagerImpl.queries.get(query);\r\n    if (!queryInfo) {\r\n        queryInfo = new QueryListenersInfo();\r\n        listenerAction = listener.listensToRemoteStore()\r\n            ? 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */\r\n            : 1 /* ListenerSetupAction.InitializeLocalListenOnly */;\r\n    }\r\n    else if (!queryInfo.hasRemoteListeners() &&\r\n        listener.listensToRemoteStore()) {\r\n        // Query has been listening to local cache, and tries to add a new listener sourced from watch.\r\n        listenerAction = 2 /* ListenerSetupAction.RequireWatchConnectionOnly */;\r\n    }\r\n    try {\r\n        switch (listenerAction) {\r\n            case 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */:\r\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \r\n                /** enableRemoteListen= */ true);\r\n                break;\r\n            case 1 /* ListenerSetupAction.InitializeLocalListenOnly */:\r\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \r\n                /** enableRemoteListen= */ false);\r\n                break;\r\n            case 2 /* ListenerSetupAction.RequireWatchConnectionOnly */:\r\n                await eventManagerImpl.onFirstRemoteStoreListen(query);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\r\n        listener.onError(firestoreError);\r\n        return;\r\n    }\r\n    eventManagerImpl.queries.set(query, queryInfo);\r\n    queryInfo.listeners.push(listener);\r\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\r\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\r\n    if (queryInfo.viewSnap) {\r\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\r\n        if (raisedEvent) {\r\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n        }\r\n    }\r\n}\r\nasync function eventManagerUnlisten(eventManager, listener) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const query = listener.query;\r\n    let listenerAction = 3 /* ListenerRemovalAction.NoActionRequired */;\r\n    const queryInfo = eventManagerImpl.queries.get(query);\r\n    if (queryInfo) {\r\n        const i = queryInfo.listeners.indexOf(listener);\r\n        if (i >= 0) {\r\n            queryInfo.listeners.splice(i, 1);\r\n            if (queryInfo.listeners.length === 0) {\r\n                listenerAction = listener.listensToRemoteStore()\r\n                    ? 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */\r\n                    : 1 /* ListenerRemovalAction.TerminateLocalListenOnly */;\r\n            }\r\n            else if (!queryInfo.hasRemoteListeners() &&\r\n                listener.listensToRemoteStore()) {\r\n                // The removed listener is the last one that sourced from watch.\r\n                listenerAction = 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */;\r\n            }\r\n        }\r\n    }\r\n    switch (listenerAction) {\r\n        case 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */:\r\n            eventManagerImpl.queries.delete(query);\r\n            return eventManagerImpl.onUnlisten(query, \r\n            /** disableRemoteListen= */ true);\r\n        case 1 /* ListenerRemovalAction.TerminateLocalListenOnly */:\r\n            eventManagerImpl.queries.delete(query);\r\n            return eventManagerImpl.onUnlisten(query, \r\n            /** disableRemoteListen= */ false);\r\n        case 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */:\r\n            return eventManagerImpl.onLastRemoteStoreUnlisten(query);\r\n        default:\r\n            return;\r\n    }\r\n}\r\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    let raisedEvent = false;\r\n    for (const viewSnap of viewSnaps) {\r\n        const query = viewSnap.query;\r\n        const queryInfo = eventManagerImpl.queries.get(query);\r\n        if (queryInfo) {\r\n            for (const listener of queryInfo.listeners) {\r\n                if (listener.onViewSnapshot(viewSnap)) {\r\n                    raisedEvent = true;\r\n                }\r\n            }\r\n            queryInfo.viewSnap = viewSnap;\r\n        }\r\n    }\r\n    if (raisedEvent) {\r\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n    }\r\n}\r\nfunction eventManagerOnWatchError(eventManager, query, error) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const queryInfo = eventManagerImpl.queries.get(query);\r\n    if (queryInfo) {\r\n        for (const listener of queryInfo.listeners) {\r\n            listener.onError(error);\r\n        }\r\n    }\r\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\r\n    // after an error.\r\n    eventManagerImpl.queries.delete(query);\r\n}\r\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.onlineState = onlineState;\r\n    let raisedEvent = false;\r\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\r\n        for (const listener of queryInfo.listeners) {\r\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\r\n            if (listener.applyOnlineStateChange(onlineState)) {\r\n                raisedEvent = true;\r\n            }\r\n        }\r\n    });\r\n    if (raisedEvent) {\r\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n    }\r\n}\r\nfunction addSnapshotsInSyncListener(eventManager, observer) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\r\n    // Immediately fire an initial event, indicating all existing listeners\r\n    // are in-sync.\r\n    observer.next();\r\n}\r\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\r\n}\r\n// Call all global snapshot listeners that have been set.\r\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\r\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\r\n        observer.next();\r\n    });\r\n}\r\nvar ListenerDataSource;\r\n(function (ListenerDataSource) {\r\n    /** Listen to both cache and server changes */\r\n    ListenerDataSource[\"Default\"] = \"default\";\r\n    /** Listen to changes in cache only */\r\n    ListenerDataSource[\"Cache\"] = \"cache\";\r\n})(ListenerDataSource || (ListenerDataSource = {}));\r\n/**\r\n * QueryListener takes a series of internal view snapshots and determines\r\n * when to raise the event.\r\n *\r\n * It uses an Observer to dispatch events.\r\n */\r\nclass QueryListener {\r\n    constructor(query, queryObserver, options) {\r\n        this.query = query;\r\n        this.queryObserver = queryObserver;\r\n        /**\r\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\r\n         * observer. This flag is set to true once we've actually raised an event.\r\n         */\r\n        this.raisedInitialEvent = false;\r\n        this.snap = null;\r\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\r\n        this.options = options || {};\r\n    }\r\n    /**\r\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\r\n     * if applicable (depending on what changed, whether the user has opted into\r\n     * metadata-only changes, etc.). Returns true if a user-facing event was\r\n     * indeed raised.\r\n     */\r\n    onViewSnapshot(snap) {\r\n        if (!this.options.includeMetadataChanges) {\r\n            // Remove the metadata only changes.\r\n            const docChanges = [];\r\n            for (const docChange of snap.docChanges) {\r\n                if (docChange.type !== 3 /* ChangeType.Metadata */) {\r\n                    docChanges.push(docChange);\r\n                }\r\n            }\r\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \r\n            /* excludesMetadataChanges= */ true, snap.hasCachedResults);\r\n        }\r\n        let raisedEvent = false;\r\n        if (!this.raisedInitialEvent) {\r\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\r\n                this.raiseInitialEvent(snap);\r\n                raisedEvent = true;\r\n            }\r\n        }\r\n        else if (this.shouldRaiseEvent(snap)) {\r\n            this.queryObserver.next(snap);\r\n            raisedEvent = true;\r\n        }\r\n        this.snap = snap;\r\n        return raisedEvent;\r\n    }\r\n    onError(error) {\r\n        this.queryObserver.error(error);\r\n    }\r\n    /** Returns whether a snapshot was raised. */\r\n    applyOnlineStateChange(onlineState) {\r\n        this.onlineState = onlineState;\r\n        let raisedEvent = false;\r\n        if (this.snap &&\r\n            !this.raisedInitialEvent &&\r\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\r\n            this.raiseInitialEvent(this.snap);\r\n            raisedEvent = true;\r\n        }\r\n        return raisedEvent;\r\n    }\r\n    shouldRaiseInitialEvent(snap, onlineState) {\r\n        // Always raise the first event when we're synced\r\n        if (!snap.fromCache) {\r\n            return true;\r\n        }\r\n        // Always raise event if listening to cache\r\n        if (!this.listensToRemoteStore()) {\r\n            return true;\r\n        }\r\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\r\n        // or Online if we wait long enough).\r\n        const maybeOnline = onlineState !== \"Offline\" /* OnlineState.Offline */;\r\n        // Don't raise the event if we're online, aren't synced yet (checked\r\n        // above) and are waiting for a sync.\r\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\r\n            return false;\r\n        }\r\n        // Raise data from cache if we have any documents, have cached results before,\r\n        // or we are offline.\r\n        return (!snap.docs.isEmpty() ||\r\n            snap.hasCachedResults ||\r\n            onlineState === \"Offline\" /* OnlineState.Offline */);\r\n    }\r\n    shouldRaiseEvent(snap) {\r\n        // We don't need to handle includeDocumentMetadataChanges here because\r\n        // the Metadata only changes have already been stripped out if needed.\r\n        // At this point the only changes we will see are the ones we should\r\n        // propagate.\r\n        if (snap.docChanges.length > 0) {\r\n            return true;\r\n        }\r\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\r\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\r\n            return this.options.includeMetadataChanges === true;\r\n        }\r\n        // Generally we should have hit one of the cases above, but it's possible\r\n        // to get here if there were only metadata docChanges and they got\r\n        // stripped out.\r\n        return false;\r\n    }\r\n    raiseInitialEvent(snap) {\r\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache, snap.hasCachedResults);\r\n        this.raisedInitialEvent = true;\r\n        this.queryObserver.next(snap);\r\n    }\r\n    listensToRemoteStore() {\r\n        return this.options.source !== ListenerDataSource.Cache;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A set of changes to what documents are currently in view and out of view for\r\n * a given query. These changes are sent to the LocalStore by the View (via\r\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\r\n */\r\nclass LocalViewChanges {\r\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\r\n        this.targetId = targetId;\r\n        this.fromCache = fromCache;\r\n        this.addedKeys = addedKeys;\r\n        this.removedKeys = removedKeys;\r\n    }\r\n    static fromSnapshot(targetId, viewSnapshot) {\r\n        let addedKeys = documentKeySet();\r\n        let removedKeys = documentKeySet();\r\n        for (const docChange of viewSnapshot.docChanges) {\r\n            switch (docChange.type) {\r\n                case 0 /* ChangeType.Added */:\r\n                    addedKeys = addedKeys.add(docChange.doc.key);\r\n                    break;\r\n                case 1 /* ChangeType.Removed */:\r\n                    removedKeys = removedKeys.add(docChange.doc.key);\r\n                    break;\r\n                // do nothing\r\n            }\r\n        }\r\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper to convert objects from bundles to model objects in the SDK.\r\n */\r\nclass BundleConverterImpl {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    toDocumentKey(name) {\r\n        return fromName(this.serializer, name);\r\n    }\r\n    /**\r\n     * Converts a BundleDocument to a MutableDocument.\r\n     */\r\n    toMutableDocument(bundledDoc) {\r\n        if (bundledDoc.metadata.exists) {\r\n            return fromDocument(this.serializer, bundledDoc.document, false);\r\n        }\r\n        else {\r\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\r\n        }\r\n    }\r\n    toSnapshotVersion(time) {\r\n        return fromVersion(time);\r\n    }\r\n}\r\n/**\r\n * A class to process the elements from a bundle, load them into local\r\n * storage and provide progress update while loading.\r\n */\r\nclass BundleLoader {\r\n    constructor(bundleMetadata, localStore, serializer) {\r\n        this.bundleMetadata = bundleMetadata;\r\n        this.localStore = localStore;\r\n        this.serializer = serializer;\r\n        /** Batched queries to be saved into storage */\r\n        this.queries = [];\r\n        /** Batched documents to be saved into storage */\r\n        this.documents = [];\r\n        /** The collection groups affected by this bundle. */\r\n        this.collectionGroups = new Set();\r\n        this.progress = bundleInitialProgress(bundleMetadata);\r\n    }\r\n    /**\r\n     * Adds an element from the bundle to the loader.\r\n     *\r\n     * Returns a new progress if adding the element leads to a new progress,\r\n     * otherwise returns null.\r\n     */\r\n    addSizedElement(element) {\r\n        this.progress.bytesLoaded += element.byteLength;\r\n        let documentsLoaded = this.progress.documentsLoaded;\r\n        if (element.payload.namedQuery) {\r\n            this.queries.push(element.payload.namedQuery);\r\n        }\r\n        else if (element.payload.documentMetadata) {\r\n            this.documents.push({ metadata: element.payload.documentMetadata });\r\n            if (!element.payload.documentMetadata.exists) {\r\n                ++documentsLoaded;\r\n            }\r\n            const path = ResourcePath.fromString(element.payload.documentMetadata.name);\r\n            this.collectionGroups.add(path.get(path.length - 2));\r\n        }\r\n        else if (element.payload.document) {\r\n            this.documents[this.documents.length - 1].document =\r\n                element.payload.document;\r\n            ++documentsLoaded;\r\n        }\r\n        if (documentsLoaded !== this.progress.documentsLoaded) {\r\n            this.progress.documentsLoaded = documentsLoaded;\r\n            return Object.assign({}, this.progress);\r\n        }\r\n        return null;\r\n    }\r\n    getQueryDocumentMapping(documents) {\r\n        const queryDocumentMap = new Map();\r\n        const bundleConverter = new BundleConverterImpl(this.serializer);\r\n        for (const bundleDoc of documents) {\r\n            if (bundleDoc.metadata.queries) {\r\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\r\n                for (const queryName of bundleDoc.metadata.queries) {\r\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\r\n                    queryDocumentMap.set(queryName, documentKeys);\r\n                }\r\n            }\r\n        }\r\n        return queryDocumentMap;\r\n    }\r\n    /**\r\n     * Update the progress to 'Success' and return the updated progress.\r\n     */\r\n    async complete() {\r\n        const changedDocs = await localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id);\r\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\r\n        for (const q of this.queries) {\r\n            await localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name));\r\n        }\r\n        this.progress.taskState = 'Success';\r\n        return {\r\n            progress: this.progress,\r\n            changedCollectionGroups: this.collectionGroups,\r\n            changedDocs\r\n        };\r\n    }\r\n}\r\n/**\r\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\r\n * loading a bundle.\r\n */\r\nfunction bundleInitialProgress(metadata) {\r\n    return {\r\n        taskState: 'Running',\r\n        documentsLoaded: 0,\r\n        bytesLoaded: 0,\r\n        totalDocuments: metadata.totalDocuments,\r\n        totalBytes: metadata.totalBytes\r\n    };\r\n}\r\n/**\r\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\r\n * has succeeded.\r\n */\r\nfunction bundleSuccessProgress(metadata) {\r\n    return {\r\n        taskState: 'Success',\r\n        documentsLoaded: metadata.totalDocuments,\r\n        bytesLoaded: metadata.totalBytes,\r\n        totalDocuments: metadata.totalDocuments,\r\n        totalBytes: metadata.totalBytes\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AddedLimboDocument {\r\n    constructor(key) {\r\n        this.key = key;\r\n    }\r\n}\r\nclass RemovedLimboDocument {\r\n    constructor(key) {\r\n        this.key = key;\r\n    }\r\n}\r\n/**\r\n * View is responsible for computing the final merged truth of what docs are in\r\n * a query. It gets notified of local and remote changes to docs, and applies\r\n * the query filters and limits to determine the most correct possible results.\r\n */\r\nclass View {\r\n    constructor(query, \r\n    /** Documents included in the remote target */\r\n    _syncedDocuments) {\r\n        this.query = query;\r\n        this._syncedDocuments = _syncedDocuments;\r\n        this.syncState = null;\r\n        this.hasCachedResults = false;\r\n        /**\r\n         * A flag whether the view is current with the backend. A view is considered\r\n         * current after it has seen the current flag from the backend and did not\r\n         * lose consistency within the watch stream (e.g. because of an existence\r\n         * filter mismatch).\r\n         */\r\n        this.current = false;\r\n        /** Documents in the view but not in the remote target */\r\n        this.limboDocuments = documentKeySet();\r\n        /** Document Keys that have local changes */\r\n        this.mutatedKeys = documentKeySet();\r\n        this.docComparator = newQueryComparator(query);\r\n        this.documentSet = new DocumentSet(this.docComparator);\r\n    }\r\n    /**\r\n     * The set of remote documents that the server has told us belongs to the target associated with\r\n     * this view.\r\n     */\r\n    get syncedDocuments() {\r\n        return this._syncedDocuments;\r\n    }\r\n    /**\r\n     * Iterates over a set of doc changes, applies the query limit, and computes\r\n     * what the new results should be, what the changes were, and whether we may\r\n     * need to go back to the local cache for more results. Does not make any\r\n     * changes to the view.\r\n     * @param docChanges - The doc changes to apply to this view.\r\n     * @param previousChanges - If this is being called with a refill, then start\r\n     *        with this set of docs and changes instead of the current view.\r\n     * @returns a new set of docs, changes, and refill flag.\r\n     */\r\n    computeDocChanges(docChanges, previousChanges) {\r\n        const changeSet = previousChanges\r\n            ? previousChanges.changeSet\r\n            : new DocumentChangeSet();\r\n        const oldDocumentSet = previousChanges\r\n            ? previousChanges.documentSet\r\n            : this.documentSet;\r\n        let newMutatedKeys = previousChanges\r\n            ? previousChanges.mutatedKeys\r\n            : this.mutatedKeys;\r\n        let newDocumentSet = oldDocumentSet;\r\n        let needsRefill = false;\r\n        // Track the last doc in a (full) limit. This is necessary, because some\r\n        // update (a delete, or an update moving a doc past the old limit) might\r\n        // mean there is some other document in the local cache that either should\r\n        // come (1) between the old last limit doc and the new last document, in the\r\n        // case of updates, or (2) after the new last document, in the case of\r\n        // deletes. So we keep this doc at the old limit to compare the updates to.\r\n        //\r\n        // Note that this should never get used in a refill (when previousChanges is\r\n        // set), because there will only be adds -- no deletes or updates.\r\n        const lastDocInLimit = this.query.limitType === \"F\" /* LimitType.First */ &&\r\n            oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.last()\r\n            : null;\r\n        const firstDocInLimit = this.query.limitType === \"L\" /* LimitType.Last */ &&\r\n            oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.first()\r\n            : null;\r\n        docChanges.inorderTraversal((key, entry) => {\r\n            const oldDoc = oldDocumentSet.get(key);\r\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\r\n            const oldDocHadPendingMutations = oldDoc\r\n                ? this.mutatedKeys.has(oldDoc.key)\r\n                : false;\r\n            const newDocHasPendingMutations = newDoc\r\n                ? newDoc.hasLocalMutations ||\r\n                    // We only consider committed mutations for documents that were\r\n                    // mutated during the lifetime of the view.\r\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\r\n                : false;\r\n            let changeApplied = false;\r\n            // Calculate change\r\n            if (oldDoc && newDoc) {\r\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\r\n                if (!docsEqual) {\r\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\r\n                        changeSet.track({\r\n                            type: 2 /* ChangeType.Modified */,\r\n                            doc: newDoc\r\n                        });\r\n                        changeApplied = true;\r\n                        if ((lastDocInLimit &&\r\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\r\n                            (firstDocInLimit &&\r\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\r\n                            // This doc moved from inside the limit to outside the limit.\r\n                            // That means there may be some other doc in the local cache\r\n                            // that should be included instead.\r\n                            needsRefill = true;\r\n                        }\r\n                    }\r\n                }\r\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\r\n                    changeSet.track({ type: 3 /* ChangeType.Metadata */, doc: newDoc });\r\n                    changeApplied = true;\r\n                }\r\n            }\r\n            else if (!oldDoc && newDoc) {\r\n                changeSet.track({ type: 0 /* ChangeType.Added */, doc: newDoc });\r\n                changeApplied = true;\r\n            }\r\n            else if (oldDoc && !newDoc) {\r\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\r\n                changeApplied = true;\r\n                if (lastDocInLimit || firstDocInLimit) {\r\n                    // A doc was removed from a full limit query. We'll need to\r\n                    // requery from the local cache to see if we know about some other\r\n                    // doc that should be in the results.\r\n                    needsRefill = true;\r\n                }\r\n            }\r\n            if (changeApplied) {\r\n                if (newDoc) {\r\n                    newDocumentSet = newDocumentSet.add(newDoc);\r\n                    if (newDocHasPendingMutations) {\r\n                        newMutatedKeys = newMutatedKeys.add(key);\r\n                    }\r\n                    else {\r\n                        newMutatedKeys = newMutatedKeys.delete(key);\r\n                    }\r\n                }\r\n                else {\r\n                    newDocumentSet = newDocumentSet.delete(key);\r\n                    newMutatedKeys = newMutatedKeys.delete(key);\r\n                }\r\n            }\r\n        });\r\n        // Drop documents out to meet limit/limitToLast requirement.\r\n        if (this.query.limit !== null) {\r\n            while (newDocumentSet.size > this.query.limit) {\r\n                const oldDoc = this.query.limitType === \"F\" /* LimitType.First */\r\n                    ? newDocumentSet.last()\r\n                    : newDocumentSet.first();\r\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\r\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\r\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\r\n            }\r\n        }\r\n        return {\r\n            documentSet: newDocumentSet,\r\n            changeSet,\r\n            needsRefill,\r\n            mutatedKeys: newMutatedKeys\r\n        };\r\n    }\r\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\r\n        // We suppress the initial change event for documents that were modified as\r\n        // part of a write acknowledgment (e.g. when the value of a server transform\r\n        // is applied) as Watch will send us the same document again.\r\n        // By suppressing the event, we only raise two user visible events (one with\r\n        // `hasPendingWrites` and the final state of the document) instead of three\r\n        // (one with `hasPendingWrites`, the modified document with\r\n        // `hasPendingWrites` and the final state of the document).\r\n        return (oldDoc.hasLocalMutations &&\r\n            newDoc.hasCommittedMutations &&\r\n            !newDoc.hasLocalMutations);\r\n    }\r\n    /**\r\n     * Updates the view with the given ViewDocumentChanges and optionally updates\r\n     * limbo docs and sync state from the provided target change.\r\n     * @param docChanges - The set of changes to make to the view's docs.\r\n     * @param limboResolutionEnabled - Whether to update limbo documents based on\r\n     *        this change.\r\n     * @param targetChange - A target change to apply for computing limbo docs and\r\n     *        sync state.\r\n     * @param targetIsPendingReset - Whether the target is pending to reset due to\r\n     *        existence filter mismatch. If not explicitly specified, it is treated\r\n     *        equivalently to `false`.\r\n     * @returns A new ViewChange with the given docs, changes, and sync state.\r\n     */\r\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\r\n    applyChanges(docChanges, limboResolutionEnabled, targetChange, targetIsPendingReset) {\r\n        const oldDocs = this.documentSet;\r\n        this.documentSet = docChanges.documentSet;\r\n        this.mutatedKeys = docChanges.mutatedKeys;\r\n        // Sort changes based on type and query comparator\r\n        const changes = docChanges.changeSet.getChanges();\r\n        changes.sort((c1, c2) => {\r\n            return (compareChangeType(c1.type, c2.type) ||\r\n                this.docComparator(c1.doc, c2.doc));\r\n        });\r\n        this.applyTargetChange(targetChange);\r\n        targetIsPendingReset = targetIsPendingReset !== null && targetIsPendingReset !== void 0 ? targetIsPendingReset : false;\r\n        const limboChanges = limboResolutionEnabled && !targetIsPendingReset\r\n            ? this.updateLimboDocuments()\r\n            : [];\r\n        // We are at synced state if there is no limbo docs are waiting to be resolved, view is current\r\n        // with the backend, and the query is not pending to reset due to existence filter mismatch.\r\n        const synced = this.limboDocuments.size === 0 && this.current && !targetIsPendingReset;\r\n        const newSyncState = synced ? 1 /* SyncState.Synced */ : 0 /* SyncState.Local */;\r\n        const syncStateChanged = newSyncState !== this.syncState;\r\n        this.syncState = newSyncState;\r\n        if (changes.length === 0 && !syncStateChanged) {\r\n            // no changes\r\n            return { limboChanges };\r\n        }\r\n        else {\r\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* SyncState.Local */, syncStateChanged, \r\n            /* excludesMetadataChanges= */ false, targetChange\r\n                ? targetChange.resumeToken.approximateByteSize() > 0\r\n                : false);\r\n            return {\r\n                snapshot: snap,\r\n                limboChanges\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Applies an OnlineState change to the view, potentially generating a\r\n     * ViewChange if the view's syncState changes as a result.\r\n     */\r\n    applyOnlineStateChange(onlineState) {\r\n        if (this.current && onlineState === \"Offline\" /* OnlineState.Offline */) {\r\n            // If we're offline, set `current` to false and then call applyChanges()\r\n            // to refresh our syncState and generate a ViewChange as appropriate. We\r\n            // are guaranteed to get a new TargetChange that sets `current` back to\r\n            // true once the client is back online.\r\n            this.current = false;\r\n            return this.applyChanges({\r\n                documentSet: this.documentSet,\r\n                changeSet: new DocumentChangeSet(),\r\n                mutatedKeys: this.mutatedKeys,\r\n                needsRefill: false\r\n            }, \r\n            /* limboResolutionEnabled= */ false);\r\n        }\r\n        else {\r\n            // No effect, just return a no-op ViewChange.\r\n            return { limboChanges: [] };\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether the doc for the given key should be in limbo.\r\n     */\r\n    shouldBeInLimbo(key) {\r\n        // If the remote end says it's part of this query, it's not in limbo.\r\n        if (this._syncedDocuments.has(key)) {\r\n            return false;\r\n        }\r\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\r\n        if (!this.documentSet.has(key)) {\r\n            return false;\r\n        }\r\n        // If there are local changes to the doc, they might explain why the server\r\n        // doesn't know that it's part of the query. So don't put it in limbo.\r\n        // TODO(klimt): Ideally, we would only consider changes that might actually\r\n        // affect this specific query.\r\n        if (this.documentSet.get(key).hasLocalMutations) {\r\n            return false;\r\n        }\r\n        // Everything else is in limbo.\r\n        return true;\r\n    }\r\n    /**\r\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\r\n     * Returns the list of changes to which docs are in limbo.\r\n     */\r\n    applyTargetChange(targetChange) {\r\n        if (targetChange) {\r\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\r\n            targetChange.modifiedDocuments.forEach(key => {\r\n            });\r\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\r\n            this.current = targetChange.current;\r\n        }\r\n    }\r\n    updateLimboDocuments() {\r\n        // We can only determine limbo documents when we're in-sync with the server.\r\n        if (!this.current) {\r\n            return [];\r\n        }\r\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\r\n        // updating many documents.\r\n        const oldLimboDocuments = this.limboDocuments;\r\n        this.limboDocuments = documentKeySet();\r\n        this.documentSet.forEach(doc => {\r\n            if (this.shouldBeInLimbo(doc.key)) {\r\n                this.limboDocuments = this.limboDocuments.add(doc.key);\r\n            }\r\n        });\r\n        // Diff the new limbo docs with the old limbo docs.\r\n        const changes = [];\r\n        oldLimboDocuments.forEach(key => {\r\n            if (!this.limboDocuments.has(key)) {\r\n                changes.push(new RemovedLimboDocument(key));\r\n            }\r\n        });\r\n        this.limboDocuments.forEach(key => {\r\n            if (!oldLimboDocuments.has(key)) {\r\n                changes.push(new AddedLimboDocument(key));\r\n            }\r\n        });\r\n        return changes;\r\n    }\r\n    /**\r\n     * Update the in-memory state of the current view with the state read from\r\n     * persistence.\r\n     *\r\n     * We update the query view whenever a client's primary status changes:\r\n     * - When a client transitions from primary to secondary, it can miss\r\n     *   LocalStorage updates and its query views may temporarily not be\r\n     *   synchronized with the state on disk.\r\n     * - For secondary to primary transitions, the client needs to update the list\r\n     *   of `syncedDocuments` since secondary clients update their query views\r\n     *   based purely on synthesized RemoteEvents.\r\n     *\r\n     * @param queryResult.documents - The documents that match the query according\r\n     * to the LocalStore.\r\n     * @param queryResult.remoteKeys - The keys of the documents that match the\r\n     * query according to the backend.\r\n     *\r\n     * @returns The ViewChange that resulted from this synchronization.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    synchronizeWithPersistedState(queryResult) {\r\n        this._syncedDocuments = queryResult.remoteKeys;\r\n        this.limboDocuments = documentKeySet();\r\n        const docChanges = this.computeDocChanges(queryResult.documents);\r\n        return this.applyChanges(docChanges, /* limboResolutionEnabled= */ true);\r\n    }\r\n    /**\r\n     * Returns a view snapshot as if this query was just listened to. Contains\r\n     * a document add for every existing document and the `fromCache` and\r\n     * `hasPendingWrites` status of the already established view.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    computeInitialSnapshot() {\r\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* SyncState.Local */, this.hasCachedResults);\r\n    }\r\n}\r\nfunction compareChangeType(c1, c2) {\r\n    const order = (change) => {\r\n        switch (change) {\r\n            case 0 /* ChangeType.Added */:\r\n                return 1;\r\n            case 2 /* ChangeType.Modified */:\r\n                return 2;\r\n            case 3 /* ChangeType.Metadata */:\r\n                // A metadata change is converted to a modified change at the public\r\n                // api layer.  Since we sort by document key and then change type,\r\n                // metadata and modified changes must be sorted equivalently.\r\n                return 2;\r\n            case 1 /* ChangeType.Removed */:\r\n                return 0;\r\n            default:\r\n                return fail();\r\n        }\r\n    };\r\n    return order(c1) - order(c2);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$3 = 'SyncEngine';\r\n/**\r\n * QueryView contains all of the data that SyncEngine needs to keep track of for\r\n * a particular query.\r\n */\r\nclass QueryView {\r\n    constructor(\r\n    /**\r\n     * The query itself.\r\n     */\r\n    query, \r\n    /**\r\n     * The target number created by the client that is used in the watch\r\n     * stream to identify this query.\r\n     */\r\n    targetId, \r\n    /**\r\n     * The view is responsible for computing the final merged truth of what\r\n     * docs are in the query. It gets notified of local and remote changes,\r\n     * and applies the query filters and limits to determine the most correct\r\n     * possible results.\r\n     */\r\n    view) {\r\n        this.query = query;\r\n        this.targetId = targetId;\r\n        this.view = view;\r\n    }\r\n}\r\n/** Tracks a limbo resolution. */\r\nclass LimboResolution {\r\n    constructor(key) {\r\n        this.key = key;\r\n        /**\r\n         * Set to true once we've received a document. This is used in\r\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\r\n         * decide whether it needs to manufacture a delete event for the target once\r\n         * the target is CURRENT.\r\n         */\r\n        this.receivedDocument = false;\r\n    }\r\n}\r\n/**\r\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\r\n *\r\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\r\n * registered individually. This is done in `syncEngineWrite()` and\r\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\r\n * serve as entry points to RemoteStore's functionality.\r\n *\r\n * Note: some field defined in this class might have public access level, but\r\n * the class is not exported so they are only accessible from this module.\r\n * This is useful to implement optional features (like bundles) in free\r\n * functions, such that they are tree-shakeable.\r\n */\r\nclass SyncEngineImpl {\r\n    constructor(localStore, remoteStore, eventManager, \r\n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\r\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\r\n        this.localStore = localStore;\r\n        this.remoteStore = remoteStore;\r\n        this.eventManager = eventManager;\r\n        this.sharedClientState = sharedClientState;\r\n        this.currentUser = currentUser;\r\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\r\n        this.syncEngineListener = {};\r\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\r\n        this.queriesByTarget = new Map();\r\n        /**\r\n         * The keys of documents that are in limbo for which we haven't yet started a\r\n         * limbo resolution query. The strings in this set are the result of calling\r\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\r\n         *\r\n         * The `Set` type was chosen because it provides efficient lookup and removal\r\n         * of arbitrary elements and it also maintains insertion order, providing the\r\n         * desired queue-like FIFO semantics.\r\n         */\r\n        this.enqueuedLimboResolutions = new Set();\r\n        /**\r\n         * Keeps track of the target ID for each document that is in limbo with an\r\n         * active target.\r\n         */\r\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\r\n        /**\r\n         * Keeps track of the information about an active limbo resolution for each\r\n         * active target ID that was started for the purpose of limbo resolution.\r\n         */\r\n        this.activeLimboResolutionsByTarget = new Map();\r\n        this.limboDocumentRefs = new ReferenceSet();\r\n        /** Stores user completion handlers, indexed by User and BatchId. */\r\n        this.mutationUserCallbacks = {};\r\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\r\n        this.pendingWritesCallbacks = new Map();\r\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\r\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\r\n        // The primary state is set to `true` or `false` immediately after Firestore\r\n        // startup. In the interim, a client should only be considered primary if\r\n        // `isPrimary` is true.\r\n        this._isPrimaryClient = undefined;\r\n    }\r\n    get isPrimaryClient() {\r\n        return this._isPrimaryClient === true;\r\n    }\r\n}\r\nfunction newSyncEngine(localStore, remoteStore, eventManager, \r\n// PORTING NOTE: Manages state synchronization in multi-tab environments.\r\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\r\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\r\n    if (isPrimary) {\r\n        syncEngine._isPrimaryClient = true;\r\n    }\r\n    return syncEngine;\r\n}\r\n/**\r\n * Initiates the new listen, resolves promise when listen enqueued to the\r\n * server. All the subsequent view snapshots or errors are sent to the\r\n * subscribed handlers. Returns the initial snapshot.\r\n */\r\nasync function syncEngineListen(syncEngine, query, shouldListenToRemote = true) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    let viewSnapshot;\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    if (queryView) {\r\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\r\n        // already exists when EventManager calls us for the first time. This\r\n        // happens when the primary tab is already listening to this query on\r\n        // behalf of another tab and the user of the primary also starts listening\r\n        // to the query. EventManager will not have an assigned target ID in this\r\n        // case and calls `listen` to obtain this ID.\r\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(queryView.targetId);\r\n        viewSnapshot = queryView.view.computeInitialSnapshot();\r\n    }\r\n    else {\r\n        viewSnapshot = await allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, \r\n        /** shouldInitializeView= */ true);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/** Query has been listening to the cache, and tries to initiate the remote store listen */\r\nasync function triggerRemoteStoreListen(syncEngine, query) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    await allocateTargetAndMaybeListen(syncEngineImpl, query, \r\n    /** shouldListenToRemote= */ true, \r\n    /** shouldInitializeView= */ false);\r\n}\r\nasync function allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, shouldInitializeView) {\r\n    const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\r\n    const targetId = targetData.targetId;\r\n    // PORTING NOTE: When the query is listening to cache only, we skip sending it over to Watch by\r\n    // not registering it in shared client state, and directly calculate initial snapshots and\r\n    // subsequent updates from cache. Otherwise, register the target ID with local Firestore client\r\n    // as active watch target.\r\n    const status = shouldListenToRemote\r\n        ? syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId)\r\n        : 'not-current';\r\n    let viewSnapshot;\r\n    if (shouldInitializeView) {\r\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current', targetData.resumeToken);\r\n    }\r\n    if (syncEngineImpl.isPrimaryClient && shouldListenToRemote) {\r\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/**\r\n * Registers a view for a previously unknown query and computes its initial\r\n * snapshot.\r\n */\r\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current, resumeToken) {\r\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\r\n    // targets based on view changes. This allows us to only depend on Limbo\r\n    // changes when user code includes queries.\r\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\r\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \r\n    /* usePreviousResults= */ true);\r\n    const view = new View(query, queryResult.remoteKeys);\r\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\r\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* OnlineState.Offline */, resumeToken);\r\n    const viewChange = view.applyChanges(viewDocChanges, \r\n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\r\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\r\n    const data = new QueryView(query, targetId, view);\r\n    syncEngineImpl.queryViewsByQuery.set(query, data);\r\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\r\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\r\n    }\r\n    else {\r\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\r\n    }\r\n    return viewChange.snapshot;\r\n}\r\n/** Stops listening to the query. */\r\nasync function syncEngineUnlisten(syncEngine, query, shouldUnlistenToRemote) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    // Only clean up the query view and target if this is the only query mapped\r\n    // to the target.\r\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\r\n    if (queries.length > 1) {\r\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\r\n        syncEngineImpl.queryViewsByQuery.delete(query);\r\n        return;\r\n    }\r\n    // No other queries are mapped to the target, clean up the query and the target.\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        // We need to remove the local query target first to allow us to verify\r\n        // whether any other client is still interested in this target.\r\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\r\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\r\n        if (!targetRemainsActive) {\r\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \r\n            /*keepPersistedTargetData=*/ false)\r\n                .then(() => {\r\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\r\n                if (shouldUnlistenToRemote) {\r\n                    remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\r\n                }\r\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\r\n            })\r\n                .catch(ignoreIfPrimaryLeaseLoss);\r\n        }\r\n    }\r\n    else {\r\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \r\n        /*keepPersistedTargetData=*/ true);\r\n    }\r\n}\r\n/** Unlistens to the remote store while still listening to the cache. */\r\nasync function triggerRemoteStoreUnlisten(syncEngine, query) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\r\n    if (syncEngineImpl.isPrimaryClient && queries.length === 1) {\r\n        // PORTING NOTE: Unregister the target ID with local Firestore client as\r\n        // watch target.\r\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\r\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\r\n    }\r\n}\r\n/**\r\n * Initiates the write of local mutation batch which involves adding the\r\n * writes to the mutation queue, notifying the remote store about new\r\n * mutations and raising events for any changes this write caused.\r\n *\r\n * The promise returned by this call is resolved when the above steps\r\n * have completed, *not* when the write was acked by the backend. The\r\n * userCallback is resolved once the write was acked/rejected by the\r\n * backend (or failed locally for any other reason).\r\n */\r\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\r\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\r\n    try {\r\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\r\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\r\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\r\n        await fillWritePipeline(syncEngineImpl.remoteStore);\r\n    }\r\n    catch (e) {\r\n        // If we can't persist the mutation, we reject the user callback and\r\n        // don't send the mutation. The user can then retry the write.\r\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\r\n        userCallback.reject(error);\r\n    }\r\n}\r\n/**\r\n * Applies one remote event to the sync engine, notifying any views of the\r\n * changes, and releasing any pending mutation batches that would become\r\n * visible because of the snapshot version the remote event contains.\r\n */\r\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    try {\r\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\r\n        // Update `receivedDocument` as appropriate for any limbo targets.\r\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\r\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n            if (limboResolution) {\r\n                // Since this is a limbo resolution lookup, it's for a single document\r\n                // and it could be added, modified, or removed, but not a combination.\r\n                hardAssert(targetChange.addedDocuments.size +\r\n                    targetChange.modifiedDocuments.size +\r\n                    targetChange.removedDocuments.size <=\r\n                    1);\r\n                if (targetChange.addedDocuments.size > 0) {\r\n                    limboResolution.receivedDocument = true;\r\n                }\r\n                else if (targetChange.modifiedDocuments.size > 0) {\r\n                    hardAssert(limboResolution.receivedDocument);\r\n                }\r\n                else if (targetChange.removedDocuments.size > 0) {\r\n                    hardAssert(limboResolution.receivedDocument);\r\n                    limboResolution.receivedDocument = false;\r\n                }\r\n                else {\r\n                    // This was probably just a CURRENT targetChange or similar.\r\n                }\r\n            }\r\n        });\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\n/**\r\n * Applies an OnlineState change to the sync engine and notifies any views of\r\n * the change.\r\n */\r\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // If we are the secondary client, we explicitly ignore the remote store's\r\n    // online state (the local client may go offline, even though the primary\r\n    // tab remains online) and only apply the primary tab's online state from\r\n    // SharedClientState.\r\n    if ((syncEngineImpl.isPrimaryClient &&\r\n        source === 0 /* OnlineStateSource.RemoteStore */) ||\r\n        (!syncEngineImpl.isPrimaryClient &&\r\n            source === 1 /* OnlineStateSource.SharedClientState */)) {\r\n        const newViewSnapshots = [];\r\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\r\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\r\n            if (viewChange.snapshot) {\r\n                newViewSnapshots.push(viewChange.snapshot);\r\n            }\r\n        });\r\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\r\n        if (newViewSnapshots.length) {\r\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\r\n        }\r\n        syncEngineImpl.onlineState = onlineState;\r\n        if (syncEngineImpl.isPrimaryClient) {\r\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Rejects the listen for the given targetID. This can be triggered by the\r\n * backend for any active target.\r\n *\r\n * @param syncEngine - The sync engine implementation.\r\n * @param targetId - The targetID corresponds to one previously initiated by the\r\n * user as part of TargetData passed to listen() on RemoteStore.\r\n * @param err - A description of the condition that has forced the rejection.\r\n * Nearly always this will be an indication that the user is no longer\r\n * authorized to see the data matching the target.\r\n */\r\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // PORTING NOTE: Multi-tab only.\r\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\r\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n    const limboKey = limboResolution && limboResolution.key;\r\n    if (limboKey) {\r\n        // TODO(klimt): We really only should do the following on permission\r\n        // denied errors, but we don't have the cause code here.\r\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\r\n        // This is kind of a hack. Ideally, we would have a method in the local\r\n        // store to purge a document. However, it would be tricky to keep all of\r\n        // the local store's invariants with another method.\r\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\r\n        // TODO(b/217189216): This limbo document should ideally have a read time,\r\n        // so that it is picked up by any read-time based scans. The backend,\r\n        // however, does not send a read time for target removals.\r\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\r\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\r\n        const event = new RemoteEvent(SnapshotVersion.min(), \r\n        /* targetChanges= */ new Map(), \r\n        /* targetMismatches= */ new SortedMap(primitiveComparator), documentUpdates, resolvedLimboDocuments);\r\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\r\n        // Since this query failed, we won't want to manually unlisten to it.\r\n        // We only remove it from bookkeeping after we successfully applied the\r\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\r\n        // this query when the RemoteStore restarts the Watch stream, which should\r\n        // re-trigger the target failure.\r\n        syncEngineImpl.activeLimboTargetsByKey =\r\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\r\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\r\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n    }\r\n    else {\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n        /* keepPersistedTargetData */ false)\r\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\r\n            .catch(ignoreIfPrimaryLeaseLoss);\r\n    }\r\n}\r\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const batchId = mutationBatchResult.batch.batchId;\r\n    try {\r\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\r\n        // The local store may or may not be able to apply the write result and\r\n        // raise events immediately (depending on whether the watcher is caught\r\n        // up), so we raise user callbacks first so that they consistently happen\r\n        // before listen events.\r\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    try {\r\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\r\n        // The local store may or may not be able to apply the write result and\r\n        // raise events immediately (depending on whether the watcher is caught up),\r\n        // so we raise user callbacks first so that they consistently happen before\r\n        // listen events.\r\n        processUserCallback(syncEngineImpl, batchId, error);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\n/**\r\n * Registers a user callback that resolves when all pending mutations at the moment of calling\r\n * are acknowledged .\r\n */\r\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\r\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\r\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\r\n    }\r\n    try {\r\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\r\n        if (highestBatchId === BATCHID_UNKNOWN) {\r\n            // Trigger the callback right away if there is no pending writes at the moment.\r\n            callback.resolve();\r\n            return;\r\n        }\r\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\r\n        callbacks.push(callback);\r\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\r\n        callback.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\r\n * if there are any.\r\n */\r\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\r\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\r\n        callback.resolve();\r\n    });\r\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\r\n}\r\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\r\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\r\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\r\n        callbacks.forEach(callback => {\r\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\r\n        });\r\n    });\r\n    syncEngineImpl.pendingWritesCallbacks.clear();\r\n}\r\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\r\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\r\n    if (!newCallbacks) {\r\n        newCallbacks = new SortedMap(primitiveComparator);\r\n    }\r\n    newCallbacks = newCallbacks.insert(batchId, callback);\r\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\r\n        newCallbacks;\r\n}\r\n/**\r\n * Resolves or rejects the user callback for the given batch and then discards\r\n * it.\r\n */\r\nfunction processUserCallback(syncEngine, batchId, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\r\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\r\n    // okay for there to be no callback for this ID.\r\n    if (newCallbacks) {\r\n        const callback = newCallbacks.get(batchId);\r\n        if (callback) {\r\n            if (error) {\r\n                callback.reject(error);\r\n            }\r\n            else {\r\n                callback.resolve();\r\n            }\r\n            newCallbacks = newCallbacks.remove(batchId);\r\n        }\r\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\r\n            newCallbacks;\r\n    }\r\n}\r\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\r\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\r\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\r\n        syncEngineImpl.queryViewsByQuery.delete(query);\r\n        if (error) {\r\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\r\n        }\r\n    }\r\n    syncEngineImpl.queriesByTarget.delete(targetId);\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\r\n        limboKeys.forEach(limboKey => {\r\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\r\n            if (!isReferenced) {\r\n                // We removed the last reference for this key\r\n                removeLimboTarget(syncEngineImpl, limboKey);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction removeLimboTarget(syncEngineImpl, key) {\r\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\r\n    // It's possible that the target already got removed because the query failed. In that case,\r\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\r\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\r\n    if (limboTargetId === null) {\r\n        // This target already got removed, because the query failed.\r\n        return;\r\n    }\r\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\r\n    syncEngineImpl.activeLimboTargetsByKey =\r\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\r\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\r\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n}\r\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\r\n    for (const limboChange of limboChanges) {\r\n        if (limboChange instanceof AddedLimboDocument) {\r\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\r\n            trackLimboChange(syncEngineImpl, limboChange);\r\n        }\r\n        else if (limboChange instanceof RemovedLimboDocument) {\r\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\r\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\r\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\r\n            if (!isReferenced) {\r\n                // We removed the last reference for this key\r\n                removeLimboTarget(syncEngineImpl, limboChange.key);\r\n            }\r\n        }\r\n        else {\r\n            fail();\r\n        }\r\n    }\r\n}\r\nfunction trackLimboChange(syncEngineImpl, limboChange) {\r\n    const key = limboChange.key;\r\n    const keyString = key.path.canonicalString();\r\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\r\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\r\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\r\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\r\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n    }\r\n}\r\n/**\r\n * Starts listens for documents in limbo that are enqueued for resolution,\r\n * subject to a maximum number of concurrent resolutions.\r\n *\r\n * Without bounding the number of concurrent resolutions, the server can fail\r\n * with \"resource exhausted\" errors which can lead to pathological client\r\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\r\n */\r\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\r\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\r\n        syncEngineImpl.activeLimboTargetsByKey.size <\r\n            syncEngineImpl.maxConcurrentLimboResolutions) {\r\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\r\n            .values()\r\n            .next().value;\r\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\r\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\r\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\r\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\r\n        syncEngineImpl.activeLimboTargetsByKey =\r\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\r\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */, ListenSequence.INVALID));\r\n    }\r\n}\r\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const newSnaps = [];\r\n    const docChangesInAllViews = [];\r\n    const queriesProcessed = [];\r\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\r\n        // Return early since `onWatchChange()` might not have been assigned yet.\r\n        return;\r\n    }\r\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\r\n        queriesProcessed.push(syncEngineImpl\r\n            .applyDocChanges(queryView, changes, remoteEvent)\r\n            .then(viewSnapshot => {\r\n            var _a;\r\n            // If there are changes, or we are handling a global snapshot, notify\r\n            // secondary clients to update query state.\r\n            if (viewSnapshot || remoteEvent) {\r\n                if (syncEngineImpl.isPrimaryClient) {\r\n                    // Query state is set to `current` if:\r\n                    // - There is a view change and it is up-to-date, or,\r\n                    // - There is a global snapshot, the Target is current, and no changes to be resolved\r\n                    const isCurrent = viewSnapshot\r\n                        ? !viewSnapshot.fromCache\r\n                        : (_a = remoteEvent === null || remoteEvent === void 0 ? void 0 : remoteEvent.targetChanges.get(queryView.targetId)) === null || _a === void 0 ? void 0 : _a.current;\r\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, isCurrent ? 'current' : 'not-current');\r\n                }\r\n            }\r\n            // Update views if there are actual changes.\r\n            if (!!viewSnapshot) {\r\n                newSnaps.push(viewSnapshot);\r\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\r\n                docChangesInAllViews.push(docChanges);\r\n            }\r\n        }));\r\n    });\r\n    await Promise.all(queriesProcessed);\r\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\r\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\r\n}\r\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\r\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\r\n    if (viewDocChanges.needsRefill) {\r\n        // The query has a limit and some docs were removed, so we need\r\n        // to re-run the query against the local store to make sure we\r\n        // didn't lose any good docs that had been past the limit.\r\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \r\n        /* usePreviousResults= */ false).then(({ documents }) => {\r\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\r\n        });\r\n    }\r\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\r\n    const targetIsPendingReset = remoteEvent && remoteEvent.targetMismatches.get(queryView.targetId) != null;\r\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \r\n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, targetChange, targetIsPendingReset);\r\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\r\n    return viewChange.snapshot;\r\n}\r\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\r\n    if (userChanged) {\r\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\r\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\r\n        syncEngineImpl.currentUser = user;\r\n        // Fails tasks waiting for pending writes requested by previous user.\r\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\r\n        // TODO(b/114226417): Consider calling this only in the primary tab.\r\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\r\n    }\r\n}\r\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n    if (limboResolution && limboResolution.receivedDocument) {\r\n        return documentKeySet().add(limboResolution.key);\r\n    }\r\n    else {\r\n        let keySet = documentKeySet();\r\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\r\n        if (!queries) {\r\n            return keySet;\r\n        }\r\n        for (const query of queries) {\r\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\r\n        }\r\n        return keySet;\r\n    }\r\n}\r\n/**\r\n * Reconcile the list of synced documents in an existing view with those\r\n * from persistence.\r\n */\r\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \r\n    /* usePreviousResults= */ true);\r\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/**\r\n * Retrieves newly changed documents from remote document cache and raises\r\n * snapshots if needed.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine, collectionGroup) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore, collectionGroup).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\r\n}\r\n/** Applies a mutation state to an existing batch.  */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\r\n    if (documents === null) {\r\n        // A throttled tab may not have seen the mutation before it was completed\r\n        // and removed from the mutation queue, in which case we won't have cached\r\n        // the affected documents. In this case we can safely ignore the update\r\n        // since that means we didn't apply the mutation locally at all (if we\r\n        // had, we would have cached the affected documents), and so we will just\r\n        // see any resulting document changes via normal remote document updates\r\n        // as applicable.\r\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\r\n        return;\r\n    }\r\n    if (batchState === 'pending') {\r\n        // If we are the primary client, we need to send this write to the\r\n        // backend. Secondary clients will ignore these writes since their remote\r\n        // connection is disabled.\r\n        await fillWritePipeline(syncEngineImpl.remoteStore);\r\n    }\r\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\r\n        // NOTE: Both these methods are no-ops for batches that originated from\r\n        // other clients.\r\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\r\n}\r\n/** Applies a query target change from a different tab. */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    ensureWatchCallbacks(syncEngineImpl);\r\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\r\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\r\n        // Secondary tabs only maintain Views for their local listeners and the\r\n        // Views internal state may not be 100% populated (in particular\r\n        // secondary tabs don't track syncedDocuments, the set of documents the\r\n        // server considers to be in the target). So when a secondary becomes\r\n        // primary, we need to need to make sure that all views for all targets\r\n        // match the state on disk.\r\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\r\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\r\n        syncEngineImpl._isPrimaryClient = true;\r\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\r\n        for (const targetData of activeQueries) {\r\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n        }\r\n    }\r\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\r\n        const activeTargets = [];\r\n        let p = Promise.resolve();\r\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\r\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\r\n                activeTargets.push(targetId);\r\n            }\r\n            else {\r\n                p = p.then(() => {\r\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\r\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n                    /*keepPersistedTargetData=*/ true);\r\n                });\r\n            }\r\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n        });\r\n        await p;\r\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\r\n        resetLimboDocuments(syncEngineImpl);\r\n        syncEngineImpl._isPrimaryClient = false;\r\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\r\n    }\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction resetLimboDocuments(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\r\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n    });\r\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\r\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\r\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\r\n}\r\n/**\r\n * Reconcile the query views of the provided query targets with the state from\r\n * persistence. Raises snapshots for any changes that affect the local\r\n * client and returns the updated state of all target's query data.\r\n *\r\n * @param syncEngine - The sync engine implementation\r\n * @param targets - the list of targets with views that need to be recomputed\r\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\r\n * tab to a primary tab\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const activeQueries = [];\r\n    const newViewSnapshots = [];\r\n    for (const targetId of targets) {\r\n        let targetData;\r\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\r\n        if (queries && queries.length !== 0) {\r\n            // For queries that have a local View, we fetch their current state\r\n            // from LocalStore (as the resume token and the snapshot version\r\n            // might have changed) and reconcile their views with the persisted\r\n            // state (the list of syncedDocuments may have gotten out of sync).\r\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\r\n            for (const query of queries) {\r\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\r\n                if (viewChange.snapshot) {\r\n                    newViewSnapshots.push(viewChange.snapshot);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // For queries that never executed on this client, we need to\r\n            // allocate the target in LocalStore and initialize a new View.\r\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\r\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\r\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \r\n            /*current=*/ false, targetData.resumeToken);\r\n        }\r\n        activeQueries.push(targetData);\r\n    }\r\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\r\n    return activeQueries;\r\n}\r\n/**\r\n * Creates a `Query` object from the specified `Target`. There is no way to\r\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\r\n * object.\r\n *\r\n * The synthesized result might be different from the original `Query`, but\r\n * since the synthesized `Query` should return the same results as the\r\n * original one (only the presentation of results might differ), the potential\r\n * difference will not cause issues.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction synthesizeTargetToQuery(target) {\r\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* LimitType.First */, target.startAt, target.endAt);\r\n}\r\n/** Returns the IDs of the clients that are currently active. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction syncEngineGetActiveClients(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\r\n}\r\n/** Applies a query target change from a different tab. */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    if (syncEngineImpl._isPrimaryClient) {\r\n        // If we receive a target state notification via WebStorage, we are\r\n        // either already secondary or another tab has taken the primary lease.\r\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\r\n        return;\r\n    }\r\n    const query = syncEngineImpl.queriesByTarget.get(targetId);\r\n    if (query && query.length > 0) {\r\n        switch (state) {\r\n            case 'current':\r\n            case 'not-current': {\r\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore, queryCollectionGroup(query[0]));\r\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current', ByteString.EMPTY_BYTE_STRING);\r\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\r\n                break;\r\n            }\r\n            case 'rejected': {\r\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n                /* keepPersistedTargetData */ true);\r\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\r\n                break;\r\n            }\r\n            default:\r\n                fail();\r\n        }\r\n    }\r\n}\r\n/** Adds or removes Watch targets for queries from different tabs. */\r\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    if (!syncEngineImpl._isPrimaryClient) {\r\n        return;\r\n    }\r\n    for (const targetId of added) {\r\n        // A target is already listening to remote store if it is already registered to\r\n        // sharedClientState.\r\n        const targetAlreadyListeningToRemoteStore = syncEngineImpl.queriesByTarget.has(targetId) &&\r\n            syncEngineImpl.sharedClientState.isActiveQueryTarget(targetId);\r\n        if (targetAlreadyListeningToRemoteStore) {\r\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\r\n            continue;\r\n        }\r\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\r\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\r\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \r\n        /*current=*/ false, targetData.resumeToken);\r\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n    }\r\n    for (const targetId of removed) {\r\n        // Check that the target is still active since the target might have been\r\n        // removed if it has been rejected by the backend.\r\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\r\n            continue;\r\n        }\r\n        // Release queries that are still active.\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n        /* keepPersistedTargetData */ false)\r\n            .then(() => {\r\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n            removeAndCleanupTarget(syncEngineImpl, targetId);\r\n        })\r\n            .catch(ignoreIfPrimaryLeaseLoss);\r\n    }\r\n}\r\nfunction ensureWatchCallbacks(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\r\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\r\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\r\n        syncEngineRejectListen.bind(null, syncEngineImpl);\r\n    syncEngineImpl.syncEngineListener.onWatchChange =\r\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\r\n    syncEngineImpl.syncEngineListener.onWatchError =\r\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\r\n    return syncEngineImpl;\r\n}\r\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\r\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\r\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\r\n    return syncEngineImpl;\r\n}\r\n/**\r\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\r\n * the bundle finished loading.\r\n *\r\n * @param syncEngine - SyncEngine to use.\r\n * @param bundleReader - Bundle to load into the SDK.\r\n * @param task - LoadBundleTask used to update the loading progress to public API.\r\n */\r\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(collectionGroups => {\r\n        syncEngineImpl.sharedClientState.notifyBundleLoaded(collectionGroups);\r\n    });\r\n}\r\n/** Loads a bundle and returns the list of affected collection groups. */\r\nasync function loadBundleImpl(syncEngine, reader, task) {\r\n    try {\r\n        const metadata = await reader.getMetadata();\r\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\r\n        if (skip) {\r\n            await reader.close();\r\n            task._completeWith(bundleSuccessProgress(metadata));\r\n            return Promise.resolve(new Set());\r\n        }\r\n        task._updateProgress(bundleInitialProgress(metadata));\r\n        const loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);\r\n        let element = await reader.nextElement();\r\n        while (element) {\r\n            ;\r\n            const progress = await loader.addSizedElement(element);\r\n            if (progress) {\r\n                task._updateProgress(progress);\r\n            }\r\n            element = await reader.nextElement();\r\n        }\r\n        const result = await loader.complete();\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \r\n        /* remoteEvent */ undefined);\r\n        // Save metadata, so loading the same bundle will skip.\r\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\r\n        task._completeWith(result.progress);\r\n        return Promise.resolve(result.changedCollectionGroups);\r\n    }\r\n    catch (e) {\r\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\r\n        task._failWith(e);\r\n        return Promise.resolve(new Set());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides all components needed for Firestore with in-memory persistence.\r\n * Uses EagerGC garbage collection.\r\n */\r\nclass MemoryOfflineComponentProvider {\r\n    constructor() {\r\n        this.synchronizeTabs = false;\r\n    }\r\n    async initialize(cfg) {\r\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\r\n        this.sharedClientState = this.createSharedClientState(cfg);\r\n        this.persistence = this.createPersistence(cfg);\r\n        await this.persistence.start();\r\n        this.localStore = this.createLocalStore(cfg);\r\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg, this.localStore);\r\n        this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(cfg, this.localStore);\r\n    }\r\n    createGarbageCollectionScheduler(cfg, localStore) {\r\n        return null;\r\n    }\r\n    createIndexBackfillerScheduler(cfg, localStore) {\r\n        return null;\r\n    }\r\n    createLocalStore(cfg) {\r\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\r\n    }\r\n    createPersistence(cfg) {\r\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\r\n    }\r\n    createSharedClientState(cfg) {\r\n        return new MemorySharedClientState();\r\n    }\r\n    async terminate() {\r\n        var _a, _b;\r\n        (_a = this.gcScheduler) === null || _a === void 0 ? void 0 : _a.stop();\r\n        (_b = this.indexBackfillerScheduler) === null || _b === void 0 ? void 0 : _b.stop();\r\n        this.sharedClientState.shutdown();\r\n        await this.persistence.shutdown();\r\n    }\r\n}\r\nclass LruGcMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {\r\n    constructor(cacheSizeBytes) {\r\n        super();\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n    }\r\n    createGarbageCollectionScheduler(cfg, localStore) {\r\n        hardAssert(this.persistence.referenceDelegate instanceof MemoryLruDelegate);\r\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\r\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\r\n    }\r\n    createPersistence(cfg) {\r\n        const lruParams = this.cacheSizeBytes !== undefined\r\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\r\n            : LruParams.DEFAULT;\r\n        return new MemoryPersistence(p => MemoryLruDelegate.factory(p, lruParams), this.serializer);\r\n    }\r\n}\r\n/**\r\n * Provides all components needed for Firestore with IndexedDB persistence.\r\n */\r\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\r\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\r\n        super();\r\n        this.onlineComponentProvider = onlineComponentProvider;\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n        this.forceOwnership = forceOwnership;\r\n        this.synchronizeTabs = false;\r\n    }\r\n    async initialize(cfg) {\r\n        await super.initialize(cfg);\r\n        await this.onlineComponentProvider.initialize(this, cfg);\r\n        // Enqueue writes from a previous session\r\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\r\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\r\n        // NOTE: This will immediately call the listener, so we make sure to\r\n        // set it after localStore / remoteStore are started.\r\n        await this.persistence.setPrimaryStateListener(() => {\r\n            if (this.gcScheduler && !this.gcScheduler.started) {\r\n                this.gcScheduler.start();\r\n            }\r\n            if (this.indexBackfillerScheduler &&\r\n                !this.indexBackfillerScheduler.started) {\r\n                this.indexBackfillerScheduler.start();\r\n            }\r\n            return Promise.resolve();\r\n        });\r\n    }\r\n    createLocalStore(cfg) {\r\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\r\n    }\r\n    createGarbageCollectionScheduler(cfg, localStore) {\r\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\r\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\r\n    }\r\n    createIndexBackfillerScheduler(cfg, localStore) {\r\n        const indexBackfiller = new IndexBackfiller(localStore, this.persistence);\r\n        return new IndexBackfillerScheduler(cfg.asyncQueue, indexBackfiller);\r\n    }\r\n    createPersistence(cfg) {\r\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\r\n        const lruParams = this.cacheSizeBytes !== undefined\r\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\r\n            : LruParams.DEFAULT;\r\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\r\n    }\r\n    createSharedClientState(cfg) {\r\n        return new MemorySharedClientState();\r\n    }\r\n}\r\n/**\r\n * Provides all components needed for Firestore with multi-tab IndexedDB\r\n * persistence.\r\n *\r\n * In the legacy client, this provider is used to provide both multi-tab and\r\n * non-multi-tab persistence since we cannot tell at build time whether\r\n * `synchronizeTabs` will be enabled.\r\n */\r\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\r\n    constructor(onlineComponentProvider, cacheSizeBytes) {\r\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\r\n        this.onlineComponentProvider = onlineComponentProvider;\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n        this.synchronizeTabs = true;\r\n    }\r\n    async initialize(cfg) {\r\n        await super.initialize(cfg);\r\n        const syncEngine = this.onlineComponentProvider.syncEngine;\r\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\r\n            this.sharedClientState.syncEngine = {\r\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\r\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\r\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\r\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\r\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\r\n            };\r\n            await this.sharedClientState.start();\r\n        }\r\n        // NOTE: This will immediately call the listener, so we make sure to\r\n        // set it after localStore / remoteStore are started.\r\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\r\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\r\n            if (this.gcScheduler) {\r\n                if (isPrimary && !this.gcScheduler.started) {\r\n                    this.gcScheduler.start();\r\n                }\r\n                else if (!isPrimary) {\r\n                    this.gcScheduler.stop();\r\n                }\r\n            }\r\n            if (this.indexBackfillerScheduler) {\r\n                if (isPrimary && !this.indexBackfillerScheduler.started) {\r\n                    this.indexBackfillerScheduler.start();\r\n                }\r\n                else if (!isPrimary) {\r\n                    this.indexBackfillerScheduler.stop();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    createSharedClientState(cfg) {\r\n        const window = getWindow();\r\n        if (!WebStorageSharedClientState.isAvailable(window)) {\r\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\r\n        }\r\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\r\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\r\n    }\r\n}\r\n/**\r\n * Initializes and wires the components that are needed to interface with the\r\n * network.\r\n */\r\nclass OnlineComponentProvider {\r\n    async initialize(offlineComponentProvider, cfg) {\r\n        if (this.localStore) {\r\n            // OnlineComponentProvider may get initialized multiple times if\r\n            // multi-tab persistence is used.\r\n            return;\r\n        }\r\n        this.localStore = offlineComponentProvider.localStore;\r\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\r\n        this.datastore = this.createDatastore(cfg);\r\n        this.remoteStore = this.createRemoteStore(cfg);\r\n        this.eventManager = this.createEventManager(cfg);\r\n        this.syncEngine = this.createSyncEngine(cfg, \r\n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\r\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* OnlineStateSource.SharedClientState */);\r\n        this.remoteStore.remoteSyncer.handleCredentialChange =\r\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\r\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\r\n    }\r\n    createEventManager(cfg) {\r\n        return newEventManager();\r\n    }\r\n    createDatastore(cfg) {\r\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\r\n        const connection = newConnection(cfg.databaseInfo);\r\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\r\n    }\r\n    createRemoteStore(cfg) {\r\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* OnlineStateSource.RemoteStore */), newConnectivityMonitor());\r\n    }\r\n    createSyncEngine(cfg, startAsPrimary) {\r\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\r\n    }\r\n    async terminate() {\r\n        var _a;\r\n        await remoteStoreShutdown(this.remoteStore);\r\n        (_a = this.datastore) === null || _a === void 0 ? void 0 : _a.terminate();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * How many bytes to read each time when `ReadableStreamReader.read()` is\r\n * called. Only applicable for byte streams that we control (e.g. those backed\r\n * by an UInt8Array).\r\n */\r\nconst DEFAULT_BYTES_PER_READ = 10240;\r\n/**\r\n * Builds a `ByteStreamReader` from a UInt8Array.\r\n * @param source - The data source to use.\r\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\r\n *        will read.\r\n */\r\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\r\n    let readFrom = 0;\r\n    // The TypeScript definition for ReadableStreamReader changed. We use\r\n    // `any` here to allow this code to compile with different versions.\r\n    // See https://github.com/microsoft/TypeScript/issues/42970\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const reader = {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        async read() {\r\n            if (readFrom < source.byteLength) {\r\n                const result = {\r\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\r\n                    done: false\r\n                };\r\n                readFrom += bytesPerRead;\r\n                return result;\r\n            }\r\n            return { done: true };\r\n        },\r\n        async cancel() { },\r\n        releaseLock() { },\r\n        closed: Promise.resolve()\r\n    };\r\n    return reader;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\r\n    if (!argument) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that two boolean options are not set at the same time.\r\n * @internal\r\n */\r\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\r\n    if (argument1 === true && argument2 === true) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\r\n    }\r\n}\r\n/**\r\n * Validates that `path` refers to a document (indicated by the fact it contains\r\n * an even numbers of segments).\r\n */\r\nfunction validateDocumentPath(path) {\r\n    if (!DocumentKey.isDocumentKey(path)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that `path` refers to a collection (indicated by the fact it\r\n * contains an odd numbers of segments).\r\n */\r\nfunction validateCollectionPath(path) {\r\n    if (DocumentKey.isDocumentKey(path)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\r\n    }\r\n}\r\n/**\r\n * Returns true if it's a non-null object without a custom prototype\r\n * (i.e. excludes Array, Date, etc.).\r\n */\r\nfunction isPlainObject(input) {\r\n    return (typeof input === 'object' &&\r\n        input !== null &&\r\n        (Object.getPrototypeOf(input) === Object.prototype ||\r\n            Object.getPrototypeOf(input) === null));\r\n}\r\n/** Returns a string describing the type / value of the provided input. */\r\nfunction valueDescription(input) {\r\n    if (input === undefined) {\r\n        return 'undefined';\r\n    }\r\n    else if (input === null) {\r\n        return 'null';\r\n    }\r\n    else if (typeof input === 'string') {\r\n        if (input.length > 20) {\r\n            input = `${input.substring(0, 20)}...`;\r\n        }\r\n        return JSON.stringify(input);\r\n    }\r\n    else if (typeof input === 'number' || typeof input === 'boolean') {\r\n        return '' + input;\r\n    }\r\n    else if (typeof input === 'object') {\r\n        if (input instanceof Array) {\r\n            return 'an array';\r\n        }\r\n        else {\r\n            const customObjectName = tryGetCustomObjectType(input);\r\n            if (customObjectName) {\r\n                return `a custom ${customObjectName} object`;\r\n            }\r\n            else {\r\n                return 'an object';\r\n            }\r\n        }\r\n    }\r\n    else if (typeof input === 'function') {\r\n        return 'a function';\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** try to get the constructor name for an object. */\r\nfunction tryGetCustomObjectType(input) {\r\n    if (input.constructor) {\r\n        return input.constructor.name;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\r\n * underlying instance. Throws if  `obj` is not an instance of `T`.\r\n *\r\n * This cast is used in the Lite and Full SDK to verify instance types for\r\n * arguments passed to the public API.\r\n * @internal\r\n */\r\nfunction cast(obj, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconstructor) {\r\n    if ('_delegate' in obj) {\r\n        // Unwrap Compat types\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        obj = obj._delegate;\r\n    }\r\n    if (!(obj instanceof constructor)) {\r\n        if (constructor.name === obj.constructor.name) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\r\n                `reference from a different Firestore SDK?`);\r\n        }\r\n        else {\r\n            const description = valueDescription(obj);\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nfunction validatePositiveNumber(functionName, n) {\r\n    if (n <= 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * On Node, only supported data source is a `Uint8Array` for now.\r\n */\r\nfunction toByteStreamReader(source, bytesPerRead) {\r\n    if (!(source instanceof Uint8Array)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\r\n    }\r\n    return toByteStreamReaderHelper(source, bytesPerRead);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * A wrapper implementation of Observer<T> that will dispatch events\r\n * asynchronously. To allow immediate silencing, a mute call is added which\r\n * causes events scheduled to no longer be raised.\r\n */\r\nclass AsyncObserver {\r\n    constructor(observer) {\r\n        this.observer = observer;\r\n        /**\r\n         * When set to true, will not raise future events. Necessary to deal with\r\n         * async detachment of listener.\r\n         */\r\n        this.muted = false;\r\n    }\r\n    next(value) {\r\n        if (this.observer.next) {\r\n            this.scheduleEvent(this.observer.next, value);\r\n        }\r\n    }\r\n    error(error) {\r\n        if (this.observer.error) {\r\n            this.scheduleEvent(this.observer.error, error);\r\n        }\r\n        else {\r\n            logError('Uncaught Error in snapshot listener:', error.toString());\r\n        }\r\n    }\r\n    mute() {\r\n        this.muted = true;\r\n    }\r\n    scheduleEvent(eventHandler, event) {\r\n        if (!this.muted) {\r\n            setTimeout(() => {\r\n                if (!this.muted) {\r\n                    eventHandler(event);\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A complete element in the bundle stream, together with the byte length it\r\n * occupies in the stream.\r\n */\r\nclass SizedBundleElement {\r\n    constructor(payload, \r\n    // How many bytes this element takes to store in the bundle.\r\n    byteLength) {\r\n        this.payload = payload;\r\n        this.byteLength = byteLength;\r\n    }\r\n    isBundleMetadata() {\r\n        return 'metadata' in this.payload;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A class representing a bundle.\r\n *\r\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\r\n * elements out of the underlying content.\r\n */\r\nclass BundleReaderImpl {\r\n    constructor(\r\n    /** The reader to read from underlying binary bundle data source. */\r\n    reader, serializer) {\r\n        this.reader = reader;\r\n        this.serializer = serializer;\r\n        /** Cached bundle metadata. */\r\n        this.metadata = new Deferred();\r\n        /**\r\n         * Internal buffer to hold bundle content, accumulating incomplete element\r\n         * content.\r\n         */\r\n        this.buffer = new Uint8Array();\r\n        this.textDecoder = newTextDecoder();\r\n        // Read the metadata (which is the first element).\r\n        this.nextElementImpl().then(element => {\r\n            if (element && element.isBundleMetadata()) {\r\n                this.metadata.resolve(element.payload.metadata);\r\n            }\r\n            else {\r\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)}`));\r\n            }\r\n        }, error => this.metadata.reject(error));\r\n    }\r\n    close() {\r\n        return this.reader.cancel();\r\n    }\r\n    async getMetadata() {\r\n        return this.metadata.promise;\r\n    }\r\n    async nextElement() {\r\n        // Makes sure metadata is read before proceeding.\r\n        await this.getMetadata();\r\n        return this.nextElementImpl();\r\n    }\r\n    /**\r\n     * Reads from the head of internal buffer, and pulling more data from\r\n     * underlying stream if a complete element cannot be found, until an\r\n     * element(including the prefixed length and the JSON string) is found.\r\n     *\r\n     * Once a complete element is read, it is dropped from internal buffer.\r\n     *\r\n     * Returns either the bundled element, or null if we have reached the end of\r\n     * the stream.\r\n     */\r\n    async nextElementImpl() {\r\n        const lengthBuffer = await this.readLength();\r\n        if (lengthBuffer === null) {\r\n            return null;\r\n        }\r\n        const lengthString = this.textDecoder.decode(lengthBuffer);\r\n        const length = Number(lengthString);\r\n        if (isNaN(length)) {\r\n            this.raiseError(`length string (${lengthString}) is not valid number`);\r\n        }\r\n        const jsonString = await this.readJsonString(length);\r\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\r\n    }\r\n    /** First index of '{' from the underlying buffer. */\r\n    indexOfOpenBracket() {\r\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\r\n    }\r\n    /**\r\n     * Reads from the beginning of the internal buffer, until the first '{', and\r\n     * return the content.\r\n     *\r\n     * If reached end of the stream, returns a null.\r\n     */\r\n    async readLength() {\r\n        while (this.indexOfOpenBracket() < 0) {\r\n            const done = await this.pullMoreDataToBuffer();\r\n            if (done) {\r\n                break;\r\n            }\r\n        }\r\n        // Broke out of the loop because underlying stream is closed, and there\r\n        // happens to be no more data to process.\r\n        if (this.buffer.length === 0) {\r\n            return null;\r\n        }\r\n        const position = this.indexOfOpenBracket();\r\n        // Broke out of the loop because underlying stream is closed, but still\r\n        // cannot find an open bracket.\r\n        if (position < 0) {\r\n            this.raiseError('Reached the end of bundle when a length string is expected.');\r\n        }\r\n        const result = this.buffer.slice(0, position);\r\n        // Update the internal buffer to drop the read length.\r\n        this.buffer = this.buffer.slice(position);\r\n        return result;\r\n    }\r\n    /**\r\n     * Reads from a specified position from the internal buffer, for a specified\r\n     * number of bytes, pulling more data from the underlying stream if needed.\r\n     *\r\n     * Returns a string decoded from the read bytes.\r\n     */\r\n    async readJsonString(length) {\r\n        while (this.buffer.length < length) {\r\n            const done = await this.pullMoreDataToBuffer();\r\n            if (done) {\r\n                this.raiseError('Reached the end of bundle when more is expected.');\r\n            }\r\n        }\r\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\r\n        // Update the internal buffer to drop the read json string.\r\n        this.buffer = this.buffer.slice(length);\r\n        return result;\r\n    }\r\n    raiseError(message) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.reader.cancel();\r\n        throw new Error(`Invalid bundle format: ${message}`);\r\n    }\r\n    /**\r\n     * Pulls more data from underlying stream to internal buffer.\r\n     * Returns a boolean indicating whether the stream is finished.\r\n     */\r\n    async pullMoreDataToBuffer() {\r\n        const result = await this.reader.read();\r\n        if (!result.done) {\r\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\r\n            newBuffer.set(this.buffer);\r\n            newBuffer.set(result.value, this.buffer.length);\r\n            this.buffer = newBuffer;\r\n        }\r\n        return result.done;\r\n    }\r\n}\r\nfunction newBundleReader(reader, serializer) {\r\n    return new BundleReaderImpl(reader, serializer);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Internal transaction object responsible for accumulating the mutations to\r\n * perform and the base versions for any documents read.\r\n */\r\nclass Transaction$2 {\r\n    constructor(datastore) {\r\n        this.datastore = datastore;\r\n        // The version of each document that was read during this transaction.\r\n        this.readVersions = new Map();\r\n        this.mutations = [];\r\n        this.committed = false;\r\n        /**\r\n         * A deferred usage error that occurred previously in this transaction that\r\n         * will cause the transaction to fail once it actually commits.\r\n         */\r\n        this.lastTransactionError = null;\r\n        /**\r\n         * Set of documents that have been written in the transaction.\r\n         *\r\n         * When there's more than one write to the same key in a transaction, any\r\n         * writes after the first are handled differently.\r\n         */\r\n        this.writtenDocs = new Set();\r\n    }\r\n    async lookup(keys) {\r\n        this.ensureCommitNotCalled();\r\n        if (this.mutations.length > 0) {\r\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\r\n            throw this.lastTransactionError;\r\n        }\r\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\r\n        docs.forEach(doc => this.recordVersion(doc));\r\n        return docs;\r\n    }\r\n    set(key, data) {\r\n        this.write(data.toMutation(key, this.precondition(key)));\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    update(key, data) {\r\n        try {\r\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\r\n        }\r\n        catch (e) {\r\n            this.lastTransactionError = e;\r\n        }\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    delete(key) {\r\n        this.write(new DeleteMutation(key, this.precondition(key)));\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    async commit() {\r\n        this.ensureCommitNotCalled();\r\n        if (this.lastTransactionError) {\r\n            throw this.lastTransactionError;\r\n        }\r\n        const unwritten = this.readVersions;\r\n        // For each mutation, note that the doc was written.\r\n        this.mutations.forEach(mutation => {\r\n            unwritten.delete(mutation.key.toString());\r\n        });\r\n        // For each document that was read but not written to, we want to perform\r\n        // a `verify` operation.\r\n        unwritten.forEach((_, path) => {\r\n            const key = DocumentKey.fromPath(path);\r\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\r\n        });\r\n        await invokeCommitRpc(this.datastore, this.mutations);\r\n        this.committed = true;\r\n    }\r\n    recordVersion(doc) {\r\n        let docVersion;\r\n        if (doc.isFoundDocument()) {\r\n            docVersion = doc.version;\r\n        }\r\n        else if (doc.isNoDocument()) {\r\n            // Represent a deleted doc using SnapshotVersion.min().\r\n            docVersion = SnapshotVersion.min();\r\n        }\r\n        else {\r\n            throw fail();\r\n        }\r\n        const existingVersion = this.readVersions.get(doc.key.toString());\r\n        if (existingVersion) {\r\n            if (!docVersion.isEqual(existingVersion)) {\r\n                // This transaction will fail no matter what.\r\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\r\n            }\r\n        }\r\n        else {\r\n            this.readVersions.set(doc.key.toString(), docVersion);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the version of this document when it was read in this transaction,\r\n     * as a precondition, or no precondition if it was not read.\r\n     */\r\n    precondition(key) {\r\n        const version = this.readVersions.get(key.toString());\r\n        if (!this.writtenDocs.has(key.toString()) && version) {\r\n            if (version.isEqual(SnapshotVersion.min())) {\r\n                return Precondition.exists(false);\r\n            }\r\n            else {\r\n                return Precondition.updateTime(version);\r\n            }\r\n        }\r\n        else {\r\n            return Precondition.none();\r\n        }\r\n    }\r\n    /**\r\n     * Returns the precondition for a document if the operation is an update.\r\n     */\r\n    preconditionForUpdate(key) {\r\n        const version = this.readVersions.get(key.toString());\r\n        // The first time a document is written, we want to take into account the\r\n        // read time and existence\r\n        if (!this.writtenDocs.has(key.toString()) && version) {\r\n            if (version.isEqual(SnapshotVersion.min())) {\r\n                // The document doesn't exist, so fail the transaction.\r\n                // This has to be validated locally because you can't send a\r\n                // precondition that a document does not exist without changing the\r\n                // semantics of the backend write to be an insert. This is the reverse\r\n                // of what we want, since we want to assert that the document doesn't\r\n                // exist but then send the update and have it fail. Since we can't\r\n                // express that to the backend, we have to validate locally.\r\n                // Note: this can change once we can send separate verify writes in the\r\n                // transaction.\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\r\n            }\r\n            // Document exists, base precondition on document update time.\r\n            return Precondition.updateTime(version);\r\n        }\r\n        else {\r\n            // Document was not read, so we just use the preconditions for a blind\r\n            // update.\r\n            return Precondition.exists(true);\r\n        }\r\n    }\r\n    write(mutation) {\r\n        this.ensureCommitNotCalled();\r\n        this.mutations.push(mutation);\r\n    }\r\n    ensureCommitNotCalled() {\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * TransactionRunner encapsulates the logic needed to run and retry transactions\r\n * with backoff.\r\n */\r\nclass TransactionRunner {\r\n    constructor(asyncQueue, datastore, options, updateFunction, deferred) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.datastore = datastore;\r\n        this.options = options;\r\n        this.updateFunction = updateFunction;\r\n        this.deferred = deferred;\r\n        this.attemptsRemaining = options.maxAttempts;\r\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\r\n    }\r\n    /** Runs the transaction and sets the result on deferred. */\r\n    run() {\r\n        this.attemptsRemaining -= 1;\r\n        this.runWithBackOff();\r\n    }\r\n    runWithBackOff() {\r\n        this.backoff.backoffAndRun(async () => {\r\n            const transaction = new Transaction$2(this.datastore);\r\n            const userPromise = this.tryRunUpdateFunction(transaction);\r\n            if (userPromise) {\r\n                userPromise\r\n                    .then(result => {\r\n                    this.asyncQueue.enqueueAndForget(() => {\r\n                        return transaction\r\n                            .commit()\r\n                            .then(() => {\r\n                            this.deferred.resolve(result);\r\n                        })\r\n                            .catch(commitError => {\r\n                            this.handleTransactionError(commitError);\r\n                        });\r\n                    });\r\n                })\r\n                    .catch(userPromiseError => {\r\n                    this.handleTransactionError(userPromiseError);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    tryRunUpdateFunction(transaction) {\r\n        try {\r\n            const userPromise = this.updateFunction(transaction);\r\n            if (isNullOrUndefined(userPromise) ||\r\n                !userPromise.catch ||\r\n                !userPromise.then) {\r\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\r\n                return null;\r\n            }\r\n            return userPromise;\r\n        }\r\n        catch (error) {\r\n            // Do not retry errors thrown by user provided updateFunction.\r\n            this.deferred.reject(error);\r\n            return null;\r\n        }\r\n    }\r\n    handleTransactionError(error) {\r\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\r\n            this.attemptsRemaining -= 1;\r\n            this.asyncQueue.enqueueAndForget(() => {\r\n                this.runWithBackOff();\r\n                return Promise.resolve();\r\n            });\r\n        }\r\n        else {\r\n            this.deferred.reject(error);\r\n        }\r\n    }\r\n    isRetryableTransactionError(error) {\r\n        if (error.name === 'FirebaseError') {\r\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\r\n            // non-matching document versions with ABORTED. These errors should be retried.\r\n            const code = error.code;\r\n            return (code === 'aborted' ||\r\n                code === 'failed-precondition' ||\r\n                code === 'already-exists' ||\r\n                !isPermanentError(code));\r\n        }\r\n        return false;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$2 = 'FirestoreClient';\r\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\r\n/** DOMException error code constants. */\r\nconst DOM_EXCEPTION_INVALID_STATE = 11;\r\nconst DOM_EXCEPTION_ABORTED = 20;\r\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\r\n/**\r\n * FirestoreClient is a top-level class that constructs and owns all of the //\r\n * pieces of the client SDK architecture. It is responsible for creating the //\r\n * async queue that is shared by all of the other components in the system. //\r\n */\r\nclass FirestoreClient {\r\n    constructor(authCredentials, appCheckCredentials, \r\n    /**\r\n     * Asynchronous queue responsible for all of our internal processing. When\r\n     * we get incoming work from the user (via public API) or the network\r\n     * (incoming GRPC messages), we should always schedule onto this queue.\r\n     * This ensures all of our work is properly serialized (e.g. we don't\r\n     * start processing a new operation while the previous one is waiting for\r\n     * an async I/O to complete).\r\n     */\r\n    asyncQueue, databaseInfo) {\r\n        this.authCredentials = authCredentials;\r\n        this.appCheckCredentials = appCheckCredentials;\r\n        this.asyncQueue = asyncQueue;\r\n        this.databaseInfo = databaseInfo;\r\n        this.user = User.UNAUTHENTICATED;\r\n        this.clientId = AutoId.newId();\r\n        this.authCredentialListener = () => Promise.resolve();\r\n        this.appCheckCredentialListener = () => Promise.resolve();\r\n        this.authCredentials.start(asyncQueue, async (user) => {\r\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\r\n            await this.authCredentialListener(user);\r\n            this.user = user;\r\n        });\r\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\r\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\r\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\r\n        });\r\n    }\r\n    get configuration() {\r\n        return {\r\n            asyncQueue: this.asyncQueue,\r\n            databaseInfo: this.databaseInfo,\r\n            clientId: this.clientId,\r\n            authCredentials: this.authCredentials,\r\n            appCheckCredentials: this.appCheckCredentials,\r\n            initialUser: this.user,\r\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\r\n        };\r\n    }\r\n    setCredentialChangeListener(listener) {\r\n        this.authCredentialListener = listener;\r\n    }\r\n    setAppCheckTokenChangeListener(listener) {\r\n        this.appCheckCredentialListener = listener;\r\n    }\r\n    /**\r\n     * Checks that the client has not been terminated. Ensures that other methods on //\r\n     * this class cannot be called after the client is terminated. //\r\n     */\r\n    verifyNotTerminated() {\r\n        if (this.asyncQueue.isShuttingDown) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\r\n        }\r\n    }\r\n    terminate() {\r\n        this.asyncQueue.enterRestrictedMode();\r\n        const deferred = new Deferred();\r\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\r\n            try {\r\n                if (this._onlineComponents) {\r\n                    await this._onlineComponents.terminate();\r\n                }\r\n                if (this._offlineComponents) {\r\n                    await this._offlineComponents.terminate();\r\n                }\r\n                // The credentials provider must be terminated after shutting down the\r\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\r\n                // tokens.\r\n                this.authCredentials.shutdown();\r\n                this.appCheckCredentials.shutdown();\r\n                deferred.resolve();\r\n            }\r\n            catch (e) {\r\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\r\n                deferred.reject(firestoreError);\r\n            }\r\n        });\r\n        return deferred.promise;\r\n    }\r\n}\r\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\r\n    client.asyncQueue.verifyOperationInProgress();\r\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\r\n    const configuration = client.configuration;\r\n    await offlineComponentProvider.initialize(configuration);\r\n    let currentUser = configuration.initialUser;\r\n    client.setCredentialChangeListener(async (user) => {\r\n        if (!currentUser.isEqual(user)) {\r\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\r\n            currentUser = user;\r\n        }\r\n    });\r\n    // When a user calls clearPersistence() in one client, all other clients\r\n    // need to be terminated to allow the delete to succeed.\r\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\r\n    client._offlineComponents = offlineComponentProvider;\r\n}\r\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\r\n    client.asyncQueue.verifyOperationInProgress();\r\n    const offlineComponentProvider = await ensureOfflineComponents(client);\r\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\r\n    await onlineComponentProvider.initialize(offlineComponentProvider, client.configuration);\r\n    // The CredentialChangeListener of the online component provider takes\r\n    // precedence over the offline component provider.\r\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\r\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\r\n    client._onlineComponents = onlineComponentProvider;\r\n}\r\n/**\r\n * Decides whether the provided error allows us to gracefully disable\r\n * persistence (as opposed to crashing the client).\r\n */\r\nfunction canFallbackFromIndexedDbError(error) {\r\n    if (error.name === 'FirebaseError') {\r\n        return (error.code === Code.FAILED_PRECONDITION ||\r\n            error.code === Code.UNIMPLEMENTED);\r\n    }\r\n    else if (typeof DOMException !== 'undefined' &&\r\n        error instanceof DOMException) {\r\n        // There are a few known circumstances where we can open IndexedDb but\r\n        // trying to read/write will fail (e.g. quota exceeded). For\r\n        // well-understood cases, we attempt to detect these and then gracefully\r\n        // fall back to memory persistence.\r\n        // NOTE: Rather than continue to add to this list, we could decide to\r\n        // always fall back, with the risk that we might accidentally hide errors\r\n        // representing actual SDK bugs.\r\n        return (\r\n        // When the browser is out of quota we could get either quota exceeded\r\n        // or an aborted error depending on whether the error happened during\r\n        // schema migration.\r\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\r\n            error.code === DOM_EXCEPTION_ABORTED ||\r\n            // Firefox Private Browsing mode disables IndexedDb and returns\r\n            // INVALID_STATE for any usage.\r\n            error.code === DOM_EXCEPTION_INVALID_STATE);\r\n    }\r\n    return true;\r\n}\r\nasync function ensureOfflineComponents(client) {\r\n    if (!client._offlineComponents) {\r\n        if (client._uninitializedComponentsProvider) {\r\n            logDebug(LOG_TAG$2, 'Using user provided OfflineComponentProvider');\r\n            try {\r\n                await setOfflineComponentProvider(client, client._uninitializedComponentsProvider._offline);\r\n            }\r\n            catch (e) {\r\n                const error = e;\r\n                if (!canFallbackFromIndexedDbError(error)) {\r\n                    throw error;\r\n                }\r\n                logWarn('Error using user provided cache. Falling back to ' +\r\n                    'memory cache: ' +\r\n                    error);\r\n                await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\r\n            }\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\r\n            await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\r\n        }\r\n    }\r\n    return client._offlineComponents;\r\n}\r\nasync function ensureOnlineComponents(client) {\r\n    if (!client._onlineComponents) {\r\n        if (client._uninitializedComponentsProvider) {\r\n            logDebug(LOG_TAG$2, 'Using user provided OnlineComponentProvider');\r\n            await setOnlineComponentProvider(client, client._uninitializedComponentsProvider._online);\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\r\n            await setOnlineComponentProvider(client, new OnlineComponentProvider());\r\n        }\r\n    }\r\n    return client._onlineComponents;\r\n}\r\nfunction getPersistence(client) {\r\n    return ensureOfflineComponents(client).then(c => c.persistence);\r\n}\r\nfunction getLocalStore(client) {\r\n    return ensureOfflineComponents(client).then(c => c.localStore);\r\n}\r\nfunction getRemoteStore(client) {\r\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\r\n}\r\nfunction getSyncEngine(client) {\r\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\r\n}\r\nfunction getDatastore(client) {\r\n    return ensureOnlineComponents(client).then(c => c.datastore);\r\n}\r\nasync function getEventManager(client) {\r\n    const onlineComponentProvider = await ensureOnlineComponents(client);\r\n    const eventManager = onlineComponentProvider.eventManager;\r\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onFirstRemoteStoreListen = triggerRemoteStoreListen.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onLastRemoteStoreUnlisten = triggerRemoteStoreUnlisten.bind(null, onlineComponentProvider.syncEngine);\r\n    return eventManager;\r\n}\r\n/** Enables the network connection and re-enqueues all pending operations. */\r\nfunction firestoreClientEnableNetwork(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        const persistence = await getPersistence(client);\r\n        const remoteStore = await getRemoteStore(client);\r\n        persistence.setNetworkEnabled(true);\r\n        return remoteStoreEnableNetwork(remoteStore);\r\n    });\r\n}\r\n/** Disables the network connection. Pending operations will not complete. */\r\nfunction firestoreClientDisableNetwork(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        const persistence = await getPersistence(client);\r\n        const remoteStore = await getRemoteStore(client);\r\n        persistence.setNetworkEnabled(false);\r\n        return remoteStoreDisableNetwork(remoteStore);\r\n    });\r\n}\r\n/**\r\n * Returns a Promise that resolves when all writes that were pending at the time\r\n * this method was called received server acknowledgement. An acknowledgement\r\n * can be either acceptance or rejection.\r\n */\r\nfunction firestoreClientWaitForPendingWrites(client) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const syncEngine = await getSyncEngine(client);\r\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientListen(client, query, options, observer) {\r\n    const wrappedObserver = new AsyncObserver(observer);\r\n    const listener = new QueryListener(query, wrappedObserver, options);\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return eventManagerListen(eventManager, listener);\r\n    });\r\n    return () => {\r\n        wrappedObserver.mute();\r\n        client.asyncQueue.enqueueAndForget(async () => {\r\n            const eventManager = await getEventManager(client);\r\n            return eventManagerUnlisten(eventManager, listener);\r\n        });\r\n    };\r\n}\r\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const localStore = await getLocalStore(client);\r\n        return readDocumentFromCache(localStore, docKey, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const localStore = await getLocalStore(client);\r\n        return executeQueryFromCache(localStore, query, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientRunAggregateQuery(client, query, aggregates) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        // Implement and call executeAggregateQueryViaSnapshotListener, similar\r\n        // to the implementation in firestoreClientGetDocumentsViaSnapshotListener\r\n        // above\r\n        try {\r\n            // TODO(b/277628384): check `canUseNetwork()` and handle multi-tab.\r\n            const datastore = await getDatastore(client);\r\n            deferred.resolve(invokeRunAggregationQueryRpc(datastore, query, aggregates));\r\n        }\r\n        catch (e) {\r\n            deferred.reject(e);\r\n        }\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientWrite(client, mutations) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const syncEngine = await getSyncEngine(client);\r\n        return syncEngineWrite(syncEngine, mutations, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\r\n    const wrappedObserver = new AsyncObserver(observer);\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\r\n    });\r\n    return () => {\r\n        wrappedObserver.mute();\r\n        client.asyncQueue.enqueueAndForget(async () => {\r\n            const eventManager = await getEventManager(client);\r\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\r\n        });\r\n    };\r\n}\r\n/**\r\n * Takes an updateFunction in which a set of reads and writes can be performed\r\n * atomically. In the updateFunction, the client can read and write values\r\n * using the supplied transaction object. After the updateFunction, all\r\n * changes will be committed. If a retryable error occurs (ex: some other\r\n * client has changed any of the data referenced), then the updateFunction\r\n * will be called again after a backoff. If the updateFunction still fails\r\n * after all retries, then the transaction will be rejected.\r\n *\r\n * The transaction object passed to the updateFunction contains methods for\r\n * accessing documents and collections. Unlike other datastore access, data\r\n * accessed with the transaction will not reflect local changes that have not\r\n * been committed. For this reason, it is required that all reads are\r\n * performed before any writes. Transactions must be performed while online.\r\n */\r\nfunction firestoreClientTransaction(client, updateFunction, options) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const datastore = await getDatastore(client);\r\n        new TransactionRunner(client.asyncQueue, datastore, options, updateFunction, deferred).run();\r\n    });\r\n    return deferred.promise;\r\n}\r\nasync function readDocumentFromCache(localStore, docKey, result) {\r\n    try {\r\n        const document = await localStoreReadDocument(localStore, docKey);\r\n        if (document.isFoundDocument()) {\r\n            result.resolve(document);\r\n        }\r\n        else if (document.isNoDocument()) {\r\n            result.resolve(null);\r\n        }\r\n        else {\r\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\r\n                \"exist on the server. Run again without setting 'source' in \" +\r\n                'the GetOptions to attempt to retrieve the document from the ' +\r\n                'server.)'));\r\n        }\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\r\n        result.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Retrieves a latency-compensated document from the backend via a\r\n * SnapshotListener.\r\n */\r\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\r\n    const wrappedObserver = new AsyncObserver({\r\n        next: (snap) => {\r\n            // Remove query first before passing event to user to avoid\r\n            // user actions affecting the now stale query.\r\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\r\n            const exists = snap.docs.has(key);\r\n            if (!exists && snap.fromCache) {\r\n                // TODO(dimond): If we're online and the document doesn't\r\n                // exist then we resolve with a doc.exists set to false. If\r\n                // we're offline however, we reject the Promise in this\r\n                // case. Two options: 1) Cache the negative response from\r\n                // the server so we can deliver that even when you're\r\n                // offline 2) Actually reject the Promise in the online case\r\n                // if the document doesn't exist.\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\r\n            }\r\n            else if (exists &&\r\n                snap.fromCache &&\r\n                options &&\r\n                options.source === 'server') {\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\r\n                    'document does exist in the local cache. Run again ' +\r\n                    'without setting source to \"server\" to ' +\r\n                    'retrieve the cached document.)'));\r\n            }\r\n            else {\r\n                result.resolve(snap);\r\n            }\r\n        },\r\n        error: e => result.reject(e)\r\n    });\r\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\r\n        includeMetadataChanges: true,\r\n        waitForSyncWhenOnline: true\r\n    });\r\n    return eventManagerListen(eventManager, listener);\r\n}\r\nasync function executeQueryFromCache(localStore, query, result) {\r\n    try {\r\n        const queryResult = await localStoreExecuteQuery(localStore, query, \r\n        /* usePreviousResults= */ true);\r\n        const view = new View(query, queryResult.remoteKeys);\r\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\r\n        const viewChange = view.applyChanges(viewDocChanges, \r\n        /* limboResolutionEnabled= */ false);\r\n        result.resolve(viewChange.snapshot);\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\r\n        result.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Retrieves a latency-compensated query snapshot from the backend via a\r\n * SnapshotListener.\r\n */\r\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\r\n    const wrappedObserver = new AsyncObserver({\r\n        next: snapshot => {\r\n            // Remove query first before passing event to user to avoid\r\n            // user actions affecting the now stale query.\r\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\r\n            if (snapshot.fromCache && options.source === 'server') {\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\r\n                    'documents may exist in the local cache. Run again ' +\r\n                    'without setting source to \"server\" to ' +\r\n                    'retrieve the cached documents.)'));\r\n            }\r\n            else {\r\n                result.resolve(snapshot);\r\n            }\r\n        },\r\n        error: e => result.reject(e)\r\n    });\r\n    const listener = new QueryListener(query, wrappedObserver, {\r\n        includeMetadataChanges: true,\r\n        waitForSyncWhenOnline: true\r\n    });\r\n    return eventManagerListen(eventManager, listener);\r\n}\r\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\r\n    const reader = createBundleReader(data, newSerializer(databaseId));\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\r\n    });\r\n}\r\nfunction firestoreClientGetNamedQuery(client, queryName) {\r\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\r\n}\r\nfunction createBundleReader(data, serializer) {\r\n    let content;\r\n    if (typeof data === 'string') {\r\n        content = newTextEncoder().encode(data);\r\n    }\r\n    else {\r\n        content = data;\r\n    }\r\n    return newBundleReader(toByteStreamReader(content), serializer);\r\n}\r\nfunction firestoreClientSetIndexConfiguration(client, indexes) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        return localStoreConfigureFieldIndexes(await getLocalStore(client), indexes);\r\n    });\r\n}\r\nfunction firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        return localStoreSetIndexAutoCreationEnabled(await getLocalStore(client), isEnabled);\r\n    });\r\n}\r\nfunction firestoreClientDeleteAllFieldIndexes(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        return localStoreDeleteAllFieldIndexes(await getLocalStore(client));\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\r\n */\r\nfunction longPollingOptionsEqual(options1, options2) {\r\n    return options1.timeoutSeconds === options2.timeoutSeconds;\r\n}\r\n/**\r\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\r\n * option values as the given instance.\r\n */\r\nfunction cloneLongPollingOptions(options) {\r\n    const clone = {};\r\n    if (options.timeoutSeconds !== undefined) {\r\n        clone.timeoutSeconds = options.timeoutSeconds;\r\n    }\r\n    return clone;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$1 = 'ComponentProvider';\r\n/**\r\n * An instance map that ensures only one Datastore exists per Firestore\r\n * instance.\r\n */\r\nconst datastoreInstances = new Map();\r\n/**\r\n * Removes all components associated with the provided instance. Must be called\r\n * when the `Firestore` instance is terminated.\r\n */\r\nfunction removeComponents(firestore) {\r\n    const datastore = datastoreInstances.get(firestore);\r\n    if (datastore) {\r\n        logDebug(LOG_TAG$1, 'Removing Datastore');\r\n        datastoreInstances.delete(firestore);\r\n        datastore.terminate();\r\n    }\r\n}\r\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\r\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// settings() defaults:\r\nconst DEFAULT_HOST = 'firestore.googleapis.com';\r\nconst DEFAULT_SSL = true;\r\n// The minimum long-polling timeout is hardcoded on the server. The value here\r\n// should be kept in sync with the value used by the server, as the server will\r\n// silently ignore a value below the minimum and fall back to the default.\r\n// Googlers see b/266868871 for relevant discussion.\r\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\r\n// No maximum long-polling timeout is configured in the server, and defaults to\r\n// 30 seconds, which is what Watch appears to use.\r\n// Googlers see b/266868871 for relevant discussion.\r\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\r\n// Whether long-polling auto-detected is enabled by default.\r\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\r\n/**\r\n * A concrete type describing all the values that can be applied via a\r\n * user-supplied `FirestoreSettings` object. This is a separate type so that\r\n * defaults can be supplied and the value can be checked for equality.\r\n */\r\nclass FirestoreSettingsImpl {\r\n    constructor(settings) {\r\n        var _a, _b;\r\n        if (settings.host === undefined) {\r\n            if (settings.ssl !== undefined) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\r\n            }\r\n            this.host = DEFAULT_HOST;\r\n            this.ssl = DEFAULT_SSL;\r\n        }\r\n        else {\r\n            this.host = settings.host;\r\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\r\n        }\r\n        this.credentials = settings.credentials;\r\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\r\n        this.localCache = settings.localCache;\r\n        if (settings.cacheSizeBytes === undefined) {\r\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\r\n        }\r\n        else {\r\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\r\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\r\n            }\r\n            else {\r\n                this.cacheSizeBytes = settings.cacheSizeBytes;\r\n            }\r\n        }\r\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\r\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\r\n        if (this.experimentalForceLongPolling) {\r\n            this.experimentalAutoDetectLongPolling = false;\r\n        }\r\n        else if (settings.experimentalAutoDetectLongPolling === undefined) {\r\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\r\n        }\r\n        else {\r\n            // For backwards compatibility, coerce the value to boolean even though\r\n            // the TypeScript compiler has narrowed the type to boolean already.\r\n            // noinspection PointlessBooleanExpressionJS\r\n            this.experimentalAutoDetectLongPolling =\r\n                !!settings.experimentalAutoDetectLongPolling;\r\n        }\r\n        this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});\r\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\r\n        this.useFetchStreams = !!settings.useFetchStreams;\r\n    }\r\n    isEqual(other) {\r\n        return (this.host === other.host &&\r\n            this.ssl === other.ssl &&\r\n            this.credentials === other.credentials &&\r\n            this.cacheSizeBytes === other.cacheSizeBytes &&\r\n            this.experimentalForceLongPolling ===\r\n                other.experimentalForceLongPolling &&\r\n            this.experimentalAutoDetectLongPolling ===\r\n                other.experimentalAutoDetectLongPolling &&\r\n            longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) &&\r\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\r\n            this.useFetchStreams === other.useFetchStreams);\r\n    }\r\n}\r\nfunction validateLongPollingOptions(options) {\r\n    if (options.timeoutSeconds !== undefined) {\r\n        if (isNaN(options.timeoutSeconds)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` +\r\n                `${options.timeoutSeconds} (must not be NaN)`);\r\n        }\r\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\r\n                `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\r\n        }\r\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\r\n                `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\r\n */\r\nclass Firestore$1 {\r\n    /** @hideconstructor */\r\n    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {\r\n        this._authCredentials = _authCredentials;\r\n        this._appCheckCredentials = _appCheckCredentials;\r\n        this._databaseId = _databaseId;\r\n        this._app = _app;\r\n        /**\r\n         * Whether it's a Firestore or Firestore Lite instance.\r\n         */\r\n        this.type = 'firestore-lite';\r\n        this._persistenceKey = '(lite)';\r\n        this._settings = new FirestoreSettingsImpl({});\r\n        this._settingsFrozen = false;\r\n    }\r\n    /**\r\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\r\n     * instance.\r\n     */\r\n    get app() {\r\n        if (!this._app) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\r\n                'not available');\r\n        }\r\n        return this._app;\r\n    }\r\n    get _initialized() {\r\n        return this._settingsFrozen;\r\n    }\r\n    get _terminated() {\r\n        return this._terminateTask !== undefined;\r\n    }\r\n    _setSettings(settings) {\r\n        if (this._settingsFrozen) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\r\n                'be changed. You can only modify settings before calling any other ' +\r\n                'methods on a Firestore object.');\r\n        }\r\n        this._settings = new FirestoreSettingsImpl(settings);\r\n        if (settings.credentials !== undefined) {\r\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\r\n        }\r\n    }\r\n    _getSettings() {\r\n        return this._settings;\r\n    }\r\n    _freezeSettings() {\r\n        this._settingsFrozen = true;\r\n        return this._settings;\r\n    }\r\n    _delete() {\r\n        if (!this._terminateTask) {\r\n            this._terminateTask = this._terminate();\r\n        }\r\n        return this._terminateTask;\r\n    }\r\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\r\n    toJSON() {\r\n        return {\r\n            app: this._app,\r\n            databaseId: this._databaseId,\r\n            settings: this._settings\r\n        };\r\n    }\r\n    /**\r\n     * Terminates all components used by this client. Subclasses can override\r\n     * this method to clean up their own dependencies, but must also call this\r\n     * method.\r\n     *\r\n     * Only ever called once.\r\n     */\r\n    _terminate() {\r\n        removeComponents(this);\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Firestore emulator.\r\n *\r\n * Note: This must be called before this instance has been used to do any\r\n * operations.\r\n *\r\n * @param firestore - The `Firestore` instance to configure to connect to the\r\n * emulator.\r\n * @param host - the emulator host (ex: localhost).\r\n * @param port - the emulator port (ex: 9000).\r\n * @param options.mockUserToken - the mock auth token to use for unit testing\r\n * Security Rules.\r\n */\r\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore$1);\r\n    const settings = firestore._getSettings();\r\n    const newHostSetting = `${host}:${port}`;\r\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\r\n        logWarn('Host has been set in both settings() and connectFirestoreEmulator(), emulator host ' +\r\n            'will be used.');\r\n    }\r\n    firestore._setSettings(Object.assign(Object.assign({}, settings), { host: newHostSetting, ssl: false }));\r\n    if (options.mockUserToken) {\r\n        let token;\r\n        let user;\r\n        if (typeof options.mockUserToken === 'string') {\r\n            token = options.mockUserToken;\r\n            user = User.MOCK_USER;\r\n        }\r\n        else {\r\n            // Let createMockUserToken validate first (catches common mistakes like\r\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\r\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\r\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\r\n            if (!uid) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n            }\r\n            user = new User(uid);\r\n        }\r\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `Query` refers to a query which you can read or listen to. You can also\r\n * construct refined `Query` objects by adding filters and ordering.\r\n */\r\nclass Query {\r\n    // This is the lite version of the Query class in the main SDK.\r\n    /** @hideconstructor protected */\r\n    constructor(firestore, \r\n    /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */\r\n    converter, _query) {\r\n        this.converter = converter;\r\n        this._query = _query;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'query';\r\n        this.firestore = firestore;\r\n    }\r\n    withConverter(converter) {\r\n        return new Query(this.firestore, converter, this._query);\r\n    }\r\n}\r\n/**\r\n * A `DocumentReference` refers to a document location in a Firestore database\r\n * and can be used to write, read, or listen to the location. The document at\r\n * the referenced location may or may not exist.\r\n */\r\nclass DocumentReference {\r\n    /** @hideconstructor */\r\n    constructor(firestore, \r\n    /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */\r\n    converter, _key) {\r\n        this.converter = converter;\r\n        this._key = _key;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'document';\r\n        this.firestore = firestore;\r\n    }\r\n    get _path() {\r\n        return this._key.path;\r\n    }\r\n    /**\r\n     * The document's identifier within its collection.\r\n     */\r\n    get id() {\r\n        return this._key.path.lastSegment();\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced document (relative\r\n     * to the root of the database).\r\n     */\r\n    get path() {\r\n        return this._key.path.canonicalString();\r\n    }\r\n    /**\r\n     * The collection this `DocumentReference` belongs to.\r\n     */\r\n    get parent() {\r\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\r\n    }\r\n    withConverter(converter) {\r\n        return new DocumentReference(this.firestore, converter, this._key);\r\n    }\r\n}\r\n/**\r\n * A `CollectionReference` object can be used for adding documents, getting\r\n * document references, and querying for documents (using {@link (query:1)}).\r\n */\r\nclass CollectionReference extends Query {\r\n    /** @hideconstructor */\r\n    constructor(firestore, converter, _path) {\r\n        super(firestore, converter, newQueryForPath(_path));\r\n        this._path = _path;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'collection';\r\n    }\r\n    /** The collection's identifier. */\r\n    get id() {\r\n        return this._query.path.lastSegment();\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced collection (relative\r\n     * to the root of the database).\r\n     */\r\n    get path() {\r\n        return this._query.path.canonicalString();\r\n    }\r\n    /**\r\n     * A reference to the containing `DocumentReference` if this is a\r\n     * subcollection. If this isn't a subcollection, the reference is null.\r\n     */\r\n    get parent() {\r\n        const parentPath = this._path.popLast();\r\n        if (parentPath.isEmpty()) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new DocumentReference(this.firestore, \r\n            /* converter= */ null, new DocumentKey(parentPath));\r\n        }\r\n    }\r\n    withConverter(converter) {\r\n        return new CollectionReference(this.firestore, converter, this._path);\r\n    }\r\n}\r\nfunction collection(parent, path, ...pathSegments) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\r\n    validateNonEmptyArgument('collection', 'path', path);\r\n    if (parent instanceof Firestore$1) {\r\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\r\n        validateCollectionPath(absolutePath);\r\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\r\n    }\r\n    else {\r\n        if (!(parent instanceof DocumentReference) &&\r\n            !(parent instanceof CollectionReference)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\r\n                'a DocumentReference or FirebaseFirestore');\r\n        }\r\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\r\n        validateCollectionPath(absolutePath);\r\n        return new CollectionReference(parent.firestore, \r\n        /* converter= */ null, absolutePath);\r\n    }\r\n}\r\n// TODO(firestorelite): Consider using ErrorFactory -\r\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\r\n/**\r\n * Creates and returns a new `Query` instance that includes all documents in the\r\n * database that are contained in a collection or subcollection with the\r\n * given `collectionId`.\r\n *\r\n * @param firestore - A reference to the root `Firestore` instance.\r\n * @param collectionId - Identifies the collections to query over. Every\r\n * collection or subcollection with this ID as the last segment of its path\r\n * will be included. Cannot contain a slash.\r\n * @returns The created `Query`.\r\n */\r\nfunction collectionGroup(firestore, collectionId) {\r\n    firestore = cast(firestore, Firestore$1);\r\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\r\n    if (collectionId.indexOf('/') >= 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\r\n            `collectionGroup(). Collection IDs must not contain '/'.`);\r\n    }\r\n    return new Query(firestore, \r\n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\r\n}\r\nfunction doc(parent, path, ...pathSegments) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\r\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\r\n    // 'undefined' and 'null'.\r\n    if (arguments.length === 1) {\r\n        path = AutoId.newId();\r\n    }\r\n    validateNonEmptyArgument('doc', 'path', path);\r\n    if (parent instanceof Firestore$1) {\r\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\r\n        validateDocumentPath(absolutePath);\r\n        return new DocumentReference(parent, \r\n        /* converter= */ null, new DocumentKey(absolutePath));\r\n    }\r\n    else {\r\n        if (!(parent instanceof DocumentReference) &&\r\n            !(parent instanceof CollectionReference)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\r\n                'a DocumentReference or FirebaseFirestore');\r\n        }\r\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\r\n        validateDocumentPath(absolutePath);\r\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\r\n    }\r\n}\r\n/**\r\n * Returns true if the provided references are equal.\r\n *\r\n * @param left - A reference to compare.\r\n * @param right - A reference to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */\r\nfunction refEqual(left, right) {\r\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\r\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\r\n    if ((left instanceof DocumentReference ||\r\n        left instanceof CollectionReference) &&\r\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\r\n        return (left.firestore === right.firestore &&\r\n            left.path === right.path &&\r\n            left.converter === right.converter);\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns true if the provided queries point to the same collection and apply\r\n * the same constraints.\r\n *\r\n * @param left - A `Query` to compare.\r\n * @param right - A `Query` to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */\r\nfunction queryEqual(left, right) {\r\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\r\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\r\n    if (left instanceof Query && right instanceof Query) {\r\n        return (left.firestore === right.firestore &&\r\n            queryEquals(left._query, right._query) &&\r\n            left.converter === right.converter);\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG = 'AsyncQueue';\r\nclass AsyncQueueImpl {\r\n    constructor() {\r\n        // The last promise in the queue.\r\n        this.tail = Promise.resolve();\r\n        // A list of retryable operations. Retryable operations are run in order and\r\n        // retried with backoff.\r\n        this.retryableOps = [];\r\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\r\n        // be changed again.\r\n        this._isShuttingDown = false;\r\n        // Operations scheduled to be queued in the future. Operations are\r\n        // automatically removed after they are run or canceled.\r\n        this.delayedOperations = [];\r\n        // visible for testing\r\n        this.failure = null;\r\n        // Flag set while there's an outstanding AsyncQueue operation, used for\r\n        // assertion sanity-checks.\r\n        this.operationInProgress = false;\r\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\r\n        this.skipNonRestrictedTasks = false;\r\n        // List of TimerIds to fast-forward delays for.\r\n        this.timerIdsToSkip = [];\r\n        // Backoff timer used to schedule retries for retryable operations\r\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */);\r\n        // Visibility handler that triggers an immediate retry of all retryable\r\n        // operations. Meant to speed up recovery when we regain file system access\r\n        // after page comes into foreground.\r\n        this.visibilityHandler = () => {\r\n            this.backoff.skipBackoff();\r\n        };\r\n    }\r\n    get isShuttingDown() {\r\n        return this._isShuttingDown;\r\n    }\r\n    /**\r\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\r\n     * we ignore the Promise result).\r\n     */\r\n    enqueueAndForget(op) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.enqueue(op);\r\n    }\r\n    enqueueAndForgetEvenWhileRestricted(op) {\r\n        this.verifyNotFailed();\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.enqueueInternal(op);\r\n    }\r\n    enterRestrictedMode(purgeExistingTasks) {\r\n        if (!this._isShuttingDown) {\r\n            this._isShuttingDown = true;\r\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\r\n        }\r\n    }\r\n    enqueue(op) {\r\n        this.verifyNotFailed();\r\n        if (this._isShuttingDown) {\r\n            // Return a Promise which never resolves.\r\n            return new Promise(() => { });\r\n        }\r\n        // Create a deferred Promise that we can return to the callee. This\r\n        // allows us to return a \"hanging Promise\" only to the callee and still\r\n        // advance the queue even when the operation is not run.\r\n        const task = new Deferred();\r\n        return this.enqueueInternal(() => {\r\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\r\n                // We do not resolve 'task'\r\n                return Promise.resolve();\r\n            }\r\n            op().then(task.resolve, task.reject);\r\n            return task.promise;\r\n        }).then(() => task.promise);\r\n    }\r\n    enqueueRetryable(op) {\r\n        this.enqueueAndForget(() => {\r\n            this.retryableOps.push(op);\r\n            return this.retryNextOp();\r\n        });\r\n    }\r\n    /**\r\n     * Runs the next operation from the retryable queue. If the operation fails,\r\n     * reschedules with backoff.\r\n     */\r\n    async retryNextOp() {\r\n        if (this.retryableOps.length === 0) {\r\n            return;\r\n        }\r\n        try {\r\n            await this.retryableOps[0]();\r\n            this.retryableOps.shift();\r\n            this.backoff.reset();\r\n        }\r\n        catch (e) {\r\n            if (isIndexedDbTransactionError(e)) {\r\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\r\n            }\r\n            else {\r\n                throw e; // Failure will be handled by AsyncQueue\r\n            }\r\n        }\r\n        if (this.retryableOps.length > 0) {\r\n            // If there are additional operations, we re-schedule `retryNextOp()`.\r\n            // This is necessary to run retryable operations that failed during\r\n            // their initial attempt since we don't know whether they are already\r\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\r\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\r\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\r\n            // call scheduled here.\r\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\r\n            // new backoff on every call, there is only ever a single additional\r\n            // operation in the queue.\r\n            this.backoff.backoffAndRun(() => this.retryNextOp());\r\n        }\r\n    }\r\n    enqueueInternal(op) {\r\n        const newTail = this.tail.then(() => {\r\n            this.operationInProgress = true;\r\n            return op()\r\n                .catch((error) => {\r\n                this.failure = error;\r\n                this.operationInProgress = false;\r\n                const message = getMessageOrStack(error);\r\n                logError('INTERNAL UNHANDLED ERROR: ', message);\r\n                // Re-throw the error so that this.tail becomes a rejected Promise and\r\n                // all further attempts to chain (via .then) will just short-circuit\r\n                // and return the rejected Promise.\r\n                throw error;\r\n            })\r\n                .then(result => {\r\n                this.operationInProgress = false;\r\n                return result;\r\n            });\r\n        });\r\n        this.tail = newTail;\r\n        return newTail;\r\n    }\r\n    enqueueAfterDelay(timerId, delayMs, op) {\r\n        this.verifyNotFailed();\r\n        // Fast-forward delays for timerIds that have been overriden.\r\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\r\n            delayMs = 0;\r\n        }\r\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\r\n        this.delayedOperations.push(delayedOp);\r\n        return delayedOp;\r\n    }\r\n    verifyNotFailed() {\r\n        if (this.failure) {\r\n            fail();\r\n        }\r\n    }\r\n    verifyOperationInProgress() {\r\n    }\r\n    /**\r\n     * Waits until all currently queued tasks are finished executing. Delayed\r\n     * operations are not run.\r\n     */\r\n    async drain() {\r\n        // Operations in the queue prior to draining may have enqueued additional\r\n        // operations. Keep draining the queue until the tail is no longer advanced,\r\n        // which indicates that no more new operations were enqueued and that all\r\n        // operations were executed.\r\n        let currentTail;\r\n        do {\r\n            currentTail = this.tail;\r\n            await currentTail;\r\n        } while (currentTail !== this.tail);\r\n    }\r\n    /**\r\n     * For Tests: Determine if a delayed operation with a particular TimerId\r\n     * exists.\r\n     */\r\n    containsDelayedOperation(timerId) {\r\n        for (const op of this.delayedOperations) {\r\n            if (op.timerId === timerId) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * For Tests: Runs some or all delayed operations early.\r\n     *\r\n     * @param lastTimerId - Delayed operations up to and including this TimerId\r\n     * will be drained. Pass TimerId.All to run all delayed operations.\r\n     * @returns a Promise that resolves once all operations have been run.\r\n     */\r\n    runAllDelayedOperationsUntil(lastTimerId) {\r\n        // Note that draining may generate more delayed ops, so we do that first.\r\n        return this.drain().then(() => {\r\n            // Run ops in the same order they'd run if they ran naturally.\r\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\r\n            for (const op of this.delayedOperations) {\r\n                op.skipDelay();\r\n                if (lastTimerId !== \"all\" /* TimerId.All */ && op.timerId === lastTimerId) {\r\n                    break;\r\n                }\r\n            }\r\n            return this.drain();\r\n        });\r\n    }\r\n    /**\r\n     * For Tests: Skip all subsequent delays for a timer id.\r\n     */\r\n    skipDelaysForTimerId(timerId) {\r\n        this.timerIdsToSkip.push(timerId);\r\n    }\r\n    /** Called once a DelayedOperation is run or canceled. */\r\n    removeDelayedOperation(op) {\r\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\r\n        const index = this.delayedOperations.indexOf(op);\r\n        this.delayedOperations.splice(index, 1);\r\n    }\r\n}\r\nfunction newAsyncQueue() {\r\n    return new AsyncQueueImpl();\r\n}\r\n/**\r\n * Chrome includes Error.message in Error.stack. Other browsers do not.\r\n * This returns expected output of message + stack when available.\r\n * @param error - Error or FirestoreError\r\n */\r\nfunction getMessageOrStack(error) {\r\n    let message = error.message || '';\r\n    if (error.stack) {\r\n        if (error.stack.includes(error.message)) {\r\n            message = error.stack;\r\n        }\r\n        else {\r\n            message = error.message + '\\n' + error.stack;\r\n        }\r\n    }\r\n    return message;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\r\n * loading, as well as task completion and error events.\r\n *\r\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\r\n */\r\nclass LoadBundleTask {\r\n    constructor() {\r\n        this._progressObserver = {};\r\n        this._taskCompletionResolver = new Deferred();\r\n        this._lastProgress = {\r\n            taskState: 'Running',\r\n            totalBytes: 0,\r\n            totalDocuments: 0,\r\n            bytesLoaded: 0,\r\n            documentsLoaded: 0\r\n        };\r\n    }\r\n    /**\r\n     * Registers functions to listen to bundle loading progress events.\r\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\r\n     *   each time a Firestore document is loaded from the bundle.\r\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\r\n     *   error, and there should be no more updates after this.\r\n     * @param complete - Called when the loading task is complete.\r\n     */\r\n    onProgress(next, error, complete) {\r\n        this._progressObserver = {\r\n            next,\r\n            error,\r\n            complete\r\n        };\r\n    }\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\r\n     *\r\n     * @param onRejected - Called when an error occurs during bundle loading.\r\n     */\r\n    catch(onRejected) {\r\n        return this._taskCompletionResolver.promise.catch(onRejected);\r\n    }\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\r\n     *\r\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\r\n     *   The update will always have its `taskState` set to `\"Success\"`.\r\n     * @param onRejected - Called when an error occurs during bundle loading.\r\n     */\r\n    then(onFulfilled, onRejected) {\r\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\r\n    }\r\n    /**\r\n     * Notifies all observers that bundle loading has completed, with a provided\r\n     * `LoadBundleTaskProgress` object.\r\n     *\r\n     * @private\r\n     */\r\n    _completeWith(progress) {\r\n        this._updateProgress(progress);\r\n        if (this._progressObserver.complete) {\r\n            this._progressObserver.complete();\r\n        }\r\n        this._taskCompletionResolver.resolve(progress);\r\n    }\r\n    /**\r\n     * Notifies all observers that bundle loading has failed, with a provided\r\n     * `Error` as the reason.\r\n     *\r\n     * @private\r\n     */\r\n    _failWith(error) {\r\n        this._lastProgress.taskState = 'Error';\r\n        if (this._progressObserver.next) {\r\n            this._progressObserver.next(this._lastProgress);\r\n        }\r\n        if (this._progressObserver.error) {\r\n            this._progressObserver.error(error);\r\n        }\r\n        this._taskCompletionResolver.reject(error);\r\n    }\r\n    /**\r\n     * Notifies a progress update of loading a bundle.\r\n     * @param progress - The new progress.\r\n     *\r\n     * @private\r\n     */\r\n    _updateProgress(progress) {\r\n        this._lastProgress = progress;\r\n        if (this._progressObserver.next) {\r\n            this._progressObserver.next(progress);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Constant used to indicate the LRU garbage collection should be disabled.\r\n * Set this value as the `cacheSizeBytes` on the settings passed to the\r\n * {@link Firestore} instance.\r\n */\r\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\r\n/**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\r\n */\r\nclass Firestore extends Firestore$1 {\r\n    /** @hideconstructor */\r\n    constructor(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app) {\r\n        super(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app);\r\n        /**\r\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\r\n         */\r\n        this.type = 'firestore';\r\n        this._queue = newAsyncQueue();\r\n        this._persistenceKey = (app === null || app === void 0 ? void 0 : app.name) || '[DEFAULT]';\r\n    }\r\n    _terminate() {\r\n        if (!this._firestoreClient) {\r\n            // The client must be initialized to ensure that all subsequent API\r\n            // usage throws an exception.\r\n            configureFirestore(this);\r\n        }\r\n        return this._firestoreClient.terminate();\r\n    }\r\n}\r\n/**\r\n * Initializes a new instance of {@link Firestore} with the provided settings.\r\n * Can only be called before any other function, including\r\n * {@link (getFirestore:1)}. If the custom settings are empty, this function is\r\n * equivalent to calling {@link (getFirestore:1)}.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\r\n * be associated.\r\n * @param settings - A settings object to configure the {@link Firestore} instance.\r\n * @param databaseId - The name of the database.\r\n * @returns A newly initialized {@link Firestore} instance.\r\n */\r\nfunction initializeFirestore(app, settings, databaseId) {\r\n    if (!databaseId) {\r\n        databaseId = DEFAULT_DATABASE_NAME;\r\n    }\r\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\r\n    if (provider.isInitialized(databaseId)) {\r\n        const existingInstance = provider.getImmediate({\r\n            identifier: databaseId\r\n        });\r\n        const initialSettings = provider.getOptions(databaseId);\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(initialSettings, settings)) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\r\n                'different options. To avoid this error, call initializeFirestore() with the ' +\r\n                'same options as when it was originally called, or call getFirestore() to return the' +\r\n                ' already initialized instance.');\r\n        }\r\n    }\r\n    if (settings.cacheSizeBytes !== undefined &&\r\n        settings.localCache !== undefined) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes will` +\r\n            `be deprecated. Instead, specify the cache size in the cache object`);\r\n    }\r\n    if (settings.cacheSizeBytes !== undefined &&\r\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\r\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\r\n    }\r\n    return provider.initialize({\r\n        options: settings,\r\n        instanceIdentifier: databaseId\r\n    });\r\n}\r\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\r\n    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\r\n    const databaseId = typeof appOrDatabaseId === 'string'\r\n        ? appOrDatabaseId\r\n        : optionalDatabaseId || DEFAULT_DATABASE_NAME;\r\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate({\r\n        identifier: databaseId\r\n    });\r\n    if (!db._initialized) {\r\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getDefaultEmulatorHostnameAndPort)('firestore');\r\n        if (emulator) {\r\n            connectFirestoreEmulator(db, ...emulator);\r\n        }\r\n    }\r\n    return db;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction ensureFirestoreConfigured(firestore) {\r\n    if (!firestore._firestoreClient) {\r\n        configureFirestore(firestore);\r\n    }\r\n    firestore._firestoreClient.verifyNotTerminated();\r\n    return firestore._firestoreClient;\r\n}\r\nfunction configureFirestore(firestore) {\r\n    var _a, _b, _c;\r\n    const settings = firestore._freezeSettings();\r\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || '', firestore._persistenceKey, settings);\r\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo);\r\n    if (((_b = settings.localCache) === null || _b === void 0 ? void 0 : _b._offlineComponentProvider) &&\r\n        ((_c = settings.localCache) === null || _c === void 0 ? void 0 : _c._onlineComponentProvider)) {\r\n        firestore._firestoreClient._uninitializedComponentsProvider = {\r\n            _offlineKind: settings.localCache.kind,\r\n            _offline: settings.localCache._offlineComponentProvider,\r\n            _online: settings.localCache._onlineComponentProvider\r\n        };\r\n    }\r\n}\r\n/**\r\n * Attempts to enable persistent storage, if possible.\r\n *\r\n * On failure, `enableIndexedDbPersistence()` will reject the promise or\r\n * throw an exception. There are several reasons why this can fail, which can be\r\n * identified by the `code` on the error.\r\n *\r\n *   * failed-precondition: The app is already open in another browser tab.\r\n *   * unimplemented: The browser is incompatible with the offline persistence\r\n *     implementation.\r\n *\r\n * Note that even after a failure, the {@link Firestore} instance will remain\r\n * usable, however offline persistence will be disabled.\r\n *\r\n * Note: `enableIndexedDbPersistence()` must be called before any other functions\r\n * (other than {@link initializeFirestore}, {@link (getFirestore:1)} or\r\n * {@link clearIndexedDbPersistence}.\r\n *\r\n * Persistence cannot be used in a Node.js environment.\r\n *\r\n * @param firestore - The {@link Firestore} instance to enable persistence for.\r\n * @param persistenceSettings - Optional settings object to configure\r\n * persistence.\r\n * @returns A `Promise` that represents successfully enabling persistent storage.\r\n * @deprecated This function will be removed in a future major release. Instead, set\r\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\r\n * turn on IndexedDb cache. Calling this function when `FirestoreSettings.localCache`\r\n * is already specified will throw an exception.\r\n */\r\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\r\n    firestore = cast(firestore, Firestore);\r\n    verifyNotInitialized(firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (client._uninitializedComponentsProvider) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\r\n    }\r\n    logWarn('enableIndexedDbPersistence() will be deprecated in the future, ' +\r\n        'you can use `FirestoreSettings.cache` instead.');\r\n    const settings = firestore._freezeSettings();\r\n    const onlineComponentProvider = new OnlineComponentProvider();\r\n    const offlineComponentProvider = new IndexedDbOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership);\r\n    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);\r\n}\r\n/**\r\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\r\n * across all tabs, all operations share access to local persistence, including\r\n * shared execution of queries and latency-compensated local document updates\r\n * across all connected instances.\r\n *\r\n * On failure, `enableMultiTabIndexedDbPersistence()` will reject the promise or\r\n * throw an exception. There are several reasons why this can fail, which can be\r\n * identified by the `code` on the error.\r\n *\r\n *   * failed-precondition: The app is already open in another browser tab and\r\n *     multi-tab is not enabled.\r\n *   * unimplemented: The browser is incompatible with the offline persistence\r\n *     implementation.\r\n *\r\n * Note that even after a failure, the {@link Firestore} instance will remain\r\n * usable, however offline persistence will be disabled.\r\n *\r\n * @param firestore - The {@link Firestore} instance to enable persistence for.\r\n * @returns A `Promise` that represents successfully enabling persistent\r\n * storage.\r\n * @deprecated This function will be removed in a future major release. Instead, set\r\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\r\n * turn on indexeddb cache. Calling this function when `FirestoreSettings.localCache`\r\n * is already specified will throw an exception.\r\n */\r\nfunction enableMultiTabIndexedDbPersistence(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    verifyNotInitialized(firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (client._uninitializedComponentsProvider) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\r\n    }\r\n    logWarn('enableMultiTabIndexedDbPersistence() will be deprecated in the future, ' +\r\n        'you can use `FirestoreSettings.cache` instead.');\r\n    const settings = firestore._freezeSettings();\r\n    const onlineComponentProvider = new OnlineComponentProvider();\r\n    const offlineComponentProvider = new MultiTabOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes);\r\n    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);\r\n}\r\n/**\r\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\r\n * If the operation fails with a recoverable error (see\r\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\r\n * but the client remains usable.\r\n */\r\nfunction setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider) {\r\n    const persistenceResult = new Deferred();\r\n    return client.asyncQueue\r\n        .enqueue(async () => {\r\n        try {\r\n            await setOfflineComponentProvider(client, offlineComponentProvider);\r\n            await setOnlineComponentProvider(client, onlineComponentProvider);\r\n            persistenceResult.resolve();\r\n        }\r\n        catch (e) {\r\n            const error = e;\r\n            if (!canFallbackFromIndexedDbError(error)) {\r\n                throw error;\r\n            }\r\n            logWarn('Error enabling indexeddb cache. Falling back to ' +\r\n                'memory cache: ' +\r\n                error);\r\n            persistenceResult.reject(error);\r\n        }\r\n    })\r\n        .then(() => persistenceResult.promise);\r\n}\r\n/**\r\n * Clears the persistent storage. This includes pending writes and cached\r\n * documents.\r\n *\r\n * Must be called while the {@link Firestore} instance is not started (after the app is\r\n * terminated or when the app is first initialized). On startup, this function\r\n * must be called before other functions (other than {@link\r\n * initializeFirestore} or {@link (getFirestore:1)})). If the {@link Firestore}\r\n * instance is still running, the promise will be rejected with the error code\r\n * of `failed-precondition`.\r\n *\r\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\r\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\r\n * dropping existing data but does not attempt to securely overwrite or\r\n * otherwise make cached data unrecoverable. For applications that are sensitive\r\n * to the disclosure of cached data in between user sessions, we strongly\r\n * recommend not enabling persistence at all.\r\n *\r\n * @param firestore - The {@link Firestore} instance to clear persistence for.\r\n * @returns A `Promise` that is resolved when the persistent storage is\r\n * cleared. Otherwise, the promise is rejected with an error.\r\n */\r\nfunction clearIndexedDbPersistence(firestore) {\r\n    if (firestore._initialized && !firestore._terminated) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\r\n            'initialized or after it is terminated.');\r\n    }\r\n    const deferred = new Deferred();\r\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\r\n        try {\r\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\r\n            deferred.resolve();\r\n        }\r\n        catch (e) {\r\n            deferred.reject(e);\r\n        }\r\n    });\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Waits until all currently pending writes for the active user have been\r\n * acknowledged by the backend.\r\n *\r\n * The returned promise resolves immediately if there are no outstanding writes.\r\n * Otherwise, the promise waits for all previously issued writes (including\r\n * those written in a previous app session), but it does not wait for writes\r\n * that were added after the function is called. If you want to wait for\r\n * additional writes, call `waitForPendingWrites()` again.\r\n *\r\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\r\n * changes.\r\n *\r\n * @returns A `Promise` which resolves when all currently pending writes have been\r\n * acknowledged by the backend.\r\n */\r\nfunction waitForPendingWrites(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientWaitForPendingWrites(client);\r\n}\r\n/**\r\n * Re-enables use of the network for this {@link Firestore} instance after a prior\r\n * call to {@link disableNetwork}.\r\n *\r\n * @returns A `Promise` that is resolved once the network has been enabled.\r\n */\r\nfunction enableNetwork(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientEnableNetwork(client);\r\n}\r\n/**\r\n * Disables network usage for this instance. It can be re-enabled via {@link\r\n * enableNetwork}. While the network is disabled, any snapshot listeners,\r\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\r\n * operations will be queued until the network is restored.\r\n *\r\n * @returns A `Promise` that is resolved once the network has been disabled.\r\n */\r\nfunction disableNetwork(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientDisableNetwork(client);\r\n}\r\n/**\r\n * Terminates the provided {@link Firestore} instance.\r\n *\r\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\r\n * may be used. Any other function will throw a `FirestoreError`.\r\n *\r\n * To restart after termination, create a new instance of FirebaseFirestore with\r\n * {@link (getFirestore:1)}.\r\n *\r\n * Termination does not cancel any pending writes, and any promises that are\r\n * awaiting a response from the server will not be resolved. If you have\r\n * persistence enabled, the next time you start this instance, it will resume\r\n * sending these writes to the server.\r\n *\r\n * Note: Under normal circumstances, calling `terminate()` is not required. This\r\n * function is useful only when you want to force this instance to release all\r\n * of its resources or in combination with `clearIndexedDbPersistence()` to\r\n * ensure that all local state is destroyed between test runs.\r\n *\r\n * @returns A `Promise` that is resolved when the instance has been successfully\r\n * terminated.\r\n */\r\nfunction terminate(firestore) {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore', firestore._databaseId.database);\r\n    return firestore._delete();\r\n}\r\n/**\r\n * Loads a Firestore bundle into the local cache.\r\n *\r\n * @param firestore - The {@link Firestore} instance to load bundles for.\r\n * @param bundleData - An object representing the bundle to be loaded. Valid\r\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\r\n *\r\n * @returns A `LoadBundleTask` object, which notifies callers with progress\r\n * updates, and completion or error events. It can be used as a\r\n * `Promise<LoadBundleTaskProgress>`.\r\n */\r\nfunction loadBundle(firestore, bundleData) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const resultTask = new LoadBundleTask();\r\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\r\n    return resultTask;\r\n}\r\n/**\r\n * Reads a Firestore {@link Query} from local cache, identified by the given\r\n * name.\r\n *\r\n * The named queries are packaged  into bundles on the server side (along\r\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\r\n * in local cache, use this method to extract a {@link Query} by name.\r\n *\r\n * @param firestore - The {@link Firestore} instance to read the query from.\r\n * @param name - The name of the query.\r\n * @returns A `Promise` that is resolved with the Query or `null`.\r\n */\r\nfunction namedQuery(firestore, name) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\r\n        if (!namedQuery) {\r\n            return null;\r\n        }\r\n        return new Query(firestore, null, namedQuery.query);\r\n    });\r\n}\r\nfunction verifyNotInitialized(firestore) {\r\n    if (firestore._initialized || firestore._terminated) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\r\n            'enabled. You can only enable persistence before calling any other ' +\r\n            'methods on a Firestore object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerFirestore(variant, useFetchStreams = true) {\r\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { instanceIdentifier: databaseId, options: settings }) => {\r\n        const app = container.getProvider('app').getImmediate();\r\n        const firestoreInstance = new Firestore(new FirebaseAuthCredentialsProvider(container.getProvider('auth-internal')), new FirebaseAppCheckTokenProvider(container.getProvider('app-check-internal')), databaseIdFromApp(app, databaseId), app);\r\n        settings = Object.assign({ useFetchStreams }, settings);\r\n        firestoreInstance._setSettings(settings);\r\n        return firestoreInstance;\r\n    }, 'PUBLIC').setMultipleInstances(true));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Concrete implementation of the Aggregate type.\r\n */\r\nclass AggregateImpl {\r\n    constructor(alias, aggregateType, fieldPath) {\r\n        this.alias = alias;\r\n        this.aggregateType = aggregateType;\r\n        this.fieldPath = fieldPath;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents an aggregation that can be performed by Firestore.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nclass AggregateField {\r\n    /**\r\n     * Create a new AggregateField<T>\r\n     * @param aggregateType Specifies the type of aggregation operation to perform.\r\n     * @param _internalFieldPath Optionally specifies the field that is aggregated.\r\n     * @internal\r\n     */\r\n    constructor(aggregateType = 'count', _internalFieldPath) {\r\n        this._internalFieldPath = _internalFieldPath;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'AggregateField';\r\n        this.aggregateType = aggregateType;\r\n    }\r\n}\r\n/**\r\n * The results of executing an aggregation query.\r\n */\r\nclass AggregateQuerySnapshot {\r\n    /** @hideconstructor */\r\n    constructor(query, _userDataWriter, _data) {\r\n        this._userDataWriter = _userDataWriter;\r\n        this._data = _data;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'AggregateQuerySnapshot';\r\n        this.query = query;\r\n    }\r\n    /**\r\n     * Returns the results of the aggregations performed over the underlying\r\n     * query.\r\n     *\r\n     * The keys of the returned object will be the same as those of the\r\n     * `AggregateSpec` object specified to the aggregation method, and the values\r\n     * will be the corresponding aggregation result.\r\n     *\r\n     * @returns The results of the aggregations performed over the underlying\r\n     * query.\r\n     */\r\n    data() {\r\n        return this._userDataWriter.convertObjectMap(this._data);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing an array of bytes.\r\n */\r\nclass Bytes {\r\n    /** @hideconstructor */\r\n    constructor(byteString) {\r\n        this._byteString = byteString;\r\n    }\r\n    /**\r\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\r\n     * bytes.\r\n     *\r\n     * @param base64 - The Base64 string used to create the `Bytes` object.\r\n     */\r\n    static fromBase64String(base64) {\r\n        try {\r\n            return new Bytes(ByteString.fromBase64String(base64));\r\n        }\r\n        catch (e) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new `Bytes` object from the given Uint8Array.\r\n     *\r\n     * @param array - The Uint8Array used to create the `Bytes` object.\r\n     */\r\n    static fromUint8Array(array) {\r\n        return new Bytes(ByteString.fromUint8Array(array));\r\n    }\r\n    /**\r\n     * Returns the underlying bytes as a Base64-encoded string.\r\n     *\r\n     * @returns The Base64-encoded string created from the `Bytes` object.\r\n     */\r\n    toBase64() {\r\n        return this._byteString.toBase64();\r\n    }\r\n    /**\r\n     * Returns the underlying bytes in a new `Uint8Array`.\r\n     *\r\n     * @returns The Uint8Array created from the `Bytes` object.\r\n     */\r\n    toUint8Array() {\r\n        return this._byteString.toUint8Array();\r\n    }\r\n    /**\r\n     * Returns a string representation of the `Bytes` object.\r\n     *\r\n     * @returns A string representation of the `Bytes` object.\r\n     */\r\n    toString() {\r\n        return 'Bytes(base64: ' + this.toBase64() + ')';\r\n    }\r\n    /**\r\n     * Returns true if this `Bytes` object is equal to the provided one.\r\n     *\r\n     * @param other - The `Bytes` object to compare against.\r\n     * @returns true if this `Bytes` object is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._byteString.isEqual(other._byteString);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `FieldPath` refers to a field in a document. The path may consist of a\r\n * single field name (referring to a top-level field in the document), or a\r\n * list of field names (referring to a nested field in the document).\r\n *\r\n * Create a `FieldPath` by providing field names. If more than one field\r\n * name is provided, the path will point to a nested field in a document.\r\n */\r\nclass FieldPath {\r\n    /**\r\n     * Creates a `FieldPath` from the provided field names. If more than one field\r\n     * name is provided, the path will point to a nested field in a document.\r\n     *\r\n     * @param fieldNames - A list of field names.\r\n     */\r\n    constructor(...fieldNames) {\r\n        for (let i = 0; i < fieldNames.length; ++i) {\r\n            if (fieldNames[i].length === 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\r\n                    'Field names must not be empty.');\r\n            }\r\n        }\r\n        this._internalPath = new FieldPath$1(fieldNames);\r\n    }\r\n    /**\r\n     * Returns true if this `FieldPath` is equal to the provided one.\r\n     *\r\n     * @param other - The `FieldPath` to compare against.\r\n     * @returns true if this `FieldPath` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._internalPath.isEqual(other._internalPath);\r\n    }\r\n}\r\n/**\r\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\r\n * It can be used in queries to sort or filter by the document ID.\r\n */\r\nfunction documentId() {\r\n    return new FieldPath(DOCUMENT_KEY_NAME);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sentinel values that can be used when writing document fields with `set()`\r\n * or `update()`.\r\n */\r\nclass FieldValue {\r\n    /**\r\n     * @param _methodName - The public API endpoint that returns this class.\r\n     * @hideconstructor\r\n     */\r\n    constructor(_methodName) {\r\n        this._methodName = _methodName;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing a geographic location in Firestore. The\r\n * location is represented as latitude/longitude pair.\r\n *\r\n * Latitude values are in the range of [-90, 90].\r\n * Longitude values are in the range of [-180, 180].\r\n */\r\nclass GeoPoint {\r\n    /**\r\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\r\n     * longitude values.\r\n     * @param latitude - The latitude as number between -90 and 90.\r\n     * @param longitude - The longitude as number between -180 and 180.\r\n     */\r\n    constructor(latitude, longitude) {\r\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\r\n        }\r\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\r\n        }\r\n        this._lat = latitude;\r\n        this._long = longitude;\r\n    }\r\n    /**\r\n     * The latitude of this `GeoPoint` instance.\r\n     */\r\n    get latitude() {\r\n        return this._lat;\r\n    }\r\n    /**\r\n     * The longitude of this `GeoPoint` instance.\r\n     */\r\n    get longitude() {\r\n        return this._long;\r\n    }\r\n    /**\r\n     * Returns true if this `GeoPoint` is equal to the provided one.\r\n     *\r\n     * @param other - The `GeoPoint` to compare against.\r\n     * @returns true if this `GeoPoint` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._lat === other._lat && this._long === other._long;\r\n    }\r\n    /** Returns a JSON-serializable representation of this GeoPoint. */\r\n    toJSON() {\r\n        return { latitude: this._lat, longitude: this._long };\r\n    }\r\n    /**\r\n     * Actually private to JS consumers of our API, so this function is prefixed\r\n     * with an underscore.\r\n     */\r\n    _compareTo(other) {\r\n        return (primitiveComparator(this._lat, other._lat) ||\r\n            primitiveComparator(this._long, other._long));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\r\n/** The result of parsing document data (e.g. for a setData call). */\r\nclass ParsedSetData {\r\n    constructor(data, fieldMask, fieldTransforms) {\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.fieldTransforms = fieldTransforms;\r\n    }\r\n    toMutation(key, precondition) {\r\n        if (this.fieldMask !== null) {\r\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\r\n        }\r\n        else {\r\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\r\n        }\r\n    }\r\n}\r\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\r\nclass ParsedUpdateData {\r\n    constructor(data, \r\n    // The fieldMask does not include document transforms.\r\n    fieldMask, fieldTransforms) {\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.fieldTransforms = fieldTransforms;\r\n    }\r\n    toMutation(key, precondition) {\r\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\r\n    }\r\n}\r\nfunction isWrite(dataSource) {\r\n    switch (dataSource) {\r\n        case 0 /* UserDataSource.Set */: // fall through\r\n        case 2 /* UserDataSource.MergeSet */: // fall through\r\n        case 1 /* UserDataSource.Update */:\r\n            return true;\r\n        case 3 /* UserDataSource.Argument */:\r\n        case 4 /* UserDataSource.ArrayArgument */:\r\n            return false;\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\n/** A \"context\" object passed around while parsing user data. */\r\nclass ParseContextImpl {\r\n    /**\r\n     * Initializes a ParseContext with the given source and path.\r\n     *\r\n     * @param settings - The settings for the parser.\r\n     * @param databaseId - The database ID of the Firestore instance.\r\n     * @param serializer - The serializer to use to generate the Value proto.\r\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\r\n     * rather than throw.\r\n     * @param fieldTransforms - A mutable list of field transforms encountered\r\n     * while parsing the data.\r\n     * @param fieldMask - A mutable list of field paths encountered while parsing\r\n     * the data.\r\n     *\r\n     * TODO(b/34871131): We don't support array paths right now, so path can be\r\n     * null to indicate the context represents any location within an array (in\r\n     * which case certain features will not work and errors will be somewhat\r\n     * compromised).\r\n     */\r\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\r\n        this.settings = settings;\r\n        this.databaseId = databaseId;\r\n        this.serializer = serializer;\r\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\r\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\r\n        // external call and we need to validate the entire path.\r\n        if (fieldTransforms === undefined) {\r\n            this.validatePath();\r\n        }\r\n        this.fieldTransforms = fieldTransforms || [];\r\n        this.fieldMask = fieldMask || [];\r\n    }\r\n    get path() {\r\n        return this.settings.path;\r\n    }\r\n    get dataSource() {\r\n        return this.settings.dataSource;\r\n    }\r\n    /** Returns a new context with the specified settings overwritten. */\r\n    contextWith(configuration) {\r\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\r\n    }\r\n    childContextForField(field) {\r\n        var _a;\r\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\r\n        const context = this.contextWith({ path: childPath, arrayElement: false });\r\n        context.validatePathSegment(field);\r\n        return context;\r\n    }\r\n    childContextForFieldPath(field) {\r\n        var _a;\r\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\r\n        const context = this.contextWith({ path: childPath, arrayElement: false });\r\n        context.validatePath();\r\n        return context;\r\n    }\r\n    childContextForArray(index) {\r\n        // TODO(b/34871131): We don't support array paths right now; so make path\r\n        // undefined.\r\n        return this.contextWith({ path: undefined, arrayElement: true });\r\n    }\r\n    createError(reason) {\r\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\r\n    }\r\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\r\n    contains(fieldPath) {\r\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\r\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\r\n    }\r\n    validatePath() {\r\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\r\n        // within arrays.\r\n        if (!this.path) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < this.path.length; i++) {\r\n            this.validatePathSegment(this.path.get(i));\r\n        }\r\n    }\r\n    validatePathSegment(segment) {\r\n        if (segment.length === 0) {\r\n            throw this.createError('Document fields must not be empty');\r\n        }\r\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\r\n            throw this.createError('Document fields cannot begin and end with \"__\"');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper for parsing raw user input (provided via the API) into internal model\r\n * classes.\r\n */\r\nclass UserDataReader {\r\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\r\n        this.databaseId = databaseId;\r\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\r\n        this.serializer = serializer || newSerializer(databaseId);\r\n    }\r\n    /** Creates a new top-level parse context. */\r\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\r\n        return new ParseContextImpl({\r\n            dataSource,\r\n            methodName,\r\n            targetDoc,\r\n            path: FieldPath$1.emptyPath(),\r\n            arrayElement: false,\r\n            hasConverter\r\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\r\n    }\r\n}\r\nfunction newUserDataReader(firestore) {\r\n    const settings = firestore._freezeSettings();\r\n    const serializer = newSerializer(firestore._databaseId);\r\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\r\n}\r\n/** Parse document data from a set() call. */\r\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\r\n    const context = userDataReader.createContext(options.merge || options.mergeFields\r\n        ? 2 /* UserDataSource.MergeSet */\r\n        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);\r\n    validatePlainObject('Data must be an object, but it was:', context, input);\r\n    const updateData = parseObject(input, context);\r\n    let fieldMask;\r\n    let fieldTransforms;\r\n    if (options.merge) {\r\n        fieldMask = new FieldMask(context.fieldMask);\r\n        fieldTransforms = context.fieldTransforms;\r\n    }\r\n    else if (options.mergeFields) {\r\n        const validatedFieldPaths = [];\r\n        for (const stringOrFieldPath of options.mergeFields) {\r\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\r\n            if (!context.contains(fieldPath)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\r\n            }\r\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\r\n                validatedFieldPaths.push(fieldPath);\r\n            }\r\n        }\r\n        fieldMask = new FieldMask(validatedFieldPaths);\r\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\r\n    }\r\n    else {\r\n        fieldMask = null;\r\n        fieldTransforms = context.fieldTransforms;\r\n    }\r\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\r\n}\r\nclass DeleteFieldValueImpl extends FieldValue {\r\n    _toFieldTransform(context) {\r\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */) {\r\n            // No transform to add for a delete, but we need to add it to our\r\n            // fieldMask so it gets deleted.\r\n            context.fieldMask.push(context.path);\r\n        }\r\n        else if (context.dataSource === 1 /* UserDataSource.Update */) {\r\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\r\n                'of your update data');\r\n        }\r\n        else {\r\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\r\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\r\n                '{merge:true}');\r\n        }\r\n        return null;\r\n    }\r\n    isEqual(other) {\r\n        return other instanceof DeleteFieldValueImpl;\r\n    }\r\n}\r\n/**\r\n * Creates a child context for parsing SerializableFieldValues.\r\n *\r\n * This is different than calling `ParseContext.contextWith` because it keeps\r\n * the fieldTransforms and fieldMask separate.\r\n *\r\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\r\n * Although these values are used with writes, any elements in these FieldValues\r\n * are not considered writes since they cannot contain any FieldValue sentinels,\r\n * etc.\r\n *\r\n * @param fieldValue - The sentinel FieldValue for which to create a child\r\n *     context.\r\n * @param context - The parent context.\r\n * @param arrayElement - Whether or not the FieldValue has an array.\r\n */\r\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\r\n    return new ParseContextImpl({\r\n        dataSource: 3 /* UserDataSource.Argument */,\r\n        targetDoc: context.settings.targetDoc,\r\n        methodName: fieldValue._methodName,\r\n        arrayElement\r\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\r\n}\r\nclass ServerTimestampFieldValueImpl extends FieldValue {\r\n    _toFieldTransform(context) {\r\n        return new FieldTransform(context.path, new ServerTimestampTransform());\r\n    }\r\n    isEqual(other) {\r\n        return other instanceof ServerTimestampFieldValueImpl;\r\n    }\r\n}\r\nclass ArrayUnionFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _elements) {\r\n        super(methodName);\r\n        this._elements = _elements;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const parseContext = createSentinelChildContext(this, context, \r\n        /*array=*/ true);\r\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\r\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\r\n        return new FieldTransform(context.path, arrayUnion);\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof ArrayUnionFieldValueImpl &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\r\n    }\r\n}\r\nclass ArrayRemoveFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _elements) {\r\n        super(methodName);\r\n        this._elements = _elements;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const parseContext = createSentinelChildContext(this, context, \r\n        /*array=*/ true);\r\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\r\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\r\n        return new FieldTransform(context.path, arrayUnion);\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof ArrayRemoveFieldValueImpl &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\r\n    }\r\n}\r\nclass NumericIncrementFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _operand) {\r\n        super(methodName);\r\n        this._operand = _operand;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\r\n        return new FieldTransform(context.path, numericIncrement);\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof NumericIncrementFieldValueImpl &&\r\n            this._operand === other._operand);\r\n    }\r\n}\r\n/** Parse update data from an update() call. */\r\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\r\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\r\n    validatePlainObject('Data must be an object, but it was:', context, input);\r\n    const fieldMaskPaths = [];\r\n    const updateData = ObjectValue.empty();\r\n    forEach(input, (key, value) => {\r\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n        const childContext = context.childContextForFieldPath(path);\r\n        if (value instanceof DeleteFieldValueImpl) {\r\n            // Add it to the field mask, but don't add anything to updateData.\r\n            fieldMaskPaths.push(path);\r\n        }\r\n        else {\r\n            const parsedValue = parseData(value, childContext);\r\n            if (parsedValue != null) {\r\n                fieldMaskPaths.push(path);\r\n                updateData.set(path, parsedValue);\r\n            }\r\n        }\r\n    });\r\n    const mask = new FieldMask(fieldMaskPaths);\r\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\r\n}\r\n/** Parse update data from a list of field/value arguments. */\r\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\r\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\r\n    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];\r\n    const values = [value];\r\n    if (moreFieldsAndValues.length % 2 !== 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\r\n            'of arguments that alternate between field names and values.');\r\n    }\r\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\r\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\r\n        values.push(moreFieldsAndValues[i + 1]);\r\n    }\r\n    const fieldMaskPaths = [];\r\n    const updateData = ObjectValue.empty();\r\n    // We iterate in reverse order to pick the last value for a field if the\r\n    // user specified the field multiple times.\r\n    for (let i = keys.length - 1; i >= 0; --i) {\r\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\r\n            const path = keys[i];\r\n            let value = values[i];\r\n            // For Compat types, we have to \"extract\" the underlying types before\r\n            // performing validation.\r\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n            const childContext = context.childContextForFieldPath(path);\r\n            if (value instanceof DeleteFieldValueImpl) {\r\n                // Add it to the field mask, but don't add anything to updateData.\r\n                fieldMaskPaths.push(path);\r\n            }\r\n            else {\r\n                const parsedValue = parseData(value, childContext);\r\n                if (parsedValue != null) {\r\n                    fieldMaskPaths.push(path);\r\n                    updateData.set(path, parsedValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const mask = new FieldMask(fieldMaskPaths);\r\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\r\n}\r\n/**\r\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\r\n * bound).\r\n *\r\n * @param allowArrays - Whether the query value is an array that may directly\r\n * contain additional arrays (e.g. the operand of an `in` query).\r\n */\r\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\r\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);\r\n    const parsed = parseData(input, context);\r\n    return parsed;\r\n}\r\n/**\r\n * Parses user data to Protobuf Values.\r\n *\r\n * @param input - Data to be parsed.\r\n * @param context - A context object representing the current path being parsed,\r\n * the source of the data being parsed, etc.\r\n * @returns The parsed value, or null if the value was a FieldValue sentinel\r\n * that should not be included in the resulting parsed data.\r\n */\r\nfunction parseData(input, context) {\r\n    // Unwrap the API type from the Compat SDK. This will return the API type\r\n    // from firestore-exp.\r\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\r\n    if (looksLikeJsonObject(input)) {\r\n        validatePlainObject('Unsupported field value:', context, input);\r\n        return parseObject(input, context);\r\n    }\r\n    else if (input instanceof FieldValue) {\r\n        // FieldValues usually parse into transforms (except deleteField())\r\n        // in which case we do not want to include this field in our parsed data\r\n        // (as doing so will overwrite the field directly prior to the transform\r\n        // trying to transform it). So we don't add this location to\r\n        // context.fieldMask and we return null as our parsing result.\r\n        parseSentinelFieldValue(input, context);\r\n        return null;\r\n    }\r\n    else if (input === undefined && context.ignoreUndefinedProperties) {\r\n        // If the input is undefined it can never participate in the fieldMask, so\r\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\r\n        // `parseScalarValue` will reject an undefined value.\r\n        return null;\r\n    }\r\n    else {\r\n        // If context.path is null we are inside an array and we don't support\r\n        // field mask paths more granular than the top-level array.\r\n        if (context.path) {\r\n            context.fieldMask.push(context.path);\r\n        }\r\n        if (input instanceof Array) {\r\n            // TODO(b/34871131): Include the path containing the array in the error\r\n            // message.\r\n            // In the case of IN queries, the parsed data is an array (representing\r\n            // the set of values to be included for the IN query) that may directly\r\n            // contain additional arrays (each representing an individual field\r\n            // value), so we disable this validation.\r\n            if (context.settings.arrayElement &&\r\n                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) {\r\n                throw context.createError('Nested arrays are not supported');\r\n            }\r\n            return parseArray(input, context);\r\n        }\r\n        else {\r\n            return parseScalarValue(input, context);\r\n        }\r\n    }\r\n}\r\nfunction parseObject(obj, context) {\r\n    const fields = {};\r\n    if (isEmpty(obj)) {\r\n        // If we encounter an empty object, we explicitly add it to the update\r\n        // mask to ensure that the server creates a map entry.\r\n        if (context.path && context.path.length > 0) {\r\n            context.fieldMask.push(context.path);\r\n        }\r\n    }\r\n    else {\r\n        forEach(obj, (key, val) => {\r\n            const parsedValue = parseData(val, context.childContextForField(key));\r\n            if (parsedValue != null) {\r\n                fields[key] = parsedValue;\r\n            }\r\n        });\r\n    }\r\n    return { mapValue: { fields } };\r\n}\r\nfunction parseArray(array, context) {\r\n    const values = [];\r\n    let entryIndex = 0;\r\n    for (const entry of array) {\r\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\r\n        if (parsedEntry == null) {\r\n            // Just include nulls in the array for fields being replaced with a\r\n            // sentinel.\r\n            parsedEntry = { nullValue: 'NULL_VALUE' };\r\n        }\r\n        values.push(parsedEntry);\r\n        entryIndex++;\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/**\r\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\r\n * context.fieldTransforms.\r\n */\r\nfunction parseSentinelFieldValue(value, context) {\r\n    // Sentinels are only supported with writes, and not within arrays.\r\n    if (!isWrite(context.dataSource)) {\r\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\r\n    }\r\n    if (!context.path) {\r\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\r\n    }\r\n    const fieldTransform = value._toFieldTransform(context);\r\n    if (fieldTransform) {\r\n        context.fieldTransforms.push(fieldTransform);\r\n    }\r\n}\r\n/**\r\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\r\n *\r\n * @returns The parsed value\r\n */\r\nfunction parseScalarValue(value, context) {\r\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n    if (value === null) {\r\n        return { nullValue: 'NULL_VALUE' };\r\n    }\r\n    else if (typeof value === 'number') {\r\n        return toNumber(context.serializer, value);\r\n    }\r\n    else if (typeof value === 'boolean') {\r\n        return { booleanValue: value };\r\n    }\r\n    else if (typeof value === 'string') {\r\n        return { stringValue: value };\r\n    }\r\n    else if (value instanceof Date) {\r\n        const timestamp = Timestamp.fromDate(value);\r\n        return {\r\n            timestampValue: toTimestamp(context.serializer, timestamp)\r\n        };\r\n    }\r\n    else if (value instanceof Timestamp) {\r\n        // Firestore backend truncates precision down to microseconds. To ensure\r\n        // offline mode works the same with regards to truncation, perform the\r\n        // truncation immediately without waiting for the backend to do that.\r\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\r\n        return {\r\n            timestampValue: toTimestamp(context.serializer, timestamp)\r\n        };\r\n    }\r\n    else if (value instanceof GeoPoint) {\r\n        return {\r\n            geoPointValue: {\r\n                latitude: value.latitude,\r\n                longitude: value.longitude\r\n            }\r\n        };\r\n    }\r\n    else if (value instanceof Bytes) {\r\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\r\n    }\r\n    else if (value instanceof DocumentReference) {\r\n        const thisDb = context.databaseId;\r\n        const otherDb = value.firestore._databaseId;\r\n        if (!otherDb.isEqual(thisDb)) {\r\n            throw context.createError('Document reference is for database ' +\r\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\r\n                `for database ${thisDb.projectId}/${thisDb.database}`);\r\n        }\r\n        return {\r\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\r\n        };\r\n    }\r\n    else {\r\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\r\n    }\r\n}\r\n/**\r\n * Checks whether an object looks like a JSON object that should be converted\r\n * into a struct. Normal class/prototype instances are considered to look like\r\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\r\n * GeoPoints, etc. are not considered to look like JSON objects since they map\r\n * to specific FieldValue types other than ObjectValue.\r\n */\r\nfunction looksLikeJsonObject(input) {\r\n    return (typeof input === 'object' &&\r\n        input !== null &&\r\n        !(input instanceof Array) &&\r\n        !(input instanceof Date) &&\r\n        !(input instanceof Timestamp) &&\r\n        !(input instanceof GeoPoint) &&\r\n        !(input instanceof Bytes) &&\r\n        !(input instanceof DocumentReference) &&\r\n        !(input instanceof FieldValue));\r\n}\r\nfunction validatePlainObject(message, context, input) {\r\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\r\n        const description = valueDescription(input);\r\n        if (description === 'an object') {\r\n            // Massage the error if it was an object.\r\n            throw context.createError(message + ' a custom object');\r\n        }\r\n        else {\r\n            throw context.createError(message + ' ' + description);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\r\n */\r\nfunction fieldPathFromArgument$1(methodName, path, targetDoc) {\r\n    // If required, replace the FieldPath Compat class with with the firestore-exp\r\n    // FieldPath.\r\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\r\n    if (path instanceof FieldPath) {\r\n        return path._internalPath;\r\n    }\r\n    else if (typeof path === 'string') {\r\n        return fieldPathFromDotSeparatedString(methodName, path);\r\n    }\r\n    else {\r\n        const message = 'Field path arguments must be of type string or ';\r\n        throw createError(message, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n}\r\n/**\r\n * Matches any characters in a field path string that are reserved.\r\n */\r\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\r\n/**\r\n * Wraps fromDotSeparatedString with an error message about the method that\r\n * was thrown.\r\n * @param methodName - The publicly visible method name\r\n * @param path - The dot-separated string form of a field path which will be\r\n * split on dots.\r\n * @param targetDoc - The document against which the field path will be\r\n * evaluated.\r\n */\r\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\r\n    const found = path.search(FIELD_PATH_RESERVED);\r\n    if (found >= 0) {\r\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\r\n            `'~', '*', '/', '[', or ']'`, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n    try {\r\n        return new FieldPath(...path.split('.'))._internalPath;\r\n    }\r\n    catch (e) {\r\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\r\n            `begin with '.', end with '.', or contain '..'`, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n}\r\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\r\n    const hasPath = path && !path.isEmpty();\r\n    const hasDocument = targetDoc !== undefined;\r\n    let message = `Function ${methodName}() called with invalid data`;\r\n    if (hasConverter) {\r\n        message += ' (via `toFirestore()`)';\r\n    }\r\n    message += '. ';\r\n    let description = '';\r\n    if (hasPath || hasDocument) {\r\n        description += ' (found';\r\n        if (hasPath) {\r\n            description += ` in field ${path}`;\r\n        }\r\n        if (hasDocument) {\r\n            description += ` in document ${targetDoc}`;\r\n        }\r\n        description += ')';\r\n    }\r\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\r\n}\r\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\r\nfunction fieldMaskContains(haystack, needle) {\r\n    return haystack.some(v => v.isEqual(needle));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */\r\nclass DocumentSnapshot$1 {\r\n    // Note: This class is stripped down version of the DocumentSnapshot in\r\n    // the legacy SDK. The changes are:\r\n    // - No support for SnapshotMetadata.\r\n    // - No support for SnapshotOptions.\r\n    /** @hideconstructor protected */\r\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._key = _key;\r\n        this._document = _document;\r\n        this._converter = _converter;\r\n    }\r\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\r\n    get id() {\r\n        return this._key.path.lastSegment();\r\n    }\r\n    /**\r\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\r\n     */\r\n    get ref() {\r\n        return new DocumentReference(this._firestore, this._converter, this._key);\r\n    }\r\n    /**\r\n     * Signals whether or not the document at the snapshot's location exists.\r\n     *\r\n     * @returns true if the document exists.\r\n     */\r\n    exists() {\r\n        return this._document !== null;\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * @returns An `Object` containing all fields in the document or `undefined`\r\n     * if the document doesn't exist.\r\n     */\r\n    data() {\r\n        if (!this._document) {\r\n            return undefined;\r\n        }\r\n        else if (this._converter) {\r\n            // We only want to use the converter and create a new DocumentSnapshot\r\n            // if a converter has been provided.\r\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \r\n            /* converter= */ null);\r\n            return this._converter.fromFirestore(snapshot);\r\n        }\r\n        else {\r\n            return this._userDataWriter.convertValue(this._document.data.value);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(fieldPath) {\r\n        if (this._document) {\r\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\r\n            if (value !== null) {\r\n                return this._userDataWriter.convertValue(value);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */\r\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * @override\r\n     * @returns An `Object` containing all fields in the document.\r\n     */\r\n    data() {\r\n        return super.data();\r\n    }\r\n}\r\n/**\r\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\r\n */\r\nfunction fieldPathFromArgument(methodName, arg) {\r\n    if (typeof arg === 'string') {\r\n        return fieldPathFromDotSeparatedString(methodName, arg);\r\n    }\r\n    else if (arg instanceof FieldPath) {\r\n        return arg._internalPath;\r\n    }\r\n    else {\r\n        return arg._delegate._internalPath;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateHasExplicitOrderByForLimitToLast(query) {\r\n    if (query.limitType === \"L\" /* LimitType.Last */ &&\r\n        query.explicitOrderBy.length === 0) {\r\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\r\n    }\r\n}\r\n/**\r\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\r\n * to a Firestore query.\r\n */\r\nclass AppliableConstraint {\r\n}\r\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\r\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\r\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\r\n * can then be passed to {@link (query:1)} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */\r\nclass QueryConstraint extends AppliableConstraint {\r\n}\r\nfunction query(query, queryConstraint, ...additionalQueryConstraints) {\r\n    let queryConstraints = [];\r\n    if (queryConstraint instanceof AppliableConstraint) {\r\n        queryConstraints.push(queryConstraint);\r\n    }\r\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\r\n    validateQueryConstraintArray(queryConstraints);\r\n    for (const constraint of queryConstraints) {\r\n        query = constraint._apply(query);\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\r\n * a Firestore query by filtering on one or more document fields.\r\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\r\n * be passed to {@link (query:1)} to create a new query instance that also contains\r\n * this `QueryFieldFilterConstraint`.\r\n */\r\nclass QueryFieldFilterConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(_field, _op, _value) {\r\n        super();\r\n        this._field = _field;\r\n        this._op = _op;\r\n        this._value = _value;\r\n        /** The type of this query constraint */\r\n        this.type = 'where';\r\n    }\r\n    static _create(_field, _op, _value) {\r\n        return new QueryFieldFilterConstraint(_field, _op, _value);\r\n    }\r\n    _apply(query) {\r\n        const filter = this._parse(query);\r\n        validateNewFieldFilter(query._query, filter);\r\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\r\n    }\r\n    _parse(query) {\r\n        const reader = newUserDataReader(query.firestore);\r\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\r\n        return filter;\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\r\n * must contain the specified field and that the value should satisfy the\r\n * relation constraint provided.\r\n *\r\n * @param fieldPath - The path to compare\r\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\r\n *   \"&lt;=\", \"!=\").\r\n * @param value - The value for comparison\r\n * @returns The created {@link QueryFieldFilterConstraint}.\r\n */\r\nfunction where(fieldPath, opStr, value) {\r\n    const op = opStr;\r\n    const field = fieldPathFromArgument('where', fieldPath);\r\n    return QueryFieldFilterConstraint._create(field, op, value);\r\n}\r\n/**\r\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\r\n * returned by a Firestore query by performing the logical OR or AND of multiple\r\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\r\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\r\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\r\n * instance that also contains the `QueryCompositeFilterConstraint`.\r\n */\r\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _queryConstraints) {\r\n        super();\r\n        this.type = type;\r\n        this._queryConstraints = _queryConstraints;\r\n    }\r\n    static _create(type, _queryConstraints) {\r\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\r\n    }\r\n    _parse(query) {\r\n        const parsedFilters = this._queryConstraints\r\n            .map(queryConstraint => {\r\n            return queryConstraint._parse(query);\r\n        })\r\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\r\n        if (parsedFilters.length === 1) {\r\n            return parsedFilters[0];\r\n        }\r\n        return CompositeFilter.create(parsedFilters, this._getOperator());\r\n    }\r\n    _apply(query) {\r\n        const parsedFilter = this._parse(query);\r\n        if (parsedFilter.getFilters().length === 0) {\r\n            // Return the existing query if not adding any more filters (e.g. an empty\r\n            // composite filter).\r\n            return query;\r\n        }\r\n        validateNewFilter(query._query, parsedFilter);\r\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));\r\n    }\r\n    _getQueryConstraints() {\r\n        return this._queryConstraints;\r\n    }\r\n    _getOperator() {\r\n        return this.type === 'and' ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\r\n    }\r\n}\r\n/**\r\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\r\n * the given filter constraints. A disjunction filter includes a document if it\r\n * satisfies any of the given filters.\r\n *\r\n * @param queryConstraints - Optional. The list of\r\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\r\n * created with calls to {@link where}, {@link or}, or {@link and}.\r\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\r\n */\r\nfunction or(...queryConstraints) {\r\n    // Only support QueryFilterConstraints\r\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));\r\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, queryConstraints);\r\n}\r\n/**\r\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\r\n * the given filter constraints. A conjunction filter includes a document if it\r\n * satisfies all of the given filters.\r\n *\r\n * @param queryConstraints - Optional. The list of\r\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\r\n * created with calls to {@link where}, {@link or}, or {@link and}.\r\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\r\n */\r\nfunction and(...queryConstraints) {\r\n    // Only support QueryFilterConstraints\r\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));\r\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, queryConstraints);\r\n}\r\n/**\r\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\r\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\r\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\r\n * instance that also contains this `QueryOrderByConstraint`.\r\n *\r\n * Note: Documents that do not contain the orderBy field will not be present in\r\n * the query result.\r\n */\r\nclass QueryOrderByConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(_field, _direction) {\r\n        super();\r\n        this._field = _field;\r\n        this._direction = _direction;\r\n        /** The type of this query constraint */\r\n        this.type = 'orderBy';\r\n    }\r\n    static _create(_field, _direction) {\r\n        return new QueryOrderByConstraint(_field, _direction);\r\n    }\r\n    _apply(query) {\r\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\r\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\r\n * specified field, optionally in descending order instead of ascending.\r\n *\r\n * Note: Documents that do not contain the specified field will not be present\r\n * in the query result.\r\n *\r\n * @param fieldPath - The field to sort by.\r\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\r\n * not specified, order will be ascending.\r\n * @returns The created {@link QueryOrderByConstraint}.\r\n */\r\nfunction orderBy(fieldPath, directionStr = 'asc') {\r\n    const direction = directionStr;\r\n    const path = fieldPathFromArgument('orderBy', fieldPath);\r\n    return QueryOrderByConstraint._create(path, direction);\r\n}\r\n/**\r\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\r\n * a Firestore query.\r\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\r\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\r\n * query instance that also contains this `QueryLimitConstraint`.\r\n */\r\nclass QueryLimitConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _limit, _limitType) {\r\n        super();\r\n        this.type = type;\r\n        this._limit = _limit;\r\n        this._limitType = _limitType;\r\n    }\r\n    static _create(type, _limit, _limitType) {\r\n        return new QueryLimitConstraint(type, _limit, _limitType);\r\n    }\r\n    _apply(query) {\r\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\r\n * documents.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link QueryLimitConstraint}.\r\n */\r\nfunction limit(limit) {\r\n    validatePositiveNumber('limit', limit);\r\n    return QueryLimitConstraint._create('limit', limit, \"F\" /* LimitType.First */);\r\n}\r\n/**\r\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\r\n * documents.\r\n *\r\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\r\n * otherwise an exception will be thrown during execution.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link QueryLimitConstraint}.\r\n */\r\nfunction limitToLast(limit) {\r\n    validatePositiveNumber('limitToLast', limit);\r\n    return QueryLimitConstraint._create('limitToLast', limit, \"L\" /* LimitType.Last */);\r\n}\r\n/**\r\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\r\n * result set returned by a Firestore query.\r\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\r\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\r\n * new query instance that also contains this `QueryStartAtConstraint`.\r\n */\r\nclass QueryStartAtConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _docOrFields, _inclusive) {\r\n        super();\r\n        this.type = type;\r\n        this._docOrFields = _docOrFields;\r\n        this._inclusive = _inclusive;\r\n    }\r\n    static _create(type, _docOrFields, _inclusive) {\r\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\r\n    }\r\n    _apply(query) {\r\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\r\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\r\n    }\r\n}\r\nfunction startAt(...docOrFields) {\r\n    return QueryStartAtConstraint._create('startAt', docOrFields, \r\n    /*inclusive=*/ true);\r\n}\r\nfunction startAfter(...docOrFields) {\r\n    return QueryStartAtConstraint._create('startAfter', docOrFields, \r\n    /*inclusive=*/ false);\r\n}\r\n/**\r\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\r\n * result set returned by a Firestore query.\r\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\r\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\r\n * query instance that also contains this `QueryEndAtConstraint`.\r\n */\r\nclass QueryEndAtConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _docOrFields, _inclusive) {\r\n        super();\r\n        this.type = type;\r\n        this._docOrFields = _docOrFields;\r\n        this._inclusive = _inclusive;\r\n    }\r\n    static _create(type, _docOrFields, _inclusive) {\r\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\r\n    }\r\n    _apply(query) {\r\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\r\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\r\n    }\r\n}\r\nfunction endBefore(...docOrFields) {\r\n    return QueryEndAtConstraint._create('endBefore', docOrFields, \r\n    /*inclusive=*/ false);\r\n}\r\nfunction endAt(...docOrFields) {\r\n    return QueryEndAtConstraint._create('endAt', docOrFields, \r\n    /*inclusive=*/ true);\r\n}\r\n/** Helper function to create a bound from a document or fields */\r\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\r\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\r\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\r\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\r\n    }\r\n    else {\r\n        const reader = newUserDataReader(query.firestore);\r\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\r\n    }\r\n}\r\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\r\n    let fieldValue;\r\n    if (fieldPath.isKeyField()) {\r\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\r\n        }\r\n        else if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\r\n            validateDisjunctiveFilterElements(value, op);\r\n            const referenceList = [];\r\n            for (const arrayValue of value) {\r\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\r\n            }\r\n            fieldValue = { arrayValue: { values: referenceList } };\r\n        }\r\n        else {\r\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\r\n        }\r\n    }\r\n    else {\r\n        if (op === \"in\" /* Operator.IN */ ||\r\n            op === \"not-in\" /* Operator.NOT_IN */ ||\r\n            op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n            validateDisjunctiveFilterElements(value, op);\r\n        }\r\n        fieldValue = parseQueryValue(dataReader, methodName, value, \r\n        /* allowArrays= */ op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */);\r\n    }\r\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\r\n    return filter;\r\n}\r\nfunction newQueryOrderBy(query, fieldPath, direction) {\r\n    if (query.startAt !== null) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\r\n            'calling orderBy().');\r\n    }\r\n    if (query.endAt !== null) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\r\n            'calling orderBy().');\r\n    }\r\n    const orderBy = new OrderBy(fieldPath, direction);\r\n    return orderBy;\r\n}\r\n/**\r\n * Create a `Bound` from a query and a document.\r\n *\r\n * Note that the `Bound` will always include the key of the document\r\n * and so only the provided document will compare equal to the returned\r\n * position.\r\n *\r\n * Will throw if the document does not contain all fields of the order by\r\n * of the query or if any of the fields in the order by are an uncommitted\r\n * server timestamp.\r\n */\r\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\r\n    if (!doc) {\r\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\r\n            `${methodName}().`);\r\n    }\r\n    const components = [];\r\n    // Because people expect to continue/end a query at the exact document\r\n    // provided, we need to use the implicit sort order rather than the explicit\r\n    // sort order, because it's guaranteed to contain the document key. That way\r\n    // the position becomes unambiguous and the query continues/ends exactly at\r\n    // the provided document. Without the key (by using the explicit sort\r\n    // orders), multiple documents could match the position, yielding duplicate\r\n    // results.\r\n    for (const orderBy of queryNormalizedOrderBy(query)) {\r\n        if (orderBy.field.isKeyField()) {\r\n            components.push(refValue(databaseId, doc.key));\r\n        }\r\n        else {\r\n            const value = doc.data.field(orderBy.field);\r\n            if (isServerTimestamp(value)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\r\n                    'document for which the field \"' +\r\n                    orderBy.field +\r\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\r\n                    'this field is unknown, you cannot start/end a query with it.)');\r\n            }\r\n            else if (value !== null) {\r\n                components.push(value);\r\n            }\r\n            else {\r\n                const field = orderBy.field.canonicalString();\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\r\n                    `document for which the field '${field}' (used as the ` +\r\n                    `orderBy) does not exist.`);\r\n            }\r\n        }\r\n    }\r\n    return new Bound(components, inclusive);\r\n}\r\n/**\r\n * Converts a list of field values to a `Bound` for the given query.\r\n */\r\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\r\n    // Use explicit order by's because it has to match the query the user made\r\n    const orderBy = query.explicitOrderBy;\r\n    if (values.length > orderBy.length) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\r\n            `The number of arguments must be less than or equal to the ` +\r\n            `number of orderBy() clauses`);\r\n    }\r\n    const components = [];\r\n    for (let i = 0; i < values.length; i++) {\r\n        const rawValue = values[i];\r\n        const orderByComponent = orderBy[i];\r\n        if (orderByComponent.field.isKeyField()) {\r\n            if (typeof rawValue !== 'string') {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\r\n                    `${methodName}(), but got a ${typeof rawValue}`);\r\n            }\r\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\r\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\r\n                    `'${rawValue}' contains a slash.`);\r\n            }\r\n            const path = query.path.child(ResourcePath.fromString(rawValue));\r\n            if (!DocumentKey.isDocumentKey(path)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\r\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\r\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\r\n                    `of segments.`);\r\n            }\r\n            const key = new DocumentKey(path);\r\n            components.push(refValue(databaseId, key));\r\n        }\r\n        else {\r\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\r\n            components.push(wrapped);\r\n        }\r\n    }\r\n    return new Bound(components, inclusive);\r\n}\r\n/**\r\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\r\n * appropriate errors if the value is anything other than a `DocumentReference`\r\n * or `string`, or if the string is malformed.\r\n */\r\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\r\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\r\n    if (typeof documentIdValue === 'string') {\r\n        if (documentIdValue === '') {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\r\n                'must provide a valid document ID, but it was an empty string.');\r\n        }\r\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\r\n                `documentId(), you must provide a plain document ID, but ` +\r\n                `'${documentIdValue}' contains a '/' character.`);\r\n        }\r\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\r\n        if (!DocumentKey.isDocumentKey(path)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\r\n                `documentId(), the value provided must result in a valid document path, ` +\r\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\r\n        }\r\n        return refValue(databaseId, new DocumentKey(path));\r\n    }\r\n    else if (documentIdValue instanceof DocumentReference) {\r\n        return refValue(databaseId, documentIdValue._key);\r\n    }\r\n    else {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\r\n            `string or a DocumentReference, but it was: ` +\r\n            `${valueDescription(documentIdValue)}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that the value passed into a disjunctive filter satisfies all\r\n * array requirements.\r\n */\r\nfunction validateDisjunctiveFilterElements(value, operator) {\r\n    if (!Array.isArray(value) || value.length === 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\r\n            `'${operator.toString()}' filters.`);\r\n    }\r\n}\r\n/**\r\n * Given an operator, returns the set of operators that cannot be used with it.\r\n *\r\n * This is not a comprehensive check, and this function should be removed in the\r\n * long term. Validations should occur in the Firestore backend.\r\n *\r\n * Operators in a query must adhere to the following set of rules:\r\n * 1. Only one inequality per query.\r\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\r\n */\r\nfunction conflictingOps(op) {\r\n    switch (op) {\r\n        case \"!=\" /* Operator.NOT_EQUAL */:\r\n            return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\r\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\r\n        case \"in\" /* Operator.IN */:\r\n            return [\"not-in\" /* Operator.NOT_IN */];\r\n        case \"not-in\" /* Operator.NOT_IN */:\r\n            return [\r\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */,\r\n                \"in\" /* Operator.IN */,\r\n                \"not-in\" /* Operator.NOT_IN */,\r\n                \"!=\" /* Operator.NOT_EQUAL */\r\n            ];\r\n        default:\r\n            return [];\r\n    }\r\n}\r\nfunction validateNewFieldFilter(query, fieldFilter) {\r\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\r\n    if (conflictingOp !== null) {\r\n        // Special case when it's a duplicate op to give a slightly clearer error message.\r\n        if (conflictingOp === fieldFilter.op) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\r\n                `'${fieldFilter.op.toString()}' filter.`);\r\n        }\r\n        else {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\r\n                `with '${conflictingOp.toString()}' filters.`);\r\n        }\r\n    }\r\n}\r\nfunction validateNewFilter(query, filter) {\r\n    let testQuery = query;\r\n    const subFilters = filter.getFlattenedFilters();\r\n    for (const subFilter of subFilters) {\r\n        validateNewFieldFilter(testQuery, subFilter);\r\n        testQuery = queryWithAddedFilter(testQuery, subFilter);\r\n    }\r\n}\r\n// Checks if any of the provided filter operators are included in the given list of filters and\r\n// returns the first one that is, or null if none are.\r\nfunction findOpInsideFilters(filters, operators) {\r\n    for (const filter of filters) {\r\n        for (const fieldFilter of filter.getFlattenedFilters()) {\r\n            if (operators.indexOf(fieldFilter.op) >= 0) {\r\n                return fieldFilter.op;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\r\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&\r\n        !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\r\n    }\r\n}\r\nfunction validateQueryConstraintArray(queryConstraint) {\r\n    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;\r\n    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;\r\n    if (compositeFilterCount > 1 ||\r\n        (compositeFilterCount > 0 && fieldFilterCount > 0)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +\r\n            'more than one filter at the top level. Consider nesting the multiple ' +\r\n            'filters within an `and(...)` statement. For example: ' +\r\n            'change `query(query, where(...), or(...))` to ' +\r\n            '`query(query, and(where(...), or(...)))`.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts Firestore's internal types to the JavaScript types that we expose\r\n * to the user.\r\n *\r\n * @internal\r\n */\r\nclass AbstractUserDataWriter {\r\n    convertValue(value, serverTimestampBehavior = 'none') {\r\n        switch (typeOrder(value)) {\r\n            case 0 /* TypeOrder.NullValue */:\r\n                return null;\r\n            case 1 /* TypeOrder.BooleanValue */:\r\n                return value.booleanValue;\r\n            case 2 /* TypeOrder.NumberValue */:\r\n                return normalizeNumber(value.integerValue || value.doubleValue);\r\n            case 3 /* TypeOrder.TimestampValue */:\r\n                return this.convertTimestamp(value.timestampValue);\r\n            case 4 /* TypeOrder.ServerTimestampValue */:\r\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\r\n            case 5 /* TypeOrder.StringValue */:\r\n                return value.stringValue;\r\n            case 6 /* TypeOrder.BlobValue */:\r\n                return this.convertBytes(normalizeByteString(value.bytesValue));\r\n            case 7 /* TypeOrder.RefValue */:\r\n                return this.convertReference(value.referenceValue);\r\n            case 8 /* TypeOrder.GeoPointValue */:\r\n                return this.convertGeoPoint(value.geoPointValue);\r\n            case 9 /* TypeOrder.ArrayValue */:\r\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\r\n            case 10 /* TypeOrder.ObjectValue */:\r\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\r\n            default:\r\n                throw fail();\r\n        }\r\n    }\r\n    convertObject(mapValue, serverTimestampBehavior) {\r\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    convertObjectMap(fields, serverTimestampBehavior = 'none') {\r\n        const result = {};\r\n        forEach(fields, (key, value) => {\r\n            result[key] = this.convertValue(value, serverTimestampBehavior);\r\n        });\r\n        return result;\r\n    }\r\n    convertGeoPoint(value) {\r\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\r\n    }\r\n    convertArray(arrayValue, serverTimestampBehavior) {\r\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\r\n    }\r\n    convertServerTimestamp(value, serverTimestampBehavior) {\r\n        switch (serverTimestampBehavior) {\r\n            case 'previous':\r\n                const previousValue = getPreviousValue(value);\r\n                if (previousValue == null) {\r\n                    return null;\r\n                }\r\n                return this.convertValue(previousValue, serverTimestampBehavior);\r\n            case 'estimate':\r\n                return this.convertTimestamp(getLocalWriteTime(value));\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    convertTimestamp(value) {\r\n        const normalizedValue = normalizeTimestamp(value);\r\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\r\n    }\r\n    convertDocumentKey(name, expectedDatabaseId) {\r\n        const resourcePath = ResourcePath.fromString(name);\r\n        hardAssert(isValidResourceName(resourcePath));\r\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\r\n        const key = new DocumentKey(resourcePath.popFirst(5));\r\n        if (!databaseId.isEqual(expectedDatabaseId)) {\r\n            // TODO(b/64130202): Somehow support foreign references.\r\n            logError(`Document ${key} contains a document ` +\r\n                `reference within a different database (` +\r\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\r\n                `supported. It will be treated as a reference in the current ` +\r\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\r\n                `instead.`);\r\n        }\r\n        return key;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts custom model object of type T into `DocumentData` by applying the\r\n * converter if it exists.\r\n *\r\n * This function is used when converting user objects to `DocumentData`\r\n * because we want to provide the user with a more specific error message if\r\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\r\n * call.\r\n */\r\nfunction applyFirestoreDataConverter(converter, value, options) {\r\n    let convertedValue;\r\n    if (converter) {\r\n        if (options && (options.merge || options.mergeFields)) {\r\n            // Cast to `any` in order to satisfy the union type constraint on\r\n            // toFirestore().\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            convertedValue = converter.toFirestore(value, options);\r\n        }\r\n        else {\r\n            convertedValue = converter.toFirestore(value);\r\n        }\r\n    }\r\n    else {\r\n        convertedValue = value;\r\n    }\r\n    return convertedValue;\r\n}\r\nclass LiteUserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Bytes(bytes);\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Create an AggregateField object that can be used to compute the sum of\r\n * a specified field over a range of documents in the result set of a query.\r\n * @param field Specifies the field to sum across the result set.\r\n */\r\nfunction sum(field) {\r\n    return new AggregateField('sum', fieldPathFromArgument$1('sum', field));\r\n}\r\n/**\r\n * Create an AggregateField object that can be used to compute the average of\r\n * a specified field over a range of documents in the result set of a query.\r\n * @param field Specifies the field to average across the result set.\r\n */\r\nfunction average(field) {\r\n    return new AggregateField('avg', fieldPathFromArgument$1('average', field));\r\n}\r\n/**\r\n * Create an AggregateField object that can be used to compute the count of\r\n * documents in the result set of a query.\r\n */\r\nfunction count() {\r\n    return new AggregateField('count');\r\n}\r\n/**\r\n * Compares two 'AggregateField` instances for equality.\r\n *\r\n * @param left Compare this AggregateField to the `right`.\r\n * @param right Compare this AggregateField to the `left`.\r\n */\r\nfunction aggregateFieldEqual(left, right) {\r\n    var _a, _b;\r\n    return (left instanceof AggregateField &&\r\n        right instanceof AggregateField &&\r\n        left.aggregateType === right.aggregateType &&\r\n        ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) ===\r\n            ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString()));\r\n}\r\n/**\r\n * Compares two `AggregateQuerySnapshot` instances for equality.\r\n *\r\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\r\n * underlying queries that compare equal, and the same data.\r\n *\r\n * @param left - The first `AggregateQuerySnapshot` to compare.\r\n * @param right - The second `AggregateQuerySnapshot` to compare.\r\n *\r\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\r\n * otherwise.\r\n */\r\nfunction aggregateQuerySnapshotEqual(left, right) {\r\n    return (queryEqual(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(left.data(), right.data()));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isPartialObserver(obj) {\r\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\r\n}\r\n/**\r\n * Returns true if obj is an object and contains at least one of the specified\r\n * methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    const object = obj;\r\n    for (const method of methods) {\r\n        if (method in object && typeof object[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Metadata about a snapshot, describing the state of the snapshot.\r\n */\r\nclass SnapshotMetadata {\r\n    /** @hideconstructor */\r\n    constructor(hasPendingWrites, fromCache) {\r\n        this.hasPendingWrites = hasPendingWrites;\r\n        this.fromCache = fromCache;\r\n    }\r\n    /**\r\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     *\r\n     * @param other - The `SnapshotMetadata` to compare against.\r\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (this.hasPendingWrites === other.hasPendingWrites &&\r\n            this.fromCache === other.fromCache);\r\n    }\r\n}\r\n/**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */\r\nclass DocumentSnapshot extends DocumentSnapshot$1 {\r\n    /** @hideconstructor protected */\r\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\r\n        super(_firestore, userDataWriter, key, document, converter);\r\n        this._firestore = _firestore;\r\n        this._firestoreImpl = _firestore;\r\n        this.metadata = metadata;\r\n    }\r\n    /**\r\n     * Returns whether or not the data exists. True if the document exists.\r\n     */\r\n    exists() {\r\n        return super.exists();\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * By default, `serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @param options - An options object to configure how data is retrieved from\r\n     * the snapshot (for example the desired behavior for server timestamps that\r\n     * have not yet been set to their final value).\r\n     * @returns An `Object` containing all fields in the document or `undefined` if\r\n     * the document doesn't exist.\r\n     */\r\n    data(options = {}) {\r\n        if (!this._document) {\r\n            return undefined;\r\n        }\r\n        else if (this._converter) {\r\n            // We only want to use the converter and create a new DocumentSnapshot\r\n            // if a converter has been provided.\r\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \r\n            /* converter= */ null);\r\n            return this._converter.fromFirestore(snapshot, options);\r\n        }\r\n        else {\r\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * By default, a `serverTimestamp()` that has not yet been set to\r\n     * its final value will be returned as `null`. You can override this by\r\n     * passing an options object.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @param options - An options object to configure how the field is retrieved\r\n     * from the snapshot (for example the desired behavior for server timestamps\r\n     * that have not yet been set to their final value).\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(fieldPath, options = {}) {\r\n        if (this._document) {\r\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\r\n            if (value !== null) {\r\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */\r\nclass QueryDocumentSnapshot extends DocumentSnapshot {\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * By default, `serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @override\r\n     * @param options - An options object to configure how data is retrieved from\r\n     * the snapshot (for example the desired behavior for server timestamps that\r\n     * have not yet been set to their final value).\r\n     * @returns An `Object` containing all fields in the document.\r\n     */\r\n    data(options = {}) {\r\n        return super.data(options);\r\n    }\r\n}\r\n/**\r\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\r\n * representing the results of a query. The documents can be accessed as an\r\n * array via the `docs` property or enumerated using the `forEach` method. The\r\n * number of documents can be determined via the `empty` and `size`\r\n * properties.\r\n */\r\nclass QuerySnapshot {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._snapshot = _snapshot;\r\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\r\n        this.query = query;\r\n    }\r\n    /** An array of all the documents in the `QuerySnapshot`. */\r\n    get docs() {\r\n        const result = [];\r\n        this.forEach(doc => result.push(doc));\r\n        return result;\r\n    }\r\n    /** The number of documents in the `QuerySnapshot`. */\r\n    get size() {\r\n        return this._snapshot.docs.size;\r\n    }\r\n    /** True if there are no documents in the `QuerySnapshot`. */\r\n    get empty() {\r\n        return this.size === 0;\r\n    }\r\n    /**\r\n     * Enumerates all of the documents in the `QuerySnapshot`.\r\n     *\r\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\r\n     * each document in the snapshot.\r\n     * @param thisArg - The `this` binding for the callback.\r\n     */\r\n    forEach(callback, thisArg) {\r\n        this._snapshot.docs.forEach(doc => {\r\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\r\n        });\r\n    }\r\n    /**\r\n     * Returns an array of the documents changes since the last snapshot. If this\r\n     * is the first snapshot, all documents will be in the list as 'added'\r\n     * changes.\r\n     *\r\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\r\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\r\n     * snapshot events.\r\n     */\r\n    docChanges(options = {}) {\r\n        const includeMetadataChanges = !!options.includeMetadataChanges;\r\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\r\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\r\n        }\r\n        if (!this._cachedChanges ||\r\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\r\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\r\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\r\n        }\r\n        return this._cachedChanges;\r\n    }\r\n}\r\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\r\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\r\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\r\n        let index = 0;\r\n        return querySnapshot._snapshot.docChanges.map(change => {\r\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\r\n            change.doc;\r\n            return {\r\n                type: 'added',\r\n                doc,\r\n                oldIndex: -1,\r\n                newIndex: index++\r\n            };\r\n        });\r\n    }\r\n    else {\r\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\r\n        // to lookup the index of a document.\r\n        let indexTracker = querySnapshot._snapshot.oldDocs;\r\n        return querySnapshot._snapshot.docChanges\r\n            .filter(change => includeMetadataChanges || change.type !== 3 /* ChangeType.Metadata */)\r\n            .map(change => {\r\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\r\n            let oldIndex = -1;\r\n            let newIndex = -1;\r\n            if (change.type !== 0 /* ChangeType.Added */) {\r\n                oldIndex = indexTracker.indexOf(change.doc.key);\r\n                indexTracker = indexTracker.delete(change.doc.key);\r\n            }\r\n            if (change.type !== 1 /* ChangeType.Removed */) {\r\n                indexTracker = indexTracker.add(change.doc);\r\n                newIndex = indexTracker.indexOf(change.doc.key);\r\n            }\r\n            return {\r\n                type: resultChangeType(change.type),\r\n                doc,\r\n                oldIndex,\r\n                newIndex\r\n            };\r\n        });\r\n    }\r\n}\r\nfunction resultChangeType(type) {\r\n    switch (type) {\r\n        case 0 /* ChangeType.Added */:\r\n            return 'added';\r\n        case 2 /* ChangeType.Modified */:\r\n        case 3 /* ChangeType.Metadata */:\r\n            return 'modified';\r\n        case 1 /* ChangeType.Removed */:\r\n            return 'removed';\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\r\n// metadata\r\n/**\r\n * Returns true if the provided snapshots are equal.\r\n *\r\n * @param left - A snapshot to compare.\r\n * @param right - A snapshot to compare.\r\n * @returns true if the snapshots are equal.\r\n */\r\nfunction snapshotEqual(left, right) {\r\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\r\n        return (left._firestore === right._firestore &&\r\n            left._key.isEqual(right._key) &&\r\n            (left._document === null\r\n                ? right._document === null\r\n                : left._document.isEqual(right._document)) &&\r\n            left._converter === right._converter);\r\n    }\r\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\r\n        return (left._firestore === right._firestore &&\r\n            queryEqual(left.query, right.query) &&\r\n            left.metadata.isEqual(right.metadata) &&\r\n            left._snapshot.isEqual(right._snapshot));\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Reads the document referred to by this `DocumentReference`.\r\n *\r\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\r\n * for data from the server, but it may return cached data or fail if you are\r\n * offline and the server cannot be reached. To specify this behavior, invoke\r\n * {@link getDocFromCache} or {@link getDocFromServer}.\r\n *\r\n * @param reference - The reference of the document to fetch.\r\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDoc(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\r\n}\r\nclass ExpUserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Bytes(bytes);\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\r\n    }\r\n}\r\n/**\r\n * Reads the document referred to by this `DocumentReference` from cache.\r\n * Returns an error if the document is not currently cached.\r\n *\r\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDocFromCache(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \r\n    /* fromCache= */ true), reference.converter));\r\n}\r\n/**\r\n * Reads the document referred to by this `DocumentReference` from the server.\r\n * Returns an error if the network is not available.\r\n *\r\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDocFromServer(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\r\n        source: 'server'\r\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot`.\r\n *\r\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\r\n * waiting for data from the server, but it may return cached data or fail if\r\n * you are offline and the server cannot be reached. To specify this behavior,\r\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocs(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    validateHasExplicitOrderByForLimitToLast(query._query);\r\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\r\n * Returns an empty result set if no documents matching the query are currently\r\n * cached.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocsFromCache(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot` from the\r\n * server. Returns an error if the network is not available.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocsFromServer(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\r\n        source: 'server'\r\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\nfunction setDoc(reference, data, options) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\r\n    const dataReader = newUserDataReader(firestore);\r\n    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\r\n    const mutation = parsed.toMutation(reference._key, Precondition.none());\r\n    return executeWrite(firestore, [mutation]);\r\n}\r\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const dataReader = newUserDataReader(firestore);\r\n    // For Compat types, we have to \"extract\" the underlying types before\r\n    // performing validation.\r\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n    let parsed;\r\n    if (typeof fieldOrUpdateData === 'string' ||\r\n        fieldOrUpdateData instanceof FieldPath) {\r\n        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n    }\r\n    else {\r\n        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\r\n    }\r\n    const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\r\n    return executeWrite(firestore, [mutation]);\r\n}\r\n/**\r\n * Deletes the document referred to by the specified `DocumentReference`.\r\n *\r\n * @param reference - A reference to the document to delete.\r\n * @returns A Promise resolved once the document has been successfully\r\n * deleted from the backend (note that it won't resolve while you're offline).\r\n */\r\nfunction deleteDoc(reference) {\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const mutations = [new DeleteMutation(reference._key, Precondition.none())];\r\n    return executeWrite(firestore, mutations);\r\n}\r\n/**\r\n * Add a new document to specified `CollectionReference` with the given data,\r\n * assigning it a document ID automatically.\r\n *\r\n * @param reference - A reference to the collection to add this document to.\r\n * @param data - An Object containing the data for the new document.\r\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\r\n * newly created document after it has been written to the backend (Note that it\r\n * won't resolve while you're offline).\r\n */\r\nfunction addDoc(reference, data) {\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const docRef = doc(reference);\r\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\r\n    const dataReader = newUserDataReader(reference.firestore);\r\n    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\r\n    const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\r\n    return executeWrite(firestore, [mutation]).then(() => docRef);\r\n}\r\nfunction onSnapshot(reference, ...args) {\r\n    var _a, _b, _c;\r\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(reference);\r\n    let options = {\r\n        includeMetadataChanges: false,\r\n        source: 'default'\r\n    };\r\n    let currArg = 0;\r\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\r\n        options = args[currArg];\r\n        currArg++;\r\n    }\r\n    const internalOptions = {\r\n        includeMetadataChanges: options.includeMetadataChanges,\r\n        source: options.source\r\n    };\r\n    if (isPartialObserver(args[currArg])) {\r\n        const userObserver = args[currArg];\r\n        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);\r\n        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);\r\n        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);\r\n    }\r\n    let observer;\r\n    let firestore;\r\n    let internalQuery;\r\n    if (reference instanceof DocumentReference) {\r\n        firestore = cast(reference.firestore, Firestore);\r\n        internalQuery = newQueryForPath(reference._key.path);\r\n        observer = {\r\n            next: snapshot => {\r\n                if (args[currArg]) {\r\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\r\n                }\r\n            },\r\n            error: args[currArg + 1],\r\n            complete: args[currArg + 2]\r\n        };\r\n    }\r\n    else {\r\n        const query = cast(reference, Query);\r\n        firestore = cast(query.firestore, Firestore);\r\n        internalQuery = query._query;\r\n        const userDataWriter = new ExpUserDataWriter(firestore);\r\n        observer = {\r\n            next: snapshot => {\r\n                if (args[currArg]) {\r\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n                }\r\n            },\r\n            error: args[currArg + 1],\r\n            complete: args[currArg + 2]\r\n        };\r\n        validateHasExplicitOrderByForLimitToLast(reference._query);\r\n    }\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientListen(client, internalQuery, internalOptions, observer);\r\n}\r\nfunction onSnapshotsInSync(firestore, arg) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const observer = isPartialObserver(arg)\r\n        ? arg\r\n        : {\r\n            next: arg\r\n        };\r\n    return firestoreClientAddSnapshotsInSyncListener(client, observer);\r\n}\r\n/**\r\n * Locally writes `mutations` on the async queue.\r\n * @internal\r\n */\r\nfunction executeWrite(firestore, mutations) {\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientWrite(client, mutations);\r\n}\r\n/**\r\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\r\n * to a {@link DocumentSnapshot}.\r\n */\r\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\r\n    const doc = snapshot.docs.get(ref._key);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Calculates the number of documents in the result set of the given query\r\n * without actually downloading the documents.\r\n *\r\n * Using this function to count the documents is efficient because only the\r\n * final count, not the documents' data, is downloaded. This function can\r\n * count the documents in cases where the result set is prohibitively large to\r\n * download entirely (thousands of documents).\r\n *\r\n * The result received from the server is presented, unaltered, without\r\n * considering any local state. That is, documents in the local cache are not\r\n * taken into consideration, neither are local modifications not yet\r\n * synchronized with the server. Previously-downloaded results, if any, are not\r\n * used. Every invocation of this function necessarily involves a round trip to\r\n * the server.\r\n *\r\n * @param query The query whose result set size is calculated.\r\n * @returns A Promise that will be resolved with the count; the count can be\r\n * retrieved from `snapshot.data().count`, where `snapshot` is the\r\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\r\n */\r\nfunction getCountFromServer(query) {\r\n    const countQuerySpec = {\r\n        count: count()\r\n    };\r\n    return getAggregateFromServer(query, countQuerySpec);\r\n}\r\n/**\r\n * Calculates the specified aggregations over the documents in the result\r\n * set of the given query without actually downloading the documents.\r\n *\r\n * Using this function to perform aggregations is efficient because only the\r\n * final aggregation values, not the documents' data, are downloaded. This\r\n * function can perform aggregations of the documents in cases where the result\r\n * set is prohibitively large to download entirely (thousands of documents).\r\n *\r\n * The result received from the server is presented, unaltered, without\r\n * considering any local state. That is, documents in the local cache are not\r\n * taken into consideration, neither are local modifications not yet\r\n * synchronized with the server. Previously-downloaded results, if any, are not\r\n * used. Every invocation of this function necessarily involves a round trip to\r\n * the server.\r\n *\r\n * @param query The query whose result set is aggregated over.\r\n * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\r\n * to perform over the result set. The AggregateSpec specifies aliases for each\r\n * aggregate, which can be used to retrieve the aggregate result.\r\n * @example\r\n * ```typescript\r\n * const aggregateSnapshot = await getAggregateFromServer(query, {\r\n *   countOfDocs: count(),\r\n *   totalHours: sum('hours'),\r\n *   averageScore: average('score')\r\n * });\r\n *\r\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\r\n * const totalHours: number = aggregateSnapshot.data().totalHours;\r\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\r\n * ```\r\n */\r\nfunction getAggregateFromServer(query, aggregateSpec) {\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\r\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\r\n    });\r\n    // Run the aggregation and convert the results\r\n    return firestoreClientRunAggregateQuery(client, query._query, internalAggregates).then(aggregateResult => convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\r\n}\r\n/**\r\n * Converts the core aggregration result to an `AggregateQuerySnapshot`\r\n * that can be returned to the consumer.\r\n * @param query\r\n * @param aggregateResult Core aggregation result\r\n * @internal\r\n */\r\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\r\n    return querySnapshot;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryLocalCacheImpl {\r\n    constructor(settings) {\r\n        this.kind = 'memory';\r\n        this._onlineComponentProvider = new OnlineComponentProvider();\r\n        if (settings === null || settings === void 0 ? void 0 : settings.garbageCollector) {\r\n            this._offlineComponentProvider =\r\n                settings.garbageCollector._offlineComponentProvider;\r\n        }\r\n        else {\r\n            this._offlineComponentProvider = new MemoryOfflineComponentProvider();\r\n        }\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\nclass PersistentLocalCacheImpl {\r\n    constructor(settings) {\r\n        this.kind = 'persistent';\r\n        let tabManager;\r\n        if (settings === null || settings === void 0 ? void 0 : settings.tabManager) {\r\n            settings.tabManager._initialize(settings);\r\n            tabManager = settings.tabManager;\r\n        }\r\n        else {\r\n            tabManager = persistentSingleTabManager(undefined);\r\n            tabManager._initialize(settings);\r\n        }\r\n        this._onlineComponentProvider = tabManager._onlineComponentProvider;\r\n        this._offlineComponentProvider = tabManager._offlineComponentProvider;\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\nclass MemoryEagerGabageCollectorImpl {\r\n    constructor() {\r\n        this.kind = 'memoryEager';\r\n        this._offlineComponentProvider = new MemoryOfflineComponentProvider();\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\nclass MemoryLruGabageCollectorImpl {\r\n    constructor(cacheSize) {\r\n        this.kind = 'memoryLru';\r\n        this._offlineComponentProvider = new LruGcMemoryOfflineComponentProvider(cacheSize);\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\n/**\r\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\r\n * default garbage collector unless it is explicitly specified otherwise.\r\n */\r\nfunction memoryEagerGarbageCollector() {\r\n    return new MemoryEagerGabageCollectorImpl();\r\n}\r\n/**\r\n * Creates an instance of `MemoryLruGarbageCollector`.\r\n *\r\n * A target size can be specified as part of the setting parameter. The\r\n * collector will start deleting documents once the cache size exceeds\r\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\r\n */\r\nfunction memoryLruGarbageCollector(settings) {\r\n    return new MemoryLruGabageCollectorImpl(settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\r\n}\r\n/**\r\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\r\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\r\n */\r\nfunction memoryLocalCache(settings) {\r\n    return new MemoryLocalCacheImpl(settings);\r\n}\r\n/**\r\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\r\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\r\n *\r\n * Persistent cache cannot be used in a Node.js environment.\r\n */\r\nfunction persistentLocalCache(settings) {\r\n    return new PersistentLocalCacheImpl(settings);\r\n}\r\nclass SingleTabManagerImpl {\r\n    constructor(forceOwnership) {\r\n        this.forceOwnership = forceOwnership;\r\n        this.kind = 'persistentSingleTab';\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _initialize(settings) {\r\n        this._onlineComponentProvider = new OnlineComponentProvider();\r\n        this._offlineComponentProvider = new IndexedDbOfflineComponentProvider(this._onlineComponentProvider, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes, this.forceOwnership);\r\n    }\r\n}\r\nclass MultiTabManagerImpl {\r\n    constructor() {\r\n        this.kind = 'PersistentMultipleTab';\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _initialize(settings) {\r\n        this._onlineComponentProvider = new OnlineComponentProvider();\r\n        this._offlineComponentProvider = new MultiTabOfflineComponentProvider(this._onlineComponentProvider, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\r\n    }\r\n}\r\n/**\r\n * Creates an instance of `PersistentSingleTabManager`.\r\n *\r\n * @param settings Configures the created tab manager.\r\n */\r\nfunction persistentSingleTabManager(settings) {\r\n    return new SingleTabManagerImpl(settings === null || settings === void 0 ? void 0 : settings.forceOwnership);\r\n}\r\n/**\r\n * Creates an instance of `PersistentMultipleTabManager`.\r\n */\r\nfunction persistentMultipleTabManager() {\r\n    return new MultiTabManagerImpl();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_TRANSACTION_OPTIONS = {\r\n    maxAttempts: 5\r\n};\r\nfunction validateTransactionOptions(options) {\r\n    if (options.maxAttempts < 1) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Max attempts must be at least 1');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A write batch, used to perform multiple writes as a single atomic unit.\r\n *\r\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\r\n * provides methods for adding writes to the write batch. None of the writes\r\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\r\n * called.\r\n */\r\nclass WriteBatch {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _commitHandler) {\r\n        this._firestore = _firestore;\r\n        this._commitHandler = _commitHandler;\r\n        this._mutations = [];\r\n        this._committed = false;\r\n        this._dataReader = newUserDataReader(_firestore);\r\n    }\r\n    set(documentRef, data, options) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\r\n        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\r\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\r\n        return this;\r\n    }\r\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n        let parsed;\r\n        if (typeof fieldOrUpdateData === 'string' ||\r\n            fieldOrUpdateData instanceof FieldPath) {\r\n            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n        }\r\n        else {\r\n            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\r\n        }\r\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\r\n        return this;\r\n    }\r\n    /**\r\n     * Commits all of the writes in this write batch as a single atomic unit.\r\n     *\r\n     * The result of these writes will only be reflected in document reads that\r\n     * occur after the returned promise resolves. If the client is offline, the\r\n     * write fails. If you would like to see local modifications or buffer writes\r\n     * until the client is online, use the full Firestore SDK.\r\n     *\r\n     * @returns A `Promise` resolved once all of the writes in the batch have been\r\n     * successfully written to the backend as an atomic unit (note that it won't\r\n     * resolve while you're offline).\r\n     */\r\n    commit() {\r\n        this._verifyNotCommitted();\r\n        this._committed = true;\r\n        if (this._mutations.length > 0) {\r\n            return this._commitHandler(this._mutations);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _verifyNotCommitted() {\r\n        if (this._committed) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\r\n                'has been called.');\r\n        }\r\n    }\r\n}\r\nfunction validateReference(documentRef, firestore) {\r\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\r\n    if (documentRef.firestore !== firestore) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\r\n    }\r\n    else {\r\n        return documentRef;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\r\n// legacy SDK.\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */\r\nclass Transaction$1 {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _transaction) {\r\n        this._firestore = _firestore;\r\n        this._transaction = _transaction;\r\n        this._dataReader = newUserDataReader(_firestore);\r\n    }\r\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */\r\n    get(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\r\n        return this._transaction.lookup([ref._key]).then(docs => {\r\n            if (!docs || docs.length !== 1) {\r\n                return fail();\r\n            }\r\n            const doc = docs[0];\r\n            if (doc.isFoundDocument()) {\r\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\r\n            }\r\n            else if (doc.isNoDocument()) {\r\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\r\n            }\r\n            else {\r\n                throw fail();\r\n            }\r\n        });\r\n    }\r\n    set(documentRef, value, options) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\r\n        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\r\n        this._transaction.set(ref._key, parsed);\r\n        return this;\r\n    }\r\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n        let parsed;\r\n        if (typeof fieldOrUpdateData === 'string' ||\r\n            fieldOrUpdateData instanceof FieldPath) {\r\n            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n        }\r\n        else {\r\n            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\r\n        }\r\n        this._transaction.update(ref._key, parsed);\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        this._transaction.delete(ref._key);\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */\r\nclass Transaction extends Transaction$1 {\r\n    // This class implements the same logic as the Transaction API in the Lite SDK\r\n    // but is subclassed in order to return its own DocumentSnapshot types.\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _transaction) {\r\n        super(_firestore, _transaction);\r\n        this._firestore = _firestore;\r\n    }\r\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */\r\n    get(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const userDataWriter = new ExpUserDataWriter(this._firestore);\r\n        return super\r\n            .get(documentRef)\r\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\r\n        /* hasPendingWrites= */ false, \r\n        /* fromCache= */ false), ref.converter));\r\n    }\r\n}\r\n/**\r\n * Executes the given `updateFunction` and then attempts to commit the changes\r\n * applied within the transaction. If any document read within the transaction\r\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\r\n * commit after 5 attempts, the transaction fails.\r\n *\r\n * The maximum number of writes allowed in a single transaction is 500.\r\n *\r\n * @param firestore - A reference to the Firestore database to run this\r\n * transaction against.\r\n * @param updateFunction - The function to execute within the transaction\r\n * context.\r\n * @param options - An options object to configure maximum number of attempts to\r\n * commit.\r\n * @returns If the transaction completed successfully or was explicitly aborted\r\n * (the `updateFunction` returned a failed promise), the promise returned by the\r\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\r\n * rejected promise with the corresponding failure error is returned.\r\n */\r\nfunction runTransaction(firestore, updateFunction, options) {\r\n    firestore = cast(firestore, Firestore);\r\n    const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);\r\n    validateTransactionOptions(optionsWithDefaults);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientTransaction(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), optionsWithDefaults);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\r\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\r\n */\r\nfunction deleteField() {\r\n    return new DeleteFieldValueImpl('deleteField');\r\n}\r\n/**\r\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\r\n * include a server-generated timestamp in the written data.\r\n */\r\nfunction serverTimestamp() {\r\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\r\n * value that already exists on the server. Each specified element that doesn't\r\n * already exist in the array will be added to the end. If the field being\r\n * modified is not already an array it will be overwritten with an array\r\n * containing exactly the specified elements.\r\n *\r\n * @param elements - The elements to union into the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`.\r\n */\r\nfunction arrayUnion(...elements) {\r\n    // NOTE: We don't actually parse the data until it's used in set() or\r\n    // update() since we'd need the Firestore instance to do this.\r\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\r\n * updateDoc:1} that tells the server to remove the given elements from any\r\n * array value that already exists on the server. All instances of each element\r\n * specified will be removed from the array. If the field being modified is not\r\n * already an array it will be overwritten with an empty array.\r\n *\r\n * @param elements - The elements to remove from the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */\r\nfunction arrayRemove(...elements) {\r\n    // NOTE: We don't actually parse the data until it's used in set() or\r\n    // update() since we'd need the Firestore instance to do this.\r\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\r\n * the given value.\r\n *\r\n * If either the operand or the current field value uses floating point\r\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\r\n * integers, values outside of JavaScript's safe number range\r\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\r\n * precision loss. Furthermore, once processed by the Firestore backend, all\r\n * integer operations are capped between -2^63 and 2^63-1.\r\n *\r\n * If the current field value is not of type `number`, or if the field does not\r\n * yet exist, the transformation sets the field to the given value.\r\n *\r\n * @param n - The value to increment by.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */\r\nfunction increment(n) {\r\n    return new NumericIncrementFieldValueImpl('increment', n);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a write batch, used for performing multiple writes as a single\r\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\r\n * is 500.\r\n *\r\n * Unlike transactions, write batches are persisted offline and therefore are\r\n * preferable when you don't need to condition your writes on read data.\r\n *\r\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\r\n * writes.\r\n */\r\nfunction writeBatch(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    ensureFirestoreConfigured(firestore);\r\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (!client._uninitializedComponentsProvider ||\r\n        ((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offlineKind) === 'memory') {\r\n        // PORTING NOTE: We don't return an error if the user has not enabled\r\n        // persistence since `enableIndexeddbPersistence()` can fail on the Web.\r\n        logWarn('Cannot enable indexes when persistence is disabled');\r\n        return Promise.resolve();\r\n    }\r\n    const parsedIndexes = parseIndexes(jsonOrConfiguration);\r\n    return firestoreClientSetIndexConfiguration(client, parsedIndexes);\r\n}\r\nfunction parseIndexes(jsonOrConfiguration) {\r\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\r\n        ? tryParseJson(jsonOrConfiguration)\r\n        : jsonOrConfiguration;\r\n    const parsedIndexes = [];\r\n    if (Array.isArray(indexConfiguration.indexes)) {\r\n        for (const index of indexConfiguration.indexes) {\r\n            const collectionGroup = tryGetString(index, 'collectionGroup');\r\n            const segments = [];\r\n            if (Array.isArray(index.fields)) {\r\n                for (const field of index.fields) {\r\n                    const fieldPathString = tryGetString(field, 'fieldPath');\r\n                    const fieldPath = fieldPathFromDotSeparatedString('setIndexConfiguration', fieldPathString);\r\n                    if (field.arrayConfig === 'CONTAINS') {\r\n                        segments.push(new IndexSegment(fieldPath, 2 /* IndexKind.CONTAINS */));\r\n                    }\r\n                    else if (field.order === 'ASCENDING') {\r\n                        segments.push(new IndexSegment(fieldPath, 0 /* IndexKind.ASCENDING */));\r\n                    }\r\n                    else if (field.order === 'DESCENDING') {\r\n                        segments.push(new IndexSegment(fieldPath, 1 /* IndexKind.DESCENDING */));\r\n                    }\r\n                }\r\n            }\r\n            parsedIndexes.push(new FieldIndex(FieldIndex.UNKNOWN_ID, collectionGroup, segments, IndexState.empty()));\r\n        }\r\n    }\r\n    return parsedIndexes;\r\n}\r\nfunction tryParseJson(json) {\r\n    try {\r\n        return JSON.parse(json);\r\n    }\r\n    catch (e) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to parse JSON: ' + (e === null || e === void 0 ? void 0 : e.message));\r\n    }\r\n}\r\nfunction tryGetString(data, property) {\r\n    if (typeof data[property] !== 'string') {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Missing string value for: ' + property);\r\n    }\r\n    return data[property];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\r\n * for local query execution.\r\n *\r\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\r\n */\r\nclass PersistentCacheIndexManager {\r\n    /** @hideconstructor */\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'PersistentCacheIndexManager';\r\n    }\r\n}\r\n/**\r\n * Returns the PersistentCache Index Manager used by the given `Firestore`\r\n * object.\r\n *\r\n * @return The `PersistentCacheIndexManager` instance, or `null` if local\r\n * persistent storage is not in use.\r\n */\r\nfunction getPersistentCacheIndexManager(firestore) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore);\r\n    const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\r\n    if (cachedInstance) {\r\n        return cachedInstance;\r\n    }\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offlineKind) !== 'persistent') {\r\n        return null;\r\n    }\r\n    const instance = new PersistentCacheIndexManager(client);\r\n    persistentCacheIndexManagerByFirestore.set(firestore, instance);\r\n    return instance;\r\n}\r\n/**\r\n * Enables the SDK to create persistent cache indexes automatically for local\r\n * query execution when the SDK believes cache indexes can help improve\r\n * performance.\r\n *\r\n * This feature is disabled by default.\r\n */\r\nfunction enablePersistentCacheIndexAutoCreation(indexManager) {\r\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\r\n}\r\n/**\r\n * Stops creating persistent cache indexes automatically for local query\r\n * execution. The indexes which have been created by calling\r\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\r\n */\r\nfunction disablePersistentCacheIndexAutoCreation(indexManager) {\r\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\r\n}\r\n/**\r\n * Removes all persistent cache indexes.\r\n *\r\n * Please note this function will also deletes indexes generated by\r\n * `setIndexConfiguration()`, which is deprecated.\r\n */\r\nfunction deleteAllPersistentCacheIndexes(indexManager) {\r\n    indexManager._client.verifyNotTerminated();\r\n    const promise = firestoreClientDeleteAllFieldIndexes(indexManager._client);\r\n    promise\r\n        .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\r\n        .catch(error => logWarn('deleting all persistent cache indexes failed', error));\r\n}\r\nfunction setPersistentCacheIndexAutoCreationEnabled(indexManager, isEnabled) {\r\n    indexManager._client.verifyNotTerminated();\r\n    const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(indexManager._client, isEnabled);\r\n    promise\r\n        .then(_ => logDebug(`setting persistent cache index auto creation ` +\r\n        `isEnabled=${isEnabled} succeeded`))\r\n        .catch(error => logWarn(`setting persistent cache index auto creation ` +\r\n        `isEnabled=${isEnabled} failed`, error));\r\n}\r\n/**\r\n * Maps `Firestore` instances to their corresponding\r\n * `PersistentCacheIndexManager` instances.\r\n *\r\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\r\n * `Firestore` instance is garbage collected. This emulates a private member\r\n * as described in https://goo.gle/454yvug.\r\n */\r\nconst persistentCacheIndexManagerByFirestore = new WeakMap();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n * @private\r\n *\r\n * This function is for internal use only.\r\n *\r\n * Returns the `QueryTarget` representation of the given query. Returns `null`\r\n * if the Firestore client associated with the given query has not been\r\n * initialized or has been terminated.\r\n *\r\n * @param query - The Query to convert to proto representation.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction _internalQueryToProtoQueryTarget(query) {\r\n    var _a;\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\r\n    if (serializer === undefined) {\r\n        return null;\r\n    }\r\n    return toQueryTarget(serializer, queryToTarget(query._query)).queryTarget;\r\n}\r\n/**\r\n * @internal\r\n * @private\r\n *\r\n * This function is for internal use only.\r\n *\r\n * Returns `RunAggregationQueryRequest` which contains the proto representation\r\n * of the given aggregation query request. Returns null if the Firestore client\r\n * associated with the given query has not been initialized or has been\r\n * terminated.\r\n *\r\n * @param query - The Query to convert to proto representation.\r\n * @param aggregateSpec - The set of aggregations and their aliases.\r\n */\r\nfunction _internalAggregationQueryToProtoRunAggregationQueryRequest(query, aggregateSpec) {\r\n    var _a;\r\n    const aggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\r\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\r\n    });\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\r\n    if (serializer === undefined) {\r\n        return null;\r\n    }\r\n    return toRunAggregationQueryRequest(serializer, queryToAggregateTarget(query._query), aggregates, \r\n    /* skipAliasing= */ true).request;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Testing hooks for use by Firestore's integration test suite to reach into the\r\n * SDK internals to validate logic and behavior that is not visible from the\r\n * public API surface.\r\n *\r\n * @internal\r\n */\r\nclass TestingHooks {\r\n    constructor() {\r\n        throw new Error('instances of this class should not be created');\r\n    }\r\n    /**\r\n     * Registers a callback to be notified when an existence filter mismatch\r\n     * occurs in the Watch listen stream.\r\n     *\r\n     * The relative order in which callbacks are notified is unspecified; do not\r\n     * rely on any particular ordering. If a given callback is registered multiple\r\n     * times then it will be notified multiple times, once per registration.\r\n     *\r\n     * @param callback the callback to invoke upon existence filter mismatch.\r\n     *\r\n     * @return a function that, when called, unregisters the given callback; only\r\n     * the first invocation of the returned function does anything; all subsequent\r\n     * invocations do nothing.\r\n     */\r\n    static onExistenceFilterMismatch(callback) {\r\n        return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\r\n    }\r\n}\r\n/**\r\n * The implementation of `TestingHooksSpi`.\r\n */\r\nclass TestingHooksSpiImpl {\r\n    constructor() {\r\n        this.existenceFilterMismatchCallbacksById = new Map();\r\n    }\r\n    static get instance() {\r\n        if (!testingHooksSpiImplInstance) {\r\n            testingHooksSpiImplInstance = new TestingHooksSpiImpl();\r\n            setTestingHooksSpi(testingHooksSpiImplInstance);\r\n        }\r\n        return testingHooksSpiImplInstance;\r\n    }\r\n    notifyOnExistenceFilterMismatch(info) {\r\n        this.existenceFilterMismatchCallbacksById.forEach(callback => callback(info));\r\n    }\r\n    onExistenceFilterMismatch(callback) {\r\n        const id = Symbol();\r\n        const callbacks = this.existenceFilterMismatchCallbacksById;\r\n        callbacks.set(id, callback);\r\n        return () => callbacks.delete(id);\r\n    }\r\n}\r\nlet testingHooksSpiImplInstance = null;\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnSjtBQUNoRztBQUNJO0FBQ0s7QUFDb0g7QUFDdkg7QUFDaUI7QUFDakM7QUFDWTs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFPLFVBQVUsWUFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0Esc0NBQXNDLFlBQVksS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QztBQUNBLHFDQUFxQyxZQUFZLEtBQUssSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsVUFBVSxVQUFVLEtBQUssYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBDQUEwQywwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0hBQWdIO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQXVEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsTUFBTSwyQkFBMkIsS0FBSyw4QkFBOEIsWUFBWSxHQUFHLE9BQU8sYUFBYTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxREFBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUs7QUFDeEI7QUFDQSwwQ0FBMEMsV0FBVyxnQkFBZ0I7QUFDckU7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVcsWUFBWSxNQUFNO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRSxHQUFHLEVBQUU7QUFDeEM7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLEVBQUUseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFxRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBK0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsR0FBRywwQkFBMEI7QUFDNUU7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsR0FBRyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxHQUFHLG9DQUFvQztBQUNoRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUIsYUFBYSxvQkFBb0IsYUFBYSwyQkFBMkI7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBLG1DQUFtQyxjQUFjLG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLElBQUksYUFBYSxJQUFJLGdDQUFnQztBQUMxRixjQUFjLGNBQWMsaUJBQWlCO0FBQzdDLGNBQWMsZ0JBQWdCLG1CQUFtQjtBQUNqRCxjQUFjLGlCQUFpQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUNBQWlDLEdBQUcsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLEdBQUcsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDLEVBQUUsV0FBVyxFQUFFLDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQyxNQUFNLGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QyxZQUFZLGdCQUFnQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0RUFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0VBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0RUFBTztBQUNoQyx5QkFBeUIsNEVBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEVBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0RUFBTztBQUN0RDtBQUNBO0FBQ0EsNEJBQTRCLDRFQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLDBCQUEwQixrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFLDhCQUE4QixvQkFBb0I7QUFDbEQsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0IsR0FBRyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksMkJBQTJCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCLGFBQWEsdUJBQXVCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFnRTtBQUN2RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsYUFBYSxXQUFXO0FBQ3JHLCtDQUErQyx5Q0FBeUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkNBQTZDO0FBQ3RGLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0EsNENBQTRDLDJCQUEyQjtBQUN2RSx3REFBd0QsMEJBQTBCO0FBQ2xGLHVCQUF1QixxQ0FBcUM7QUFDNUQsaUNBQWlDLGdCQUFnQjtBQUNqRCx1QkFBdUIscUNBQXFDO0FBQzVELGlDQUFpQyxrQkFBa0I7QUFDbkQsdUJBQXVCLHNDQUFzQztBQUM3RCx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QixzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFlBQVk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtHQUErRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZHQUE2RyxjQUFjO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUhBQXFILGNBQWM7QUFDbkk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBGQUEwRixjQUFjO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtJQUFrSSxlQUFlO0FBQ2pKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0dBQXdHLGVBQWU7QUFDdkg7QUFDQTtBQUNBLEtBQUs7QUFDTCxrR0FBa0csZUFBZTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxSUFBcUksZUFBZTtBQUNwSix1SUFBdUksZUFBZTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtFQUErRSxPQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYyxJQUFJLGNBQWM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsSUFBSSw2QkFBNkI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCLEdBQUcsb0JBQW9CLEdBQUcsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVMsSUFBSSxFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEIsR0FBRyxlQUFlLEdBQUcsUUFBUTtBQUNoRjtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWUsR0FBRyxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QixHQUFHLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkIsR0FBRyxlQUFlO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUSxLQUFLLE1BQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsU0FBUyxLQUFLLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUyxLQUFLLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QixHQUFHLHNCQUFzQjtBQUNoRyxpREFBaUQsMEJBQTBCLEdBQUcsc0JBQXNCO0FBQ3BHLCtDQUErQyx3QkFBd0IsR0FBRyxzQkFBc0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsdUJBQXVCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUIsT0FBTyxhQUFhLE9BQU8sWUFBWTtBQUN6RztBQUNBO0FBQ0EseUJBQXlCLG1EQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDLGFBQWEsaUNBQWlDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFnQjtBQUNsQyxrQkFBa0Isc0RBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxJQUFJLFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsSUFBSSxVQUFVO0FBQ3RFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxJQUFJLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyxFQUFFLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxXQUFXLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsV0FBVyxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxXQUFXLFVBQVU7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLFdBQVcsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLFFBQVEsV0FBVyxVQUFVO0FBQ3pFLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckYsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2QyxFQUFFLGNBQWM7QUFDdkcsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkMsRUFBRSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvREFBb0Q7QUFDaEc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQ0FBMkM7QUFDeEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkNBQTJDLEVBQUUsY0FBYztBQUN0RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQTJDLEVBQUUsY0FBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBb0I7QUFDbEQsV0FBVyxnRUFBMEI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELHNDQUFzQywwQkFBMEI7QUFDaEUsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixnQ0FBZ0M7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDJCQUEyQjtBQUN4RyxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxzQ0FBc0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJLElBQUksRUFBRTtBQUNyQztBQUNBLHVEQUF1RCxJQUFJLElBQUksRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLCtCQUErQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNENBQTRDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0RBQWdEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZDQUE2QztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYSxvQ0FBb0MsYUFBYTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWEsTUFBTSxhQUFhO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSkFBcUosTUFBTSxNQUFNLFlBQVk7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SixNQUFNLE1BQU0sWUFBWTtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGlCQUFpQixpQkFBaUIsWUFBWTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYSw2Q0FBNkMsRUFBRTtBQUNoSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSx5QkFBeUI7QUFDeko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0ZBQWtGO0FBQ2pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLE9BQU87QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyw2QkFBNkI7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSw2RkFBNkYsd0JBQXdCO0FBQ3JILDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckgsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxHQUFHLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZSxrQ0FBa0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0IsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QixZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBLElBQUksdUJBQXVCO0FBQzNCLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQSxxQkFBcUIsaUNBQWlDLGdCQUFnQixpQkFBaUI7QUFDdkY7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw2QkFBNkI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdFQUF3RSxxREFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLGlGQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLEdBQUcsd0JBQXdCO0FBQ3JFLElBQUksZ0NBQWdDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQSxzREFBc0Q7QUFDdEQsd0JBQXdCLElBQUksdUJBQXVCLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RCxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBYTtBQUMvQixJQUFJLGlFQUFrQixLQUFLLDBEQUFTLDRCQUE0QixtREFBbUQ7QUFDbkg7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFELGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsR0FBRyxrQkFBa0I7QUFDMUQsZ0NBQWdDLGlCQUFpQixHQUFHLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0JBQXdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUUsSUFBSSxjQUFjLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUc7QUFDbEUsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLG1CQUFtQjtBQUN6RSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkUsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUSxlQUFlO0FBQ3hFLFVBQVU7QUFDVjtBQUNBLHlCQUF5QixpQ0FBaUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQ0FBaUMsTUFBTSxxQ0FBcUM7QUFDaEYsOERBQThELFVBQVU7QUFDeEUsSUFBSSxXQUFXLDJCQUEyQixpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsMEJBQTBCLFlBQVksR0FBRyxTQUFTLE1BQU0sVUFBVTtBQUNsRSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLDBCQUEwQixZQUFZLEdBQUcsU0FBUyxNQUFNLFVBQVU7QUFDbEUsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsMkJBQTJCLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFLElBQUksbUJBQW1CLDJCQUEyQixpQkFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekUsSUFBSSxzQkFBc0IsMkJBQTJCLGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLElBQUkscUJBQXFCLDJCQUEyQixpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLEdBQUc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxnQkFBZ0IsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3RELHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEUsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUsscURBQXFELFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQSw4RkFBOEYsMEJBQTBCO0FBQ3hILHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQSxtQkFBbUIscUJBQXFCLEdBQUcsb0JBQW9CO0FBQy9EO0FBQ0EsNkJBQTZCLDZCQUE2QixHQUFHLDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlEQUFTO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QixJQUFJLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLElBQUksd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRixJQUFJLDJDQUEyQyxPQUFPLFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkMsSUFBSSw4Q0FBOEM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJDQUEyQyxJQUFJO0FBQ2pHLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCLElBQUk7QUFDeEUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkNBQTJDLElBQUk7QUFDakcsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdXJFO0FBQ3ZyRSIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVudG9yeV9tYW5hZ21lbnQvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzPzU3OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2dldFByb3ZpZGVyLCBnZXRBcHAsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IGluc3BlY3QsIFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgY3JlYXRlTW9ja1VzZXJUb2tlbiwgZ2V0TW9kdWxhckluc3RhbmNlLCBkZWVwRXF1YWwsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgZ2V0VUEsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCBpc1NhZmFyaSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzJDEgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgSW50ZWdlciwgTWQ1IH0gZnJvbSAnQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9ibG9vbS1ibG9iJztcbmltcG9ydCAqIGFzIGdycGMgZnJvbSAnQGdycGMvZ3JwYy1qcyc7XG5pbXBvcnQgKiBhcyBwcm90b0xvYWRlciBmcm9tICdAZ3JwYy9wcm90by1sb2FkZXInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjQuNi40XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYSBudWxsYWJsZSBVSUQuIE1vc3RseSBleGlzdHMgdG8gbWFrZSBjb2RlIG1vcmVcclxuICogcmVhZGFibGUuXHJcbiAqL1xyXG5jbGFzcyBVc2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHVpZCkge1xyXG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xyXG4gICAgfVxyXG4gICAgaXNBdXRoZW50aWNhdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVpZCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxyXG4gICAgICogZGljdGlvbmFyeS5cclxuICAgICAqL1xyXG4gICAgdG9LZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd1aWQ6JyArIHRoaXMudWlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMtdXNlcic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlclVzZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXJVc2VyLnVpZCA9PT0gdGhpcy51aWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovXHJcblVzZXIuVU5BVVRIRU5USUNBVEVEID0gbmV3IFVzZXIobnVsbCk7XHJcbi8vIFRPRE8obWlrZWxlaGVuKTogTG9vayBpbnRvIGdldHRpbmcgYSBwcm9wZXIgdWlkLWVxdWl2YWxlbnQgZm9yXHJcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxyXG5Vc2VyLkdPT0dMRV9DUkVERU5USUFMUyA9IG5ldyBVc2VyKCdnb29nbGUtY3JlZGVudGlhbHMtdWlkJyk7XHJcblVzZXIuRklSU1RfUEFSVFkgPSBuZXcgVXNlcignZmlyc3QtcGFydHktdWlkJyk7XHJcblVzZXIuTU9DS19VU0VSID0gbmV3IFVzZXIoJ21vY2stdXNlcicpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIxMC4xMi4zXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBTREtfVkVSU0lPTiA9IHZlcnNpb247XHJcbmZ1bmN0aW9uIHNldFNES1ZlcnNpb24odmVyc2lvbikge1xyXG4gICAgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBGb3JtYXRzIGFuIG9iamVjdCBhcyBhIEpTT04gc3RyaW5nLCBzdWl0YWJsZSBmb3IgbG9nZ2luZy4gKi9cclxuZnVuY3Rpb24gZm9ybWF0SlNPTih2YWx1ZSkge1xyXG4gICAgLy8gdXRpbC5pbnNwZWN0KCkgcmVzdWx0cyBpbiBtdWNoIG1vcmUgcmVhZGFibGUgb3V0cHV0IHRoYW4gSlNPTi5zdHJpbmdpZnkoKVxyXG4gICAgcmV0dXJuIGluc3BlY3QodmFsdWUsIHsgZGVwdGg6IDEwMCB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZmlyZXN0b3JlJyk7XHJcbi8vIEhlbHBlciBtZXRob2RzIGFyZSBuZWVkZWQgYmVjYXVzZSB2YXJpYWJsZXMgY2FuJ3QgYmUgZXhwb3J0ZWQgYXMgcmVhZC93cml0ZVxyXG5mdW5jdGlvbiBnZXRMb2dMZXZlbCgpIHtcclxuICAgIHJldHVybiBsb2dDbGllbnQubG9nTGV2ZWw7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgdGhlIHZlcmJvc2l0eSBvZiBDbG91ZCBGaXJlc3RvcmUgbG9ncyAoZGVidWcsIGVycm9yLCBvciBzaWxlbnQpLlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9nTGV2ZWwgLSBUaGUgdmVyYm9zaXR5IHlvdSBzZXQgZm9yIGFjdGl2aXR5IGFuZCBlcnJvciBsb2dnaW5nLiBDYW5cclxuICogICBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XHJcbiAqXHJcbiAqICAgPHVsPlxyXG4gKiAgICAgPGxpPmBkZWJ1Z2AgZm9yIHRoZSBtb3N0IHZlcmJvc2UgbG9nZ2luZyBsZXZlbCwgcHJpbWFyaWx5IGZvclxyXG4gKiAgICAgZGVidWdnaW5nLjwvbGk+XHJcbiAqICAgICA8bGk+YGVycm9yYCB0byBsb2cgZXJyb3JzIG9ubHkuPC9saT5cclxuICogICAgIDxsaT48Y29kZT5gc2lsZW50YCB0byB0dXJuIG9mZiBsb2dnaW5nLjwvbGk+XHJcbiAqICAgPC91bD5cclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBsb2dDbGllbnQuc2V0TG9nTGV2ZWwobG9nTGV2ZWwpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0RlYnVnKG1zZywgLi4ub2JqKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkRFQlVHKSB7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IG9iai5tYXAoYXJnVG9TdHJpbmcpO1xyXG4gICAgICAgIGxvZ0NsaWVudC5kZWJ1ZyhgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKG1zZywgLi4ub2JqKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IG9iai5tYXAoYXJnVG9TdHJpbmcpO1xyXG4gICAgICAgIGxvZ0NsaWVudC5lcnJvcihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGxvZ1dhcm4obXNnLCAuLi5vYmopIHtcclxuICAgIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuV0FSTikge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcclxuICAgICAgICBsb2dDbGllbnQud2FybihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiBhZGRpdGlvbmFsIGxvZyBwYXJhbWV0ZXIgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmdUb1N0cmluZyhvYmopIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SlNPTihvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0aW5nIHRvIEpTT04gZmFpbGVkLCBqdXN0IGxvZyB0aGUgb2JqZWN0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBVbmNvbmRpdGlvbmFsbHkgZmFpbHMsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXHJcbiAqIE1lc3NhZ2VzIGFyZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cclxuICpcclxuICogUmV0dXJucyBgbmV2ZXJgIGFuZCBjYW4gYmUgdXNlZCBpbiBleHByZXNzaW9uczpcclxuICogQGV4YW1wbGVcclxuICogbGV0IGZ1dHVyZVZhciA9IGZhaWwoJ25vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcclxuICovXHJcbmZ1bmN0aW9uIGZhaWwoZmFpbHVyZSA9ICdVbmV4cGVjdGVkIHN0YXRlJykge1xyXG4gICAgLy8gTG9nIHRoZSBmYWlsdXJlIGluIGFkZGl0aW9uIHRvIHRocm93IGFuIGV4Y2VwdGlvbiwganVzdCBpbiBjYXNlIHRoZVxyXG4gICAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRklSRVNUT1JFICgke1NES19WRVJTSU9OfSkgSU5URVJOQUwgQVNTRVJUSU9OIEZBSUxFRDogYCArIGZhaWx1cmU7XHJcbiAgICBsb2dFcnJvcihtZXNzYWdlKTtcclxuICAgIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlc3RvcmVFcnJvciBoZXJlIGJlY2F1c2UgdGhlc2UgYXJlIGludGVybmFsIGZhaWx1cmVzXHJcbiAgICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxyXG4gICAgLy8gZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSBlcnJvciBhbmQgYXNzZXJ0IG1vZHVsZXMgd2hpY2ggZG9lc24ndCB3b3JrLilcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxufVxyXG4vKipcclxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXHJcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxyXG4gKlxyXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXJkQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xyXG4gICAgaWYgKCFhc3NlcnRpb24pIHtcclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxyXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cclxuICpcclxuICogVGhlIGNvZGUgb2YgY2FsbHNpdGVzIGludm9raW5nIHRoaXMgZnVuY3Rpb24gYXJlIHN0cmlwcGVkIG91dCBpbiBwcm9kdWN0aW9uXHJcbiAqIGJ1aWxkcy4gQW55IHNpZGUtZWZmZWN0cyBvZiBjb2RlIHdpdGhpbiB0aGUgZGVidWdBc3NlcnQoKSBpbnZvY2F0aW9uIHdpbGwgbm90XHJcbiAqIGhhcHBlbiBpbiB0aGlzIGNhc2UuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZGVidWdBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FzdHMgYG9iamAgdG8gYFRgLiBJbiBub24tcHJvZHVjdGlvbiBidWlsZHMsIHZlcmlmaWVzIHRoYXQgYG9iamAgaXMgYW5cclxuICogaW5zdGFuY2Ugb2YgYFRgIGJlZm9yZSBjYXN0aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVidWdDYXN0KG9iaiwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmNvbnN0cnVjdG9yKSB7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IENvZGUgPSB7XHJcbiAgICAvLyBDYXVzZXMgYXJlIGNvcGllZCBmcm9tOlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL2JjZWVjOTRlYTRmYzVmMDA4NWQ4MTIzNWQ4ZTFjMDY3OThkYzM0MWEvaW5jbHVkZS9ncnBjJTJCJTJCL2ltcGwvY29kZWdlbi9zdGF0dXNfY29kZV9lbnVtLmhcclxuICAgIC8qKiBOb3QgYW4gZXJyb3I7IHJldHVybmVkIG9uIHN1Y2Nlc3MuICovXHJcbiAgICBPSzogJ29rJyxcclxuICAgIC8qKiBUaGUgb3BlcmF0aW9uIHdhcyBjYW5jZWxsZWQgKHR5cGljYWxseSBieSB0aGUgY2FsbGVyKS4gKi9cclxuICAgIENBTkNFTExFRDogJ2NhbmNlbGxlZCcsXHJcbiAgICAvKiogVW5rbm93biBlcnJvciBvciBhbiBlcnJvciBmcm9tIGEgZGlmZmVyZW50IGVycm9yIGRvbWFpbi4gKi9cclxuICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICAgIC8qKlxyXG4gICAgICogQ2xpZW50IHNwZWNpZmllZCBhbiBpbnZhbGlkIGFyZ3VtZW50LiBOb3RlIHRoYXQgdGhpcyBkaWZmZXJzIGZyb21cclxuICAgICAqIEZBSUxFRF9QUkVDT05ESVRJT04uIElOVkFMSURfQVJHVU1FTlQgaW5kaWNhdGVzIGFyZ3VtZW50cyB0aGF0IGFyZVxyXG4gICAgICogcHJvYmxlbWF0aWMgcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2YgdGhlIHN5c3RlbSAoZS5nLiwgYSBtYWxmb3JtZWQgZmlsZVxyXG4gICAgICogbmFtZSkuXHJcbiAgICAgKi9cclxuICAgIElOVkFMSURfQVJHVU1FTlQ6ICdpbnZhbGlkLWFyZ3VtZW50JyxcclxuICAgIC8qKlxyXG4gICAgICogRGVhZGxpbmUgZXhwaXJlZCBiZWZvcmUgb3BlcmF0aW9uIGNvdWxkIGNvbXBsZXRlLiBGb3Igb3BlcmF0aW9ucyB0aGF0XHJcbiAgICAgKiBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBzeXN0ZW0sIHRoaXMgZXJyb3IgbWF5IGJlIHJldHVybmVkIGV2ZW4gaWYgdGhlXHJcbiAgICAgKiBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIEZvciBleGFtcGxlLCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcclxuICAgICAqIGZyb20gYSBzZXJ2ZXIgY291bGQgaGF2ZSBiZWVuIGRlbGF5ZWQgbG9uZyBlbm91Z2ggZm9yIHRoZSBkZWFkbGluZSB0b1xyXG4gICAgICogZXhwaXJlLlxyXG4gICAgICovXHJcbiAgICBERUFETElORV9FWENFRURFRDogJ2RlYWRsaW5lLWV4Y2VlZGVkJyxcclxuICAgIC8qKiBTb21lIHJlcXVlc3RlZCBlbnRpdHkgKGUuZy4sIGZpbGUgb3IgZGlyZWN0b3J5KSB3YXMgbm90IGZvdW5kLiAqL1xyXG4gICAgTk9UX0ZPVU5EOiAnbm90LWZvdW5kJyxcclxuICAgIC8qKlxyXG4gICAgICogU29tZSBlbnRpdHkgdGhhdCB3ZSBhdHRlbXB0ZWQgdG8gY3JlYXRlIChlLmcuLCBmaWxlIG9yIGRpcmVjdG9yeSkgYWxyZWFkeVxyXG4gICAgICogZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBBTFJFQURZX0VYSVNUUzogJ2FscmVhZHktZXhpc3RzJyxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbGxlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZXhlY3V0ZSB0aGUgc3BlY2lmaWVkIG9wZXJhdGlvbi5cclxuICAgICAqIFBFUk1JU1NJT05fREVOSUVEIG11c3Qgbm90IGJlIHVzZWQgZm9yIHJlamVjdGlvbnMgY2F1c2VkIGJ5IGV4aGF1c3RpbmdcclxuICAgICAqIHNvbWUgcmVzb3VyY2UgKHVzZSBSRVNPVVJDRV9FWEhBVVNURUQgaW5zdGVhZCBmb3IgdGhvc2UgZXJyb3JzKS5cclxuICAgICAqIFBFUk1JU1NJT05fREVOSUVEIG11c3Qgbm90IGJlIHVzZWQgaWYgdGhlIGNhbGxlciBjYW4gbm90IGJlIGlkZW50aWZpZWRcclxuICAgICAqICh1c2UgVU5BVVRIRU5USUNBVEVEIGluc3RlYWQgZm9yIHRob3NlIGVycm9ycykuXHJcbiAgICAgKi9cclxuICAgIFBFUk1JU1NJT05fREVOSUVEOiAncGVybWlzc2lvbi1kZW5pZWQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVxdWVzdCBkb2VzIG5vdCBoYXZlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGVcclxuICAgICAqIG9wZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgVU5BVVRIRU5USUNBVEVEOiAndW5hdXRoZW50aWNhdGVkJyxcclxuICAgIC8qKlxyXG4gICAgICogU29tZSByZXNvdXJjZSBoYXMgYmVlbiBleGhhdXN0ZWQsIHBlcmhhcHMgYSBwZXItdXNlciBxdW90YSwgb3IgcGVyaGFwcyB0aGVcclxuICAgICAqIGVudGlyZSBmaWxlIHN5c3RlbSBpcyBvdXQgb2Ygc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIFJFU09VUkNFX0VYSEFVU1RFRDogJ3Jlc291cmNlLWV4aGF1c3RlZCcsXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbiB3YXMgcmVqZWN0ZWQgYmVjYXVzZSB0aGUgc3lzdGVtIGlzIG5vdCBpbiBhIHN0YXRlIHJlcXVpcmVkIGZvclxyXG4gICAgICogdGhlIG9wZXJhdGlvbidzIGV4ZWN1dGlvbi4gRm9yIGV4YW1wbGUsIGRpcmVjdG9yeSB0byBiZSBkZWxldGVkIG1heSBiZVxyXG4gICAgICogbm9uLWVtcHR5LCBhbiBybWRpciBvcGVyYXRpb24gaXMgYXBwbGllZCB0byBhIG5vbi1kaXJlY3RvcnksIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBBIGxpdG11cyB0ZXN0IHRoYXQgbWF5IGhlbHAgYSBzZXJ2aWNlIGltcGxlbWVudG9yIGluIGRlY2lkaW5nXHJcbiAgICAgKiBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsIGFuZCBVTkFWQUlMQUJMRTpcclxuICAgICAqICAoYSkgVXNlIFVOQVZBSUxBQkxFIGlmIHRoZSBjbGllbnQgY2FuIHJldHJ5IGp1c3QgdGhlIGZhaWxpbmcgY2FsbC5cclxuICAgICAqICAoYikgVXNlIEFCT1JURUQgaWYgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkgYXQgYSBoaWdoZXItbGV2ZWxcclxuICAgICAqICAgICAgKGUuZy4sIHJlc3RhcnRpbmcgYSByZWFkLW1vZGlmeS13cml0ZSBzZXF1ZW5jZSkuXHJcbiAgICAgKiAgKGMpIFVzZSBGQUlMRURfUFJFQ09ORElUSU9OIGlmIHRoZSBjbGllbnQgc2hvdWxkIG5vdCByZXRyeSB1bnRpbFxyXG4gICAgICogICAgICB0aGUgc3lzdGVtIHN0YXRlIGhhcyBiZWVuIGV4cGxpY2l0bHkgZml4ZWQuIEUuZy4sIGlmIGFuIFwicm1kaXJcIlxyXG4gICAgICogICAgICBmYWlscyBiZWNhdXNlIHRoZSBkaXJlY3RvcnkgaXMgbm9uLWVtcHR5LCBGQUlMRURfUFJFQ09ORElUSU9OXHJcbiAgICAgKiAgICAgIHNob3VsZCBiZSByZXR1cm5lZCBzaW5jZSB0aGUgY2xpZW50IHNob3VsZCBub3QgcmV0cnkgdW5sZXNzXHJcbiAgICAgKiAgICAgIHRoZXkgaGF2ZSBmaXJzdCBmaXhlZCB1cCB0aGUgZGlyZWN0b3J5IGJ5IGRlbGV0aW5nIGZpbGVzIGZyb20gaXQuXHJcbiAgICAgKiAgKGQpIFVzZSBGQUlMRURfUFJFQ09ORElUSU9OIGlmIHRoZSBjbGllbnQgcGVyZm9ybXMgY29uZGl0aW9uYWxcclxuICAgICAqICAgICAgUkVTVCBHZXQvVXBkYXRlL0RlbGV0ZSBvbiBhIHJlc291cmNlIGFuZCB0aGUgcmVzb3VyY2Ugb24gdGhlXHJcbiAgICAgKiAgICAgIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgY29uZGl0aW9uLiBFLmcuLCBjb25mbGljdGluZ1xyXG4gICAgICogICAgICByZWFkLW1vZGlmeS13cml0ZSBvbiB0aGUgc2FtZSByZXNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgRkFJTEVEX1BSRUNPTkRJVElPTjogJ2ZhaWxlZC1wcmVjb25kaXRpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLCB0eXBpY2FsbHkgZHVlIHRvIGEgY29uY3VycmVuY3kgaXNzdWUgbGlrZVxyXG4gICAgICogc2VxdWVuY2VyIGNoZWNrIGZhaWx1cmVzLCB0cmFuc2FjdGlvbiBhYm9ydHMsIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBTZWUgbGl0bXVzIHRlc3QgYWJvdmUgZm9yIGRlY2lkaW5nIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiwgQUJPUlRFRCxcclxuICAgICAqIGFuZCBVTkFWQUlMQUJMRS5cclxuICAgICAqL1xyXG4gICAgQUJPUlRFRDogJ2Fib3J0ZWQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb24gd2FzIGF0dGVtcHRlZCBwYXN0IHRoZSB2YWxpZCByYW5nZS4gRS5nLiwgc2Vla2luZyBvciByZWFkaW5nXHJcbiAgICAgKiBwYXN0IGVuZCBvZiBmaWxlLlxyXG4gICAgICpcclxuICAgICAqIFVubGlrZSBJTlZBTElEX0FSR1VNRU5ULCB0aGlzIGVycm9yIGluZGljYXRlcyBhIHByb2JsZW0gdGhhdCBtYXkgYmUgZml4ZWRcclxuICAgICAqIGlmIHRoZSBzeXN0ZW0gc3RhdGUgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGEgMzItYml0IGZpbGUgc3lzdGVtIHdpbGxcclxuICAgICAqIGdlbmVyYXRlIElOVkFMSURfQVJHVU1FTlQgaWYgYXNrZWQgdG8gcmVhZCBhdCBhbiBvZmZzZXQgdGhhdCBpcyBub3QgaW4gdGhlXHJcbiAgICAgKiByYW5nZSBbMCwyXjMyLTFdLCBidXQgaXQgd2lsbCBnZW5lcmF0ZSBPVVRfT0ZfUkFOR0UgaWYgYXNrZWQgdG8gcmVhZCBmcm9tXHJcbiAgICAgKiBhbiBvZmZzZXQgcGFzdCB0aGUgY3VycmVudCBmaWxlIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmUgaXMgYSBmYWlyIGJpdCBvZiBvdmVybGFwIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcclxuICAgICAqIE9VVF9PRl9SQU5HRS4gV2UgcmVjb21tZW5kIHVzaW5nIE9VVF9PRl9SQU5HRSAodGhlIG1vcmUgc3BlY2lmaWMgZXJyb3IpXHJcbiAgICAgKiB3aGVuIGl0IGFwcGxpZXMgc28gdGhhdCBjYWxsZXJzIHdobyBhcmUgaXRlcmF0aW5nIHRocm91Z2ggYSBzcGFjZSBjYW5cclxuICAgICAqIGVhc2lseSBsb29rIGZvciBhbiBPVVRfT0ZfUkFOR0UgZXJyb3IgdG8gZGV0ZWN0IHdoZW4gdGhleSBhcmUgZG9uZS5cclxuICAgICAqL1xyXG4gICAgT1VUX09GX1JBTkdFOiAnb3V0LW9mLXJhbmdlJyxcclxuICAgIC8qKiBPcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIG9yIG5vdCBzdXBwb3J0ZWQvZW5hYmxlZCBpbiB0aGlzIHNlcnZpY2UuICovXHJcbiAgICBVTklNUExFTUVOVEVEOiAndW5pbXBsZW1lbnRlZCcsXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGVycm9ycy4gTWVhbnMgc29tZSBpbnZhcmlhbnRzIGV4cGVjdGVkIGJ5IHVuZGVybHlpbmcgU3lzdGVtIGhhc1xyXG4gICAgICogYmVlbiBicm9rZW4uIElmIHlvdSBzZWUgb25lIG9mIHRoZXNlIGVycm9ycywgU29tZXRoaW5nIGlzIHZlcnkgYnJva2VuLlxyXG4gICAgICovXHJcbiAgICBJTlRFUk5BTDogJ2ludGVybmFsJyxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLiBUaGlzIGlzIGEgbW9zdCBsaWtlbHkgYSB0cmFuc2llbnRcclxuICAgICAqIGNvbmRpdGlvbiBhbmQgbWF5IGJlIGNvcnJlY3RlZCBieSByZXRyeWluZyB3aXRoIGEgYmFja29mZi5cclxuICAgICAqXHJcbiAgICAgKiBTZWUgbGl0bXVzIHRlc3QgYWJvdmUgZm9yIGRlY2lkaW5nIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiwgQUJPUlRFRCxcclxuICAgICAqIGFuZCBVTkFWQUlMQUJMRS5cclxuICAgICAqL1xyXG4gICAgVU5BVkFJTEFCTEU6ICd1bmF2YWlsYWJsZScsXHJcbiAgICAvKiogVW5yZWNvdmVyYWJsZSBkYXRhIGxvc3Mgb3IgY29ycnVwdGlvbi4gKi9cclxuICAgIERBVEFfTE9TUzogJ2RhdGEtbG9zcydcclxufTtcclxuLyoqIEFuIGVycm9yIHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIG9wZXJhdGlvbi4gKi9cclxuY2xhc3MgRmlyZXN0b3JlRXJyb3IgZXh0ZW5kcyBGaXJlYmFzZUVycm9yIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhY2tlbmQgZXJyb3IgY29kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlcnJvci5cclxuICAgICAqL1xyXG4gICAgY29kZSwgXHJcbiAgICAvKipcclxuICAgICAqIEEgY3VzdG9tIGVycm9yIGRlc2NyaXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIoY29kZSwgbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIC8vIEhBQ0s6IFdlIHdyaXRlIGEgdG9TdHJpbmcgcHJvcGVydHkgZGlyZWN0bHkgYmVjYXVzZSBFcnJvciBpcyBub3QgYSByZWFsXHJcbiAgICAgICAgLy8gY2xhc3MgYW5kIHNvIGluaGVyaXRhbmNlIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LiBXZSBjb3VsZCBhbHRlcm5hdGl2ZWx5XHJcbiAgICAgICAgLy8gZG8gdGhlIHNhbWUgXCJiYWNrLWRvb3IgaW5oZXJpdGFuY2VcIiB0cmljayB0aGF0IEZpcmViYXNlRXJyb3IgZG9lcy5cclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5uYW1lfTogW2NvZGU9JHt0aGlzLmNvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE9BdXRoVG9rZW4ge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUsIHVzZXIpIHtcclxuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdPQXV0aCc7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dmFsdWV9YCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyB5aWVsZHMgYW4gZW1wdHkgdG9rZW4uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXHJcbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKFVzZXIuVU5BVVRIRU5USUNBVEVEKSk7XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bigpIHsgfVxyXG59XHJcbi8qKlxyXG4gKiBBIENyZWRlbnRpYWxzUHJvdmlkZXIgdGhhdCBhbHdheXMgcmV0dXJucyBhIGNvbnN0YW50IHRva2VuLiBVc2VkIGZvclxyXG4gKiBlbXVsYXRvciB0b2tlbiBtb2NraW5nLlxyXG4gKi9cclxuY2xhc3MgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCBzZXRDaGFuZ2VMaXN0ZW5lcigpXHJcbiAgICAgICAgICogVGhpcyBpc24ndCBhY3R1YWxseSBuZWNlc3Nhcnkgc2luY2UgdGhlIFVJRCBuZXZlciBjaGFuZ2VzLCBidXQgd2UgdXNlIHRoaXNcclxuICAgICAgICAgKiB0byB2ZXJpZnkgdGhlIGxpc3RlbiBjb250cmFjdCBpcyBhZGhlcmVkIHRvIGluIHRlc3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnRva2VuKTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gY2hhbmdlTGlzdGVuZXI7XHJcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cclxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIodGhpcy50b2tlbi51c2VyKSk7XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bigpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGhQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gYXV0aFByb3ZpZGVyO1xyXG4gICAgICAgIC8qKiBUcmFja3MgdGhlIGN1cnJlbnQgVXNlci4gKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gVXNlci5VTkFVVEhFTlRJQ0FURUQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ291bnRlciB1c2VkIHRvIGRldGVjdCBpZiB0aGUgdG9rZW4gY2hhbmdlZCB3aGlsZSBhIGdldFRva2VuIHJlcXVlc3Qgd2FzXHJcbiAgICAgICAgICogb3V0c3RhbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b2tlbkNvdW50ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgbGV0IGxhc3RUb2tlbklkID0gdGhpcy50b2tlbkNvdW50ZXI7XHJcbiAgICAgICAgLy8gQSBjaGFuZ2UgbGlzdGVuZXIgdGhhdCBwcmV2ZW50cyBkb3VibGUtZmlyaW5nIGZvciB0aGUgc2FtZSB0b2tlbiBjaGFuZ2UuXHJcbiAgICAgICAgY29uc3QgZ3VhcmRlZENoYW5nZUxpc3RlbmVyID0gdXNlciA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuQ291bnRlciAhPT0gbGFzdFRva2VuSWQpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RUb2tlbklkID0gdGhpcy50b2tlbkNvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlTGlzdGVuZXIodXNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEEgcHJvbWlzZSB0aGF0IGNhbiBiZSB3YWl0ZWQgb24gdG8gYmxvY2sgb24gdGhlIG5leHQgdG9rZW4gY2hhbmdlLlxyXG4gICAgICAgIC8vIFRoaXMgcHJvbWlzZSBpcyByZS1jcmVhdGVkIGFmdGVyIGVhY2ggY2hhbmdlLlxyXG4gICAgICAgIGxldCBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudG9rZW5Db3VudGVyKys7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLmdldFVzZXIoKTtcclxuICAgICAgICAgICAgbmV4dFRva2VuLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBndWFyZGVkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50VXNlcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXdhaXROZXh0VG9rZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbkF0dGVtcHQgPSBuZXh0VG9rZW47XHJcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjdXJyZW50VG9rZW5BdHRlbXB0LnByb21pc2U7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBndWFyZGVkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJBdXRoID0gKGF1dGgpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnQXV0aCBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcclxuICAgICAgICAgICAgYXdhaXROZXh0VG9rZW4oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyLm9uSW5pdChhdXRoID0+IHJlZ2lzdGVyQXV0aChhdXRoKSk7XHJcbiAgICAgICAgLy8gT3VyIHVzZXJzIGNhbiBpbml0aWFsaXplIEF1dGggcmlnaHQgYWZ0ZXIgRmlyZXN0b3JlLCBzbyB3ZSBnaXZlIGl0XHJcbiAgICAgICAgLy8gYSBjaGFuY2UgdG8gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGNvbXBvbmVudCBmcmFtZXdvcmsgYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gc3RhcnQgdXAgaW4gdW5hdXRoZW50aWNhdGVkIG1vZGUuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hdXRoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5hdXRoUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXV0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQXV0aChhdXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGF1dGggaXMgc3RpbGwgbm90IGF2YWlsYWJsZSwgcHJvY2VlZCB3aXRoIGBudWxsYCB1c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnQXV0aCBub3QgeWV0IGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGF3YWl0TmV4dFRva2VuKCk7XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICAvLyBUYWtlIG5vdGUgb2YgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHRva2VuQ291bnRlciBzbyB0aGF0IHRoaXMgbWV0aG9kXHJcbiAgICAgICAgLy8gY2FuIGZhaWwgKHdpdGggYW4gQUJPUlRFRCBlcnJvcikgaWYgdGhlcmUgaXMgYSB0b2tlbiBjaGFuZ2Ugd2hpbGUgdGhlXHJcbiAgICAgICAgLy8gcmVxdWVzdCBpcyBvdXRzdGFuZGluZy5cclxuICAgICAgICBjb25zdCBpbml0aWFsVG9rZW5Db3VudGVyID0gdGhpcy50b2tlbkNvdW50ZXI7XHJcbiAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVJlZnJlc2g7XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoLmdldFRva2VuKGZvcmNlUmVmcmVzaCkudGhlbih0b2tlbkRhdGEgPT4ge1xyXG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3Qgc2luY2UgdGhlIHRva2VuIGNoYW5nZWQgd2hpbGUgdGhlIHJlcXVlc3Qgd2FzXHJcbiAgICAgICAgICAgIC8vIG91dHN0YW5kaW5nIHNvIHRoZSByZXNwb25zZSBpcyBwb3RlbnRpYWxseSBmb3IgYSBwcmV2aW91cyB1c2VyICh3aGljaFxyXG4gICAgICAgICAgICAvLyB1c2VyLCB3ZSBjYW4ndCBiZSBzdXJlKS5cclxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Db3VudGVyICE9PSBpbml0aWFsVG9rZW5Db3VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdnZXRUb2tlbiBhYm9ydGVkIGR1ZSB0byB0b2tlbiBjaGFuZ2UuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuRGF0YS5hY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT0F1dGhUb2tlbih0b2tlbkRhdGEuYWNjZXNzVG9rZW4sIHRoaXMuY3VycmVudFVzZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcclxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bigpIHtcclxuICAgICAgICBpZiAodGhpcy5hdXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aC5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEF1dGguZ2V0VWlkKCkgY2FuIHJldHVybiBudWxsIGV2ZW4gd2l0aCBhIHVzZXIgbG9nZ2VkIGluLiBJdCBpcyBiZWNhdXNlXHJcbiAgICAvLyBnZXRVaWQoKSBpcyBzeW5jaHJvbm91cywgYnV0IHRoZSBhdXRoIGNvZGUgcG9wdWxhdGluZyBVaWQgaXMgYXN5bmNocm9ub3VzLlxyXG4gICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIHRoZSBBdXRoVG9rZW5MaXN0ZW5lciBjYWxsYmFja1xyXG4gICAgLy8gdG8gZ3VhcmFudGVlIHRvIGdldCB0aGUgYWN0dWFsIHVzZXIuXHJcbiAgICBnZXRVc2VyKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRVaWQgPSB0aGlzLmF1dGggJiYgdGhpcy5hdXRoLmdldFVpZCgpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoY3VycmVudFVpZCA9PT0gbnVsbCB8fCB0eXBlb2YgY3VycmVudFVpZCA9PT0gJ3N0cmluZycpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVXNlcihjdXJyZW50VWlkKTtcclxuICAgIH1cclxufVxyXG4vKlxyXG4gKiBGaXJzdFBhcnR5VG9rZW4gcHJvdmlkZXMgYSBmcmVzaCB0b2tlbiBlYWNoIHRpbWUgaXRzIHZhbHVlXHJcbiAqIGlzIHJlcXVlc3RlZCwgYmVjYXVzZSBpZiB0aGUgdG9rZW4gaXMgdG9vIG9sZCwgcmVxdWVzdHMgd2lsbCBiZSByZWplY3RlZC5cclxuICogVGVjaG5pY2FsbHkgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgU0RLIHNob3VsZCBncmFjZWZ1bGx5XHJcbiAqIHJlY292ZXIgZnJvbSB1bmF1dGhlbnRpY2F0ZWQgZXJyb3JzIChzZWUgYi8zMzE0NzgxOCBmb3IgY29udGV4dCksIGJ1dCBpdCdzXHJcbiAqIHNhZmVyIHRvIGtlZXAgdGhlIGltcGxlbWVudGF0aW9uIGFzLWlzLlxyXG4gKi9cclxuY2xhc3MgRmlyc3RQYXJ0eVRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JbmRleCwgaWFtVG9rZW4sIGF1dGhUb2tlbkZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcclxuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5GYWN0b3J5ID0gYXV0aFRva2VuRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnRmlyc3RQYXJ0eSc7XHJcbiAgICAgICAgdGhpcy51c2VyID0gVXNlci5GSVJTVF9QQVJUWTtcclxuICAgICAgICB0aGlzLl9oZWFkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIGF1dGhvcml6YXRpb24gdG9rZW4sIHVzaW5nIGEgcHJvdmlkZWQgZmFjdG9yeSBmdW5jdGlvbiwgb3IgcmV0dXJuXHJcbiAgICAgKiBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXRBdXRoVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuRmFjdG9yeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoVG9rZW5GYWN0b3J5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaGVhZGVycygpIHtcclxuICAgICAgICB0aGlzLl9oZWFkZXJzLnNldCgnWC1Hb29nLUF1dGhVc2VyJywgdGhpcy5zZXNzaW9uSW5kZXgpO1xyXG4gICAgICAgIC8vIFVzZSBhcnJheSBub3RhdGlvbiB0byBwcmV2ZW50IG1pbmlmaWNhdGlvblxyXG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJUb2tlblZhbHVlID0gdGhpcy5nZXRBdXRoVG9rZW4oKTtcclxuICAgICAgICBpZiAoYXV0aEhlYWRlclRva2VuVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlhbVRva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW4nLCB0aGlzLmlhbVRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnM7XHJcbiAgICB9XHJcbn1cclxuLypcclxuICogUHJvdmlkZXMgdXNlciBjcmVkZW50aWFscyByZXF1aXJlZCBmb3IgdGhlIEZpcmVzdG9yZSBKYXZhU2NyaXB0IFNES1xyXG4gKiB0byBhdXRoZW50aWNhdGUgdGhlIHVzZXIsIHVzaW5nIHRlY2huaXF1ZSB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlXHJcbiAqIHRvIGFwcGxpY2F0aW9ucyBob3N0ZWQgYnkgR29vZ2xlLlxyXG4gKi9cclxuY2xhc3MgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JbmRleCwgaWFtVG9rZW4sIGF1dGhUb2tlbkZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcclxuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5GYWN0b3J5ID0gYXV0aFRva2VuRmFjdG9yeTtcclxuICAgIH1cclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEZpcnN0UGFydHlUb2tlbih0aGlzLnNlc3Npb25JbmRleCwgdGhpcy5pYW1Ub2tlbiwgdGhpcy5hdXRoVG9rZW5GYWN0b3J5KSk7XHJcbiAgICB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVpZC5cclxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5GSVJTVF9QQVJUWSkpO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7IH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG59XHJcbmNsYXNzIEFwcENoZWNrVG9rZW4ge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0FwcENoZWNrJztcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgneC1maXJlYmFzZS1hcHBjaGVjaycsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHBDaGVja1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IG9uVG9rZW5DaGFuZ2VkID0gdG9rZW5SZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5SZXN1bHQuZXJyb3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgYEVycm9yIGdldHRpbmcgQXBwIENoZWNrIHRva2VuOyB1c2luZyBwbGFjZWhvbGRlciB0b2tlbiBpbnN0ZWFkLiBFcnJvcjogJHt0b2tlblJlc3VsdC5lcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuVXBkYXRlZCA9IHRva2VuUmVzdWx0LnRva2VuICE9PSB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbiA9IHRva2VuUmVzdWx0LnRva2VuO1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCBgUmVjZWl2ZWQgJHt0b2tlblVwZGF0ZWQgPyAnbmV3JyA6ICdleGlzdGluZyd9IHRva2VuLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5VcGRhdGVkXHJcbiAgICAgICAgICAgICAgICA/IGNoYW5nZUxpc3RlbmVyKHRva2VuUmVzdWx0LnRva2VuKVxyXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9ICh0b2tlblJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gb25Ub2tlbkNoYW5nZWQodG9rZW5SZXN1bHQpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyQXBwQ2hlY2sgPSAoYXBwQ2hlY2spID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgJ0FwcENoZWNrIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBhcHBDaGVjaztcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVjay5hZGRUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFwcENoZWNrUHJvdmlkZXIub25Jbml0KGFwcENoZWNrID0+IHJlZ2lzdGVyQXBwQ2hlY2soYXBwQ2hlY2spKTtcclxuICAgICAgICAvLyBPdXIgdXNlcnMgY2FuIGluaXRpYWxpemUgQXBwQ2hlY2sgYWZ0ZXIgRmlyZXN0b3JlLCBzbyB3ZSBnaXZlIGl0XHJcbiAgICAgICAgLy8gYSBjaGFuY2UgdG8gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGNvbXBvbmVudCBmcmFtZXdvcmsuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXBwQ2hlY2sgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckFwcENoZWNrKGFwcENoZWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIEFwcENoZWNrIGlzIHN0aWxsIG5vdCBhdmFpbGFibGUsIHByb2NlZWQgd2l0aG91dCBpdC5cclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCAnQXBwQ2hlY2sgbm90IHlldCBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlUmVmcmVzaDtcclxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4odG9rZW5SZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5SZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuUmVzdWx0LnRva2VuID09PSAnc3RyaW5nJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSB0b2tlblJlc3VsdC50b2tlbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXBwQ2hlY2tUb2tlbih0b2tlblJlc3VsdC50b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkge1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sucmVtb3ZlVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gQXBwQ2hlY2sgdG9rZW4gcHJvdmlkZXIgdGhhdCBhbHdheXMgeWllbGRzIGFuIGVtcHR5IHRva2VuLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEVtcHR5QXBwQ2hlY2tUb2tlblByb3ZpZGVyIHtcclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEFwcENoZWNrVG9rZW4oJycpKTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHsgfVxyXG4gICAgc2h1dGRvd24oKSB7IH1cclxufVxyXG4vKipcclxuICogQnVpbGRzIGEgQ3JlZGVudGlhbHNQcm92aWRlciBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2ZcclxuICogdGhlIGNyZWRlbnRpYWxzIHBhc3NlZCBpbi5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihjcmVkZW50aWFscykge1xyXG4gICAgaWYgKCFjcmVkZW50aWFscykge1xyXG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlcigpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChjcmVkZW50aWFsc1sndHlwZSddKSB7XHJcbiAgICAgICAgY2FzZSAnZmlyc3RQYXJ0eSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzWydzZXNzaW9uSW5kZXgnXSB8fCAnMCcsIGNyZWRlbnRpYWxzWydpYW1Ub2tlbiddIHx8IG51bGwsIGNyZWRlbnRpYWxzWydhdXRoVG9rZW5GYWN0b3J5J10gfHwgbnVsbCk7XHJcbiAgICAgICAgY2FzZSAncHJvdmlkZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gY3JlZGVudGlhbHNbJ2NsaWVudCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgZmFpbGVkIGR1ZSB0byBpbnZhbGlkIGNyZWRlbnRpYWwgdHlwZScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYG5CeXRlc2Agb2YgcmFuZG9tIGJ5dGVzLlxyXG4gKlxyXG4gKiBJZiBgbkJ5dGVzIDwgMGAgLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKG5CeXRlcykge1xyXG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzJDEobkJ5dGVzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBhbHBoYW51bWVyaWMgSURzIG9mIGEgc3BlY2lmaWVkIGxlbmd0aC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEV4cG9ydGVkIGludGVybmFsbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXHJcbiAqL1xyXG5jbGFzcyBBdXRvSWQge1xyXG4gICAgc3RhdGljIG5ld0lkKCkge1xyXG4gICAgICAgIC8vIEFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXHJcbiAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xyXG4gICAgICAgIC8vIFRoZSBsYXJnZXN0IGJ5dGUgdmFsdWUgdGhhdCBpcyBhIG11bHRpcGxlIG9mIGBjaGFyLmxlbmd0aGAuXHJcbiAgICAgICAgY29uc3QgbWF4TXVsdGlwbGUgPSBNYXRoLmZsb29yKDI1NiAvIGNoYXJzLmxlbmd0aCkgKiBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGF1dG9JZCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IDIwO1xyXG4gICAgICAgIHdoaWxlIChhdXRvSWQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmFuZG9tQnl0ZXMoNDApO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFjY2VwdCB2YWx1ZXMgdGhhdCBhcmUgWzAsIG1heE11bHRpcGxlKSwgdGhpcyBlbnN1cmVzIHRoZXkgY2FuXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBldmVubHkgbWFwcGVkIHRvIGluZGljZXMgb2YgYGNoYXJzYCB2aWEgYSBtb2R1bG8gb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGggJiYgYnl0ZXNbaV0gPCBtYXhNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9JZCArPSBjaGFycy5jaGFyQXQoYnl0ZXNbaV0gJSBjaGFycy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdXRvSWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbi8qKiBIZWxwZXIgdG8gY29tcGFyZSBhcnJheXMgdXNpbmcgaXNFcXVhbCgpLiAqL1xyXG5mdW5jdGlvbiBhcnJheUVxdWFscyhsZWZ0LCByaWdodCwgY29tcGFyYXRvcikge1xyXG4gICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdC5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiBjb21wYXJhdG9yKHZhbHVlLCByaWdodFtpbmRleF0pKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgaW1tZWRpYXRlIGxleGljb2dyYXBoaWNhbGx5LWZvbGxvd2luZyBzdHJpbmcuIFRoaXMgaXMgdXNlZnVsIHRvXHJcbiAqIGNvbnN0cnVjdCBhbiBpbmNsdXNpdmUgcmFuZ2UgZm9yIGluZGV4ZWRkYiBpdGVyYXRvcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbW1lZGlhdGVTdWNjZXNzb3Iocykge1xyXG4gICAgLy8gUmV0dXJuIHRoZSBpbnB1dCBzdHJpbmcsIHdpdGggYW4gYWRkaXRpb25hbCBOVUwgYnl0ZSBhcHBlbmRlZC5cclxuICAgIHJldHVybiBzICsgJ1xcMCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVGhlIGVhcmxpZXN0IGRhdGUgc3VwcG9ydGVkIGJ5IEZpcmVzdG9yZSB0aW1lc3RhbXBzICgwMDAxLTAxLTAxVDAwOjAwOjAwWikuXHJcbmNvbnN0IE1JTl9TRUNPTkRTID0gLTYyMTM1NTk2ODAwO1xyXG4vLyBOdW1iZXIgb2YgbmFub3NlY29uZHMgaW4gYSBtaWxsaXNlY29uZC5cclxuY29uc3QgTVNfVE9fTkFOT1MgPSAxZTY7XHJcbi8qKlxyXG4gKiBBIGBUaW1lc3RhbXBgIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3JcclxuICogY2FsZW5kYXIsIHJlcHJlc2VudGVkIGFzIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0IG5hbm9zZWNvbmRcclxuICogcmVzb2x1dGlvbiBpbiBVVEMgRXBvY2ggdGltZS5cclxuICpcclxuICogSXQgaXMgZW5jb2RlZCB1c2luZyB0aGUgUHJvbGVwdGljIEdyZWdvcmlhbiBDYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxyXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLiBJdCBpcyBlbmNvZGVkIGFzc3VtaW5nIGFsbCBtaW51dGVzXHJcbiAqIGFyZSA2MCBzZWNvbmRzIGxvbmcsIGkuZS4gbGVhcCBzZWNvbmRzIGFyZSBcInNtZWFyZWRcIiBzbyB0aGF0IG5vIGxlYXAgc2Vjb25kXHJcbiAqIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24uIFJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cclxuICogOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZXMgYW5kIGZ1cnRoZXIgc3BlY2lmaWNhdGlvbnMsIHJlZmVyIHRvIHRoZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9wcm90b2J1Zi9ibG9iL21hc3Rlci9zcmMvZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byB8IFRpbWVzdGFtcCBkZWZpbml0aW9ufS5cclxuICovXHJcbmNsYXNzIFRpbWVzdGFtcCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcclxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXHJcbiAgICAgKiAgICAgOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxyXG4gICAgICogQHBhcmFtIG5hbm9zZWNvbmRzIC0gVGhlIG5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxyXG4gICAgICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXHJcbiAgICAgKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zZWNvbmRzIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZVxyXG4gICAgICogICAgIGZyb20gMCB0byA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cclxuICAgICAqL1xyXG4gICAgc2Vjb25kcywgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLipcclxuICAgICAqL1xyXG4gICAgbmFub3NlY29uZHMpIHtcclxuICAgICAgICB0aGlzLnNlY29uZHMgPSBzZWNvbmRzO1xyXG4gICAgICAgIHRoaXMubmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcztcclxuICAgICAgICBpZiAobmFub3NlY29uZHMgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaW1lc3RhbXAgbmFub3NlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgbmFub3NlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmFub3NlY29uZHMgPj0gMWU5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaW1lc3RhbXAgbmFub3NlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgbmFub3NlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2Vjb25kcyA8IE1JTl9TRUNPTkRTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaW1lc3RhbXAgc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBzZWNvbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJyZWFrIGluIHRoZSB5ZWFyIDEwLDAwMC5cclxuICAgICAgICBpZiAoc2Vjb25kcyA+PSAyNTM0MDIzMDA4MDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgd2l0aCB0aGUgY3VycmVudCBkYXRlLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0aW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBub3coKSB7XHJcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tTWlsbGlzKERhdGUubm93KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gaW5pdGlhbGl6ZSB0aGUgYFRpbWVzdGFtcGAgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBUaW1lc3RhbXBgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzIHRoZSBnaXZlblxyXG4gICAgICogICAgIGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tTWlsbGlzKGRhdGUuZ2V0VGltZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWlsbGlzZWNvbmRzIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoXHJcbiAgICAgKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cclxuICAgICAqICAgICBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMpIHtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcclxuICAgICAgICBjb25zdCBuYW5vcyA9IE1hdGguZmxvb3IoKG1pbGxpc2Vjb25kcyAtIHNlY29uZHMgKiAxMDAwKSAqIE1TX1RPX05BTk9TKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChzZWNvbmRzLCBuYW5vcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QuIFRoaXMgY29udmVyc2lvblxyXG4gICAgICogY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24gc2luY2UgYERhdGVgIG9iamVjdHMgb25seSBzdXBwb3J0IG1pbGxpc2Vjb25kXHJcbiAgICAgKiBwcmVjaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzXHJcbiAgICAgKiAgICAgdGhpcyBgVGltZXN0YW1wYCwgd2l0aCBtaWxsaXNlY29uZCBwcmVjaXNpb24uXHJcbiAgICAgKi9cclxuICAgIHRvRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b01pbGxpcygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIG51bWVyaWMgdGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMgc2luY2VcclxuICAgICAqIGVwb2NoKS4gVGhpcyBvcGVyYXRpb24gY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHBvaW50IGluIHRpbWUgY29ycmVzcG9uZGluZyB0byB0aGlzIHRpbWVzdGFtcCwgcmVwcmVzZW50ZWQgYXNcclxuICAgICAqICAgICB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxyXG4gICAgICovXHJcbiAgICB0b01pbGxpcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRzICogMTAwMCArIHRoaXMubmFub3NlY29uZHMgLyBNU19UT19OQU5PUztcclxuICAgIH1cclxuICAgIF9jb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRzID09PSBvdGhlci5zZWNvbmRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMubmFub3NlY29uZHMsIG90aGVyLm5hbm9zZWNvbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5zZWNvbmRzLCBvdGhlci5zZWNvbmRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYFRpbWVzdGFtcGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBUaW1lc3RhbXBgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyLnNlY29uZHMgPT09IHRoaXMuc2Vjb25kcyAmJiBvdGhlci5uYW5vc2Vjb25kcyA9PT0gdGhpcy5uYW5vc2Vjb25kcyk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgVGltZXN0YW1wYC4gKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoJ1RpbWVzdGFtcChzZWNvbmRzPScgK1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZHMgK1xyXG4gICAgICAgICAgICAnLCBuYW5vc2Vjb25kcz0nICtcclxuICAgICAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kczogdGhpcy5zZWNvbmRzLCBuYW5vc2Vjb25kczogdGhpcy5uYW5vc2Vjb25kcyB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIG9iamVjdCB0byBhIHByaW1pdGl2ZSBzdHJpbmcsIHdoaWNoIGFsbG93cyBgVGltZXN0YW1wYCBvYmplY3RzXHJcbiAgICAgKiB0byBiZSBjb21wYXJlZCB1c2luZyB0aGUgYD5gLCBgPD1gLCBgPj1gIGFuZCBgPmAgb3BlcmF0b3JzLlxyXG4gICAgICovXHJcbiAgICB2YWx1ZU9mKCkge1xyXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gPHNlY29uZHM+LjxuYW5vc2Vjb25kcz4gd2hlcmVcclxuICAgICAgICAvLyA8c2Vjb25kcz4gaXMgdHJhbnNsYXRlZCB0byBoYXZlIGEgbm9uLW5lZ2F0aXZlIHZhbHVlIGFuZCBib3RoIDxzZWNvbmRzPlxyXG4gICAgICAgIC8vIGFuZCA8bmFub3NlY29uZHM+IGFyZSBsZWZ0LXBhZGRlZCB3aXRoIHplcm9lcyB0byBiZSBhIGNvbnNpc3RlbnQgbGVuZ3RoLlxyXG4gICAgICAgIC8vIFN0cmluZ3Mgd2l0aCB0aGlzIGZvcm1hdCB0aGVuIGhhdmUgYSBsZXhpb2dyYXBoaWNhbCBvcmRlcmluZyB0aGF0IG1hdGNoZXNcclxuICAgICAgICAvLyB0aGUgZXhwZWN0ZWQgb3JkZXJpbmcuIFRoZSA8c2Vjb25kcz4gdHJhbnNsYXRpb24gaXMgZG9uZSB0byBhdm9pZCBoYXZpbmdcclxuICAgICAgICAvLyBhIGxlYWRpbmcgbmVnYXRpdmUgc2lnbiAoaS5lLiBhIGxlYWRpbmcgJy0nIGNoYXJhY3RlcikgaW4gaXRzIHN0cmluZ1xyXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3aGljaCB3b3VsZCBhZmZlY3QgaXRzIGxleGlvZ3JhcGhpY2FsIG9yZGVyaW5nLlxyXG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2Vjb25kcyA9IHRoaXMuc2Vjb25kcyAtIE1JTl9TRUNPTkRTO1xyXG4gICAgICAgIC8vIE5vdGU6IFVwIHRvIDEyIGRlY2ltYWwgZGlnaXRzIGFyZSByZXF1aXJlZCB0byByZXByZXNlbnQgYWxsIHZhbGlkXHJcbiAgICAgICAgLy8gJ3NlY29uZHMnIHZhbHVlcy5cclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRTZWNvbmRzID0gU3RyaW5nKGFkanVzdGVkU2Vjb25kcykucGFkU3RhcnQoMTIsICcwJyk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTmFub3NlY29uZHMgPSBTdHJpbmcodGhpcy5uYW5vc2Vjb25kcykucGFkU3RhcnQoOSwgJzAnKTtcclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkU2Vjb25kcyArICcuJyArIGZvcm1hdHRlZE5hbm9zZWNvbmRzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHZlcnNpb25cclxuICogdGltZXN0YW1wLCBzdWNoIGFzIHVwZGF0ZV90aW1lIG9yIHJlYWRfdGltZS5cclxuICovXHJcbmNsYXNzIFNuYXBzaG90VmVyc2lvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aW1lc3RhbXApIHtcclxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tVGltZXN0YW1wKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1pbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbihuZXcgVGltZXN0YW1wKDAsIDApKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24obmV3IFRpbWVzdGFtcCgyNTM0MDIzMDA3OTksIDFlOSAtIDEpKTtcclxuICAgIH1cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcC5fY29tcGFyZVRvKG90aGVyLnRpbWVzdGFtcCk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLmlzRXF1YWwob3RoZXIudGltZXN0YW1wKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZXJzaW9uIGZvciB1c2UgaW4gc3BlYyB0ZXN0cy4gKi9cclxuICAgIHRvTWljcm9zZWNvbmRzKCkge1xyXG4gICAgICAgIC8vIENvbnZlcnQgdG8gbWljcm9zZWNvbmRzLlxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcC5zZWNvbmRzICogMWU2ICsgdGhpcy50aW1lc3RhbXAubmFub3NlY29uZHMgLyAxMDAwO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICdTbmFwc2hvdFZlcnNpb24oJyArIHRoaXMudGltZXN0YW1wLnRvU3RyaW5nKCkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICB0b1RpbWVzdGFtcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXA7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRE9DVU1FTlRfS0VZX05BTUUgPSAnX19uYW1lX18nO1xyXG4vKipcclxuICogUGF0aCByZXByZXNlbnRzIGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2Ygc3RyaW5nIHNlZ21lbnRzLlxyXG4gKi9cclxuY2xhc3MgQmFzZVBhdGgge1xyXG4gICAgY29uc3RydWN0b3Ioc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9mZnNldCA+IHNlZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA+IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldCkge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICB0aGlzLmxlbiA9IGxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBCYXNlUGF0aC5jb21wYXJhdG9yKHRoaXMsIG90aGVyKSA9PT0gMDtcclxuICAgIH1cclxuICAgIGNoaWxkKG5hbWVPclBhdGgpIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMubGltaXQoKSk7XHJcbiAgICAgICAgaWYgKG5hbWVPclBhdGggaW5zdGFuY2VvZiBCYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBuYW1lT3JQYXRoLmZvckVhY2goc2VnbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmFtZU9yUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdChzZWdtZW50cyk7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIGluZGV4IG9mIG9uZSBwYXN0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIHBhdGguICovXHJcbiAgICBsaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIHBvcEZpcnN0KHNpemUpIHtcclxuICAgICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHRoaXMuc2VnbWVudHMsIHRoaXMub2Zmc2V0ICsgc2l6ZSwgdGhpcy5sZW5ndGggLSBzaXplKTtcclxuICAgIH1cclxuICAgIHBvcExhc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHRoaXMuc2VnbWVudHMsIHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG4gICAgZmlyc3RTZWdtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzW3RoaXMub2Zmc2V0XTtcclxuICAgIH1cclxuICAgIGxhc3RTZWdtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG4gICAgZ2V0KGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXQgKyBpbmRleF07XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGlzUHJlZml4T2Yob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIubGVuZ3RoIDwgdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGkpICE9PSBvdGhlci5nZXQoaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlzSW1tZWRpYXRlUGFyZW50T2YocG90ZW50aWFsQ2hpbGQpIHtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggKyAxICE9PSBwb3RlbnRpYWxDaGlsZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGkpICE9PSBwb3RlbnRpYWxDaGlsZC5nZXQoaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vZmZzZXQsIGVuZCA9IHRoaXMubGltaXQoKTsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZuKHRoaXMuc2VnbWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHMuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMubGltaXQoKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29tcGFyYXRvcihwMSwgcDIpIHtcclxuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihwMS5sZW5ndGgsIHAyLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gcDEuZ2V0KGkpO1xyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHAyLmdldChpKTtcclxuICAgICAgICAgICAgaWYgKGxlZnQgPCByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwMS5sZW5ndGggPCBwMi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocDEubGVuZ3RoID4gcDIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBzbGFzaC1zZXBhcmF0ZWQgcGF0aCBmb3IgbmF2aWdhdGluZyByZXNvdXJjZXMgKGRvY3VtZW50cyBhbmQgY29sbGVjdGlvbnMpXHJcbiAqIHdpdGhpbiBGaXJlc3RvcmUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUmVzb3VyY2VQYXRoIGV4dGVuZHMgQmFzZVBhdGgge1xyXG4gICAgY29uc3RydWN0KHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBjYW5vbmljYWxTdHJpbmcoKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhlIGNsaWVudCBpcyBpZ25vcmFudCBvZiBhbnkgcGF0aCBzZWdtZW50cyBjb250YWluaW5nIGVzY2FwZVxyXG4gICAgICAgIC8vIHNlcXVlbmNlcyAoZS5nLiBfX2lkMTIzX18pIGFuZCBqdXN0IHBhc3NlcyB0aGVtIHRocm91Z2ggcmF3ICh0aGV5IGV4aXN0XHJcbiAgICAgICAgLy8gZm9yIGxlZ2FjeSByZWFzb25zIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZnJlcXVlbnRseSkuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGF0aFxyXG4gICAgICogd2hlcmUgZWFjaCBwYXRoIHNlZ21lbnQgaGFzIGJlZW4gZW5jb2RlZCB3aXRoXHJcbiAgICAgKiBgZW5jb2RlVVJJQ29tcG9uZW50YC5cclxuICAgICAqL1xyXG4gICAgdG9VcmlFbmNvZGVkU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByZXNvdXJjZSBwYXRoIGZyb20gdGhlIGdpdmVuIHNsYXNoLWRlbGltaXRlZCBzdHJpbmcuIElmIG11bHRpcGxlXHJcbiAgICAgKiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBhbGwgY29tcG9uZW50cyBhcmUgY29tYmluZWQuIExlYWRpbmcgYW5kIHRyYWlsaW5nXHJcbiAgICAgKiBzbGFzaGVzIGZyb20gYWxsIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKC4uLnBhdGhDb21wb25lbnRzKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhlIGNsaWVudCBpcyBpZ25vcmFudCBvZiBhbnkgcGF0aCBzZWdtZW50cyBjb250YWluaW5nIGVzY2FwZVxyXG4gICAgICAgIC8vIHNlcXVlbmNlcyAoZS5nLiBfX2lkMTIzX18pIGFuZCBqdXN0IHBhc3NlcyB0aGVtIHRocm91Z2ggcmF3ICh0aGV5IGV4aXN0XHJcbiAgICAgICAgLy8gZm9yIGxlZ2FjeSByZWFzb25zIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZnJlcXVlbnRseSkuXHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aENvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZignLy8nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBzZWdtZW50ICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgY29udGFpbiAvLyBpbiB0aGVtLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWxpbmcgc2xhc2hlZC5cclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaCguLi5wYXRoLnNwbGl0KCcvJykuZmlsdGVyKHNlZ21lbnQgPT4gc2VnbWVudC5sZW5ndGggPiAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoW10pO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlkZW50aWZpZXJSZWdFeHAgPSAvXltfYS16QS1aXVtfYS16QS1aMC05XSokLztcclxuLyoqXHJcbiAqIEEgZG90LXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHN1Yi1vYmplY3RzIHdpdGhpbiBhIGRvY3VtZW50LlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEZpZWxkUGF0aCQxIGV4dGVuZHMgQmFzZVBhdGgge1xyXG4gICAgY29uc3RydWN0KHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgY291bGQgYmUgdXNlZCBhcyBhIHNlZ21lbnQgaW4gYSBmaWVsZCBwYXRoXHJcbiAgICAgKiB3aXRob3V0IGVzY2FwaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNWYWxpZElkZW50aWZpZXIoc2VnbWVudCkge1xyXG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyUmVnRXhwLnRlc3Qoc2VnbWVudCk7XHJcbiAgICB9XHJcbiAgICBjYW5vbmljYWxTdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpXHJcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHtcclxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvYC9nLCAnXFxcXGAnKTtcclxuICAgICAgICAgICAgaWYgKCFGaWVsZFBhdGgkMS5pc1ZhbGlkSWRlbnRpZmllcihzdHIpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnYCcgKyBzdHIgKyAnYCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbignLicpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpZWxkIHJlZmVyZW5jZXMgdGhlIGtleSBvZiBhIGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICBpc0tleUZpZWxkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmdldCgwKSA9PT0gRE9DVU1FTlRfS0VZX05BTUU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWVsZCBkZXNpZ25hdGluZyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBrZXlGaWVsZCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKFtET0NVTUVOVF9LRVlfTkFNRV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBmaWVsZCBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gc2VydmVyLWZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogLSBTcGxpdHRpbmcgdGhlIGVtcHR5IHN0cmluZyBpcyBub3QgYWxsb3dlZCAoZm9yIG5vdyBhdCBsZWFzdCkuXHJcbiAgICAgKiAtIEVtcHR5IHNlZ21lbnRzIHdpdGhpbiB0aGUgc3RyaW5nIChlLmcuIGlmIHRoZXJlIGFyZSB0d28gY29uc2VjdXRpdmVcclxuICAgICAqICAgc2VwYXJhdG9ycykgYXJlIG5vdCBhbGxvd2VkLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8oYi8zNzI0NDE1Nyk6IHdlIHNob3VsZCBtYWtlIHRoaXMgbW9yZSBzdHJpY3QuIFJpZ2h0IG5vdywgaXQgYWxsb3dzXHJcbiAgICAgKiBub24taWRlbnRpZmllciBwYXRoIGNvbXBvbmVudHMsIGV2ZW4gaWYgdGhleSBhcmVuJ3QgZXNjYXBlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TZXJ2ZXJGb3JtYXQocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAnJztcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgYWRkQ3VycmVudFNlZ21lbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGJlIGVtcHR5LCBiZWdpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgd2l0aCAnLicsIGVuZCB3aXRoICcuJywgb3IgY29udGFpbiAnLi4nYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGluQmFja3RpY2tzID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBjID0gcGF0aFtpXTtcclxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBwYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyB0cmFpbGluZyBlc2NhcGUgY2hhcmFjdGVyOiAnICsgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGF0aFtpICsgMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIShuZXh0ID09PSAnXFxcXCcgfHwgbmV4dCA9PT0gJy4nIHx8IG5leHQgPT09ICdgJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnUGF0aCBoYXMgaW52YWxpZCBlc2NhcGUgc2VxdWVuY2U6ICcgKyBwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnYCcpIHtcclxuICAgICAgICAgICAgICAgIGluQmFja3RpY2tzID0gIWluQmFja3RpY2tzO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcuJyAmJiAhaW5CYWNrdGlja3MpIHtcclxuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRTZWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkQ3VycmVudFNlZ21lbnQoKTtcclxuICAgICAgICBpZiAoaW5CYWNrdGlja3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1VudGVybWluYXRlZCBgIGluIHBhdGg6ICcgKyBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHlQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW10pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIERvY3VtZW50S2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21QYXRoKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKS5wb3BGaXJzdCg1KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbGxlY3Rpb25Hcm91cCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKS5sYXN0U2VnbWVudCgpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgaXMgaW4gdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uSWQuICovXHJcbiAgICBoYXNDb2xsZWN0aW9uSWQoY29sbGVjdGlvbklkKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhdGgubGVuZ3RoID49IDIgJiZcclxuICAgICAgICAgICAgdGhpcy5wYXRoLmdldCh0aGlzLnBhdGgubGVuZ3RoIC0gMikgPT09IGNvbGxlY3Rpb25JZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBncm91cCAoaS5lLiB0aGUgbmFtZSBvZiB0aGUgcGFyZW50IGNvbGxlY3Rpb24pIGZvciB0aGlzIGtleS4gKi9cclxuICAgIGdldENvbGxlY3Rpb25Hcm91cCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLmdldCh0aGlzLnBhdGgubGVuZ3RoIC0gMik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIHBhcmVudCBjb2xsZWN0aW9uLiAqL1xyXG4gICAgZ2V0Q29sbGVjdGlvblBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3BMYXN0KCk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcih0aGlzLnBhdGgsIG90aGVyLnBhdGgpID09PSAwKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21wYXJhdG9yKGsxLCBrMikge1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcihrMS5wYXRoLCBrMi5wYXRoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0RvY3VtZW50S2V5KHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggJSAyID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGRvY3VtZW50IGtleSB3aXRoIHRoZSBnaXZlbiBzZWdtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VnbWVudHMgLSBUaGUgc2VnbWVudHMgb2YgdGhlIHBhdGggdG8gdGhlIGRvY3VtZW50XHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBEb2N1bWVudEtleVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVNlZ21lbnRzKHNlZ21lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLnNsaWNlKCkpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGluaXRpYWwgbXV0YXRpb24gYmF0Y2ggaWQgZm9yIGVhY2ggaW5kZXguIEdldHMgdXBkYXRlZCBkdXJpbmcgaW5kZXhcclxuICogYmFja2ZpbGwuXHJcbiAqL1xyXG5jb25zdCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQgPSAtMTtcclxuLyoqXHJcbiAqIFRoZSBpbml0aWFsIHNlcXVlbmNlIG51bWJlciBmb3IgZWFjaCBpbmRleC4gR2V0cyB1cGRhdGVkIGR1cmluZyBpbmRleFxyXG4gKiBiYWNrZmlsbC5cclxuICovXHJcbmNvbnN0IElOSVRJQUxfU0VRVUVOQ0VfTlVNQkVSID0gMDtcclxuLyoqXHJcbiAqIEFuIGluZGV4IGRlZmluaXRpb24gZm9yIGZpZWxkIGluZGV4ZXMgaW4gRmlyZXN0b3JlLlxyXG4gKlxyXG4gKiBFdmVyeSBpbmRleCBpcyBhc3NvY2lhdGVkIHdpdGggYSBjb2xsZWN0aW9uLiBUaGUgZGVmaW5pdGlvbiBjb250YWlucyBhIGxpc3RcclxuICogb2YgZmllbGRzIGFuZCB0aGVpciBpbmRleCBraW5kICh3aGljaCBjYW4gYmUgYEFTQ0VORElOR2AsIGBERVNDRU5ESU5HYCBvclxyXG4gKiBgQ09OVEFJTlNgIGZvciBBcnJheUNvbnRhaW5zL0FycmF5Q29udGFpbnNBbnkgcXVlcmllcykuXHJcbiAqXHJcbiAqIFVubGlrZSB0aGUgYmFja2VuZCwgdGhlIFNESyBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gY29sbGVjdGlvbiBvclxyXG4gKiBjb2xsZWN0aW9uIGdyb3VwLXNjb3BlZCBpbmRpY2VzLiBFdmVyeSBpbmRleCBjYW4gYmUgdXNlZCBmb3IgYm90aCBzaW5nbGVcclxuICogY29sbGVjdGlvbiBhbmQgY29sbGVjdGlvbiBncm91cCBxdWVyaWVzLlxyXG4gKi9cclxuY2xhc3MgRmllbGRJbmRleCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IElELiBSZXR1cm5zIC0xIGlmIHRoZSBpbmRleCBJRCBpcyBub3QgYXZhaWxhYmxlIChlLmcuIHRoZSBpbmRleFxyXG4gICAgICogaGFzIG5vdCB5ZXQgYmVlbiBwZXJzaXN0ZWQpLlxyXG4gICAgICovXHJcbiAgICBpbmRleElkLCBcclxuICAgIC8qKiBUaGUgY29sbGVjdGlvbiBJRCB0aGlzIGluZGV4IGFwcGxpZXMgdG8uICovXHJcbiAgICBjb2xsZWN0aW9uR3JvdXAsIFxyXG4gICAgLyoqIFRoZSBmaWVsZCBzZWdtZW50cyBmb3IgdGhpcyBpbmRleC4gKi9cclxuICAgIGZpZWxkcywgXHJcbiAgICAvKiogU2hvd3MgaG93IHVwLXRvLWRhdGUgdGhlIGluZGV4IGlzIGZvciB0aGUgY3VycmVudCB1c2VyLiAqL1xyXG4gICAgaW5kZXhTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXhJZCA9IGluZGV4SWQ7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICAgICAgdGhpcy5pbmRleFN0YXRlID0gaW5kZXhTdGF0ZTtcclxuICAgIH1cclxufVxyXG4vKiogQW4gSUQgZm9yIGFuIGluZGV4IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBhZGRlZCB0byBwZXJzaXN0ZW5jZS4gICovXHJcbkZpZWxkSW5kZXguVU5LTk9XTl9JRCA9IC0xO1xyXG4vKiogUmV0dXJucyB0aGUgQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55IHNlZ21lbnQgZm9yIHRoaXMgaW5kZXguICovXHJcbmZ1bmN0aW9uIGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCkge1xyXG4gICAgcmV0dXJuIGZpZWxkSW5kZXguZmllbGRzLmZpbmQocyA9PiBzLmtpbmQgPT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKTtcclxufVxyXG4vKiogUmV0dXJucyBhbGwgZGlyZWN0aW9uYWwgKGFzY2VuZGluZy9kZXNjZW5kaW5nKSBzZWdtZW50cyBmb3IgdGhpcyBpbmRleC4gKi9cclxuZnVuY3Rpb24gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkge1xyXG4gICAgcmV0dXJuIGZpZWxkSW5kZXguZmllbGRzLmZpbHRlcihzID0+IHMua2luZCAhPT0gMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBvcmRlciBvZiB0aGUgZG9jdW1lbnQga2V5IGNvbXBvbmVudCBmb3IgdGhlIGdpdmVuIGluZGV4LlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBXZWIgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZmllbGRJbmRleEdldEtleU9yZGVyKGZpZWxkSW5kZXgpIHtcclxuICAgIGNvbnN0IGRpcmVjdGlvbmFsU2VnbWVudHMgPSBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KTtcclxuICAgIHJldHVybiBkaXJlY3Rpb25hbFNlZ21lbnRzLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgID8gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXHJcbiAgICAgICAgOiBkaXJlY3Rpb25hbFNlZ21lbnRzW2RpcmVjdGlvbmFsU2VnbWVudHMubGVuZ3RoIC0gMV0ua2luZDtcclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgaW5kZXhlcyBieSBjb2xsZWN0aW9uIGdyb3VwIGFuZCBzZWdtZW50cy4gSWdub3JlcyB1cGRhdGUgdGltZSBhbmRcclxuICogaW5kZXggSUQuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBsZXQgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmNvbGxlY3Rpb25Hcm91cCwgcmlnaHQuY29sbGVjdGlvbkdyb3VwKTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihsZWZ0LmZpZWxkcy5sZW5ndGgsIHJpZ2h0LmZpZWxkcy5sZW5ndGgpOyArK2kpIHtcclxuICAgICAgICBjbXAgPSBpbmRleFNlZ21lbnRDb21wYXJhdG9yKGxlZnQuZmllbGRzW2ldLCByaWdodC5maWVsZHNbaV0pO1xyXG4gICAgICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmZpZWxkcy5sZW5ndGgsIHJpZ2h0LmZpZWxkcy5sZW5ndGgpO1xyXG59XHJcbi8qKiBSZXR1cm5zIGEgZGVidWcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpZWxkIGluZGV4ICovXHJcbmZ1bmN0aW9uIGZpZWxkSW5kZXhUb1N0cmluZyhmaWVsZEluZGV4KSB7XHJcbiAgICByZXR1cm4gYGlkPSR7ZmllbGRJbmRleC5pbmRleElkfXxjZz0ke2ZpZWxkSW5kZXguY29sbGVjdGlvbkdyb3VwfXxmPSR7ZmllbGRJbmRleC5maWVsZHMubWFwKGYgPT4gYCR7Zi5maWVsZFBhdGh9OiR7Zi5raW5kfWApLmpvaW4oJywnKX1gO1xyXG59XHJcbi8qKiBBbiBpbmRleCBjb21wb25lbnQgY29uc2lzdGluZyBvZiBmaWVsZCBwYXRoIGFuZCBpbmRleCB0eXBlLiAgKi9cclxuY2xhc3MgSW5kZXhTZWdtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBmaWVsZCBwYXRoIG9mIHRoZSBjb21wb25lbnQuICovXHJcbiAgICBmaWVsZFBhdGgsIFxyXG4gICAgLyoqIFRoZSBmaWVsZHMgc29ydGluZyBvcmRlci4gKi9cclxuICAgIGtpbmQpIHtcclxuICAgICAgICB0aGlzLmZpZWxkUGF0aCA9IGZpZWxkUGF0aDtcclxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluZGV4U2VnbWVudENvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGNtcCA9IEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IobGVmdC5maWVsZFBhdGgsIHJpZ2h0LmZpZWxkUGF0aCk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQua2luZCwgcmlnaHQua2luZCk7XHJcbn1cclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgXCJoaWdoIHdhdGVyIG1hcmtcIiB0aGF0IGluZGljYXRlcyBob3cgdXBkYXRlZCB0aGUgSW5kZXggaXMgZm9yIHRoZVxyXG4gKiBjdXJyZW50IHVzZXIuXHJcbiAqL1xyXG5jbGFzcyBJbmRleFN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbiB0aGUgaW5kZXggd2FzIGxhc3QgdXBkYXRlZCAocmVsYXRpdmUgdG8gb3RoZXIgaW5kZXhlcykuXHJcbiAgICAgKi9cclxuICAgIHNlcXVlbmNlTnVtYmVyLCBcclxuICAgIC8qKiBUaGUgdGhlIGxhdGVzdCBpbmRleGVkIHJlYWQgdGltZSwgZG9jdW1lbnQgYW5kIGJhdGNoIGlkLiAqL1xyXG4gICAgb2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiBhbiBpbmRleCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYmFja2ZpbGxlZC4gKi9cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4U3RhdGUoSU5JVElBTF9TRVFVRU5DRV9OVU1CRVIsIEluZGV4T2Zmc2V0Lm1pbigpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBvZmZzZXQgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgd2l0aCBhIHJlYWQgdGltZSBoaWdoZXIgdGhhblxyXG4gKiBgcmVhZFRpbWVgLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3SW5kZXhPZmZzZXRTdWNjZXNzb3JGcm9tUmVhZFRpbWUocmVhZFRpbWUsIGxhcmdlc3RCYXRjaElkKSB7XHJcbiAgICAvLyBXZSB3YW50IHRvIGNyZWF0ZSBhbiBvZmZzZXQgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgd2l0aCBhIHJlYWQgdGltZVxyXG4gICAgLy8gZ3JlYXRlciB0aGFuIHRoZSBwcm92aWRlZCByZWFkIHRpbWUuIFRvIGRvIHNvLCB3ZSB0ZWNobmljYWxseSBuZWVkIHRvXHJcbiAgICAvLyBjcmVhdGUgYW4gb2Zmc2V0IGZvciBgKHJlYWRUaW1lLCBNQVhfRE9DVU1FTlRfS0VZKWAuIFdoaWxlIHdlIGNvdWxkIHVzZVxyXG4gICAgLy8gVW5pY29kZSBjb2RlcG9pbnRzIHRvIGdlbmVyYXRlIE1BWF9ET0NVTUVOVF9LRVksIGl0IGlzIG11Y2ggZWFzaWVyIHRvIHVzZVxyXG4gICAgLy8gYChyZWFkVGltZSArIDEsIERvY3VtZW50S2V5LmVtcHR5KCkpYCBzaW5jZSBgPiBEb2N1bWVudEtleS5lbXB0eSgpYCBtYXRjaGVzXHJcbiAgICAvLyBhbGwgdmFsaWQgZG9jdW1lbnQgSURzLlxyXG4gICAgY29uc3Qgc3VjY2Vzc29yU2Vjb25kcyA9IHJlYWRUaW1lLnRvVGltZXN0YW1wKCkuc2Vjb25kcztcclxuICAgIGNvbnN0IHN1Y2Nlc3Nvck5hbm9zID0gcmVhZFRpbWUudG9UaW1lc3RhbXAoKS5uYW5vc2Vjb25kcyArIDE7XHJcbiAgICBjb25zdCBzdWNjZXNzb3IgPSBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChzdWNjZXNzb3JOYW5vcyA9PT0gMWU5XHJcbiAgICAgICAgPyBuZXcgVGltZXN0YW1wKHN1Y2Nlc3NvclNlY29uZHMgKyAxLCAwKVxyXG4gICAgICAgIDogbmV3IFRpbWVzdGFtcChzdWNjZXNzb3JTZWNvbmRzLCBzdWNjZXNzb3JOYW5vcykpO1xyXG4gICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChzdWNjZXNzb3IsIERvY3VtZW50S2V5LmVtcHR5KCksIGxhcmdlc3RCYXRjaElkKTtcclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBvZmZzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRvY3VtZW50LiAqL1xyXG5mdW5jdGlvbiBuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChkb2N1bWVudC5yZWFkVGltZSwgZG9jdW1lbnQua2V5LCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xyXG59XHJcbi8qKlxyXG4gKiBTdG9yZXMgdGhlIGxhdGVzdCByZWFkIHRpbWUsIGRvY3VtZW50IGFuZCBiYXRjaCBJRCB0aGF0IHdlcmUgcHJvY2Vzc2VkIGZvciBhblxyXG4gKiBpbmRleC5cclxuICovXHJcbmNsYXNzIEluZGV4T2Zmc2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGF0ZXN0IHJlYWQgdGltZSB2ZXJzaW9uIHRoYXQgaGFzIGJlZW4gaW5kZXhlZCBieSBGaXJlc3RvcmUgZm9yIHRoaXNcclxuICAgICAqIGZpZWxkIGluZGV4LlxyXG4gICAgICovXHJcbiAgICByZWFkVGltZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXkgb2YgdGhlIGxhc3QgZG9jdW1lbnQgdGhhdCB3YXMgaW5kZXhlZCBmb3IgdGhpcyBxdWVyeS4gVXNlXHJcbiAgICAgKiBgRG9jdW1lbnRLZXkuZW1wdHkoKWAgaWYgbm8gZG9jdW1lbnQgaGFzIGJlZW4gaW5kZXhlZC5cclxuICAgICAqL1xyXG4gICAgZG9jdW1lbnRLZXksIFxyXG4gICAgLypcclxuICAgICAqIFRoZSBsYXJnZXN0IG11dGF0aW9uIGJhdGNoIGlkIHRoYXQncyBiZWVuIHByb2Nlc3NlZCBieSBGaXJlc3RvcmUuXHJcbiAgICAgKi9cclxuICAgIGxhcmdlc3RCYXRjaElkKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXkgPSBkb2N1bWVudEtleTtcclxuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhbiBvZmZzZXQgdGhhdCBzb3J0cyBiZWZvcmUgYWxsIHJlZ3VsYXIgb2Zmc2V0cy4gKi9cclxuICAgIHN0YXRpYyBtaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChTbmFwc2hvdFZlcnNpb24ubWluKCksIERvY3VtZW50S2V5LmVtcHR5KCksIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhbiBvZmZzZXQgdGhhdCBzb3J0cyBhZnRlciBhbGwgcmVndWxhciBvZmZzZXRzLiAqL1xyXG4gICAgc3RhdGljIG1heCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KFNuYXBzaG90VmVyc2lvbi5tYXgoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmRleE9mZnNldENvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcclxuICAgIGxldCBjbXAgPSBsZWZ0LnJlYWRUaW1lLmNvbXBhcmVUbyhyaWdodC5yZWFkVGltZSk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIGNtcCA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5kb2N1bWVudEtleSwgcmlnaHQuZG9jdW1lbnRLZXkpO1xyXG4gICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxhcmdlc3RCYXRjaElkLCByaWdodC5sYXJnZXN0QmF0Y2hJZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUFJJTUFSWV9MRUFTRV9MT1NUX0VSUk9SX01TRyA9ICdUaGUgY3VycmVudCB0YWIgaXMgbm90IGluIHRoZSByZXF1aXJlZCBzdGF0ZSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uLiAnICtcclxuICAgICdJdCBtaWdodCBiZSBuZWNlc3NhcnkgdG8gcmVmcmVzaCB0aGUgYnJvd3NlciB0YWIuJztcclxuLyoqXHJcbiAqIEEgYmFzZSBjbGFzcyByZXByZXNlbnRpbmcgYSBwZXJzaXN0ZW5jZSB0cmFuc2FjdGlvbiwgZW5jYXBzdWxhdGluZyBib3RoIHRoZVxyXG4gKiB0cmFuc2FjdGlvbidzIHNlcXVlbmNlIG51bWJlcnMgYXMgd2VsbCBhcyBhIGxpc3Qgb2Ygb25Db21taXR0ZWQgbGlzdGVuZXJzLlxyXG4gKlxyXG4gKiBXaGVuIHlvdSBjYWxsIFBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCksIGl0IHdpbGwgY3JlYXRlIGEgdHJhbnNhY3Rpb24gYW5kXHJcbiAqIHBhc3MgaXQgdG8geW91ciBjYWxsYmFjay4gWW91IHRoZW4gcGFzcyBpdCB0byBhbnkgbWV0aG9kIHRoYXQgb3BlcmF0ZXNcclxuICogb24gcGVyc2lzdGVuY2UuXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW5jZVRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub25Db21taXR0ZWRMaXN0ZW5lcnMgPSBbXTtcclxuICAgIH1cclxuICAgIGFkZE9uQ29tbWl0dGVkTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgcmFpc2VPbkNvbW1pdHRlZEV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMub25Db21taXR0ZWRMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVmVyaWZpZXMgdGhlIGVycm9yIHRocm93biBieSBhIExvY2FsU3RvcmUgb3BlcmF0aW9uLiBJZiBhIExvY2FsU3RvcmVcclxuICogb3BlcmF0aW9uIGZhaWxzIGJlY2F1c2UgdGhlIHByaW1hcnkgbGVhc2UgaGFzIGJlZW4gdGFrZW4gYnkgYW5vdGhlciBjbGllbnQsXHJcbiAqIHdlIGlnbm9yZSB0aGUgZXJyb3IgKHRoZSBwZXJzaXN0ZW5jZSBsYXllciB3aWxsIGltbWVkaWF0ZWx5IGNhbGxcclxuICogYGFwcGx5UHJpbWFyeUxlYXNlYCB0byBwcm9wYWdhdGUgdGhlIHByaW1hcnkgc3RhdGUgY2hhbmdlKS4gQWxsIG90aGVyIGVycm9yc1xyXG4gKiBhcmUgcmUtdGhyb3duLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXJyIC0gQW4gZXJyb3IgcmV0dXJuZWQgYnkgYSBMb2NhbFN0b3JlIG9wZXJhdGlvbi5cclxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgd2UgcmVjb3ZlcmVkLCBvciB0aGUgb3JpZ2luYWwgZXJyb3IuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyKSB7XHJcbiAgICBpZiAoZXJyLmNvZGUgPT09IENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiAmJlxyXG4gICAgICAgIGVyci5tZXNzYWdlID09PSBQUklNQVJZX0xFQVNFX0xPU1RfRVJST1JfTVNHKSB7XHJcbiAgICAgICAgbG9nRGVidWcoJ0xvY2FsU3RvcmUnLCAnVW5leHBlY3RlZGx5IGxvc3QgcHJpbWFyeSBsZWFzZScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQZXJzaXN0ZW5jZVByb21pc2UgaXMgZXNzZW50aWFsbHkgYSByZS1pbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlIGV4Y2VwdFxyXG4gKiBpdCBoYXMgYSAubmV4dCgpIG1ldGhvZCBpbnN0ZWFkIG9mIC50aGVuKCkgYW5kIC5uZXh0KCkgYW5kIC5jYXRjaCgpIGNhbGxiYWNrc1xyXG4gKiBhcmUgZXhlY3V0ZWQgc3luY2hyb25vdXNseSB3aGVuIGEgUGVyc2lzdGVuY2VQcm9taXNlIHJlc29sdmVzIHJhdGhlciB0aGFuXHJcbiAqIGFzeW5jaHJvbm91c2x5IChQcm9taXNlIGltcGxlbWVudGF0aW9ucyB1c2Ugc2V0SW1tZWRpYXRlKCkgb3Igc2ltaWxhcikuXHJcbiAqXHJcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGludGVyb3BlcmF0ZSB3aXRoIEluZGV4ZWREQiB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICogY29tbWl0IHRyYW5zYWN0aW9ucyBpZiBjb250cm9sIGlzIHJldHVybmVkIHRvIHRoZSBldmVudCBsb29wIHdpdGhvdXRcclxuICogc3luY2hyb25vdXNseSBpbml0aWF0aW5nIGFub3RoZXIgb3BlcmF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvbi5cclxuICpcclxuICogTk9URTogLnRoZW4oKSBhbmQgLmNhdGNoKCkgb25seSBhbGxvdyBhIHNpbmdsZSBjb25zdW1lciwgdW5saWtlIG5vcm1hbFxyXG4gKiBQcm9taXNlcy5cclxuICovXHJcbmNsYXNzIFBlcnNpc3RlbmNlUHJvbWlzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIE5PVEU6IG5leHQvY2F0Y2hDYWxsYmFjayB3aWxsIGFsd2F5cyBwb2ludCB0byBvdXIgb3duIHdyYXBwZXIgZnVuY3Rpb25zLFxyXG4gICAgICAgIC8vIG5vdCB0aGUgdXNlcidzIHJhdyBuZXh0KCkgb3IgY2F0Y2goKSBjYWxsYmFja3MuXHJcbiAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2F0Y2hDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgLy8gV2hlbiB0aGUgb3BlcmF0aW9uIHJlc29sdmVzLCB3ZSdsbCBzZXQgcmVzdWx0IG9yIGVycm9yIGFuZCBtYXJrIGlzRG9uZS5cclxuICAgICAgICB0aGlzLnJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XHJcbiAgICAgICAgLy8gU2V0IHRvIHRydWUgd2hlbiAudGhlbigpIG9yIC5jYXRjaCgpIGFyZSBjYWxsZWQgYW5kIHByZXZlbnRzIGFkZGl0aW9uYWxcclxuICAgICAgICAvLyBjaGFpbmluZy5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrQXR0YWNoZWQgPSBmYWxzZTtcclxuICAgICAgICBjYWxsYmFjayh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBzaG91bGQgYmUgZGVmaW5lZCB1bmxlc3MgVCBpcyBWb2lkLCBidXQgd2UgY2FuJ3QgZXhwcmVzc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBpbiB0aGUgdHlwZSBzeXN0ZW0uXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsYmFjayh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYXRjaENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaChmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQodW5kZWZpbmVkLCBmbik7XHJcbiAgICB9XHJcbiAgICBuZXh0KG5leHRGbiwgY2F0Y2hGbikge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQXR0YWNoZWQpIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrQXR0YWNoZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBTdWNjZXNzKG5leHRGbiwgdGhpcy5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcEZhaWx1cmUoY2F0Y2hGbiwgdGhpcy5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwU3VjY2VzcyhuZXh0Rm4sIHZhbHVlKS5uZXh0KHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrID0gKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwRmFpbHVyZShjYXRjaEZuLCBlcnJvcikubmV4dChyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9Qcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dChyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgd3JhcFVzZXJGdW5jdGlvbihmbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQZXJzaXN0ZW5jZVByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cmFwU3VjY2VzcyhuZXh0Rm4sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5leHRGbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwVXNlckZ1bmN0aW9uKCgpID0+IG5leHRGbih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBuZXh0Rm4sIHRoZW4gUiBtdXN0IGJlIHRoZSBzYW1lIGFzIFRcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cmFwRmFpbHVyZShjYXRjaEZuLCBlcnJvcikge1xyXG4gICAgICAgIGlmIChjYXRjaEZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBVc2VyRnVuY3Rpb24oKCkgPT4gY2F0Y2hGbihlcnJvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyByZXNvbHZlKHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlamVjdChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB3YWl0Rm9yKFxyXG4gICAgLy8gQWNjZXB0IGFsbCBQcm9taXNlIHR5cGVzIGluIHdhaXRGb3IoKS5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBhbGwpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBleHBlY3RlZENvdW50ID0gMDtcclxuICAgICAgICAgICAgbGV0IHJlc29sdmVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhbGwuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICsrZXhwZWN0ZWRDb3VudDtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKytyZXNvbHZlZENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lICYmIHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiByZWplY3QoZXJyKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBwcmVkaWNhdGUgZnVuY3Rpb25zIHRoYXQgYXN5bmNocm9ub3VzbHkgZXZhbHVhdGUgdG8gYVxyXG4gICAgICogYm9vbGVhbiwgaW1wbGVtZW50cyBhIHNob3J0LWNpcmN1aXRpbmcgYG9yYCBiZXR3ZWVuIHRoZSByZXN1bHRzLiBQcmVkaWNhdGVzXHJcbiAgICAgKiB3aWxsIGJlIGV2YWx1YXRlZCB1bnRpbCBvbmUgb2YgdGhlbSByZXR1cm5zIGB0cnVlYCwgdGhlbiBzdG9wLiBUaGUgZmluYWxcclxuICAgICAqIHJlc3VsdCB3aWxsIGJlIHdoZXRoZXIgYW55IG9mIHRoZW0gcmV0dXJuZWQgYHRydWVgLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb3IocHJlZGljYXRlcykge1xyXG4gICAgICAgIGxldCBwID0gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIHByZWRpY2F0ZXMpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dChpc1RydWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShpc1RydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZm9yRWFjaChjb2xsZWN0aW9uLCBmKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goKHIsIHMpID0+IHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChmLmNhbGwodGhpcywgciwgcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25jdXJyZW50bHkgbWFwIGFsbCBhcnJheSBlbGVtZW50cyB0aHJvdWdoIGFzeW5jaHJvbm91cyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG1hcEFycmF5KGFycmF5LCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGV4cGVjdGVkQ291bnQpO1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gaTtcclxuICAgICAgICAgICAgICAgIGYoYXJyYXlbY3VycmVudF0pLm5leHQocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2N1cnJlbnRdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICsrcmVzb2x2ZWRDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiByZWplY3QoZXJyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gcmVjdXJzaXZlIFBlcnNpc3RlbmNlUHJvbWlzZSBjYWxscywgdGhhdCBhdm9pZHNcclxuICAgICAqIHBvdGVudGlhbCBtZW1vcnkgcHJvYmxlbXMgZnJvbSB1bmJvdW5kZWQgY2hhaW5zIG9mIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgYWN0aW9uYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRlZGx5IHdoaWxlIGBjb25kaXRpb25gIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkb1doaWxlKGNvbmRpdGlvbiwgYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbigpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBwcm9jZXNzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gUmVmZXJlbmNlcyB0byBgd2luZG93YCBhcmUgZ3VhcmRlZCBieSBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5jb25zdCBMT0dfVEFHJGkgPSAnU2ltcGxlRGInO1xyXG4vKipcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIGZvciBhbiBJbmRleGVkRGIgdHJhbnNhY3Rpb24gdGhhdCBmYWlsc1xyXG4gKiB3aXRoIGEgRE9NRXhjZXB0aW9uLlxyXG4gKi9cclxuY29uc3QgVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQgPSAzO1xyXG4vKipcclxuICogV3JhcHMgYW4gSURCVHJhbnNhY3Rpb24gYW5kIGV4cG9zZXMgYSBzdG9yZSgpIG1ldGhvZCB0byBnZXQgYSBoYW5kbGUgdG8gYVxyXG4gKiBzcGVjaWZpYyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5jbGFzcyBTaW1wbGVEYlRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjdGlvbiwgdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIEluZGV4ZWREYiB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmFib3J0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIHRyYW5zYWN0aW9uLmVycm9yKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZXJyb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG9wZW4oZGIsIGFjdGlvbiwgbW9kZSwgb2JqZWN0U3RvcmVOYW1lcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGJUcmFuc2FjdGlvbihhY3Rpb24sIGRiLnRyYW5zYWN0aW9uKG9iamVjdFN0b3JlTmFtZXMsIG1vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgY29tcGxldGlvblByb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBhYm9ydChlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdBYm9ydGluZyB0cmFuc2FjdGlvbjonLCBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQ2xpZW50LWluaXRpYXRlZCBhYm9ydCcpO1xyXG4gICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLmFib3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF5YmVDb21taXQoKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgVjMgSW5kZXhlZERCLCB3ZSBpbnZva2UgY29tbWl0KCkgZXhwbGljaXRseSB0b1xyXG4gICAgICAgIC8vIHNwZWVkIHVwIGluZGV4IERCIHByb2Nlc3NpbmcgaWYgdGhlIGV2ZW50IGxvb3AgcmVtYWlucyBibG9ja3MuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBjb25zdCBtYXliZVYzSW5kZXhlZERiID0gdGhpcy50cmFuc2FjdGlvbjtcclxuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCAmJiB0eXBlb2YgbWF5YmVWM0luZGV4ZWREYi5jb21taXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbWF5YmVWM0luZGV4ZWREYi5jb21taXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBTaW1wbGVEYlN0b3JlPEtleVR5cGUsIFZhbHVlVHlwZT4gZm9yIHRoZSBzcGVjaWZpZWQgc3RvcmUuIEFsbFxyXG4gICAgICogb3BlcmF0aW9ucyBwZXJmb3JtZWQgb24gdGhlIFNpbXBsZURiU3RvcmUgaGFwcGVuIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGlzXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBhbmQgaXQgY2Fubm90IGJlIHVzZWQgYW55bW9yZSBvbmNlIHRoZSB0cmFuc2FjdGlvbiBpc1xyXG4gICAgICogY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB3ZSBjYW4ndCBhY3R1YWxseSBlbmZvcmNlIHRoYXQgdGhlIEtleVR5cGUgYW5kIFZhbHVlVHlwZSBhcmVcclxuICAgICAqIGNvcnJlY3QsIGJ1dCB0aGV5IGFsbG93IHR5cGUgc2FmZXR5IHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNvbnN1bWluZyBjb2RlLlxyXG4gICAgICovXHJcbiAgICBzdG9yZShzdG9yZU5hbWUpIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXMudHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcclxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURiU3RvcmUoc3RvcmUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIEluZGV4ZWREYiB3aXRoIGEgc2ltcGxpZmllZCBpbnRlcmZhY2UgdGhhdCB1c2VzXHJcbiAqIFByb21pc2UtbGlrZSByZXR1cm4gdmFsdWVzIHRvIGNoYWluIG9wZXJhdGlvbnMuIFJlYWwgcHJvbWlzZXMgY2Fubm90IGJlIHVzZWRcclxuICogc2luY2UgLnRoZW4oKSBjb250aW51YXRpb25zIGFyZSBleGVjdXRlZCBhc3luY2hyb25vdXNseSAoZS5nLiB2aWFcclxuICogLnNldEltbWVkaWF0ZSksIHdoaWNoIHdvdWxkIGNhdXNlIEluZGV4ZWREQiB0byBlbmQgdGhlIHRyYW5zYWN0aW9uLlxyXG4gKiBTZWUgUGVyc2lzdGVuY2VQcm9taXNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5jbGFzcyBTaW1wbGVEYiB7XHJcbiAgICAvKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaW1wbGVEYiB3cmFwcGVyIGZvciBJbmRleGVkRGIgZGF0YWJhc2UgYG5hbWVgLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBgdmVyc2lvbmAgbXVzdCBub3QgYmUgYSBkb3duZ3JhZGUuIEluZGV4ZWREQiBkb2VzIG5vdCBzdXBwb3J0XHJcbiAgICAgKiBkb3duZ3JhZGluZyB0aGUgc2NoZW1hIHZlcnNpb24uIFdlIGN1cnJlbnRseSBkbyBub3Qgc3VwcG9ydCBhbnkgd2F5IHRvIGRvXHJcbiAgICAgKiB2ZXJzaW9uaW5nIG91dHNpZGUgb2YgSW5kZXhlZERCJ3MgdmVyc2lvbmluZyBtZWNoYW5pc20sIGFzIG9ubHlcclxuICAgICAqIHZlcnNpb24tdXBncmFkZSB0cmFuc2FjdGlvbnMgYXJlIGFsbG93ZWQgdG8gZG8gdGhpbmdzIGxpa2UgY3JlYXRlXHJcbiAgICAgKiBvYmplY3RzdG9yZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIHNjaGVtYUNvbnZlcnRlcikge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLnNjaGVtYUNvbnZlcnRlciA9IHNjaGVtYUNvbnZlcnRlcjtcclxuICAgICAgICBjb25zdCBpT1NWZXJzaW9uID0gU2ltcGxlRGIuZ2V0SU9TVmVyc2lvbihnZXRVQSgpKTtcclxuICAgICAgICAvLyBOT1RFOiBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NzA1MCwgdGhlXHJcbiAgICAgICAgLy8gYnVnIHdlJ3JlIGNoZWNraW5nIGZvciBzaG91bGQgZXhpc3QgaW4gaU9TID49IDEyLjIgYW5kIDwgMTMsIGJ1dCBmb3JcclxuICAgICAgICAvLyB3aGF0ZXZlciByZWFzb24gaXQncyBtdWNoIGhhcmRlciB0byBoaXQgYWZ0ZXIgMTIuMiBzbyB3ZSBvbmx5IHByb2FjdGl2ZWx5XHJcbiAgICAgICAgLy8gbG9nIG9uIDEyLjIuXHJcbiAgICAgICAgaWYgKGlPU1ZlcnNpb24gPT09IDEyLjIpIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoJ0ZpcmVzdG9yZSBwZXJzaXN0ZW5jZSBzdWZmZXJzIGZyb20gYSBidWcgaW4gaU9TIDEyLjIgJyArXHJcbiAgICAgICAgICAgICAgICAnU2FmYXJpIHRoYXQgbWF5IGNhdXNlIHlvdXIgYXBwIHRvIHN0b3Agd29ya2luZy4gU2VlICcgK1xyXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NjQ5NjI5Ni8xMTA5MTUgZm9yIGRldGFpbHMgJyArXHJcbiAgICAgICAgICAgICAgICAnYW5kIGEgcG90ZW50aWFsIHdvcmthcm91bmQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBkYXRhYmFzZS4gKi9cclxuICAgIHN0YXRpYyBkZWxldGUobmFtZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1JlbW92aW5nIGRhdGFiYXNlOicsIG5hbWUpO1xyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdCh3aW5kb3cuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpKS50b1Byb21pc2UoKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgSW5kZXhlZERCIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gKi9cclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoU2ltcGxlRGIuaXNNb2NrUGVyc2lzdGVuY2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgZXh0ZW5zaXZlbHkgdXNlIGluZGV4ZWQgYXJyYXkgdmFsdWVzIGFuZCBjb21wb3VuZCBrZXlzLFxyXG4gICAgICAgIC8vIHdoaWNoIElFIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0LiBIb3dldmVyLCB0aGV5IHN0aWxsIGhhdmUgaW5kZXhlZERCXHJcbiAgICAgICAgLy8gZGVmaW5lZCBvbiB0aGUgd2luZG93LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGVtIGhlcmUgYW5kIG1ha2Ugc3VyZVxyXG4gICAgICAgIC8vIHRvIHJldHVybiB0aGF0IHBlcnNpc3RlbmNlIGlzIG5vdCBlbmFibGVkIGZvciB0aG9zZSBicm93c2Vycy5cclxuICAgICAgICAvLyBGb3IgdHJhY2tpbmcgc3VwcG9ydCBvZiB0aGlzIGZlYXR1cmUsIHNlZSBoZXJlOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vc3RhdHVzL2luZGV4ZWRkYmFycmF5c2FuZG11bHRpZW50cnlzdXBwb3J0L1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBVQSBzdHJpbmcgdG8gZmluZCBvdXQgdGhlIGJyb3dzZXIuXHJcbiAgICAgICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgICAgIC8vIElFIDEwXHJcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKGNvbXBhdGlibGU7IE1TSUUgMTAuMDsgV2luZG93cyBOVCA2LjI7IFRyaWRlbnQvNi4wKSc7XHJcbiAgICAgICAgLy8gSUUgMTFcclxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztcclxuICAgICAgICAvLyBFZGdlXHJcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV09XNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsXHJcbiAgICAgICAgLy8gbGlrZSBHZWNrbykgQ2hyb21lLzM5LjAuMjE3MS43MSBTYWZhcmkvNTM3LjM2IEVkZ2UvMTIuMCc7XHJcbiAgICAgICAgLy8gaU9TIFNhZmFyaTogRGlzYWJsZSBmb3IgdXNlcnMgcnVubmluZyBpT1MgdmVyc2lvbiA8IDEwLlxyXG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKHVhKTtcclxuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkSU9TID0gMCA8IGlPU1ZlcnNpb24gJiYgaU9TVmVyc2lvbiA8IDEwO1xyXG4gICAgICAgIC8vIEFuZHJvaWQgYnJvd3NlcjogRGlzYWJsZSBmb3IgdXNlcnNlIHJ1bm5pbmcgdmVyc2lvbiA8IDQuNS5cclxuICAgICAgICBjb25zdCBhbmRyb2lkVmVyc2lvbiA9IGdldEFuZHJvaWRWZXJzaW9uKHVhKTtcclxuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkQW5kcm9pZCA9IDAgPCBhbmRyb2lkVmVyc2lvbiAmJiBhbmRyb2lkVmVyc2lvbiA8IDQuNTtcclxuICAgICAgICBpZiAodWEuaW5kZXhPZignTVNJRSAnKSA+IDAgfHxcclxuICAgICAgICAgICAgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+IDAgfHxcclxuICAgICAgICAgICAgdWEuaW5kZXhPZignRWRnZS8nKSA+IDAgfHxcclxuICAgICAgICAgICAgaXNVbnN1cHBvcnRlZElPUyB8fFxyXG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkQW5kcm9pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmFja2luZyBJbmRleGVkREIgc3RvcmUgaXMgdGhlIE5vZGUgSW5kZXhlZERCU2hpbVxyXG4gICAgICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhlbWNsaW9uL0luZGV4ZWREQlNoaW0pLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNNb2NrUGVyc2lzdGVuY2UoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICgoX2EgPSBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLlVTRV9NT0NLX1BFUlNJU1RFTkNFKSA9PT0gJ1lFUycpO1xyXG4gICAgfVxyXG4gICAgLyoqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZyb20gYSB0cmFuc2FjdGlvbi4gKi9cclxuICAgIHN0YXRpYyBnZXRTdG9yZSh0eG4sIHN0b3JlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4bi5zdG9yZShzdG9yZSk7XHJcbiAgICB9XHJcbiAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAgICAvKiogUGFyc2UgVXNlciBBZ2VudCB0byBkZXRlcm1pbmUgaU9TIHZlcnNpb24uIFJldHVybnMgLTEgaWYgbm90IGZvdW5kLiAqL1xyXG4gICAgc3RhdGljIGdldElPU1ZlcnNpb24odWEpIHtcclxuICAgICAgICBjb25zdCBpT1NWZXJzaW9uUmVnZXggPSB1YS5tYXRjaCgvaSg/OnBob25lfHBhZHxwb2QpIG9zIChbXFxkX10rKS9pKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaU9TVmVyc2lvblJlZ2V4XHJcbiAgICAgICAgICAgID8gaU9TVmVyc2lvblJlZ2V4WzFdLnNwbGl0KCdfJykuc2xpY2UoMCwgMikuam9pbignLicpXHJcbiAgICAgICAgICAgIDogJy0xJztcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZlcnNpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlLCBjcmVhdGluZyBvciB1cGdyYWRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBlbnN1cmVEYihhY3Rpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGIpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnT3BlbmluZyBkYXRhYmFzZTonLCB0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRiID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBJbnZlc3RpZ2F0ZSBicm93c2VyIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSS9Vc2luZ19JbmRleGVkREJcclxuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RzIElFOSBhbmQgb2xkZXIgV2ViS2l0IGJyb3dzZXJzIGhhbmRsZSB1cGdyYWRlXHJcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnRseS4gVGhleSBleHBlY3Qgc2V0VmVyc2lvbiwgYXMgZGVzY3JpYmVkIGhlcmU6XHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCVmVyc2lvbkNoYW5nZVJlcXVlc3Qvc2V0VmVyc2lvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMubmFtZSwgdGhpcy52ZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sICdDYW5ub3QgdXBncmFkZSBJbmRleGVkREIgc2NoZW1hIHdoaWxlIGFub3RoZXIgdGFiIGlzIG9wZW4uICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2xvc2UgYWxsIHRhYnMgdGhhdCBhY2Nlc3MgRmlyZXN0b3JlIGFuZCByZWxvYWQgdGhpcyBwYWdlIHRvIHByb2NlZWQuJykpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQudGFyZ2V0LmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVmVyc2lvbkVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0EgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgRmlyZXN0b3JlIFNESyB3YXMgcHJldmlvdXNseSB1c2VkIGFuZCBzbyB0aGUgcGVyc2lzdGVkICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgdmVyc2lvbiBvZiB0aGUgU0RLIHlvdSBhcmUgbm93IHVzaW5nLiBUaGUgU0RLICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpbGwgb3BlcmF0ZSB3aXRoIHBlcnNpc3RlbmNlIGRpc2FibGVkLiBJZiB5b3UgbmVlZCBwZXJzaXN0ZW5jZSwgcGxlYXNlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlLXVwZ3JhZGUgdG8gYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBTREsgb3IgZWxzZSBjbGVhciB0aGUgcGVyc2lzdGVkIEluZGV4ZWREQiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhIGZvciB5b3VyIGFwcCB0byBzdGFydCBmcmVzaC4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdVbmFibGUgdG8gb3BlbiBhbiBJbmRleGVkREIgY29ubmVjdGlvbi4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gcnVubmluZyBpbiBhICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUgYnJvd3Npbmcgc2Vzc2lvbiBvbiBhIGJyb3dzZXIgd2hvc2UgcHJpdmF0ZSBicm93c2luZyBzZXNzaW9ucyBkbyBub3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3VwcG9ydCBJbmRleGVkREI6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIGVycm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnRGF0YWJhc2UgXCInICsgdGhpcy5uYW1lICsgJ1wiIHJlcXVpcmVzIHVwZ3JhZGUgZnJvbSB2ZXJzaW9uOicsIGV2ZW50Lm9sZFZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYUNvbnZlcnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlT3JVcGdyYWRlKGRiLCByZXF1ZXN0LnRyYW5zYWN0aW9uLCBldmVudC5vbGRWZXJzaW9uLCB0aGlzLnZlcnNpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnRGF0YWJhc2UgdXBncmFkZSB0byB2ZXJzaW9uICcgKyB0aGlzLnZlcnNpb24gKyAnIGNvbXBsZXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbmNoYW5nZWxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGIub252ZXJzaW9uY2hhbmdlID0gZXZlbnQgPT4gdGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kYjtcclxuICAgIH1cclxuICAgIHNldFZlcnNpb25DaGFuZ2VMaXN0ZW5lcih2ZXJzaW9uQ2hhbmdlTGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lciA9IHZlcnNpb25DaGFuZ2VMaXN0ZW5lcjtcclxuICAgICAgICBpZiAodGhpcy5kYikge1xyXG4gICAgICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25DaGFuZ2VMaXN0ZW5lcihldmVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCBvYmplY3RTdG9yZXMsIHRyYW5zYWN0aW9uRm4pIHtcclxuICAgICAgICBjb25zdCByZWFkb25seSA9IG1vZGUgPT09ICdyZWFkb25seSc7XHJcbiAgICAgICAgbGV0IGF0dGVtcHROdW1iZXIgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICsrYXR0ZW1wdE51bWJlcjtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGIgPSBhd2FpdCB0aGlzLmVuc3VyZURiKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IFNpbXBsZURiVHJhbnNhY3Rpb24ub3Blbih0aGlzLmRiLCBhY3Rpb24sIHJlYWRvbmx5ID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnLCBvYmplY3RTdG9yZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25GblJlc3VsdCA9IHRyYW5zYWN0aW9uRm4odHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5tYXliZUNvbW1pdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgdGhlIHRyYW5zYWN0aW9uIGlmIHRoZXJlIHdhcyBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hYm9ydChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGFjdHVhbGx5IHJlY292ZXIsIGFuZCBjYWxsaW5nIGBhYm9ydCgpYCB3aWxsIGNhdXNlIHRoZSB0cmFuc2FjdGlvbidzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGlvbiBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBUaGlzIGluIHR1cm4gbWVhbnMgdGhhdCB3ZSB3b24ndCB1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBgdHJhbnNhY3Rpb25GblJlc3VsdGAgYmVsb3cuIFdlIHJldHVybiBhIHJlamVjdGlvbiBoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgYWRkIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyBgdm9pZGAgdG8gdGhlIHR5cGUgb2YgYHRyYW5zYWN0aW9uRm5SZXN1bHRgLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gQXMgbm90ZWQgYWJvdmUsIGVycm9ycyBhcmUgcHJvcGFnYXRlZCBieSBhYm9ydGluZyB0aGUgdHJhbnNhY3Rpb24uIFNvXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBzd2FsbG93IGFueSBlcnJvciBoZXJlIHRvIGF2b2lkIHRoZSBicm93c2VyIGxvZ2dpbmcgaXQgYXMgdW5oYW5kbGVkLlxyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25GblJlc3VsdC5jYXRjaCgoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIChpLmUuIEluZGV4ZWREYidzIG9uc3VjY2VzcyBldmVudCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gZmlyZSksIGJ1dCBzdGlsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHRyYW5zYWN0aW9uRm5SZXN1bHQgYmFjayB0byB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGNhbGxlci5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbXBsZXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRm5SZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oc2NobWlkdC1zZWJhc3RpYW4pOiBXZSBjb3VsZCBwcm9iYWJseSBiZSBzbWFydGVyIGFib3V0IHRoaXMgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBub3QgcmV0cnkgZXhjZXB0aW9ucyB0aGF0IGFyZSBsaWtlbHkgdW5yZWNvdmVyYWJsZSAoc3VjaCBhcyBxdW90YVxyXG4gICAgICAgICAgICAgICAgLy8gZXhjZWVkZWQgZXJyb3JzKS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGNhbm5vdCB1c2UgYW4gaW5zdGFuY2VvZiBjaGVjayBmb3IgRmlyZXN0b3JlRXhjZXB0aW9uLCBzaW5jZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBpcyB3cmFwcGVkIGluIGEgZ2VuZXJpYyBlcnJvciBieSBvdXIgYXN5bmMvYXdhaXQgaGFuZGxpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeWFibGUgPSBlcnJvci5uYW1lICE9PSAnRmlyZWJhc2VFcnJvcicgJiZcclxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0TnVtYmVyIDwgVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQ7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdUcmFuc2FjdGlvbiBmYWlsZWQgd2l0aCBlcnJvcjonLCBlcnJvci5tZXNzYWdlLCAnUmV0cnlpbmc6JywgcmV0cnlhYmxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmV0cnlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGIuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYiA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKiogUGFyc2UgVXNlciBBZ2VudCB0byBkZXRlcm1pbmUgQW5kcm9pZCB2ZXJzaW9uLiBSZXR1cm5zIC0xIGlmIG5vdCBmb3VuZC4gKi9cclxuZnVuY3Rpb24gZ2V0QW5kcm9pZFZlcnNpb24odWEpIHtcclxuICAgIGNvbnN0IGFuZHJvaWRWZXJzaW9uUmVnZXggPSB1YS5tYXRjaCgvQW5kcm9pZCAoW1xcZC5dKykvaSk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gYW5kcm9pZFZlcnNpb25SZWdleFxyXG4gICAgICAgID8gYW5kcm9pZFZlcnNpb25SZWdleFsxXS5zcGxpdCgnLicpLnNsaWNlKDAsIDIpLmpvaW4oJy4nKVxyXG4gICAgICAgIDogJy0xJztcclxuICAgIHJldHVybiBOdW1iZXIodmVyc2lvbik7XHJcbn1cclxuLyoqXHJcbiAqIEEgY29udHJvbGxlciBmb3IgaXRlcmF0aW5nIG92ZXIgYSBrZXkgcmFuZ2Ugb3IgaW5kZXguIEl0IGFsbG93cyBhbiBpdGVyYXRlXHJcbiAqIGNhbGxiYWNrIHRvIGRlbGV0ZSB0aGUgY3VycmVudGx5LXJlZmVyZW5jZWQgb2JqZWN0LCBvciBqdW1wIHRvIGEgbmV3IGtleVxyXG4gKiB3aXRoaW4gdGhlIGtleSByYW5nZSBvciBpbmRleC5cclxuICovXHJcbmNsYXNzIEl0ZXJhdGlvbkNvbnRyb2xsZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGJDdXJzb3IpIHtcclxuICAgICAgICB0aGlzLmRiQ3Vyc29yID0gZGJDdXJzb3I7XHJcbiAgICAgICAgdGhpcy5zaG91bGRTdG9wID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5uZXh0S2V5ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldCBpc0RvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcclxuICAgIH1cclxuICAgIGdldCBza2lwVG9LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEtleTtcclxuICAgIH1cclxuICAgIHNldCBjdXJzb3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmRiQ3Vyc29yID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byBzdG9wIGl0ZXJhdGlvbiBhdCBhbnkgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIGRvbmUoKSB7XHJcbiAgICAgICAgdGhpcy5zaG91bGRTdG9wID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIHNraXAgdG8gdGhhdCBuZXh0IGtleSwgd2hpY2ggY291bGQgYmVcclxuICAgICAqIGFuIGluZGV4IG9yIGEgcHJpbWFyeSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHNraXAoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5uZXh0S2V5ID0ga2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgdGhlIGN1cnJlbnQgY3Vyc29yIHZhbHVlIGZyb20gdGhlIG9iamVjdCBzdG9yZS5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBZb3UgQ0FOTk9UIGRvIHRoaXMgd2l0aCBhIGtleXNPbmx5IHF1ZXJ5LlxyXG4gICAgICovXHJcbiAgICBkZWxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHRoaXMuZGJDdXJzb3IuZGVsZXRlKCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBBbiBlcnJvciB0aGF0IHdyYXBzIGV4Y2VwdGlvbnMgdGhhdCB0aHJvd24gZHVyaW5nIEluZGV4ZWREQiBleGVjdXRpb24uICovXHJcbmNsYXNzIEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBGaXJlc3RvcmVFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25OYW1lLCBjYXVzZSkge1xyXG4gICAgICAgIHN1cGVyKENvZGUuVU5BVkFJTEFCTEUsIGBJbmRleGVkREIgdHJhbnNhY3Rpb24gJyR7YWN0aW9uTmFtZX0nIGZhaWxlZDogJHtjYXVzZX1gKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcic7XHJcbiAgICB9XHJcbn1cclxuLyoqIFZlcmlmaWVzIHdoZXRoZXIgYGVgIGlzIGFuIEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IuICovXHJcbmZ1bmN0aW9uIGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSB7XHJcbiAgICAvLyBVc2UgbmFtZSBlcXVhbGl0eSwgYXMgaW5zdGFuY2VvZiBjaGVja3Mgb24gZXJyb3JzIGRvbid0IHdvcmsgd2l0aCBlcnJvcnNcclxuICAgIC8vIHRoYXQgd3JhcCBvdGhlciBlcnJvcnMuXHJcbiAgICByZXR1cm4gZS5uYW1lID09PSAnSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcic7XHJcbn1cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBhcm91bmQgYW4gSURCT2JqZWN0U3RvcmUgcHJvdmlkaW5nIGFuIEFQSSB0aGF0OlxyXG4gKlxyXG4gKiAxKSBIYXMgZ2VuZXJpYyBLZXlUeXBlIC8gVmFsdWVUeXBlIHBhcmFtZXRlcnMgdG8gcHJvdmlkZSBzdHJvbmdseS10eXBlZFxyXG4gKiBtZXRob2RzIGZvciBhY3RpbmcgYWdhaW5zdCB0aGUgb2JqZWN0IHN0b3JlLlxyXG4gKiAyKSBEZWFscyB3aXRoIEluZGV4ZWREQidzIG9uc3VjY2VzcyAvIG9uZXJyb3IgZXZlbnQgY2FsbGJhY2tzLCBtYWtpbmcgZXZlcnlcclxuICogbWV0aG9kIHJldHVybiBhIFBlcnNpc3RlbmNlUHJvbWlzZSBpbnN0ZWFkLlxyXG4gKiAzKSBQcm92aWRlcyBhIGhpZ2hlci1sZXZlbCBBUEkgdG8gYXZvaWQgbmVlZGluZyB0byBkbyBleGNlc3NpdmUgd3JhcHBpbmcgb2ZcclxuICogaW50ZXJtZWRpYXRlIEluZGV4ZWREQiB0eXBlcyAoSURCQ3Vyc29yV2l0aFZhbHVlLCBldGMuKVxyXG4gKi9cclxuY2xhc3MgU2ltcGxlRGJTdG9yZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xyXG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcclxuICAgIH1cclxuICAgIHB1dChrZXlPclZhbHVlLCB2YWx1ZSkge1xyXG4gICAgICAgIGxldCByZXF1ZXN0O1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1BVVCcsIHRoaXMuc3RvcmUubmFtZSwga2V5T3JWYWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zdG9yZS5wdXQodmFsdWUsIGtleU9yVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnUFVUJywgdGhpcy5zdG9yZS5uYW1lLCAnPGF1dG8ta2V5PicsIGtleU9yVmFsdWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zdG9yZS5wdXQoa2V5T3JWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyB2YWx1ZSBpbnRvIGFuIE9iamVjdCBTdG9yZSBhbmQgcmV0dXJucyB0aGUgbmV3IGtleS4gU2ltaWxhciB0b1xyXG4gICAgICogSW5kZXhlZERiJ3MgYGFkZCgpYCwgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIG9uIHByaW1hcnkga2V5IGNvbGxpc2lvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byB3cml0ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgYWRkKHZhbHVlKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnQUREJywgdGhpcy5zdG9yZS5uYW1lLCB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBmcm9tIHRoZSBzcGVjaWZpZWQgc3RvcmUsIG9yIG51bGxcclxuICAgICAqIGlmIG5vIG9iamVjdCBleGlzdHMgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAa2V5IFRoZSBrZXkgb2YgdGhlIG9iamVjdCB0byBnZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgb3IgbnVsbCBpZiBubyBvYmplY3QgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZ2V0KGtleSk7XHJcbiAgICAgICAgLy8gV2UncmUgZG9pbmcgYW4gdW5zYWZlIGNhc3QgdG8gVmFsdWVUeXBlLlxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpLm5leHQocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5vbmV4aXN0ZW5jZSB0byBudWxsLlxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnR0VUJywgdGhpcy5zdG9yZS5uYW1lLCBrZXksIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnREVMRVRFJywgdGhpcy5zdG9yZS5uYW1lLCBrZXkpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgd2UgZXZlciBuZWVkIG1vcmUgb2YgdGhlIGNvdW50IHZhcmlhbnRzLCB3ZSBjYW4gYWRkIG92ZXJsb2Fkcy4gRm9yIG5vdyxcclxuICAgICAqIGFsbCB3ZSBuZWVkIGlzIHRvIGNvdW50IGV2ZXJ5dGhpbmcgaW4gYSBzdG9yZS5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgc3RvcmUuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0NPVU5UJywgdGhpcy5zdG9yZS5uYW1lKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5jb3VudCgpO1xyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIGxvYWRBbGwoaW5kZXhPclJhbmdlLCByYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZXJhdGVPcHRpb25zID0gdGhpcy5vcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpO1xyXG4gICAgICAgIC8vIFVzZSBgZ2V0QWxsKClgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIEluZGV4ZWREQiB2MywgYXMgaXQgaXMgcm91Z2hseVxyXG4gICAgICAgIC8vIDIwJSBmYXN0ZXIuXHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBpdGVyYXRlT3B0aW9ucy5pbmRleFxyXG4gICAgICAgICAgICA/IHRoaXMuc3RvcmUuaW5kZXgoaXRlcmF0ZU9wdGlvbnMuaW5kZXgpXHJcbiAgICAgICAgICAgIDogdGhpcy5zdG9yZTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLmdldEFsbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0QWxsKGl0ZXJhdGVPcHRpb25zLnJhbmdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihpdGVyYXRlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZUN1cnNvcihjdXJzb3IsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9KS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSBmaXJzdCBgY291bnRgIGVsZW1lbnRzIGZyb20gdGhlIHByb3ZpZGVkIGluZGV4IHJhbmdlLiBMb2FkcyBhbGxcclxuICAgICAqIGVsZW1lbnRzIGlmIG5vIGxpbWl0IGlzIHByb3ZpZGVkLlxyXG4gICAgICovXHJcbiAgICBsb2FkRmlyc3QocmFuZ2UsIGNvdW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZ2V0QWxsKHJhbmdlLCBjb3VudCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGNvdW50KTtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlQWxsKGluZGV4T3JSYW5nZSwgcmFuZ2UpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdERUxFVEUgQUxMJywgdGhpcy5zdG9yZS5uYW1lKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpO1xyXG4gICAgICAgIG9wdGlvbnMua2V5c09ubHkgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgLy8gTk9URTogQ2FsbGluZyBkZWxldGUoKSBvbiBhIGN1cnNvciBpcyBkb2N1bWVudGVkIGFzIG1vcmUgZWZmaWNpZW50IHRoYW5cclxuICAgICAgICAgICAgLy8gY2FsbGluZyBkZWxldGUoKSBvbiBhbiBvYmplY3Qgc3RvcmUgd2l0aCBhIHNpbmdsZSBrZXlcclxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJPYmplY3RTdG9yZS9kZWxldGUpLFxyXG4gICAgICAgICAgICAvLyBob3dldmVyLCB0aGlzIHJlcXVpcmVzIHVzICpub3QqIHRvIHVzZSBhIGtleXNPbmx5IGN1cnNvclxyXG4gICAgICAgICAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQkN1cnNvci9kZWxldGUpLiBXZVxyXG4gICAgICAgICAgICAvLyBtYXkgd2FudCB0byBjb21wYXJlIHRoZSBwZXJmb3JtYW5jZSBvZiBlYWNoIG1ldGhvZC5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wuZGVsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpdGVyYXRlKG9wdGlvbnNPckNhbGxiYWNrLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgc3RvcmUsIGJ1dCB3YWl0cyBmb3IgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIGNvbXBsZXRlIGZvclxyXG4gICAgICogZWFjaCBlbnRyeSBiZWZvcmUgaXRlcmF0aW5nIHRoZSBuZXh0IGVudHJ5LiBUaGlzIGFsbG93cyB0aGUgY2FsbGJhY2sgdG8gZG9cclxuICAgICAqIGFzeW5jaHJvbm91cyB3b3JrIHRvIGRldGVybWluZSBpZiB0aGlzIGl0ZXJhdGlvbiBzaG91bGQgY29udGludWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gYHRydWVgIHRvIGNvbnRpbnVlIGl0ZXJhdGlvbiwgYW5kXHJcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXRlcmF0ZVNlcmlhbChjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGN1cnNvclJlcXVlc3QgPSB0aGlzLmN1cnNvcih7fSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihldmVudC50YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yLnZhbHVlKS5uZXh0KHNob3VsZENvbnRpbnVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29udGludWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpdGVyYXRlQ3Vyc29yKGN1cnNvclJlcXVlc3QsIGZuKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEl0ZXJhdGlvbkNvbnRyb2xsZXIoY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXN1bHQgPSBmbihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yLnZhbHVlLCBjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyUmVzdWx0IGluc3RhbmNlb2YgUGVyc2lzdGVuY2VQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB1c2VyUmVzdWx0LmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh1c2VyUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc0RvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250cm9sbGVyLnNraXBUb0tleSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKGNvbnRyb2xsZXIuc2tpcFRvS2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHJlc3VsdHMpKTtcclxuICAgIH1cclxuICAgIG9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSkge1xyXG4gICAgICAgIGxldCBpbmRleE5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGluZGV4T3JSYW5nZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPclJhbmdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhOYW1lID0gaW5kZXhPclJhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBpbmRleE9yUmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgaW5kZXg6IGluZGV4TmFtZSwgcmFuZ2UgfTtcclxuICAgIH1cclxuICAgIGN1cnNvcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9ICduZXh0JztcclxuICAgICAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdwcmV2JztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnN0b3JlLmluZGV4KG9wdGlvbnMuaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlzT25seSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5LZXlDdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5vcGVuQ3Vyc29yKG9wdGlvbnMucmFuZ2UsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlLm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdyYXBzIGFuIElEQlJlcXVlc3QgaW4gYSBQZXJzaXN0ZW5jZVByb21pc2UsIHVzaW5nIHRoZSBvbnN1Y2Nlc3MgLyBvbmVycm9yXHJcbiAqIGhhbmRsZXJzIHRvIHJlc29sdmUgLyByZWplY3QgdGhlIFBlcnNpc3RlbmNlUHJvbWlzZSBhcyBhcHByb3ByaWF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHdyYXBSZXF1ZXN0KHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIEd1YXJkIHNvIHdlIG9ubHkgcmVwb3J0IHRoZSBlcnJvciBvbmNlLlxyXG5sZXQgcmVwb3J0ZWRJT1NFcnJvciA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGVycm9yKSB7XHJcbiAgICBjb25zdCBpT1NWZXJzaW9uID0gU2ltcGxlRGIuZ2V0SU9TVmVyc2lvbihnZXRVQSgpKTtcclxuICAgIGlmIChpT1NWZXJzaW9uID49IDEyLjIgJiYgaU9TVmVyc2lvbiA8IDEzKSB7XHJcbiAgICAgICAgY29uc3QgSU9TX0VSUk9SID0gJ0FuIGludGVybmFsIGVycm9yIHdhcyBlbmNvdW50ZXJlZCBpbiB0aGUgSW5kZXhlZCBEYXRhYmFzZSBzZXJ2ZXInO1xyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluZGV4T2YoSU9TX0VSUk9SKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIFdyYXAgZXJyb3IgaW4gYSBtb3JlIGRlc2NyaXB0aXZlIG9uZS5cclxuICAgICAgICAgICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoJ2ludGVybmFsJywgYElPU19JTkRFWEVEREJfQlVHMTogSW5kZXhlZERiIGhhcyB0aHJvd24gJyR7SU9TX0VSUk9SfScuIFRoaXMgaXMgbGlrZWx5IGAgK1xyXG4gICAgICAgICAgICAgICAgYGR1ZSB0byBhbiB1bmF2b2lkYWJsZSBidWcgaW4gaU9TLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU2NDk2Mjk2LzExMDkxNSBgICtcclxuICAgICAgICAgICAgICAgIGBmb3IgZGV0YWlscyBhbmQgYSBwb3RlbnRpYWwgd29ya2Fyb3VuZC5gKTtcclxuICAgICAgICAgICAgaWYgKCFyZXBvcnRlZElPU0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXBvcnRlZElPU0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIFRocm93IGEgZ2xvYmFsIGV4Y2VwdGlvbiBvdXRzaWRlIG9mIHRoaXMgcHJvbWlzZSBjaGFpbiwgZm9yIHRoZSB1c2VyIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBwb3RlbnRpYWxseSBjYXRjaC5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ld0Vycm9yO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld0Vycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlcnJvcjtcclxufVxuXG5jb25zdCBMT0dfVEFHJGggPSAnSW5kZXhCYWNrZmlsbGVyJztcclxuLyoqIEhvdyBsb25nIHdlIHdhaXQgdG8gdHJ5IHJ1bm5pbmcgaW5kZXggYmFja2ZpbGwgYWZ0ZXIgU0RLIGluaXRpYWxpemF0aW9uLiAqL1xyXG5jb25zdCBJTklUSUFMX0JBQ0tGSUxMX0RFTEFZX01TID0gMTUgKiAxMDAwO1xyXG4vKiogTWluaW11bSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIGJhY2tmaWxsIGNoZWNrcywgYWZ0ZXIgdGhlIGZpcnN0IG9uZS4gKi9cclxuY29uc3QgUkVHVUxBUl9CQUNLRklMTF9ERUxBWV9NUyA9IDYwICogMTAwMDtcclxuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcHJvY2VzcyBlYWNoIHRpbWUgYmFja2ZpbGwoKSBpcyBjYWxsZWQuICovXHJcbmNvbnN0IE1BWF9ET0NVTUVOVFNfVE9fUFJPQ0VTUyA9IDUwO1xyXG4vKiogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHNjaGVkdWxpbmcgb2YgSW5kZXggQmFja2ZpbGxlci4gKi9cclxuY2xhc3MgSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFzeW5jUXVldWUsIGJhY2tmaWxsZXIpIHtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMuYmFja2ZpbGxlciA9IGJhY2tmaWxsZXI7XHJcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGUoSU5JVElBTF9CQUNLRklMTF9ERUxBWV9NUyk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRhc2spIHtcclxuICAgICAgICAgICAgdGhpcy50YXNrLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzdGFydGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhc2sgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZShkZWxheSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYFNjaGVkdWxlZCBpbiAke2RlbGF5fW1zYCk7XHJcbiAgICAgICAgdGhpcy50YXNrID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwiaW5kZXhfYmFja2ZpbGxcIiAvKiBUaW1lcklkLkluZGV4QmFja2ZpbGwgKi8sIGRlbGF5LCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudHNQcm9jZXNzZWQgPSBhd2FpdCB0aGlzLmJhY2tmaWxsZXIuYmFja2ZpbGwoKTtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYERvY3VtZW50cyB3cml0dGVuOiAke2RvY3VtZW50c1Byb2Nlc3NlZH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0lnbm9yaW5nIEluZGV4ZWREQiBlcnJvciBkdXJpbmcgaW5kZXggYmFja2ZpbGw6ICcsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGUoUkVHVUxBUl9CQUNLRklMTF9ERUxBWV9NUyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBiYWNrZmlsbGluZyBpbmRleGVzLiAqL1xyXG5jbGFzcyBJbmRleEJhY2tmaWxsZXIge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsU3RvcmUgcHJvdmlkZXMgYWNjZXNzIHRvIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFZpZXcuXHJcbiAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHdpbGwgdXBkYXRlIHdoZW4gdGhlIHVzZXIgY2hhbmdlcy4gQ29uc2VxdWVudGx5LFxyXG4gICAgICogbWFraW5nIGEgbG9jYWwgY29weSBvZiBJbmRleE1hbmFnZXIgYW5kIExvY2FsRG9jdW1lbnRWaWV3IHdpbGwgcmVxdWlyZVxyXG4gICAgICogdXBkYXRlcyBvdmVyIHRpbWUuIFRoZSBzaW1wbGVyIHNvbHV0aW9uIGlzIHRvIHJlbHkgb24gTG9jYWxTdG9yZSB0byBoYXZlXHJcbiAgICAgKiBhbiB1cC10by1kYXRlIHJlZmVyZW5jZXMgdG8gSW5kZXhNYW5hZ2VyIGFuZCBMb2NhbERvY3VtZW50U3RvcmUuXHJcbiAgICAgKi9cclxuICAgIGxvY2FsU3RvcmUsIHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyBiYWNrZmlsbChtYXhEb2N1bWVudHNUb1Byb2Nlc3MgPSBNQVhfRE9DVU1FTlRTX1RPX1BST0NFU1MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQmFja2ZpbGwgSW5kZXhlcycsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB0aGlzLndyaXRlSW5kZXhFbnRyaWVzKHR4biwgbWF4RG9jdW1lbnRzVG9Qcm9jZXNzKSk7XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIGluZGV4IGVudHJpZXMgdW50aWwgdGhlIGNhcCBpcyByZWFjaGVkLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHByb2Nlc3NlZC4gKi9cclxuICAgIHdyaXRlSW5kZXhFbnRyaWVzKHRyYW5zYXRpb24sIG1heERvY3VtZW50c1RvUHJvY2Vzcykge1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZENvbGxlY3Rpb25Hcm91cHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGRvY3VtZW50c1JlbWFpbmluZyA9IG1heERvY3VtZW50c1RvUHJvY2VzcztcclxuICAgICAgICBsZXQgY29udGludWVMb29wID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmRvV2hpbGUoKCkgPT4gY29udGludWVMb29wID09PSB0cnVlICYmIGRvY3VtZW50c1JlbWFpbmluZyA+IDAsICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgICAgIC5nZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhdGlvbilcclxuICAgICAgICAgICAgICAgIC5uZXh0KChjb2xsZWN0aW9uR3JvdXApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzLmhhcyhjb2xsZWN0aW9uR3JvdXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVMb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBQcm9jZXNzaW5nIGNvbGxlY3Rpb246ICR7Y29sbGVjdGlvbkdyb3VwfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlRW50cmllc0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2F0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGRvY3VtZW50c1JlbWFpbmluZykubmV4dChkb2N1bWVudHNQcm9jZXNzZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1haW5pbmcgLT0gZG9jdW1lbnRzUHJvY2Vzc2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzLmFkZChjb2xsZWN0aW9uR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IG1heERvY3VtZW50c1RvUHJvY2VzcyAtIGRvY3VtZW50c1JlbWFpbmluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBlbnRyaWVzIGZvciB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBncm91cC4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBwcm9jZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlRW50cmllc0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBkb2N1bWVudHNSZW1haW5pbmdVbmRlckNhcCkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgZWFybGllc3Qgb2Zmc2V0IG9mIGFsbCBmaWVsZCBpbmRleGVzIHRvIHF1ZXJ5IHRoZSBsb2NhbCBjYWNoZS5cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlclxyXG4gICAgICAgICAgICAuZ2V0TWluT2Zmc2V0RnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKVxyXG4gICAgICAgICAgICAubmV4dChleGlzdGluZ09mZnNldCA9PiB0aGlzLmxvY2FsU3RvcmUubG9jYWxEb2N1bWVudHNcclxuICAgICAgICAgICAgLmdldE5leHREb2N1bWVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgZXhpc3RpbmdPZmZzZXQsIGRvY3VtZW50c1JlbWFpbmluZ1VuZGVyQ2FwKVxyXG4gICAgICAgICAgICAubmV4dChuZXh0QmF0Y2ggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2NzID0gbmV4dEJhdGNoLmNoYW5nZXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2NzKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5nZXROZXdPZmZzZXQoZXhpc3RpbmdPZmZzZXQsIG5leHRCYXRjaCkpXHJcbiAgICAgICAgICAgICAgICAubmV4dChuZXdPZmZzZXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgVXBkYXRpbmcgb2Zmc2V0OiAke25ld09mZnNldH1gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyLnVwZGF0ZUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBuZXdPZmZzZXQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jcy5zaXplKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgbmV4dCBvZmZzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gKi9cclxuICAgIGdldE5ld09mZnNldChleGlzdGluZ09mZnNldCwgbG9va3VwUmVzdWx0KSB7XHJcbiAgICAgICAgbGV0IG1heE9mZnNldCA9IGV4aXN0aW5nT2Zmc2V0O1xyXG4gICAgICAgIGxvb2t1cFJlc3VsdC5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gbmV3SW5kZXhPZmZzZXRGcm9tRG9jdW1lbnQoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhPZmZzZXRDb21wYXJhdG9yKG5ld09mZnNldCwgbWF4T2Zmc2V0KSA+IDApIHtcclxuICAgICAgICAgICAgICAgIG1heE9mZnNldCA9IG5ld09mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQobWF4T2Zmc2V0LnJlYWRUaW1lLCBtYXhPZmZzZXQuZG9jdW1lbnRLZXksIE1hdGgubWF4KGxvb2t1cFJlc3VsdC5iYXRjaElkLCBleGlzdGluZ09mZnNldC5sYXJnZXN0QmF0Y2hJZCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBgTGlzdGVuU2VxdWVuY2VgIGlzIGEgbW9ub3RvbmljIHNlcXVlbmNlLiBJdCBpcyBpbml0aWFsaXplZCB3aXRoIGEgbWluaW11bSB2YWx1ZSB0b1xyXG4gKiBleGNlZWQuIEFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvIG5leHQgd2lsbCByZXR1cm4gaW5jcmVhc2luZyB2YWx1ZXMuIElmIHByb3ZpZGVkIHdpdGggYVxyXG4gKiBgU2VxdWVuY2VOdW1iZXJTeW5jZXJgLCBpdCB3aWxsIGFkZGl0aW9uYWxseSBidW1wIGl0cyBuZXh0IHZhbHVlIHdoZW4gdG9sZCBvZiBhIG5ldyB2YWx1ZSwgYXNcclxuICogd2VsbCBhcyB3cml0ZSBvdXQgc2VxdWVuY2UgbnVtYmVycyB0aGF0IGl0IHByb2R1Y2VzIHZpYSBgbmV4dCgpYC5cclxuICovXHJcbmNsYXNzIExpc3RlblNlcXVlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzVmFsdWUsIHNlcXVlbmNlTnVtYmVyU3luY2VyKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcclxuICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXJTeW5jZXIpIHtcclxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXJTeW5jZXIuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gc2VxdWVuY2VOdW1iZXIgPT4gdGhpcy5zZXRQcmV2aW91c1ZhbHVlKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXIgPT4gc2VxdWVuY2VOdW1iZXJTeW5jZXIud3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0UHJldmlvdXNWYWx1ZShleHRlcm5hbFByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBNYXRoLm1heChleHRlcm5hbFByZXZpb3VzVmFsdWUsIHRoaXMucHJldmlvdXNWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZTtcclxuICAgIH1cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKyt0aGlzLnByZXZpb3VzVmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMud3JpdGVOZXdTZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIobmV4dFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcclxuICAgIH1cclxufVxyXG5MaXN0ZW5TZXF1ZW5jZS5JTlZBTElEID0gLTE7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGVzY2FwZUNoYXIgPSAnXFx1MDAwMSc7XHJcbmNvbnN0IGVuY29kZWRTZXBhcmF0b3JDaGFyID0gJ1xcdTAwMDEnO1xyXG5jb25zdCBlbmNvZGVkTnVsID0gJ1xcdTAwMTAnO1xyXG5jb25zdCBlbmNvZGVkRXNjYXBlID0gJ1xcdTAwMTEnO1xyXG4vKipcclxuICogRW5jb2RlcyBhIHJlc291cmNlIHBhdGggaW50byBhIEluZGV4ZWREYi1jb21wYXRpYmxlIHN0cmluZyBmb3JtLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpIHtcclxuICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ID0gZW5jb2RlU2VnbWVudChwYXRoLmdldChpKSwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KTtcclxufVxyXG4vKiogRW5jb2RlcyBhIHNpbmdsZSBzZWdtZW50IG9mIGEgcmVzb3VyY2UgcGF0aCBpbnRvIHRoZSBnaXZlbiByZXN1bHQgKi9cclxuZnVuY3Rpb24gZW5jb2RlU2VnbWVudChzZWdtZW50LCByZXN1bHRCdWYpIHtcclxuICAgIGxldCByZXN1bHQgPSByZXN1bHRCdWY7XHJcbiAgICBjb25zdCBsZW5ndGggPSBzZWdtZW50Lmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjID0gc2VnbWVudC5jaGFyQXQoaSk7XHJcbiAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1xcMCc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQ2hhciArIGVuY29kZWROdWw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBlc2NhcGVDaGFyOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXIgKyBlbmNvZGVkRXNjYXBlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgcGF0aCBzZXBhcmF0b3IgaW50byB0aGUgZ2l2ZW4gcmVzdWx0ICovXHJcbmZ1bmN0aW9uIGVuY29kZVNlcGFyYXRvcihyZXN1bHQpIHtcclxuICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVDaGFyICsgZW5jb2RlZFNlcGFyYXRvckNoYXI7XHJcbn1cclxuLyoqXHJcbiAqIERlY29kZXMgdGhlIGdpdmVuIEluZGV4ZWREYi1jb21wYXRpYmxlIHN0cmluZyBmb3JtIG9mIGEgcmVzb3VyY2UgcGF0aCBpbnRvXHJcbiAqIGEgUmVzb3VyY2VQYXRoIGluc3RhbmNlLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgbm90IHN1aXRhYmxlIGZvciB1c2Ugd2l0aFxyXG4gKiBkZWNvZGluZyByZXNvdXJjZSBuYW1lcyBmcm9tIHRoZSBzZXJ2ZXI7IHRob3NlIGFyZSBPbmUgUGxhdGZvcm0gZm9ybWF0XHJcbiAqIHN0cmluZ3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVSZXNvdXJjZVBhdGgocGF0aCkge1xyXG4gICAgLy8gRXZlbnQgdGhlIGVtcHR5IHBhdGggbXVzdCBlbmNvZGUgYXMgYSBwYXRoIG9mIGF0IGxlYXN0IGxlbmd0aCAyLiBBIHBhdGhcclxuICAgIC8vIHdpdGggZXhhY3RseSAyIG11c3QgYmUgdGhlIGVtcHR5IHBhdGguXHJcbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgIGhhcmRBc3NlcnQobGVuZ3RoID49IDIpO1xyXG4gICAgaWYgKGxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIGhhcmRBc3NlcnQocGF0aC5jaGFyQXQoMCkgPT09IGVzY2FwZUNoYXIgJiYgcGF0aC5jaGFyQXQoMSkgPT09IGVuY29kZWRTZXBhcmF0b3JDaGFyKTtcclxuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpO1xyXG4gICAgfVxyXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgY2Fubm90IGV4aXN0IHBhc3QgdGhlIHNlY29uZC10by1sYXN0IHBvc2l0aW9uIGluIHRoZVxyXG4gICAgLy8gc291cmNlIHZhbHVlLlxyXG4gICAgY29uc3QgbGFzdFJlYXNvbmFibGVFc2NhcGVJbmRleCA9IGxlbmd0aCAtIDI7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgbGV0IHNlZ21lbnRCdWlsZGVyID0gJyc7XHJcbiAgICBmb3IgKGxldCBzdGFydCA9IDA7IHN0YXJ0IDwgbGVuZ3RoOykge1xyXG4gICAgICAgIC8vIFRoZSBsYXN0IHR3byBjaGFyYWN0ZXJzIG9mIGEgdmFsaWQgZW5jb2RlZCBwYXRoIG11c3QgYmUgYSBzZXBhcmF0b3IsIHNvXHJcbiAgICAgICAgLy8gdGhlcmUgbXVzdCBiZSBhbiBlbmQgdG8gdGhpcyBzZWdtZW50LlxyXG4gICAgICAgIGNvbnN0IGVuZCA9IHBhdGguaW5kZXhPZihlc2NhcGVDaGFyLCBzdGFydCk7XHJcbiAgICAgICAgaWYgKGVuZCA8IDAgfHwgZW5kID4gbGFzdFJlYXNvbmFibGVFc2NhcGVJbmRleCkge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHQgPSBwYXRoLmNoYXJBdChlbmQgKyAxKTtcclxuICAgICAgICBzd2l0Y2ggKG5leHQpIHtcclxuICAgICAgICAgICAgY2FzZSBlbmNvZGVkU2VwYXJhdG9yQ2hhcjpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQaWVjZSA9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudEJ1aWxkZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgY29weWluZyBmb3IgdGhlIGNvbW1vbiBjYXNlIG9mIGEgc2VnbWVudCB0aGF0IGV4Y2x1ZGVzIFxcMFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBcXDAwMVxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBjdXJyZW50UGllY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSBjdXJyZW50UGllY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRCdWlsZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZW5jb2RlZE51bDpcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gJ1xcMCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBlbmNvZGVkRXNjYXBlOlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVzY2FwZSBjaGFyYWN0ZXIgY2FuIGJlIHVzZWQgaW4gdGhlIG91dHB1dCB0byBlbmNvZGUgaXRzZWxmLlxyXG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCArIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0ID0gZW5kICsgMjtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEYlJlbW90ZURvY3VtZW50U3RvcmUkMSA9ICdyZW1vdGVEb2N1bWVudHMnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBuYW1lICdvd25lcicgaXMgY2hvc2VuIHRvIGVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXHJcbiAqIG9sZGVyIGNsaWVudHMgdGhhdCBvbmx5IHN1cHBvcnRlZCBzaW5nbGUgbG9ja2VkIGFjY2VzcyB0byB0aGUgcGVyc2lzdGVuY2VcclxuICogbGF5ZXIuXHJcbiAqL1xyXG5jb25zdCBEYlByaW1hcnlDbGllbnRTdG9yZSA9ICdvd25lcic7XHJcbi8qKlxyXG4gKiBUaGUga2V5IHN0cmluZyB1c2VkIGZvciB0aGUgc2luZ2xlIG9iamVjdCB0aGF0IGV4aXN0cyBpbiB0aGVcclxuICogRGJQcmltYXJ5Q2xpZW50IHN0b3JlLlxyXG4gKi9cclxuY29uc3QgRGJQcmltYXJ5Q2xpZW50S2V5ID0gJ293bmVyJztcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xyXG5jb25zdCBEYk11dGF0aW9uUXVldWVTdG9yZSA9ICdtdXRhdGlvblF1ZXVlcyc7XHJcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdXNlcklkIHByb3BlcnR5LiAqL1xyXG5jb25zdCBEYk11dGF0aW9uUXVldWVLZXlQYXRoID0gJ3VzZXJJZCc7XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAgKi9cclxuY29uc3QgRGJNdXRhdGlvbkJhdGNoU3RvcmUgPSAnbXV0YXRpb25zJztcclxuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB1c2VySWQsIGJhdGNoSWQgcHJvcGVydGllcy4gKi9cclxuY29uc3QgRGJNdXRhdGlvbkJhdGNoS2V5UGF0aCA9ICdiYXRjaElkJztcclxuLyoqIFRoZSBpbmRleCBuYW1lIGZvciBsb29rdXAgb2YgbXV0YXRpb25zIGJ5IHVzZXIuICovXHJcbmNvbnN0IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCA9ICd1c2VyTXV0YXRpb25zSW5kZXgnO1xyXG4vKiogVGhlIHVzZXIgbXV0YXRpb25zIGluZGV4IGlzIGtleWVkIGJ5IFt1c2VySWQsIGJhdGNoSWRdIHBhaXJzLiAqL1xyXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zS2V5UGF0aCA9IFsndXNlcklkJywgJ2JhdGNoSWQnXTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBbdXNlcklkXSBrZXkgZm9yIHVzZSBpbiB0aGUgRGJEb2N1bWVudE11dGF0aW9ucyBpbmRleCB0byBpdGVyYXRlXHJcbiAqIG92ZXIgYWxsIG9mIGEgdXNlcidzIGRvY3VtZW50IG11dGF0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclVzZXIodXNlcklkKSB7XHJcbiAgICByZXR1cm4gW3VzZXJJZF07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBbdXNlcklkLCBlbmNvZGVkUGF0aF0ga2V5IGZvciB1c2UgaW4gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnNcclxuICogaW5kZXggdG8gaXRlcmF0ZSBvdmVyIGFsbCBhdCBkb2N1bWVudCBtdXRhdGlvbnMgZm9yIGEgZ2l2ZW4gcGF0aCBvciBsb3dlci5cclxuICovXHJcbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodXNlcklkLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpXTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGZ1bGwgaW5kZXgga2V5IG9mIFt1c2VySWQsIGVuY29kZWRQYXRoLCBiYXRjaElkXSBmb3IgaW5zZXJ0aW5nXHJcbiAqIGFuZCBkZWxldGluZyBpbnRvIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zIGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uS2V5KHVzZXJJZCwgcGF0aCwgYmF0Y2hJZCkge1xyXG4gICAgcmV0dXJuIFt1c2VySWQsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKSwgYmF0Y2hJZF07XHJcbn1cclxuLyoqXHJcbiAqIEJlY2F1c2Ugd2Ugc3RvcmUgYWxsIHRoZSB1c2VmdWwgaW5mb3JtYXRpb24gZm9yIHRoaXMgc3RvcmUgaW4gdGhlIGtleSxcclxuICogdGhlcmUgaXMgbm8gdXNlZnVsIGluZm9ybWF0aW9uIHRvIHN0b3JlIGFzIHRoZSB2YWx1ZS4gVGhlIHJhdyAodW5lbmNvZGVkKVxyXG4gKiBwYXRoIGNhbm5vdCBiZSBzdG9yZWQgYmVjYXVzZSBJbmRleGVkRGIgZG9lc24ndCBzdG9yZSBwcm90b3R5cGVcclxuICogaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5jb25zdCBEYkRvY3VtZW50TXV0YXRpb25QbGFjZWhvbGRlciA9IHt9O1xyXG5jb25zdCBEYkRvY3VtZW50TXV0YXRpb25TdG9yZSA9ICdkb2N1bWVudE11dGF0aW9ucyc7XHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRTdG9yZSA9ICdyZW1vdGVEb2N1bWVudHNWMTQnO1xyXG4vKipcclxuICogVGhlIHByaW1hcnkga2V5IG9mIHRoZSByZW1vdGUgZG9jdW1lbnRzIHN0b3JlLCB3aGljaCBhbGxvd3MgZm9yIGVmZmljaWVudFxyXG4gKiBhY2Nlc3MgYnkgY29sbGVjdGlvbiBwYXRoIGFuZCByZWFkIHRpbWUuXHJcbiAqL1xyXG5jb25zdCBEYlJlbW90ZURvY3VtZW50S2V5UGF0aCA9IFtcclxuICAgICdwcmVmaXhQYXRoJyxcclxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxyXG4gICAgJ3JlYWRUaW1lJyxcclxuICAgICdkb2N1bWVudElkJ1xyXG5dO1xyXG4vKiogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gZG9jdW1lbnRzIGJ5IGtleS4gKi9cclxuY29uc3QgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXggPSAnZG9jdW1lbnRLZXlJbmRleCc7XHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4UGF0aCA9IFtcclxuICAgICdwcmVmaXhQYXRoJyxcclxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxyXG4gICAgJ2RvY3VtZW50SWQnXHJcbl07XHJcbi8qKlxyXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgYnkgY29sbGVjdGlvbiBncm91cCBhbmQgcmVhZFxyXG4gKiB0aW1lLlxyXG4gKlxyXG4gKiBUaGlzIGluZGV4IGlzIHVzZWQgYnkgdGhlIGluZGV4IGJhY2tmaWxsZXIuXHJcbiAqL1xyXG5jb25zdCBEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXggPSAnY29sbGVjdGlvbkdyb3VwSW5kZXgnO1xyXG5jb25zdCBEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXhQYXRoID0gW1xyXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXHJcbiAgICAncmVhZFRpbWUnLFxyXG4gICAgJ3ByZWZpeFBhdGgnLFxyXG4gICAgJ2RvY3VtZW50SWQnXHJcbl07XHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSA9ICdyZW1vdGVEb2N1bWVudEdsb2JhbCc7XHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXkgPSAncmVtb3RlRG9jdW1lbnRHbG9iYWxLZXknO1xyXG5jb25zdCBEYlRhcmdldFN0b3JlID0gJ3RhcmdldHMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHRhcmdldElkIHByb3BlcnR5LiAqL1xyXG5jb25zdCBEYlRhcmdldEtleVBhdGggPSAndGFyZ2V0SWQnO1xyXG4vKiogVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleC4gKi9cclxuY29uc3QgRGJUYXJnZXRRdWVyeVRhcmdldHNJbmRleE5hbWUgPSAncXVlcnlUYXJnZXRzSW5kZXgnO1xyXG4vKipcclxuICogVGhlIGluZGV4IG9mIGFsbCBjYW5vbmljYWxJZHMgdG8gdGhlIHRhcmdldHMgdGhhdCB0aGV5IG1hdGNoLiBUaGlzIGlzIG5vdFxyXG4gKiBhIHVuaXF1ZSBtYXBwaW5nIGJlY2F1c2UgY2Fub25pY2FsSWQgZG9lcyBub3QgcHJvbWlzZSBhIHVuaXF1ZSBuYW1lIGZvciBhbGxcclxuICogcG9zc2libGUgcXVlcmllcywgc28gd2UgYXBwZW5kIHRoZSB0YXJnZXRJZCB0byBtYWtlIHRoZSBtYXBwaW5nIHVuaXF1ZS5cclxuICovXHJcbmNvbnN0IERiVGFyZ2V0UXVlcnlUYXJnZXRzS2V5UGF0aCA9IFsnY2Fub25pY2FsSWQnLCAndGFyZ2V0SWQnXTtcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xyXG5jb25zdCBEYlRhcmdldERvY3VtZW50U3RvcmUgPSAndGFyZ2V0RG9jdW1lbnRzJztcclxuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB0YXJnZXRJZCwgcGF0aCBwcm9wZXJ0aWVzLiAqL1xyXG5jb25zdCBEYlRhcmdldERvY3VtZW50S2V5UGF0aCA9IFsndGFyZ2V0SWQnLCAncGF0aCddO1xyXG4vKiogVGhlIGluZGV4IG5hbWUgZm9yIHRoZSByZXZlcnNlIGluZGV4LiAqL1xyXG5jb25zdCBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXggPSAnZG9jdW1lbnRUYXJnZXRzSW5kZXgnO1xyXG4vKiogV2UgYWxzbyBuZWVkIHRvIGNyZWF0ZSB0aGUgcmV2ZXJzZSBpbmRleCBmb3IgdGhlc2UgcHJvcGVydGllcy4gKi9cclxuY29uc3QgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0tleVBhdGggPSBbJ3BhdGgnLCAndGFyZ2V0SWQnXTtcclxuLyoqXHJcbiAqIFRoZSBrZXkgc3RyaW5nIHVzZWQgZm9yIHRoZSBzaW5nbGUgb2JqZWN0IHRoYXQgZXhpc3RzIGluIHRoZVxyXG4gKiBEYlRhcmdldEdsb2JhbCBzdG9yZS5cclxuICovXHJcbmNvbnN0IERiVGFyZ2V0R2xvYmFsS2V5ID0gJ3RhcmdldEdsb2JhbEtleSc7XHJcbmNvbnN0IERiVGFyZ2V0R2xvYmFsU3RvcmUgPSAndGFyZ2V0R2xvYmFsJztcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiQ29sbGVjdGlvblBhcmVudFN0b3JlID0gJ2NvbGxlY3Rpb25QYXJlbnRzJztcclxuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSBjb2xsZWN0aW9uSWQsIHBhcmVudCBwcm9wZXJ0aWVzLiAqL1xyXG5jb25zdCBEYkNvbGxlY3Rpb25QYXJlbnRLZXlQYXRoID0gWydjb2xsZWN0aW9uSWQnLCAncGFyZW50J107XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5jb25zdCBEYkNsaWVudE1ldGFkYXRhU3RvcmUgPSAnY2xpZW50TWV0YWRhdGEnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIGNsaWVudElkIHByb3BlcnRpZXMuICovXHJcbmNvbnN0IERiQ2xpZW50TWV0YWRhdGFLZXlQYXRoID0gJ2NsaWVudElkJztcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiQnVuZGxlU3RvcmUgPSAnYnVuZGxlcyc7XHJcbmNvbnN0IERiQnVuZGxlS2V5UGF0aCA9ICdidW5kbGVJZCc7XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5jb25zdCBEYk5hbWVkUXVlcnlTdG9yZSA9ICduYW1lZFF1ZXJpZXMnO1xyXG5jb25zdCBEYk5hbWVkUXVlcnlLZXlQYXRoID0gJ25hbWUnO1xyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cclxuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSA9ICdpbmRleENvbmZpZ3VyYXRpb24nO1xyXG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvbktleVBhdGggPSAnaW5kZXhJZCc7XHJcbi8qKlxyXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgaW5kZXggY29uZmlndXJhdGlvbnMgYnkgY29sbGVjdGlvblxyXG4gKiBncm91cC5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBpT1MgYW5kIEFuZHJvaWQgbWFpbnRhaW4gdGhpcyBpbmRleCBpbi1tZW1vcnksIGJ1dCB0aGlzIGlzXHJcbiAqIG5vdCBwb3NzaWJsZSBoZXJlIGFzIHRoZSBXZWIgY2xpZW50IHN1cHBvcnRzIGNvbmN1cnJlbnQgYWNjZXNzIHRvXHJcbiAqIHBlcnNpc3RlbmNlIHZpYSBtdWx0aS10YWIuXHJcbiAqL1xyXG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4ID0gJ2NvbGxlY3Rpb25Hcm91cEluZGV4JztcclxuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleFBhdGggPSAnY29sbGVjdGlvbkdyb3VwJztcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiSW5kZXhTdGF0ZVN0b3JlID0gJ2luZGV4U3RhdGUnO1xyXG5jb25zdCBEYkluZGV4U3RhdGVLZXlQYXRoID0gWydpbmRleElkJywgJ3VpZCddO1xyXG4vKipcclxuICogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gZG9jdW1lbnRzIGluIGEgY29sbGVjdGlvbiBzb3J0ZWQgYnkgbGFzdFxyXG4gKiB1cGRhdGUgdGltZS4gVXNlZCBieSB0aGUgYmFja2ZpbGxlci5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBpT1MgYW5kIEFuZHJvaWQgbWFpbnRhaW4gdGhpcyBpbmRleCBpbi1tZW1vcnksIGJ1dCB0aGlzIGlzXHJcbiAqIG5vdCBwb3NzaWJsZSBoZXJlIGFzIHRoZSBXZWIgY2xpZW50IHN1cHBvcnRzIGNvbmN1cnJlbnQgYWNjZXNzIHRvXHJcbiAqIHBlcnNpc3RlbmNlIHZpYSBtdWx0aS10YWIuXHJcbiAqL1xyXG5jb25zdCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4ID0gJ3NlcXVlbmNlTnVtYmVySW5kZXgnO1xyXG5jb25zdCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4UGF0aCA9IFsndWlkJywgJ3NlcXVlbmNlTnVtYmVyJ107XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5jb25zdCBEYkluZGV4RW50cnlTdG9yZSA9ICdpbmRleEVudHJpZXMnO1xyXG5jb25zdCBEYkluZGV4RW50cnlLZXlQYXRoID0gW1xyXG4gICAgJ2luZGV4SWQnLFxyXG4gICAgJ3VpZCcsXHJcbiAgICAnYXJyYXlWYWx1ZScsXHJcbiAgICAnZGlyZWN0aW9uYWxWYWx1ZScsXHJcbiAgICAnb3JkZXJlZERvY3VtZW50S2V5JyxcclxuICAgICdkb2N1bWVudEtleSdcclxuXTtcclxuY29uc3QgRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCA9ICdkb2N1bWVudEtleUluZGV4JztcclxuY29uc3QgRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleFBhdGggPSBbXHJcbiAgICAnaW5kZXhJZCcsXHJcbiAgICAndWlkJyxcclxuICAgICdvcmRlcmVkRG9jdW1lbnRLZXknXHJcbl07XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheVN0b3JlID0gJ2RvY3VtZW50T3ZlcmxheXMnO1xyXG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUtleVBhdGggPSBbXHJcbiAgICAndXNlcklkJyxcclxuICAgICdjb2xsZWN0aW9uUGF0aCcsXHJcbiAgICAnZG9jdW1lbnRJZCdcclxuXTtcclxuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCA9ICdjb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCc7XHJcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXhQYXRoID0gW1xyXG4gICAgJ3VzZXJJZCcsXHJcbiAgICAnY29sbGVjdGlvblBhdGgnLFxyXG4gICAgJ2xhcmdlc3RCYXRjaElkJ1xyXG5dO1xyXG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXgnO1xyXG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleFBhdGggPSBbXHJcbiAgICAndXNlcklkJyxcclxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxyXG4gICAgJ2xhcmdlc3RCYXRjaElkJ1xyXG5dO1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmNvbnN0IFYxX1NUT1JFUyA9IFtcclxuICAgIERiTXV0YXRpb25RdWV1ZVN0b3JlLFxyXG4gICAgRGJNdXRhdGlvbkJhdGNoU3RvcmUsXHJcbiAgICBEYkRvY3VtZW50TXV0YXRpb25TdG9yZSxcclxuICAgIERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxLFxyXG4gICAgRGJUYXJnZXRTdG9yZSxcclxuICAgIERiUHJpbWFyeUNsaWVudFN0b3JlLFxyXG4gICAgRGJUYXJnZXRHbG9iYWxTdG9yZSxcclxuICAgIERiVGFyZ2V0RG9jdW1lbnRTdG9yZVxyXG5dO1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmNvbnN0IFYzX1NUT1JFUyA9IFYxX1NUT1JFUztcclxuLy8gTm90ZTogRGJSZW1vdGVEb2N1bWVudENoYW5nZXMgaXMgbm8gbG9uZ2VyIHVzZWQgYW5kIGRyb3BwZWQgd2l0aCB2OS5cclxuY29uc3QgVjRfU1RPUkVTID0gWy4uLlYzX1NUT1JFUywgRGJDbGllbnRNZXRhZGF0YVN0b3JlXTtcclxuY29uc3QgVjZfU1RPUkVTID0gWy4uLlY0X1NUT1JFUywgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlXTtcclxuY29uc3QgVjhfU1RPUkVTID0gWy4uLlY2X1NUT1JFUywgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmVdO1xyXG5jb25zdCBWMTFfU1RPUkVTID0gWy4uLlY4X1NUT1JFUywgRGJCdW5kbGVTdG9yZSwgRGJOYW1lZFF1ZXJ5U3RvcmVdO1xyXG5jb25zdCBWMTJfU1RPUkVTID0gWy4uLlYxMV9TVE9SRVMsIERiRG9jdW1lbnRPdmVybGF5U3RvcmVdO1xyXG5jb25zdCBWMTNfU1RPUkVTID0gW1xyXG4gICAgRGJNdXRhdGlvblF1ZXVlU3RvcmUsXHJcbiAgICBEYk11dGF0aW9uQmF0Y2hTdG9yZSxcclxuICAgIERiRG9jdW1lbnRNdXRhdGlvblN0b3JlLFxyXG4gICAgRGJSZW1vdGVEb2N1bWVudFN0b3JlLFxyXG4gICAgRGJUYXJnZXRTdG9yZSxcclxuICAgIERiUHJpbWFyeUNsaWVudFN0b3JlLFxyXG4gICAgRGJUYXJnZXRHbG9iYWxTdG9yZSxcclxuICAgIERiVGFyZ2V0RG9jdW1lbnRTdG9yZSxcclxuICAgIERiQ2xpZW50TWV0YWRhdGFTdG9yZSxcclxuICAgIERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSxcclxuICAgIERiQ29sbGVjdGlvblBhcmVudFN0b3JlLFxyXG4gICAgRGJCdW5kbGVTdG9yZSxcclxuICAgIERiTmFtZWRRdWVyeVN0b3JlLFxyXG4gICAgRGJEb2N1bWVudE92ZXJsYXlTdG9yZVxyXG5dO1xyXG5jb25zdCBWMTRfU1RPUkVTID0gVjEzX1NUT1JFUztcclxuY29uc3QgVjE1X1NUT1JFUyA9IFtcclxuICAgIC4uLlYxNF9TVE9SRVMsXHJcbiAgICBEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlLFxyXG4gICAgRGJJbmRleFN0YXRlU3RvcmUsXHJcbiAgICBEYkluZGV4RW50cnlTdG9yZVxyXG5dO1xyXG5jb25zdCBWMTZfU1RPUkVTID0gVjE1X1NUT1JFUztcclxuLyoqIFJldHVybnMgdGhlIG9iamVjdCBzdG9yZXMgZm9yIHRoZSBwcm92aWRlZCBzY2hlbWEuICovXHJcbmZ1bmN0aW9uIGdldE9iamVjdFN0b3JlcyhzY2hlbWFWZXJzaW9uKSB7XHJcbiAgICBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTYpIHtcclxuICAgICAgICByZXR1cm4gVjE2X1NUT1JFUztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE1KSB7XHJcbiAgICAgICAgcmV0dXJuIFYxNV9TVE9SRVM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNCkge1xyXG4gICAgICAgIHJldHVybiBWMTRfU1RPUkVTO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTMpIHtcclxuICAgICAgICByZXR1cm4gVjEzX1NUT1JFUztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDEyKSB7XHJcbiAgICAgICAgcmV0dXJuIFYxMl9TVE9SRVM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMSkge1xyXG4gICAgICAgIHJldHVybiBWMTFfU1RPUkVTO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYlRyYW5zYWN0aW9uIGV4dGVuZHMgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaW1wbGVEYlRyYW5zYWN0aW9uLCBjdXJyZW50U2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlRGJUcmFuc2FjdGlvbiA9IHNpbXBsZURiVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2VOdW1iZXIgPSBjdXJyZW50U2VxdWVuY2VOdW1iZXI7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3RvcmUodHhuLCBzdG9yZSkge1xyXG4gICAgY29uc3QgaW5kZXhlZERiVHJhbnNhY3Rpb24gPSBkZWJ1Z0Nhc3QodHhuKTtcclxuICAgIHJldHVybiBTaW1wbGVEYi5nZXRTdG9yZShpbmRleGVkRGJUcmFuc2FjdGlvbi5zaW1wbGVEYlRyYW5zYWN0aW9uLCBzdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb3VudDtcclxufVxyXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYXBUb0FycmF5KG9iaiwgZm4pIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4ob2JqW2tleV0sIGtleSwgb2JqKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuLy8gdHJlZS5cclxuY2xhc3MgU29ydGVkTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IsIHJvb3QpIHtcclxuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QgPyByb290IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkIG9yIHJlcGxhY2VkLlxyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxyXG4gICAgICAgICAgICAuaW5zZXJ0KGtleSwgdmFsdWUsIHRoaXMuY29tcGFyYXRvcilcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhpcyBzb3J0ZWQgbWFwLCBvciAtMSBpZiBpdCBkb2Vzbid0XHJcbiAgICAvLyBleGlzdC5cclxuICAgIGluZGV4T2Yoa2V5KSB7XHJcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vZGVzIHRoYXQgd2VyZSBwcnVuZWQgd2hlbiBkZXNjZW5kaW5nIHJpZ2h0XHJcbiAgICAgICAgbGV0IHBydW5lZE5vZGVzID0gMDtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyYXRvcihrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBydW5lZE5vZGVzICsgbm9kZS5sZWZ0LnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENvdW50IGFsbCBub2RlcyBsZWZ0IG9mIHRoZSBub2RlIHBsdXMgdGhlIG5vZGUgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICBwcnVuZWROb2RlcyArPSBub2RlLmxlZnQuc2l6ZSArIDE7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb2RlIG5vdCBmb3VuZFxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5tYXhLZXkoKTtcclxuICAgIH1cclxuICAgIC8vIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgIC8vIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICB0aGlzLmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcclxuICAgICAgICAgICAgZm4oaywgdik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbnMucHVzaChgJHtrfToke3Z9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYHske2Rlc2NyaXB0aW9ucy5qb2luKCcsICcpfX1gO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uXHJcbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzXHJcbiAgICAvLyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICBnZXRJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBrZXksIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XHJcbiAgICB9XHJcbn0gLy8gZW5kIFNvcnRlZE1hcFxyXG4vLyBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxyXG5jbGFzcyBTb3J0ZWRNYXBJdGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlKSB7XHJcbiAgICAgICAgdGhpcy5pc1JldmVyc2UgPSBpc1JldmVyc2U7XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbXTtcclxuICAgICAgICBsZXQgY21wID0gMTtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHN0YXJ0S2V5ID8gY29tcGFyYXRvcihub2RlLmtleSwgc3RhcnRLZXkpIDogMTtcclxuICAgICAgICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXHJcbiAgICAgICAgICAgIGlmIChzdGFydEtleSAmJiBpc1JldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2subGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIHBlZWsoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICB9XHJcbn0gLy8gZW5kIFNvcnRlZE1hcEl0ZXJhdG9yXHJcbi8vIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxyXG5jbGFzcyBMTFJCTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMubGVmdC5zaXplICsgMSArIHRoaXMucmlnaHQuc2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgIC8vIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8vIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cclxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgIG1pbigpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKCkua2V5O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIGtleS92YWx1ZSBhZGRlZC5cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW4oKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IHNtYWxsZXN0O1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFuLnJpZ2h0LmlzRW1wdHkoKSAmJiAhbi5yaWdodC5pc1JlZCgpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChuLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMTFJCTm9kZS5FTVBUWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gbi5yaWdodC5taW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XHJcbiAgICB9XHJcbiAgICBpc1JlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgIGZpeFVwKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZCgpICYmICFuLmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLmxlZnQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLnJpZ2h0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlZExlZnQoKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHQoKSk7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlZFJpZ2h0KCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXAoKTtcclxuICAgICAgICBpZiAobi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICByb3RhdGVMZWZ0KCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIHJvdGF0ZVJpZ2h0KCkge1xyXG4gICAgICAgIGNvbnN0IG5yID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbnVsbCwgbnIpO1xyXG4gICAgfVxyXG4gICAgY29sb3JGbGlwKCkge1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIHRlc3RpbmcuXHJcbiAgICBjaGVja01heERlcHRoKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrKCk7XHJcbiAgICAgICAgaWYgKE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5zaXplICsgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJbiBhIGJhbGFuY2VkIFJCIHRyZWUsIHRoZSBibGFjay1kZXB0aCAobnVtYmVyIG9mIGJsYWNrIG5vZGVzKSBmcm9tIHJvb3QgdG9cclxuICAgIC8vIGxlYXZlcyBpcyBlcXVhbCBvbiBib3RoIHNpZGVzLiAgVGhpcyBmdW5jdGlvbiB2ZXJpZmllcyB0aGF0IG9yIGFzc2VydHMuXHJcbiAgICBjaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JlZCgpICYmIHRoaXMubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2soKTtcclxuICAgICAgICBpZiAoYmxhY2tEZXB0aCAhPT0gdGhpcy5yaWdodC5jaGVjaygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibGFja0RlcHRoICsgKHRoaXMuaXNSZWQoKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gLy8gZW5kIExMUkJOb2RlXHJcbi8vIEVtcHR5IG5vZGUgaXMgc2hhcmVkIGJldHdlZW4gYWxsIExMUkIgdHJlZXMuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbkxMUkJOb2RlLkVNUFRZID0gbnVsbDtcclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLy8gUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxyXG5jbGFzcyBMTFJCRW1wdHlOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgY29sb3IoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlZnQoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJpZ2h0KCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpc1JlZCgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIGNoZWNrTWF4RGVwdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjaGVjaygpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufSAvLyBlbmQgTExSQkVtcHR5Tm9kZVxyXG5MTFJCTm9kZS5FTVBUWSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTb3J0ZWRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZWxlbWVudHNcclxuICogaW4gb3JkZXIgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLlxyXG4gKlxyXG4gKiBOT1RFOiBpZiBwcm92aWRlZCBjb21wYXJhdG9yIHJldHVybnMgMCBmb3IgdHdvIGVsZW1lbnRzLCB3ZSBjb25zaWRlciB0aGVtIHRvXHJcbiAqIGJlIGVxdWFsIVxyXG4gKi9cclxuY2xhc3MgU29ydGVkU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIGhhcyhlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZWxlbSkgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBmaXJzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1pbktleSgpO1xyXG4gICAgfVxyXG4gICAgbGFzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1heEtleSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zaXplO1xyXG4gICAgfVxyXG4gICAgaW5kZXhPZihlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pbmRleE9mKGVsZW0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIG9yZGVyIGRlZmluZWQgYnkgXCJjb21wYXJhdG9yXCIgKi9cclxuICAgIGZvckVhY2goY2IpIHtcclxuICAgICAgICB0aGlzLmRhdGEuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBjYihrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHJhbmdlWzBdICZsdDs9IGVsZW0gJmx0OyByYW5nZVsxXS4gKi9cclxuICAgIGZvckVhY2hJblJhbmdlKHJhbmdlLCBjYikge1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHJhbmdlWzBdKTtcclxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKGVsZW0ua2V5LCByYW5nZVsxXSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNiKGVsZW0ua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHN0YXJ0ICZsdDs9IGVsZW0gdW50aWwgZmFsc2UgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hXaGlsZShjYiwgc3RhcnQpIHtcclxuICAgICAgICBsZXQgaXRlcjtcclxuICAgICAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKGVsZW0ua2V5KTtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBGaW5kcyB0aGUgbGVhc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYGVsZW1gLiAqL1xyXG4gICAgZmlyc3RBZnRlck9yRXF1YWwoZWxlbSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGVsZW0pO1xyXG4gICAgICAgIHJldHVybiBpdGVyLmhhc05leHQoKSA/IGl0ZXIuZ2V0TmV4dCgpLmtleSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oa2V5KSk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgKi9cclxuICAgIGFkZChlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmRhdGEucmVtb3ZlKGVsZW0pLmluc2VydChlbGVtLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICAvKiogRGVsZXRlcyBhbiBlbGVtZW50ICovXHJcbiAgICBkZWxldGUoZWxlbSkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXMoZWxlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5kYXRhLnJlbW92ZShlbGVtKSk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgdW5pb25XaXRoKG90aGVyKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIGByZXN1bHRgIGFsd2F5cyByZWZlcnMgdG8gdGhlIGxhcmdlciBvbmUgb2YgdGhlIHR3byBzZXRzLlxyXG4gICAgICAgIGlmIChyZXN1bHQuc2l6ZSA8IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gb3RoZXI7XHJcbiAgICAgICAgICAgIG90aGVyID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgb3RoZXIuZm9yRWFjaChlbGVtID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChlbGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU29ydGVkU2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGlzSXQgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICBjb25zdCBvdGhlckl0ID0gb3RoZXIuZGF0YS5nZXRJdGVyYXRvcigpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzSXQuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRoaXNFbGVtID0gdGhpc0l0LmdldE5leHQoKS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRWxlbSA9IG90aGVySXQuZ2V0TmV4dCgpLmtleTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvcih0aGlzRWxlbSwgb3RoZXJFbGVtKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2godGFyZ2V0SWQgPT4ge1xyXG4gICAgICAgICAgICByZXMucHVzaCh0YXJnZXRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChlbGVtID0+IHJlc3VsdC5wdXNoKGVsZW0pKTtcclxuICAgICAgICByZXR1cm4gJ1NvcnRlZFNldCgnICsgcmVzdWx0LnRvU3RyaW5nKCkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICBjb3B5KGRhdGEpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KHRoaXMuY29tcGFyYXRvcik7XHJcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU29ydGVkU2V0SXRlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoaXRlcikge1xyXG4gICAgICAgIHRoaXMuaXRlciA9IGl0ZXI7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuZ2V0TmV4dCgpLmtleTtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5oYXNOZXh0KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBzb3J0ZWQgc2V0cyBmb3IgZXF1YWxpdHkgdXNpbmcgdGhlaXIgbmF0dXJhbCBvcmRlcmluZy4gVGhlXHJcbiAqIG1ldGhvZCBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIGFuZCBpbnZva2VzIGBvbkFkZGAgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdFxyXG4gKiBpcyBpbiBgYWZ0ZXJgIGJ1dCBub3QgYGJlZm9yZWAuIGBvblJlbW92ZWAgaXMgaW52b2tlZCBmb3IgZXZlcnkgZWxlbWVudCBpblxyXG4gKiBgYmVmb3JlYCBidXQgbWlzc2luZyBmcm9tIGBhZnRlcmAuXHJcbiAqXHJcbiAqIFRoZSBtZXRob2QgY3JlYXRlcyBhIGNvcHkgb2YgYm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhbmQgcnVucyBpbiBPKG4gbG9nXHJcbiAqIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSB0d28gbGlzdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBiZWZvcmUgLSBUaGUgZWxlbWVudHMgdGhhdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgc2V0LlxyXG4gKiBAcGFyYW0gYWZ0ZXIgLSBUaGUgZWxlbWVudHMgdG8gZGlmZiBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBzZXQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIC0gVGhlIGNvbXBhcmF0b3IgZm9yIHRoZSBlbGVtZW50cyBpbiBiZWZvcmUgYW5kIGFmdGVyLlxyXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxyXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cclxuICogQHBhcmFtIG9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mXHJcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cclxuICovXHJcbmZ1bmN0aW9uIGRpZmZTb3J0ZWRTZXRzKGJlZm9yZSwgYWZ0ZXIsIGNvbXBhcmF0b3IsIG9uQWRkLCBvblJlbW92ZSkge1xyXG4gICAgY29uc3QgYmVmb3JlSXQgPSBiZWZvcmUuZ2V0SXRlcmF0b3IoKTtcclxuICAgIGNvbnN0IGFmdGVySXQgPSBhZnRlci5nZXRJdGVyYXRvcigpO1xyXG4gICAgbGV0IGJlZm9yZVZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGJlZm9yZUl0KTtcclxuICAgIGxldCBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xyXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSB0d28gc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCB1c2luZyB0aGUgb3JkZXJpbmcgZGVmaW5lZCBieVxyXG4gICAgLy8gYGNvbXBhcmF0b3JgLlxyXG4gICAgd2hpbGUgKGJlZm9yZVZhbHVlIHx8IGFmdGVyVmFsdWUpIHtcclxuICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChiZWZvcmVWYWx1ZSAmJiBhZnRlclZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlVmFsdWUsIGFmdGVyVmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgaWYgdGhlIG5leHQgZWxlbWVudCBpbiBvdXIgb3JkZXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2Fsa3Rocm91Z2ggaXMgb25seSBpbiBgYmVmb3JlYC5cclxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBhZGRlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkIHdhbGt0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBpcyBvbmx5IGluIGBhZnRlcmAuXHJcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZGVkKSB7XHJcbiAgICAgICAgICAgIG9uQWRkKGFmdGVyVmFsdWUpO1xyXG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIG9uUmVtb3ZlKGJlZm9yZVZhbHVlKTtcclxuICAgICAgICAgICAgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xyXG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGl0ZXJhdG9yIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgYXZhaWxhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gYWR2YW5jZUl0ZXJhdG9yKGl0KSB7XHJcbiAgICByZXR1cm4gaXQuaGFzTmV4dCgpID8gaXQuZ2V0TmV4dCgpIDogdW5kZWZpbmVkO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHNldCBvZiBmaWVsZHMgdGhhdCBjYW4gYmUgdXNlZCB0byBwYXJ0aWFsbHkgcGF0Y2ggYSBkb2N1bWVudC5cclxuICogRmllbGRNYXNrIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBPYmplY3RWYWx1ZS5cclxuICogRXhhbXBsZXM6XHJcbiAqICAgZm9vIC0gT3ZlcndyaXRlcyBmb28gZW50aXJlbHkgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuIElmIGZvbyBpcyBub3RcclxuICogICAgICAgICBwcmVzZW50IGluIHRoZSBjb21wYW5pb24gT2JqZWN0VmFsdWUsIHRoZSBmaWVsZCBpcyBkZWxldGVkLlxyXG4gKiAgIGZvby5iYXIgLSBPdmVyd3JpdGVzIG9ubHkgdGhlIGZpZWxkIGJhciBvZiB0aGUgb2JqZWN0IGZvby5cclxuICogICAgICAgICAgICAgSWYgZm9vIGlzIG5vdCBhbiBvYmplY3QsIGZvbyBpcyByZXBsYWNlZCB3aXRoIGFuIG9iamVjdFxyXG4gKiAgICAgICAgICAgICBjb250YWluaW5nIGZvb1xyXG4gKi9cclxuY2xhc3MgRmllbGRNYXNrIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xyXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xyXG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogdmFsaWRhdGlvbiBvZiBGaWVsZE1hc2tcclxuICAgICAgICAvLyBTb3J0IHRoZSBmaWVsZCBtYXNrIHRvIHN1cHBvcnQgYEZpZWxkTWFzay5pc0VxdWFsKClgIGFuZCBhc3NlcnQgYmVsb3cuXHJcbiAgICAgICAgZmllbGRzLnNvcnQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZE1hc2soW10pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEZpZWxkTWFzayBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGFkZGluZyBhbGwgdGhlIGdpdmVuXHJcbiAgICAgKiBmaWVsZHMgcGF0aHMgdG8gdGhpcyBmaWVsZCBtYXNrLlxyXG4gICAgICovXHJcbiAgICB1bmlvbldpdGgoZXh0cmFGaWVsZHMpIHtcclxuICAgICAgICBsZXQgbWVyZ2VkTWFza1NldCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZFBhdGggb2YgdGhpcy5maWVsZHMpIHtcclxuICAgICAgICAgICAgbWVyZ2VkTWFza1NldCA9IG1lcmdlZE1hc2tTZXQuYWRkKGZpZWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGRQYXRoIG9mIGV4dHJhRmllbGRzKSB7XHJcbiAgICAgICAgICAgIG1lcmdlZE1hc2tTZXQgPSBtZXJnZWRNYXNrU2V0LmFkZChmaWVsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhtZXJnZWRNYXNrU2V0LnRvQXJyYXkoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmaWVzIHRoYXQgYGZpZWxkUGF0aGAgaXMgaW5jbHVkZWQgYnkgYXQgbGVhc3Qgb25lIGZpZWxkIGluIHRoaXMgZmllbGRcclxuICAgICAqIG1hc2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhbiBPKG4pIG9wZXJhdGlvbiwgd2hlcmUgYG5gIGlzIHRoZSBzaXplIG9mIHRoZSBmaWVsZCBtYXNrLlxyXG4gICAgICovXHJcbiAgICBjb3ZlcnMoZmllbGRQYXRoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE1hc2tQYXRoIG9mIHRoaXMuZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZE1hc2tQYXRoLmlzUHJlZml4T2YoZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBhcnJheUVxdWFscyh0aGlzLmZpZWxkcywgb3RoZXIuZmllbGRzLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQ29udmVydHMgYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nLiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoZW5jb2RlZCkge1xyXG4gICAgLy8gTm90ZTogV2UgdXNlZCB0byB2YWxpZGF0ZSB0aGUgYmFzZTY0IHN0cmluZyBoZXJlIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICAgIC8vIFRoaXMgd2FzIHJlbW92ZWQgdG8gaW1wcm92ZSB0aGUgcGVyZm9ybWFuY2Ugb2YgaW5kZXhpbmcuXHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZW5jb2RlZCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcclxufVxyXG4vKiogQ29udmVydHMgYSBiaW5hcnkgc3RyaW5nIHRvIGEgQmFzZTY0IGVuY29kZWQgc3RyaW5nLiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQocmF3KSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmF3LCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG59XHJcbi8qKiBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBCYXNlNjQgY29udmVyc2lvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS4gKi9cclxuZnVuY3Rpb24gaXNCYXNlNjRBdmFpbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW1tdXRhYmxlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIFwicHJvdG9cIiBieXRlIHN0cmluZy5cclxuICpcclxuICogUHJvdG8gYnl0ZSBzdHJpbmdzIGNhbiBlaXRoZXIgYmUgQmFzZTY0LWVuY29kZWQgc3RyaW5ncyBvciBVaW50OEFycmF5cyB3aGVuXHJcbiAqIHNlbnQgb24gdGhlIHdpcmUuIFRoaXMgY2xhc3MgYWJzdHJhY3RzIGF3YXkgdGhpcyBkaWZmZXJlbnRpYXRpb24gYnkgaG9sZGluZ1xyXG4gKiB0aGUgcHJvdG8gYnl0ZSBzdHJpbmcgaW4gYSBjb21tb24gY2xhc3MgdGhhdCBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIGEgc3RyaW5nXHJcbiAqIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgcHJvdG8uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgQnl0ZVN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihiaW5hcnlTdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZztcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xyXG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XHJcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk7IFJlbW92ZSB0aGUgY29weSBvZiB0aGUgYnl0ZSBzdHJpbmcgaGVyZSBhcyB0aGlzIG1ldGhvZFxyXG4gICAgICAgIC8vIGlzIGZyZXF1ZW50bHkgY2FsbGVkIGR1cmluZyBpbmRleGluZy5cclxuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmdGcm9tVWludDhBcnJheShhcnJheSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlU3RyaW5nKGJpbmFyeVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmJpbmFyeVN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5iaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKyspLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHRvQmFzZTY0KCkge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNjQodGhpcy5iaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgdG9VaW50OEFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiB1aW50OEFycmF5RnJvbUJpbmFyeVN0cmluZyh0aGlzLmJpbmFyeVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBhcHByb3hpbWF0ZUJ5dGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVN0cmluZy5sZW5ndGggKiAyO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5iaW5hcnlTdHJpbmcsIG90aGVyLmJpbmFyeVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U3RyaW5nID09PSBvdGhlci5iaW5hcnlTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORyA9IG5ldyBCeXRlU3RyaW5nKCcnKTtcclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIFVpbnQ4YXJyYXkgdG8gYSBiaW5hcnkgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluYXJ5U3RyaW5nRnJvbVVpbnQ4QXJyYXkoYXJyYXkpIHtcclxuICAgIGxldCBiaW5hcnlTdHJpbmcgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmluYXJ5U3RyaW5nO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhIGJpbmFyeSBzdHJpbmcgdG8gYW4gVWludDhBcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHVpbnQ4QXJyYXlGcm9tQmluYXJ5U3RyaW5nKGJpbmFyeVN0cmluZykge1xyXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGJ1ZmZlcltpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBBIFJlZ0V4cCBtYXRjaGluZyBJU08gODYwMSBVVEMgdGltZXN0YW1wcyB3aXRoIG9wdGlvbmFsIGZyYWN0aW9uLlxyXG5jb25zdCBJU09fVElNRVNUQU1QX1JFR19FWFAgPSBuZXcgUmVnRXhwKC9eXFxkezR9LVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGQoPzpcXC4oXFxkKykpP1okLyk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdmFsdWVzIGZvciBhIHRpbWVzdGFtcCB2YWx1ZSBpbnRvIGEgXCJzZWNvbmRzIGFuZFxyXG4gKiBuYW5vc1wiIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplVGltZXN0YW1wKGRhdGUpIHtcclxuICAgIGhhcmRBc3NlcnQoISFkYXRlKTtcclxuICAgIC8vIFRoZSBqc29uIGludGVyZmFjZSAoZm9yIHRoZSBicm93c2VyKSB3aWxsIHJldHVybiBhbiBpc28gdGltZXN0YW1wIHN0cmluZyxcclxuICAgIC8vIHdoaWxlIHRoZSBwcm90byBqcyBsaWJyYXJ5IChmb3Igbm9kZSkgd2lsbCByZXR1cm4gYVxyXG4gICAgLy8gZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBpbnN0YW5jZS5cclxuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBUaGUgZGF0ZSBzdHJpbmcgY2FuIGhhdmUgaGlnaGVyIHByZWNpc2lvbiAobmFub3MpIHRoYW4gdGhlIERhdGUgY2xhc3NcclxuICAgICAgICAvLyAobWlsbGlzKSwgc28gd2UgZG8gc29tZSBjdXN0b20gcGFyc2luZyBoZXJlLlxyXG4gICAgICAgIC8vIFBhcnNlIHRoZSBuYW5vcyByaWdodCBvdXQgb2YgdGhlIHN0cmluZy5cclxuICAgICAgICBsZXQgbmFub3MgPSAwO1xyXG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gSVNPX1RJTUVTVEFNUF9SRUdfRVhQLmV4ZWMoZGF0ZSk7XHJcbiAgICAgICAgaGFyZEFzc2VydCghIWZyYWN0aW9uKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb25bMV0pIHtcclxuICAgICAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cclxuICAgICAgICAgICAgbGV0IG5hbm9TdHIgPSBmcmFjdGlvblsxXTtcclxuICAgICAgICAgICAgbmFub1N0ciA9IChuYW5vU3RyICsgJzAwMDAwMDAwMCcpLnN1YnN0cigwLCA5KTtcclxuICAgICAgICAgICAgbmFub3MgPSBOdW1iZXIobmFub1N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhcnNlIHRoZSBkYXRlIHRvIGdldCB0aGUgc2Vjb25kcy5cclxuICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IocGFyc2VkRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICAgICAgICByZXR1cm4geyBzZWNvbmRzLCBuYW5vcyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVE9ETyhiLzM3MjgyMjM3KTogVXNlIHN0cmluZ3MgZm9yIFByb3RvMyB0aW1lc3RhbXBzXHJcbiAgICAgICAgLy8gYXNzZXJ0KCF0aGlzLm9wdGlvbnMudXNlUHJvdG8zSnNvbixcclxuICAgICAgICAvLyAgICdUaGUgdGltZXN0YW1wIGluc3RhbmNlIGZvcm1hdCByZXF1aXJlcyBQcm90byBKUy4nKTtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gbm9ybWFsaXplTnVtYmVyKGRhdGUuc2Vjb25kcyk7XHJcbiAgICAgICAgY29uc3QgbmFub3MgPSBub3JtYWxpemVOdW1iZXIoZGF0ZS5uYW5vcyk7XHJcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHR5cGVzIGZvciBudW1iZXJzIGludG8gYSBKYXZhU2NyaXB0IG51bWJlci5cclxuICogUmV0dXJucyAwIGlmIHRoZSB2YWx1ZSBpcyBub3QgbnVtZXJpYy5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU51bWJlcih2YWx1ZSkge1xyXG4gICAgLy8gVE9ETyhiam9ybmljayk6IEhhbmRsZSBpbnQ2NCBncmVhdGVyIHRoYW4gNTMgYml0cy5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuLyoqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgQmxvYnMgaW50byBhIEJ5dGVTdHJpbmcuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYmxvYikge1xyXG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcoYmxvYik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheShibG9iKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGxvY2FsbHktYXBwbGllZCBTZXJ2ZXJUaW1lc3RhbXAuXHJcbiAqXHJcbiAqIFNlcnZlciBUaW1lc3RhbXBzIGFyZSBiYWNrZWQgYnkgTWFwVmFsdWVzIHRoYXQgY29udGFpbiBhbiBpbnRlcm5hbCBmaWVsZFxyXG4gKiBgX190eXBlX19gIHdpdGggYSB2YWx1ZSBvZiBgc2VydmVyX3RpbWVzdGFtcGAuIFRoZSBwcmV2aW91cyB2YWx1ZSBhbmQgbG9jYWxcclxuICogd3JpdGUgdGltZSBhcmUgc3RvcmVkIGluIGl0cyBgX19wcmV2aW91c192YWx1ZV9fYCBhbmQgYF9fbG9jYWxfd3JpdGVfdGltZV9fYFxyXG4gKiBmaWVsZHMgcmVzcGVjdGl2ZWx5LlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgYXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhXHJcbiAqICAgdHJhbnNmb3JtLiBUaGV5IGNhbiBvbmx5IGV4aXN0IGluIHRoZSBsb2NhbCB2aWV3IG9mIGEgZG9jdW1lbnQuIFRoZXJlZm9yZVxyXG4gKiAgIHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgcGFyc2VkIG9yIHNlcmlhbGl6ZWQuXHJcbiAqIC0gV2hlbiBldmFsdWF0ZWQgbG9jYWxseSAoZS5nLiBmb3Igc25hcHNob3QuZGF0YSgpKSwgdGhleSBieSBkZWZhdWx0XHJcbiAqICAgZXZhbHVhdGUgdG8gYG51bGxgLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBjb25maWd1cmVkIGJ5IHBhc3NpbmcgY3VzdG9tXHJcbiAqICAgRmllbGRWYWx1ZU9wdGlvbnMgdG8gdmFsdWUoKS5cclxuICogLSBXaXRoIHJlc3BlY3QgdG8gb3RoZXIgU2VydmVyVGltZXN0YW1wVmFsdWVzLCB0aGV5IHNvcnQgYnkgdGhlaXJcclxuICogICBsb2NhbFdyaXRlVGltZS5cclxuICovXHJcbmNvbnN0IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUwgPSAnc2VydmVyX3RpbWVzdGFtcCc7XHJcbmNvbnN0IFRZUEVfS0VZID0gJ19fdHlwZV9fJztcclxuY29uc3QgUFJFVklPVVNfVkFMVUVfS0VZID0gJ19fcHJldmlvdXNfdmFsdWVfXyc7XHJcbmNvbnN0IExPQ0FMX1dSSVRFX1RJTUVfS0VZID0gJ19fbG9jYWxfd3JpdGVfdGltZV9fJztcclxuZnVuY3Rpb24gaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBjb25zdCB0eXBlID0gKF9iID0gKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUubWFwVmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWVsZHMpIHx8IHt9KVtUWVBFX0tFWV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdHJpbmdWYWx1ZTtcclxuICAgIHJldHVybiB0eXBlID09PSBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IFNlcnZlclRpbWVzdGFtcCBwcm90byB2YWx1ZSAodXNpbmcgdGhlIGludGVybmFsIGZvcm1hdCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJ2ZXJUaW1lc3RhbXAkMShsb2NhbFdyaXRlVGltZSwgcHJldmlvdXNWYWx1ZSkge1xyXG4gICAgY29uc3QgbWFwVmFsdWUgPSB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgIFtUWVBFX0tFWV06IHtcclxuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtMT0NBTF9XUklURV9USU1FX0tFWV06IHtcclxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kczogbG9jYWxXcml0ZVRpbWUuc2Vjb25kcyxcclxuICAgICAgICAgICAgICAgICAgICBuYW5vczogbG9jYWxXcml0ZVRpbWUubmFub3NlY29uZHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBXZSBzaG91bGQgYXZvaWQgc3RvcmluZyBkZWVwbHkgbmVzdGVkIHNlcnZlciB0aW1lc3RhbXAgbWFwIHZhbHVlc1xyXG4gICAgLy8gYmVjYXVzZSB3ZSBuZXZlciB1c2UgdGhlIGludGVybWVkaWF0ZSBcInByZXZpb3VzIHZhbHVlc1wiLlxyXG4gICAgLy8gRm9yIGV4YW1wbGU6XHJcbiAgICAvLyBwcmV2aW91czogNDJMLCBhZGQ6IHQxLCByZXN1bHQ6IHQxIC0+IDQyTFxyXG4gICAgLy8gcHJldmlvdXM6IHQxLCAgYWRkOiB0MiwgcmVzdWx0OiB0MiAtPiA0MkwgKE5PVCB0MiAtPiB0MSAtPiA0MkwpXHJcbiAgICAvLyBwcmV2aW91czogdDIsICBhZGQ6IHQzLCByZXN1bHQ6IHQzIC0+IDQyTCAoTk9UIHQzIC0+IHQyIC0+IHQxIC0+IDQyTClcclxuICAgIC8vIGBnZXRQcmV2aW91c1ZhbHVlYCByZWN1cnNpdmVseSB0cmF2ZXJzZXMgc2VydmVyIHRpbWVzdGFtcHMgdG8gZmluZCB0aGVcclxuICAgIC8vIGxlYXN0IHJlY2VudCBWYWx1ZS5cclxuICAgIGlmIChwcmV2aW91c1ZhbHVlICYmIGlzU2VydmVyVGltZXN0YW1wKHByZXZpb3VzVmFsdWUpKSB7XHJcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGdldFByZXZpb3VzVmFsdWUocHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgIG1hcFZhbHVlLmZpZWxkc1tQUkVWSU9VU19WQUxVRV9LRVldID0gcHJldmlvdXNWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1hcFZhbHVlIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBiZWZvcmUgdGhpcyBTZXJ2ZXJUaW1lc3RhbXAgd2FzIHNldC5cclxuICpcclxuICogUHJlc2VydmluZyB0aGUgcHJldmlvdXMgdmFsdWVzIGFsbG93cyB0aGUgdXNlciB0byBkaXNwbGF5IHRoZSBsYXN0IHJlc29sZWRcclxuICogdmFsdWUgdW50aWwgdGhlIGJhY2tlbmQgcmVzcG9uZHMgd2l0aCB0aGUgdGltZXN0YW1wLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tQUkVWSU9VU19WQUxVRV9LRVldO1xyXG4gICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHByZXZpb3VzVmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFByZXZpb3VzVmFsdWUocHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbG9jYWwgdGltZSBhdCB3aGljaCB0aGlzIHRpbWVzdGFtcCB3YXMgZmlyc3Qgc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpIHtcclxuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tMT0NBTF9XUklURV9USU1FX0tFWV0udGltZXN0YW1wVmFsdWUpO1xyXG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobG9jYWxXcml0ZVRpbWUuc2Vjb25kcywgbG9jYWxXcml0ZVRpbWUubmFub3MpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERhdGFiYXNlSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBEYXRhYmFzZUluZm8gdXNpbmcgdGhlIHByb3ZpZGVkIGhvc3QsIGRhdGFiYXNlSWQgYW5kXHJcbiAgICAgKiBwZXJzaXN0ZW5jZUtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gYXBwSWQgLSBUaGUgRmlyZWJhc2UgQXBwIElkLlxyXG4gICAgICogQHBhcmFtIHBlcnNpc3RlbmNlS2V5IC0gQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBGaXJlc3RvcmUncyBsb2NhbFxyXG4gICAgICogc3RvcmFnZSAodXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBkYXRhYmFzZUlkKS5cclxuICAgICAqIEBwYXJhbSBob3N0IC0gVGhlIEZpcmVzdG9yZSBiYWNrZW5kIGhvc3QgdG8gY29ubmVjdCB0by5cclxuICAgICAqIEBwYXJhbSBzc2wgLSBXaGV0aGVyIHRvIHVzZSBTU0wgd2hlbiBjb25uZWN0aW5nLlxyXG4gICAgICogQHBhcmFtIGZvcmNlTG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZm9yY2VMb25nUG9sbGluZyBvcHRpb25cclxuICAgICAqIHdoZW4gdXNpbmcgV2ViQ2hhbm5lbCBhcyB0aGUgbmV0d29yayB0cmFuc3BvcnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0b0RldGVjdExvbmdQb2xsaW5nIC0gV2hldGhlciB0byB1c2UgdGhlIGRldGVjdEJ1ZmZlcmluZ1Byb3h5XHJcbiAgICAgKiBvcHRpb24gd2hlbiB1c2luZyBXZWJDaGFubmVsIGFzIHRoZSBuZXR3b3JrIHRyYW5zcG9ydC5cclxuICAgICAqIEBwYXJhbSBsb25nUG9sbGluZ09wdGlvbnMgT3B0aW9ucyB0aGF0IGNvbmZpZ3VyZSBsb25nLXBvbGxpbmcuXHJcbiAgICAgKiBAcGFyYW0gdXNlRmV0Y2hTdHJlYW1zIFdoZXRoZXIgdG8gdXNlIHRoZSBGZXRjaCBBUEkgaW5zdGVhZCBvZlxyXG4gICAgICogWE1MSFRUUFJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgYXBwSWQsIHBlcnNpc3RlbmNlS2V5LCBob3N0LCBzc2wsIGZvcmNlTG9uZ1BvbGxpbmcsIGF1dG9EZXRlY3RMb25nUG9sbGluZywgbG9uZ1BvbGxpbmdPcHRpb25zLCB1c2VGZXRjaFN0cmVhbXMpIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XHJcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcclxuICAgICAgICB0aGlzLnNzbCA9IHNzbDtcclxuICAgICAgICB0aGlzLmZvcmNlTG9uZ1BvbGxpbmcgPSBmb3JjZUxvbmdQb2xsaW5nO1xyXG4gICAgICAgIHRoaXMuYXV0b0RldGVjdExvbmdQb2xsaW5nID0gYXV0b0RldGVjdExvbmdQb2xsaW5nO1xyXG4gICAgICAgIHRoaXMubG9uZ1BvbGxpbmdPcHRpb25zID0gbG9uZ1BvbGxpbmdPcHRpb25zO1xyXG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gdXNlRmV0Y2hTdHJlYW1zO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUaGUgZGVmYXVsdCBkYXRhYmFzZSBuYW1lIGZvciBhIHByb2plY3QuICovXHJcbmNvbnN0IERFRkFVTFRfREFUQUJBU0VfTkFNRSA9ICcoZGVmYXVsdCknO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgZGF0YWJhc2UgSUQgYSBGaXJlc3RvcmUgY2xpZW50IGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZUlkIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb2plY3RJZCwgZGF0YWJhc2UpIHtcclxuICAgICAgICB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2UgPyBkYXRhYmFzZSA6IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFiYXNlSWQoJycsICcnKTtcclxuICAgIH1cclxuICAgIGdldCBpc0RlZmF1bHREYXRhYmFzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhYmFzZSA9PT0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBEYXRhYmFzZUlkICYmXHJcbiAgICAgICAgICAgIG90aGVyLnByb2plY3RJZCA9PT0gdGhpcy5wcm9qZWN0SWQgJiZcclxuICAgICAgICAgICAgb3RoZXIuZGF0YWJhc2UgPT09IHRoaXMuZGF0YWJhc2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRhdGFiYXNlSWRGcm9tQXBwKGFwcCwgZGF0YWJhc2UpIHtcclxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5hcHBseShhcHAub3B0aW9ucywgWydwcm9qZWN0SWQnXSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnXCJwcm9qZWN0SWRcIiBub3QgcHJvdmlkZWQgaW4gZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcC4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2VJZChhcHAub3B0aW9ucy5wcm9qZWN0SWQsIGRhdGFiYXNlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogU2VudGluZWwgdmFsdWUgdGhhdCBzb3J0cyBiZWZvcmUgYW55IE11dGF0aW9uIEJhdGNoIElELiAqL1xyXG5jb25zdCBCQVRDSElEX1VOS05PV04gPSAtMTtcclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBhIHZhcmlhYmxlIGlzIGVpdGhlciB1bmRlZmluZWQgb3IgbnVsbC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxufVxyXG4vKiogUmV0dXJucyB3aGV0aGVyIHRoZSB2YWx1ZSByZXByZXNlbnRzIC0wLiAqL1xyXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkge1xyXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSB2YWx1ZSBpcyAtMC4wLiBCYXNlZCBvbiBwb2x5ZmlsbCBmcm9tXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IDEgLyAtMDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZVxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdCBmb3IgYmVpbmcgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgcmFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmXHJcbiAgICAgICAgIWlzTmVnYXRpdmVaZXJvKHZhbHVlKSAmJlxyXG4gICAgICAgIHZhbHVlIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmXHJcbiAgICAgICAgdmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IE1BWF9WQUxVRV9UWVBFID0gJ19fbWF4X18nO1xyXG5jb25zdCBNQVhfVkFMVUUgPSB7XHJcbiAgICBtYXBWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICAnX190eXBlX18nOiB7IHN0cmluZ1ZhbHVlOiBNQVhfVkFMVUVfVFlQRSB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBNSU5fVkFMVUUgPSB7XHJcbiAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xyXG59O1xyXG4vKiogRXh0cmFjdHMgdGhlIGJhY2tlbmQncyB0eXBlIG9yZGVyIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUuICovXHJcbmZ1bmN0aW9uIHR5cGVPcmRlcih2YWx1ZSkge1xyXG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlIHx8ICdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNNYXhWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTAgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogVGVzdHMgYGxlZnRgIGFuZCBgcmlnaHRgIGZvciBlcXVhbGl0eSBiYXNlZCBvbiB0aGUgYmFja2VuZCBzZW1hbnRpY3MuICovXHJcbmZ1bmN0aW9uIHZhbHVlRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlZnRUeXBlID0gdHlwZU9yZGVyKGxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHRUeXBlID0gdHlwZU9yZGVyKHJpZ2h0KTtcclxuICAgIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQuYm9vbGVhblZhbHVlID09PSByaWdodC5ib29sZWFuVmFsdWU7XHJcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGdldExvY2FsV3JpdGVUaW1lKGxlZnQpLmlzRXF1YWwoZ2V0TG9jYWxXcml0ZVRpbWUocmlnaHQpKTtcclxuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5zdHJpbmdWYWx1ZSA9PT0gcmlnaHQuc3RyaW5nVmFsdWU7XHJcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5yZWZlcmVuY2VWYWx1ZSA9PT0gcmlnaHQucmVmZXJlbmNlVmFsdWU7XHJcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHJpZ2h0LmFycmF5VmFsdWUudmFsdWVzIHx8IFtdLCB2YWx1ZUVxdWFscyk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxlZnQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgdHlwZW9mIHJpZ2h0LnRpbWVzdGFtcFZhbHVlID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGxlZnQudGltZXN0YW1wVmFsdWUubGVuZ3RoID09PSByaWdodC50aW1lc3RhbXBWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAvLyBVc2Ugc3RyaW5nIGVxdWFsaXR5IGZvciBJU08gODYwMSB0aW1lc3RhbXBzXHJcbiAgICAgICAgcmV0dXJuIGxlZnQudGltZXN0YW1wVmFsdWUgPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0LnRpbWVzdGFtcFZhbHVlKTtcclxuICAgIGNvbnN0IHJpZ2h0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHJpZ2h0LnRpbWVzdGFtcFZhbHVlKTtcclxuICAgIHJldHVybiAobGVmdFRpbWVzdGFtcC5zZWNvbmRzID09PSByaWdodFRpbWVzdGFtcC5zZWNvbmRzICYmXHJcbiAgICAgICAgbGVmdFRpbWVzdGFtcC5uYW5vcyA9PT0gcmlnaHRUaW1lc3RhbXAubmFub3MpO1xyXG59XHJcbmZ1bmN0aW9uIGdlb1BvaW50RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpID09PVxyXG4gICAgICAgIG5vcm1hbGl6ZU51bWJlcihyaWdodC5nZW9Qb2ludFZhbHVlLmxhdGl0dWRlKSAmJlxyXG4gICAgICAgIG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSA9PT1cclxuICAgICAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSk7XHJcbn1cclxuZnVuY3Rpb24gYmxvYkVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdC5ieXRlc1ZhbHVlKS5pc0VxdWFsKG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQuYnl0ZXNWYWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIG51bWJlckVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGxlZnQgJiYgJ2ludGVnZXJWYWx1ZScgaW4gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmludGVnZXJWYWx1ZSkgPT09IG5vcm1hbGl6ZU51bWJlcihyaWdodC5pbnRlZ2VyVmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gbGVmdCAmJiAnZG91YmxlVmFsdWUnIGluIHJpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgbjEgPSBub3JtYWxpemVOdW1iZXIobGVmdC5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgbjIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuZG91YmxlVmFsdWUpO1xyXG4gICAgICAgIGlmIChuMSA9PT0gbjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvKG4xKSA9PT0gaXNOZWdhdGl2ZVplcm8objIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKG4xKSAmJiBpc05hTihuMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQubWFwVmFsdWUuZmllbGRzIHx8IHt9O1xyXG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5tYXBWYWx1ZS5maWVsZHMgfHwge307XHJcbiAgICBpZiAob2JqZWN0U2l6ZShsZWZ0TWFwKSAhPT0gb2JqZWN0U2l6ZShyaWdodE1hcCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsZWZ0TWFwKSB7XHJcbiAgICAgICAgaWYgKGxlZnRNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRNYXBba2V5XSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAhdmFsdWVFcXVhbHMobGVmdE1hcFtrZXldLCByaWdodE1hcFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQXJyYXlWYWx1ZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuICovXHJcbmZ1bmN0aW9uIGFycmF5VmFsdWVDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICByZXR1cm4gKChoYXlzdGFjay52YWx1ZXMgfHwgW10pLmZpbmQodiA9PiB2YWx1ZUVxdWFscyh2LCBuZWVkbGUpKSAhPT0gdW5kZWZpbmVkKTtcclxufVxyXG5mdW5jdGlvbiB2YWx1ZUNvbXBhcmUobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XHJcbiAgICBjb25zdCByaWdodFR5cGUgPSB0eXBlT3JkZXIocmlnaHQpO1xyXG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VHlwZSwgcmlnaHRUeXBlKTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcclxuICAgICAgICBjYXNlIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5ib29sZWFuVmFsdWUsIHJpZ2h0LmJvb2xlYW5WYWx1ZSk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVRpbWVzdGFtcHMobGVmdC50aW1lc3RhbXBWYWx1ZSwgcmlnaHQudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhnZXRMb2NhbFdyaXRlVGltZShsZWZ0KSwgZ2V0TG9jYWxXcml0ZVRpbWUocmlnaHQpKTtcclxuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LnN0cmluZ1ZhbHVlLCByaWdodC5zdHJpbmdWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQmxvYnMobGVmdC5ieXRlc1ZhbHVlLCByaWdodC5ieXRlc1ZhbHVlKTtcclxuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlZmVyZW5jZXMobGVmdC5yZWZlcmVuY2VWYWx1ZSwgcmlnaHQucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVHZW9Qb2ludHMobGVmdC5nZW9Qb2ludFZhbHVlLCByaWdodC5nZW9Qb2ludFZhbHVlKTtcclxuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGxlZnQuYXJyYXlWYWx1ZSwgcmlnaHQuYXJyYXlWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTWFwcyhsZWZ0Lm1hcFZhbHVlLCByaWdodC5tYXBWYWx1ZSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0TnVtYmVyID0gbm9ybWFsaXplTnVtYmVyKGxlZnQuaW50ZWdlclZhbHVlIHx8IGxlZnQuZG91YmxlVmFsdWUpO1xyXG4gICAgY29uc3QgcmlnaHROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuaW50ZWdlclZhbHVlIHx8IHJpZ2h0LmRvdWJsZVZhbHVlKTtcclxuICAgIGlmIChsZWZ0TnVtYmVyIDwgcmlnaHROdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID4gcmlnaHROdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnROdW1iZXIgPT09IHJpZ2h0TnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBvbmUgb3IgYm90aCBhcmUgTmFOLlxyXG4gICAgICAgIGlmIChpc05hTihsZWZ0TnVtYmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4ocmlnaHROdW1iZXIpID8gMCA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVUaW1lc3RhbXBzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGxlZnQubGVuZ3RoID09PSByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQpO1xyXG4gICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5zZWNvbmRzLCByaWdodFRpbWVzdGFtcC5zZWNvbmRzKTtcclxuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VGltZXN0YW1wLm5hbm9zLCByaWdodFRpbWVzdGFtcC5uYW5vcyk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZVJlZmVyZW5jZXMobGVmdFBhdGgsIHJpZ2h0UGF0aCkge1xyXG4gICAgY29uc3QgbGVmdFNlZ21lbnRzID0gbGVmdFBhdGguc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IHJpZ2h0U2VnbWVudHMgPSByaWdodFBhdGguc3BsaXQoJy8nKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdFNlZ21lbnRzLmxlbmd0aCAmJiBpIDwgcmlnaHRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRTZWdtZW50c1tpXSwgcmlnaHRTZWdtZW50c1tpXSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzLmxlbmd0aCwgcmlnaHRTZWdtZW50cy5sZW5ndGgpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVHZW9Qb2ludHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxhdGl0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmxhdGl0dWRlKSk7XHJcbiAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3Iobm9ybWFsaXplTnVtYmVyKGxlZnQubG9uZ2l0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmxvbmdpdHVkZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVCbG9icyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdEJ5dGVzID0gbm9ybWFsaXplQnl0ZVN0cmluZyhsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKHJpZ2h0KTtcclxuICAgIHJldHVybiBsZWZ0Qnl0ZXMuY29tcGFyZVRvKHJpZ2h0Qnl0ZXMpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRBcnJheSA9IGxlZnQudmFsdWVzIHx8IFtdO1xyXG4gICAgY29uc3QgcmlnaHRBcnJheSA9IHJpZ2h0LnZhbHVlcyB8fCBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFycmF5Lmxlbmd0aCAmJiBpIDwgcmlnaHRBcnJheS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdEFycmF5W2ldLCByaWdodEFycmF5W2ldKTtcclxuICAgICAgICBpZiAoY29tcGFyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0QXJyYXkubGVuZ3RoLCByaWdodEFycmF5Lmxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZU1hcHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUgJiYgcmlnaHQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaWdodCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQuZmllbGRzIHx8IHt9O1xyXG4gICAgY29uc3QgbGVmdEtleXMgPSBPYmplY3Qua2V5cyhsZWZ0TWFwKTtcclxuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQuZmllbGRzIHx8IHt9O1xyXG4gICAgY29uc3QgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHRNYXApO1xyXG4gICAgLy8gRXZlbiB0aG91Z2ggTWFwVmFsdWVzIGFyZSBsaWtlbHkgc29ydGVkIGNvcnJlY3RseSBiYXNlZCBvbiB0aGVpciBpbnNlcnRpb25cclxuICAgIC8vIG9yZGVyIChlLmcuIHdoZW4gcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCksIGxvY2FsIG1vZGlmaWNhdGlvbnMgY2FuIGJyaW5nXHJcbiAgICAvLyBlbGVtZW50cyBvdXQgb2Ygb3JkZXIuIFdlIG5lZWQgdG8gcmUtc29ydCB0aGUgZWxlbWVudHMgdG8gZW5zdXJlIHRoYXRcclxuICAgIC8vIGNhbm9uaWNhbCBJRHMgYXJlIGluZGVwZW5kZW50IG9mIGluc2VydGlvbiBvcmRlci5cclxuICAgIGxlZnRLZXlzLnNvcnQoKTtcclxuICAgIHJpZ2h0S2V5cy5zb3J0KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aCAmJiBpIDwgcmlnaHRLZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qga2V5Q29tcGFyZSA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XHJcbiAgICAgICAgaWYgKGtleUNvbXBhcmUgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleUNvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdE1hcFtsZWZ0S2V5c1tpXV0sIHJpZ2h0TWFwW3JpZ2h0S2V5c1tpXV0pO1xyXG4gICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRLZXlzLmxlbmd0aCwgcmlnaHRLZXlzLmxlbmd0aCk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB0aGUgY2Fub25pY2FsIElEIGZvciB0aGUgcHJvdmlkZWQgZmllbGQgdmFsdWUgKGFzIHVzZWQgaW4gVGFyZ2V0XHJcbiAqIHNlcmlhbGl6YXRpb24pLlxyXG4gKi9cclxuZnVuY3Rpb24gY2Fub25pY2FsSWQodmFsdWUpIHtcclxuICAgIHJldHVybiBjYW5vbmlmeVZhbHVlKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeVZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZS5ib29sZWFuVmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmludGVnZXJWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZS5kb3VibGVWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlUaW1lc3RhbXAodmFsdWUudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmdWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjYW5vbmlmeUJ5dGVTdHJpbmcodmFsdWUuYnl0ZXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5UmVmZXJlbmNlKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjYW5vbmlmeUdlb1BvaW50KHZhbHVlLmdlb1BvaW50VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5QXJyYXkodmFsdWUuYXJyYXlWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5TWFwKHZhbHVlLm1hcFZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlCeXRlU3RyaW5nKGJ5dGVTdHJpbmcpIHtcclxuICAgIHJldHVybiBub3JtYWxpemVCeXRlU3RyaW5nKGJ5dGVTdHJpbmcpLnRvQmFzZTY0KCk7XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlUaW1lc3RhbXAodGltZXN0YW1wKSB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkVGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcCk7XHJcbiAgICByZXR1cm4gYHRpbWUoJHtub3JtYWxpemVkVGltZXN0YW1wLnNlY29uZHN9LCR7bm9ybWFsaXplZFRpbWVzdGFtcC5uYW5vc30pYDtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeUdlb1BvaW50KGdlb1BvaW50KSB7XHJcbiAgICByZXR1cm4gYGdlbygke2dlb1BvaW50LmxhdGl0dWRlfSwke2dlb1BvaW50LmxvbmdpdHVkZX0pYDtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeVJlZmVyZW5jZShyZWZlcmVuY2VWYWx1ZSkge1xyXG4gICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHJlZmVyZW5jZVZhbHVlKS50b1N0cmluZygpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5TWFwKG1hcFZhbHVlKSB7XHJcbiAgICAvLyBJdGVyYXRpb24gb3JkZXIgaW4gSmF2YVNjcmlwdCBpcyBub3QgZ3VhcmFudGVlZC4gVG8gZW5zdXJlIHRoYXQgd2UgZ2VuZXJhdGVcclxuICAgIC8vIG1hdGNoaW5nIGNhbm9uaWNhbCBJRHMgZm9yIGlkZW50aWNhbCBtYXBzLCB3ZSBuZWVkIHRvIHNvcnQgdGhlIGtleXMuXHJcbiAgICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMobWFwVmFsdWUuZmllbGRzIHx8IHt9KS5zb3J0KCk7XHJcbiAgICBsZXQgcmVzdWx0ID0gJ3snO1xyXG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIHNvcnRlZEtleXMpIHtcclxuICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gYCR7a2V5fToke2Nhbm9uaWZ5VmFsdWUobWFwVmFsdWUuZmllbGRzW2tleV0pfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgJ30nO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5QXJyYXkoYXJyYXlWYWx1ZSkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICdbJztcclxuICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKSB7XHJcbiAgICAgICAgaWYgKCFmaXJzdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9IGNhbm9uaWZ5VmFsdWUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdCArICddJztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBhcHByb3hpbWF0ZSAoYW5kIHdpbGRseSBpbmFjY3VyYXRlKSBpbi1tZW1vcnkgc2l6ZSBmb3IgdGhlIGZpZWxkXHJcbiAqIHZhbHVlLlxyXG4gKlxyXG4gKiBUaGUgbWVtb3J5IHNpemUgdGFrZXMgaW50byBhY2NvdW50IG9ubHkgdGhlIGFjdHVhbCB1c2VyIGRhdGEgYXMgaXQgcmVzaWRlc1xyXG4gKiBpbiBtZW1vcnkgYW5kIGlnbm9yZXMgb2JqZWN0IG92ZXJoZWFkLlxyXG4gKi9cclxuZnVuY3Rpb24gZXN0aW1hdGVCeXRlU2l6ZSh2YWx1ZSkge1xyXG4gICAgc3dpdGNoICh0eXBlT3JkZXIodmFsdWUpKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICAvLyBUaW1lc3RhbXBzIGFyZSBtYWRlIHVwIG9mIHR3byBkaXN0aW5jdCBudW1iZXJzIChzZWNvbmRzICsgbmFub3NlY29uZHMpXHJcbiAgICAgICAgICAgIHJldHVybiAxNjtcclxuICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlID8gMTYgKyBlc3RpbWF0ZUJ5dGVTaXplKHByZXZpb3VzVmFsdWUpIDogMTY7XHJcbiAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcclxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRGF0YV9zdHJ1Y3R1cmVzOlxyXG4gICAgICAgICAgICAvLyBcIkphdmFTY3JpcHQncyBTdHJpbmcgdHlwZSBpcyBbLi4uXSBhIHNldCBvZiBlbGVtZW50cyBvZiAxNi1iaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgLy8gaW50ZWdlciB2YWx1ZXNcIlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWUubGVuZ3RoICogMjtcclxuICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcodmFsdWUuYnl0ZXNWYWx1ZSkuYXBwcm94aW1hdGVCeXRlU2l6ZSgpO1xyXG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZWZlcmVuY2VWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxyXG4gICAgICAgICAgICAvLyBHZW9Qb2ludHMgYXJlIG1hZGUgdXAgb2YgdHdvIGRpc3RpbmN0IG51bWJlcnMgKGxhdGl0dWRlICsgbG9uZ2l0dWRlKVxyXG4gICAgICAgICAgICByZXR1cm4gMTY7XHJcbiAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZXN0aW1hdGVBcnJheUJ5dGVTaXplKHZhbHVlLmFycmF5VmFsdWUpO1xyXG4gICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZXN0aW1hdGVNYXBCeXRlU2l6ZSh2YWx1ZS5tYXBWYWx1ZSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVzdGltYXRlTWFwQnl0ZVNpemUobWFwVmFsdWUpIHtcclxuICAgIGxldCBzaXplID0gMDtcclxuICAgIGZvckVhY2gobWFwVmFsdWUuZmllbGRzLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICBzaXplICs9IGtleS5sZW5ndGggKyBlc3RpbWF0ZUJ5dGVTaXplKHZhbCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzaXplO1xyXG59XHJcbmZ1bmN0aW9uIGVzdGltYXRlQXJyYXlCeXRlU2l6ZShhcnJheVZhbHVlKSB7XHJcbiAgICByZXR1cm4gKGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKS5yZWR1Y2UoKHByZXZpb3VzU2l6ZSwgdmFsdWUpID0+IHByZXZpb3VzU2l6ZSArIGVzdGltYXRlQnl0ZVNpemUodmFsdWUpLCAwKTtcclxufVxyXG4vKiogUmV0dXJucyBhIHJlZmVyZW5jZSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIGRhdGFiYXNlIGFuZCBrZXkuICovXHJcbmZ1bmN0aW9uIHJlZlZhbHVlKGRhdGFiYXNlSWQsIGtleSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWZlcmVuY2VWYWx1ZTogYHByb2plY3RzLyR7ZGF0YWJhc2VJZC5wcm9qZWN0SWR9L2RhdGFiYXNlcy8ke2RhdGFiYXNlSWQuZGF0YWJhc2V9L2RvY3VtZW50cy8ke2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpfWBcclxuICAgIH07XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIEludGVnZXJWYWx1ZSAuICovXHJcbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgRG91YmxlVmFsdWUuICovXHJcbmZ1bmN0aW9uIGlzRG91YmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnZG91YmxlVmFsdWUnIGluIHZhbHVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBlaXRoZXIgYW4gSW50ZWdlclZhbHVlIG9yIGEgRG91YmxlVmFsdWUuICovXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSB8fCBpc0RvdWJsZSh2YWx1ZSk7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIEFycmF5VmFsdWUuICovXHJcbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdhcnJheVZhbHVlJyBpbiB2YWx1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBOdWxsVmFsdWUuICovXHJcbmZ1bmN0aW9uIGlzTnVsbFZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnbnVsbFZhbHVlJyBpbiB2YWx1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgTmFOLiAqL1xyXG5mdW5jdGlvbiBpc05hblZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnZG91YmxlVmFsdWUnIGluIHZhbHVlICYmIGlzTmFOKE51bWJlcih2YWx1ZS5kb3VibGVWYWx1ZSkpO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIE1hcFZhbHVlLiAqL1xyXG5mdW5jdGlvbiBpc01hcFZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnbWFwVmFsdWUnIGluIHZhbHVlO1xyXG59XHJcbi8qKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgLiAqL1xyXG5mdW5jdGlvbiBkZWVwQ2xvbmUoc291cmNlKSB7XHJcbiAgICBpZiAoc291cmNlLmdlb1BvaW50VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBnZW9Qb2ludFZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuZ2VvUG9pbnRWYWx1ZSkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNvdXJjZS50aW1lc3RhbXBWYWx1ZSAmJlxyXG4gICAgICAgIHR5cGVvZiBzb3VyY2UudGltZXN0YW1wVmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdGltZXN0YW1wVmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS50aW1lc3RhbXBWYWx1ZSkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNvdXJjZS5tYXBWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHsgbWFwVmFsdWU6IHsgZmllbGRzOiB7fSB9IH07XHJcbiAgICAgICAgZm9yRWFjaChzb3VyY2UubWFwVmFsdWUuZmllbGRzLCAoa2V5LCB2YWwpID0+ICh0YXJnZXQubWFwVmFsdWUuZmllbGRzW2tleV0gPSBkZWVwQ2xvbmUodmFsKSkpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2UuYXJyYXlWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXM6IFtdIH0gfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzb3VyY2UuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5hcnJheVZhbHVlLnZhbHVlc1tpXSA9IGRlZXBDbG9uZShzb3VyY2UuYXJyYXlWYWx1ZS52YWx1ZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVmFsdWUgcmVwcmVzZW50cyB0aGUgY2Fub25pY2FsIHtAbGluayAjTUFYX1ZBTFVFfSAuICovXHJcbmZ1bmN0aW9uIGlzTWF4VmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAoKCgodmFsdWUubWFwVmFsdWUgfHwge30pLmZpZWxkcyB8fCB7fSlbJ19fdHlwZV9fJ10gfHwge30pLnN0cmluZ1ZhbHVlID09PVxyXG4gICAgICAgIE1BWF9WQUxVRV9UWVBFKTtcclxufVxyXG4vKiogUmV0dXJucyB0aGUgbG93ZXN0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgdHlwZSAoaW5jbHVzaXZlKS4gKi9cclxuZnVuY3Rpb24gdmFsdWVzR2V0TG93ZXJCb3VuZCh2YWx1ZSkge1xyXG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYm9vbGVhblZhbHVlOiBmYWxzZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBOYU4gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogeyBzZWNvbmRzOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6ICcnIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiByZWZWYWx1ZShEYXRhYmFzZUlkLmVtcHR5KCksIERvY3VtZW50S2V5LmVtcHR5KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBtYXBWYWx1ZToge30gfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFJldHVybnMgdGhlIGxhcmdlc3QgdmFsdWUgZm9yIHRoZSBnaXZlbiB2YWx1ZSB0eXBlIChleGNsdXNpdmUpLiAqL1xyXG5mdW5jdGlvbiB2YWx1ZXNHZXRVcHBlckJvdW5kKHZhbHVlKSB7XHJcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBib29sZWFuVmFsdWU6IGZhbHNlIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBOYU4gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlIHx8ICdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogeyBzZWNvbmRzOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6ICcnIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogJycgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiByZWZWYWx1ZShEYXRhYmFzZUlkLmVtcHR5KCksIERvY3VtZW50S2V5LmVtcHR5KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IHsgbGF0aXR1ZGU6IC05MCwgbG9uZ2l0dWRlOiAtMTgwIH0gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHt9IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBtYXBWYWx1ZToge30gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBsb3dlckJvdW5kQ29tcGFyZShsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgY21wID0gdmFsdWVDb21wYXJlKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICYmICFyaWdodC5pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghbGVmdC5pbmNsdXNpdmUgJiYgcmlnaHQuaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiB1cHBlckJvdW5kQ29tcGFyZShsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgY21wID0gdmFsdWVDb21wYXJlKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICYmICFyaWdodC5pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFsZWZ0LmluY2x1c2l2ZSAmJiByaWdodC5pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gT2JqZWN0VmFsdWUgcmVwcmVzZW50cyBhIE1hcFZhbHVlIGluIHRoZSBGaXJlc3RvcmUgUHJvdG8gYW5kIG9mZmVycyB0aGVcclxuICogYWJpbGl0eSB0byBhZGQgYW5kIHJlbW92ZSBmaWVsZHMgKHZpYSB0aGUgT2JqZWN0VmFsdWVCdWlsZGVyKS5cclxuICovXHJcbmNsYXNzIE9iamVjdFZhbHVlIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0VmFsdWUoeyBtYXBWYWx1ZToge30gfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIG9yIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSB0aGUgcGF0aCB0byBzZWFyY2hcclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhdCB0aGUgcGF0aCBvciBudWxsIGlmIHRoZSBwYXRoIGlzIG5vdCBzZXQuXHJcbiAgICAgKi9cclxuICAgIGZpZWxkKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsID0gKGN1cnJlbnRMZXZlbC5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3BhdGguZ2V0KGkpXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNNYXBWYWx1ZShjdXJyZW50TGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudExldmVsID0gKGN1cnJlbnRMZXZlbC5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3BhdGgubGFzdFNlZ21lbnQoKV07XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWwgfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZpZWxkIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHNldC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIHNldChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkc01hcCA9IHRoaXMuZ2V0RmllbGRzTWFwKHBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICBmaWVsZHNNYXBbcGF0aC5sYXN0U2VnbWVudCgpXSA9IGRlZXBDbG9uZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHByb3ZpZGVkIGZpZWxkcyB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gQSBtYXAgb2YgZmllbGRzIHRvIHZhbHVlcyAob3IgbnVsbCBmb3IgZGVsZXRlcykuXHJcbiAgICAgKi9cclxuICAgIHNldEFsbChkYXRhKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IEZpZWxkUGF0aCQxLmVtcHR5UGF0aCgpO1xyXG4gICAgICAgIGxldCB1cHNlcnRzID0ge307XHJcbiAgICAgICAgbGV0IGRlbGV0ZXMgPSBbXTtcclxuICAgICAgICBkYXRhLmZvckVhY2goKHZhbHVlLCBwYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50LmlzSW1tZWRpYXRlUGFyZW50T2YocGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgYWNjdW11bGF0ZWQgY2hhbmdlcyBhdCB0aGlzIHBhcmVudCBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlDaGFuZ2VzKGZpZWxkc01hcCwgdXBzZXJ0cywgZGVsZXRlcyk7XHJcbiAgICAgICAgICAgICAgICB1cHNlcnRzID0ge307XHJcbiAgICAgICAgICAgICAgICBkZWxldGVzID0gW107XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoLnBvcExhc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHVwc2VydHNbcGF0aC5sYXN0U2VnbWVudCgpXSA9IGRlZXBDbG9uZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVzLnB1c2gocGF0aC5sYXN0U2VnbWVudCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkc01hcCA9IHRoaXMuZ2V0RmllbGRzTWFwKHBhcmVudCk7XHJcbiAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZmllbGQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBubyBmaWVsZCBhdCB0aGVcclxuICAgICAqIHNwZWNpZmllZCBwYXRoLCBub3RoaW5nIGlzIGNoYW5nZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZmllbGQgcGF0aCB0byByZW1vdmUuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZShwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgbmVzdGVkVmFsdWUgPSB0aGlzLmZpZWxkKHBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICBpZiAoaXNNYXBWYWx1ZShuZXN0ZWRWYWx1ZSkgJiYgbmVzdGVkVmFsdWUubWFwVmFsdWUuZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBuZXN0ZWRWYWx1ZS5tYXBWYWx1ZS5maWVsZHNbcGF0aC5sYXN0U2VnbWVudCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlRXF1YWxzKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFwIHRoYXQgY29udGFpbnMgdGhlIGxlYWYgZWxlbWVudCBvZiBgcGF0aGAuIElmIHRoZSBwYXJlbnRcclxuICAgICAqIGVudHJ5IGRvZXMgbm90IHlldCBleGlzdCwgb3IgaWYgaXQgaXMgbm90IGEgbWFwLCBhIG5ldyBtYXAgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXRGaWVsZHNNYXAocGF0aCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoIWN1cnJlbnQubWFwVmFsdWUuZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQubWFwVmFsdWUgPSB7IGZpZWxkczoge30gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldO1xyXG4gICAgICAgICAgICBpZiAoIWlzTWFwVmFsdWUobmV4dCkgfHwgIW5leHQubWFwVmFsdWUuZmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0geyBtYXBWYWx1ZTogeyBmaWVsZHM6IHt9IH0gfTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzW3BhdGguZ2V0KGkpXSA9IG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZpZXMgYGZpZWxkc01hcGAgYnkgYWRkaW5nLCByZXBsYWNpbmcgb3IgZGVsZXRpbmcgdGhlIHNwZWNpZmllZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqL1xyXG4gICAgYXBwbHlDaGFuZ2VzKGZpZWxkc01hcCwgaW5zZXJ0cywgZGVsZXRlcykge1xyXG4gICAgICAgIGZvckVhY2goaW5zZXJ0cywgKGtleSwgdmFsKSA9PiAoZmllbGRzTWFwW2tleV0gPSB2YWwpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGRlbGV0ZXMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGZpZWxkc01hcFtmaWVsZF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZShkZWVwQ2xvbmUodGhpcy52YWx1ZSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgRmllbGRNYXNrIGJ1aWx0IGZyb20gYWxsIGZpZWxkcyBpbiBhIE1hcFZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEZpZWxkTWFzayh2YWx1ZSkge1xyXG4gICAgY29uc3QgZmllbGRzID0gW107XHJcbiAgICBmb3JFYWNoKHZhbHVlLmZpZWxkcywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IG5ldyBGaWVsZFBhdGgkMShba2V5XSk7XHJcbiAgICAgICAgaWYgKGlzTWFwVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZE1hc2sgPSBleHRyYWN0RmllbGRNYXNrKHZhbHVlLm1hcFZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3QgbmVzdGVkRmllbGRzID0gbmVzdGVkTWFzay5maWVsZHM7XHJcbiAgICAgICAgICAgIGlmIChuZXN0ZWRGaWVsZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgZW1wdHkgbWFwIGJ5IGFkZGluZyBpdCB0byB0aGUgRmllbGRNYXNrLlxyXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5lc3RlZCBhbmQgbm9uLWVtcHR5IE9iamVjdFZhbHVlcywgYWRkIHRoZSBGaWVsZFBhdGggb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBsZWFmIG5vZGVzLlxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRQYXRoIG9mIG5lc3RlZEZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGN1cnJlbnRQYXRoLmNoaWxkKG5lc3RlZFBhdGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9yIG5lc3RlZCBhbmQgbm9uLWVtcHR5IE9iamVjdFZhbHVlcywgYWRkIHRoZSBGaWVsZFBhdGggb2YgdGhlIGxlYWZcclxuICAgICAgICAgICAgLy8gbm9kZXMuXHJcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGN1cnJlbnRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgRmllbGRNYXNrKGZpZWxkcyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUgd2l0aCBhIGtleSwgdmVyc2lvbiwgZGF0YSBhbmQgd2hldGhlciBpdFxyXG4gKiBoYXMgbG9jYWwgbXV0YXRpb25zIGFwcGxpZWQgdG8gaXQuXHJcbiAqXHJcbiAqIERvY3VtZW50cyBjYW4gdHJhbnNpdGlvbiBiZXR3ZWVuIHN0YXRlcyB2aWEgYGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoKWAsXHJcbiAqIGBjb252ZXJ0VG9Ob0RvY3VtZW50KClgIGFuZCBgY29udmVydFRvVW5rbm93bkRvY3VtZW50KClgLiBJZiBhIGRvY3VtZW50IGRvZXNcclxuICogbm90IHRyYW5zaXRpb24gdG8gb25lIG9mIHRoZXNlIHN0YXRlcyBldmVuIGFmdGVyIGFsbCBtdXRhdGlvbnMgaGF2ZSBiZWVuXHJcbiAqIGFwcGxpZWQsIGBpc1ZhbGlkRG9jdW1lbnQoKWAgcmV0dXJucyBmYWxzZSBhbmQgdGhlIGRvY3VtZW50IHNob3VsZCBiZSByZW1vdmVkXHJcbiAqIGZyb20gYWxsIHZpZXdzLlxyXG4gKi9cclxuY2xhc3MgTXV0YWJsZURvY3VtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgZG9jdW1lbnRUeXBlLCB2ZXJzaW9uLCByZWFkVGltZSwgY3JlYXRlVGltZSwgZGF0YSwgZG9jdW1lbnRTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gZG9jdW1lbnRUeXBlO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlVGltZSA9IGNyZWF0ZVRpbWU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSBkb2N1bWVudFN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZG9jdW1lbnQgd2l0aCBubyBrbm93biB2ZXJzaW9uIG9yIGRhdGEsIGJ1dCB3aGljaCBjYW4gc2VydmUgYXNcclxuICAgICAqIGJhc2UgZG9jdW1lbnQgZm9yIG11dGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCB3aXRoIHRoZSBnaXZlbiBkYXRhIGF0IHRoZVxyXG4gICAgICogZ2l2ZW4gdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxyXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBjcmVhdGVUaW1lLCB2YWx1ZSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbi4gKi9cclxuICAgIHN0YXRpYyBuZXdOb0RvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxyXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gZXhpc3QgYXQgdGhlIGdpdmVuIHZlcnNpb24gYnV0XHJcbiAgICAgKiB3aG9zZSBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXHJcbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld1Vua25vd25Eb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxyXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYW5kIHRoYXQgaXRzIHZlcnNpb25cclxuICAgICAqIGFuZCBkYXRhIGFyZSBrbm93bi5cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvRm91bmREb2N1bWVudCh2ZXJzaW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIC8vIElmIGEgZG9jdW1lbnQgaXMgc3dpdGNoaW5nIHN0YXRlIGZyb20gYmVpbmcgYW4gaW52YWxpZCBvciBkZWxldGVkXHJcbiAgICAgICAgLy8gZG9jdW1lbnQgdG8gYSB2YWxpZCAoRk9VTkRfRE9DVU1FTlQpIGRvY3VtZW50LCBlaXRoZXIgZHVlIHRvIHJlY2VpdmluZyBhblxyXG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIFdhdGNoIG9yIGR1ZSB0byBhcHBseWluZyBhIGxvY2FsIHNldCBtdXRhdGlvbiBvbiB0b3BcclxuICAgICAgICAvLyBvZiBhIGRlbGV0ZWQgZG9jdW1lbnQsIG91ciBiZXN0IGd1ZXNzIGFib3V0IGl0cyBjcmVhdGVUaW1lIHdvdWxkIGJlIHRoZVxyXG4gICAgICAgIC8vIHZlcnNpb24gYXQgd2hpY2ggdGhlIGRvY3VtZW50IHRyYW5zaXRpb25lZCB0byBhIEZPVU5EX0RPQ1VNRU5ULlxyXG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZVRpbWUuaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmRvY3VtZW50VHlwZSA9PT0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbWUgPSB2ZXJzaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3QgZXhpc3QgYXQgdGhlIGdpdmVuXHJcbiAgICAgKiB2ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Ob0RvY3VtZW50KHZlcnNpb24pIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZXhpc3RzIGF0IGEgZ2l2ZW4gdmVyc2lvbiBidXRcclxuICAgICAqIHRoYXQgaXRzIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cclxuICAgICAqIGJhc2UgZG9jdW1lbnQpLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQodmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldEhhc0xvY2FsTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldFJlYWRUaW1lKHJlYWRUaW1lKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0xvY2FsTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U3RhdGUgPT09IDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID09PSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzUGVuZGluZ1dyaXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNMb2NhbE11dGF0aW9ucyB8fCB0aGlzLmhhc0NvbW1pdHRlZE11dGF0aW9ucztcclxuICAgIH1cclxuICAgIGlzVmFsaWREb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgIT09IDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi87XHJcbiAgICB9XHJcbiAgICBpc0ZvdW5kRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLztcclxuICAgIH1cclxuICAgIGlzTm9Eb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNVbmtub3duRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBNdXRhYmxlRG9jdW1lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5rZXkuaXNFcXVhbChvdGhlci5rZXkpICYmXHJcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5pc0VxdWFsKG90aGVyLnZlcnNpb24pICYmXHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSBvdGhlci5kb2N1bWVudFR5cGUgJiZcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID09PSBvdGhlci5kb2N1bWVudFN0YXRlICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5pc0VxdWFsKG90aGVyLmRhdGEpKTtcclxuICAgIH1cclxuICAgIG11dGFibGVDb3B5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KHRoaXMua2V5LCB0aGlzLmRvY3VtZW50VHlwZSwgdGhpcy52ZXJzaW9uLCB0aGlzLnJlYWRUaW1lLCB0aGlzLmNyZWF0ZVRpbWUsIHRoaXMuZGF0YS5jbG9uZSgpLCB0aGlzLmRvY3VtZW50U3RhdGUpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIChgRG9jdW1lbnQoJHt0aGlzLmtleX0sICR7dGhpcy52ZXJzaW9ufSwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEudmFsdWUpfSwgYCArXHJcbiAgICAgICAgICAgIGB7Y3JlYXRlVGltZTogJHt0aGlzLmNyZWF0ZVRpbWV9fSksIGAgK1xyXG4gICAgICAgICAgICBge2RvY3VtZW50VHlwZTogJHt0aGlzLmRvY3VtZW50VHlwZX19KSwgYCArXHJcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRTdGF0ZTogJHt0aGlzLmRvY3VtZW50U3RhdGV9fSlgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgdGhlIHZhbHVlIGZvciBmaWVsZCBgZmllbGRgIGluIHRoZSBwcm92aWRlZCBkb2N1bWVudHMuIFRocm93cyBpZlxyXG4gKiB0aGUgZmllbGQgZG9lcyBub3QgZXhpc3QgaW4gYm90aCBkb2N1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlRG9jdW1lbnRzQnlGaWVsZChmaWVsZCwgZDEsIGQyKSB7XHJcbiAgICBjb25zdCB2MSA9IGQxLmRhdGEuZmllbGQoZmllbGQpO1xyXG4gICAgY29uc3QgdjIgPSBkMi5kYXRhLmZpZWxkKGZpZWxkKTtcclxuICAgIGlmICh2MSAhPT0gbnVsbCAmJiB2MiAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZUNvbXBhcmUodjEsIHYyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBib3VuZCBvZiBhIHF1ZXJ5LlxyXG4gKlxyXG4gKiBUaGUgYm91bmQgaXMgc3BlY2lmaWVkIHdpdGggdGhlIGdpdmVuIGNvbXBvbmVudHMgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gYW5kXHJcbiAqIHdoZXRoZXIgaXQncyBqdXN0IGJlZm9yZSBvciBqdXN0IGFmdGVyIHRoZSBwb3NpdGlvbiAocmVsYXRpdmUgdG8gd2hhdGV2ZXIgdGhlXHJcbiAqIHF1ZXJ5IG9yZGVyIGlzKS5cclxuICpcclxuICogVGhlIHBvc2l0aW9uIHJlcHJlc2VudHMgYSBsb2dpY2FsIGluZGV4IHBvc2l0aW9uIGZvciBhIHF1ZXJ5LiBJdCdzIGEgcHJlZml4XHJcbiAqIG9mIHZhbHVlcyBmb3IgdGhlIChwb3RlbnRpYWxseSBpbXBsaWNpdCkgb3JkZXIgYnkgY2xhdXNlcyBvZiBhIHF1ZXJ5LlxyXG4gKlxyXG4gKiBCb3VuZCBwcm92aWRlcyBhIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZG9jdW1lbnQgY29tZXMgYmVmb3JlIG9yXHJcbiAqIGFmdGVyIGEgYm91bmQuIFRoaXMgaXMgaW5mbHVlbmNlZCBieSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBqdXN0IGJlZm9yZSBvclxyXG4gKiBqdXN0IGFmdGVyIHRoZSBwcm92aWRlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jbGFzcyBCb3VuZCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuaW5jbHVzaXZlID0gaW5jbHVzaXZlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJvdW5kQ29tcGFyZVRvRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYykge1xyXG4gICAgbGV0IGNvbXBhcmlzb24gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9yZGVyQnlDb21wb25lbnQgPSBvcmRlckJ5W2ldO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGJvdW5kLnBvc2l0aW9uW2ldO1xyXG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICBjb21wYXJpc29uID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihEb2N1bWVudEtleS5mcm9tTmFtZShjb21wb25lbnQucmVmZXJlbmNlVmFsdWUpLCBkb2Mua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGEuZmllbGQob3JkZXJCeUNvbXBvbmVudC5maWVsZCk7XHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSB2YWx1ZUNvbXBhcmUoY29tcG9uZW50LCBkb2NWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmRpciA9PT0gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi8pIHtcclxuICAgICAgICAgICAgY29tcGFyaXNvbiA9IGNvbXBhcmlzb24gKiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhcmlzb247XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGRvY3VtZW50IHNvcnRzIGFmdGVyIGEgYm91bmQgdXNpbmcgdGhlIHByb3ZpZGVkIHNvcnRcclxuICogb3JkZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBib3VuZFNvcnRzQWZ0ZXJEb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcclxuICAgIHJldHVybiBib3VuZC5pbmNsdXNpdmUgPyBjb21wYXJpc29uID49IDAgOiBjb21wYXJpc29uID4gMDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGEgZG9jdW1lbnQgc29ydHMgYmVmb3JlIGEgYm91bmQgdXNpbmcgdGhlIHByb3ZpZGVkIHNvcnRcclxuICogb3JkZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBib3VuZFNvcnRzQmVmb3JlRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYykge1xyXG4gICAgY29uc3QgY29tcGFyaXNvbiA9IGJvdW5kQ29tcGFyZVRvRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYyk7XHJcbiAgICByZXR1cm4gYm91bmQuaW5jbHVzaXZlID8gY29tcGFyaXNvbiA8PSAwIDogY29tcGFyaXNvbiA8IDA7XHJcbn1cclxuZnVuY3Rpb24gYm91bmRFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJpZ2h0ID09PSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgIT09IHJpZ2h0LmluY2x1c2l2ZSB8fFxyXG4gICAgICAgIGxlZnQucG9zaXRpb24ubGVuZ3RoICE9PSByaWdodC5wb3NpdGlvbi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQucG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsZWZ0UG9zaXRpb24gPSBsZWZ0LnBvc2l0aW9uW2ldO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0UG9zaXRpb24gPSByaWdodC5wb3NpdGlvbltpXTtcclxuICAgICAgICBpZiAoIXZhbHVlRXF1YWxzKGxlZnRQb3NpdGlvbiwgcmlnaHRQb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBvcmRlcmluZyBvbiBhIGZpZWxkLCBpbiBzb21lIERpcmVjdGlvbi4gRGlyZWN0aW9uIGRlZmF1bHRzIHRvIEFTQ0VORElORy5cclxuICovXHJcbmNsYXNzIE9yZGVyQnkge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIGRpciA9IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLykge1xyXG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICAgICAgICB0aGlzLmRpciA9IGRpcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeU9yZGVyQnkob3JkZXJCeSkge1xyXG4gICAgLy8gVE9ETyhiLzI5MTgzMTY1KTogTWFrZSB0aGlzIGNvbGxpc2lvbiByb2J1c3QuXHJcbiAgICByZXR1cm4gb3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSArIG9yZGVyQnkuZGlyO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeU9yZGVyQnkob3JkZXJCeSkge1xyXG4gICAgcmV0dXJuIGAke29yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICgke29yZGVyQnkuZGlyfSlgO1xyXG59XHJcbmZ1bmN0aW9uIG9yZGVyQnlFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBsZWZ0LmRpciA9PT0gcmlnaHQuZGlyICYmIGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlsdGVyIHtcclxufVxyXG5jbGFzcyBGaWVsZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5RmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNGaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNBbnlGaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovXHJcbiAgICAgICAgICAgID8gbmV3IEtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIHZhbHVlKVxyXG4gICAgICAgICAgICA6IG5ldyBLZXlGaWVsZE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgLy8gVHlwZXMgZG8gbm90IGhhdmUgdG8gbWF0Y2ggaW4gTk9UX0VRVUFMIGZpbHRlcnMuXHJcbiAgICAgICAgaWYgKHRoaXMub3AgPT09IFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzQ29tcGFyaXNvbih2YWx1ZUNvbXBhcmUob3RoZXIsIHRoaXMudmFsdWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE9ubHkgY29tcGFyZSB0eXBlcyB3aXRoIG1hdGNoaW5nIGJhY2tlbmQgb3JkZXIgKHN1Y2ggYXMgZG91YmxlIGFuZCBpbnQpLlxyXG4gICAgICAgIHJldHVybiAob3RoZXIgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgdHlwZU9yZGVyKHRoaXMudmFsdWUpID09PSB0eXBlT3JkZXIob3RoZXIpICYmXHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24odmFsdWVDb21wYXJlKG90aGVyLCB0aGlzLnZhbHVlKSkpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlc0NvbXBhcmlzb24oY29tcGFyaXNvbikge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uIDwgMDtcclxuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPD0gMDtcclxuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gMDtcclxuICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gIT09IDA7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPiAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+PSAwO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0luZXF1YWxpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIChbXHJcbiAgICAgICAgICAgIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLyxcclxuICAgICAgICAgICAgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLyxcclxuICAgICAgICAgICAgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovLFxyXG4gICAgICAgICAgICBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovLFxyXG4gICAgICAgICAgICBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLFxyXG4gICAgICAgICAgICBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL1xyXG4gICAgICAgIF0uaW5kZXhPZih0aGlzLm9wKSA+PSAwKTtcclxuICAgIH1cclxuICAgIGdldEZsYXR0ZW5lZEZpbHRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcclxuICAgIH1cclxuICAgIGdldEZpbHRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb21wb3NpdGVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmlsdGVycywgb3ApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XHJcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xyXG4gICAgICAgIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKGZpbHRlcnMsIG9wKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVGaWx0ZXIoZmlsdGVycywgb3ApO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhkb2MpIHtcclxuICAgICAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbih0aGlzKSkge1xyXG4gICAgICAgICAgICAvLyBGb3IgY29uanVuY3Rpb25zLCBhbGwgZmlsdGVycyBtdXN0IG1hdGNoLCBzbyByZXR1cm4gZmFsc2UgaWYgYW55IGZpbHRlciBkb2Vzbid0IG1hdGNoLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbmQoZmlsdGVyID0+ICFmaWx0ZXIubWF0Y2hlcyhkb2MpKSA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9yIGRpc2p1bmN0aW9ucywgYXQgbGVhc3Qgb25lIGZpbHRlciBzaG91bGQgbWF0Y2guXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gZmlsdGVyLm1hdGNoZXMoZG9jKSkgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGbGF0dGVuZWRGaWx0ZXJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLnJlZHVjZSgocmVzdWx0LCBzdWJmaWx0ZXIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoc3ViZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSk7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycztcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBtdXRhYmxlIGNvcHkgb2YgYHRoaXMuZmlsdGVyc2BcclxuICAgIGdldEZpbHRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oW10sIHRoaXMuZmlsdGVycyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXIub3AgPT09IFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyLm9wID09PSBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi87XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpbHRlciBpcyBhIGNvbmp1bmN0aW9uIG9mIGZpZWxkIGZpbHRlcnMgb25seS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgIHJldHVybiAoY29tcG9zaXRlRmlsdGVySXNGbGF0KGNvbXBvc2l0ZUZpbHRlcikgJiZcclxuICAgICAgICBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBmaWx0ZXIgZG9lcyBub3QgY29udGFpbiBhbnkgY29tcG9zaXRlIGZpbHRlcnMuIFJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNGbGF0KGNvbXBvc2l0ZUZpbHRlcikge1xyXG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMpIHtcclxuICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xyXG4gICAgICAgIC8vIFRPRE8oYi8yOTE4MzE2NSk6IFRlY2huaWNhbGx5LCB0aGlzIHdvbid0IGJlIHVuaXF1ZSBpZiB0d28gdmFsdWVzIGhhdmVcclxuICAgICAgICAvLyB0aGUgc2FtZSBkZXNjcmlwdGlvbiwgc3VjaCBhcyB0aGUgaW50IDMgYW5kIHRoZSBzdHJpbmcgXCIzXCIuIFNvIHdlIHNob3VsZFxyXG4gICAgICAgIC8vIGFkZCB0aGUgdHlwZXMgaW4gaGVyZSBzb21laG93LCB0b28uXHJcbiAgICAgICAgcmV0dXJuIChmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICBmaWx0ZXIub3AudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgIGNhbm9uaWNhbElkKGZpbHRlci52YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSkge1xyXG4gICAgICAgIC8vIE9sZGVyIFNESyB2ZXJzaW9ucyB1c2UgYW4gaW1wbGljaXQgQU5EIG9wZXJhdGlvbiBiZXR3ZWVuIHRoZWlyIGZpbHRlcnMuXHJcbiAgICAgICAgLy8gSW4gdGhlIG5ldyBTREsgdmVyc2lvbnMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSBhbiBleHBsaWNpdCBBTkQgZmlsdGVyLlxyXG4gICAgICAgIC8vIFRvIHN0YXkgY29uc2lzdGVudCB3aXRoIHRoZSBvbGQgdXNhZ2VzLCB3ZSBhZGQgYSBzcGVjaWFsIGNhc2UgdG8gZW5zdXJlXHJcbiAgICAgICAgLy8gdGhlIGNhbm9uaWNhbCBJRCBmb3IgdGhlc2UgdHdvIGFyZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGU6XHJcbiAgICAgICAgLy8gYGNvbC53aGVyZUVxdWFscyhcImFcIiwgMSkud2hlcmVFcXVhbHMoXCJiXCIsIDIpYCBzaG91bGQgaGF2ZSB0aGUgc2FtZVxyXG4gICAgICAgIC8vIGNhbm9uaWNhbCBJRCBhcyBgY29sLndoZXJlKGFuZChlcXVhbHMoXCJhXCIsMSksIGVxdWFscyhcImJcIiwyKSkpYC5cclxuICAgICAgICByZXR1cm4gZmlsdGVyLmZpbHRlcnMubWFwKGZpbHRlciA9PiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpKS5qb2luKCcsJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXJcclxuICAgICAgICBjb25zdCBjYW5vbmljYWxJZHNTdHJpbmcgPSBmaWx0ZXIuZmlsdGVyc1xyXG4gICAgICAgICAgICAubWFwKGZpbHRlciA9PiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpKVxyXG4gICAgICAgICAgICAuam9pbignLCcpO1xyXG4gICAgICAgIHJldHVybiBgJHtmaWx0ZXIub3B9KCR7Y2Fub25pY2FsSWRzU3RyaW5nfSlgO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbHRlckVxdWFscyhmMSwgZjIpIHtcclxuICAgIGlmIChmMSBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyRXF1YWxzKGYxLCBmMik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmMSBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcikge1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXJFcXVhbHMoZjEsIGYyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaWVsZEZpbHRlckVxdWFscyhmMSwgZjIpIHtcclxuICAgIHJldHVybiAoZjIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciAmJlxyXG4gICAgICAgIGYxLm9wID09PSBmMi5vcCAmJlxyXG4gICAgICAgIGYxLmZpZWxkLmlzRXF1YWwoZjIuZmllbGQpICYmXHJcbiAgICAgICAgdmFsdWVFcXVhbHMoZjEudmFsdWUsIGYyLnZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVyRXF1YWxzKGYxLCBmMikge1xyXG4gICAgaWYgKGYyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyICYmXHJcbiAgICAgICAgZjEub3AgPT09IGYyLm9wICYmXHJcbiAgICAgICAgZjEuZmlsdGVycy5sZW5ndGggPT09IGYyLmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViRmlsdGVyc01hdGNoID0gZjEuZmlsdGVycy5yZWR1Y2UoKHJlc3VsdCwgZjFGaWx0ZXIsIGluZGV4KSA9PiByZXN1bHQgJiYgZmlsdGVyRXF1YWxzKGYxRmlsdGVyLCBmMi5maWx0ZXJzW2luZGV4XSksIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBzdWJGaWx0ZXJzTWF0Y2g7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgY29tcG9zaXRlIGZpbHRlciB0aGF0IGNvbnRhaW5zIGFsbCBmaWx0ZXIgZnJvbVxyXG4gKiBgY29tcG9zaXRlRmlsdGVyYCBwbHVzIGFsbCB0aGUgZ2l2ZW4gZmlsdGVycyBpbiBgb3RoZXJGaWx0ZXJzYC5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMoY29tcG9zaXRlRmlsdGVyLCBvdGhlckZpbHRlcnMpIHtcclxuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBjb21wb3NpdGVGaWx0ZXIuZmlsdGVycy5jb25jYXQob3RoZXJGaWx0ZXJzKTtcclxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG1lcmdlZEZpbHRlcnMsIGNvbXBvc2l0ZUZpbHRlci5vcCk7XHJcbn1cclxuLyoqIFJldHVybnMgYSBkZWJ1ZyBkZXNjcmlwdGlvbiBmb3IgYGZpbHRlcmAuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlGaWVsZEZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICdGaWx0ZXInO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHJldHVybiAoZmlsdGVyLm9wLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgIGAge2AgK1xyXG4gICAgICAgIGZpbHRlci5nZXRGaWx0ZXJzKCkubWFwKHN0cmluZ2lmeUZpbHRlcikuam9pbignICwnKSArXHJcbiAgICAgICAgJ30nKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlGaWVsZEZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHJldHVybiBgJHtmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICR7ZmlsdGVyLm9wfSAke2Nhbm9uaWNhbElkKGZpbHRlci52YWx1ZSl9YDtcclxufVxyXG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIChpLmUuICdfX25hbWVfXycpLiAqL1xyXG5jbGFzcyBLZXlGaWVsZEZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmtleSA9IERvY3VtZW50S2V5LmZyb21OYW1lKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZG9jLmtleSwgdGhpcy5rZXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXNDb21wYXJpc29uKGNvbXBhcmlzb24pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgd2l0aGluIGFuIGFycmF5LiAqL1xyXG5jbGFzcyBLZXlGaWVsZEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5zb21lKGtleSA9PiBrZXkuaXNFcXVhbChkb2Mua2V5KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyBub3QgcHJlc2VudCB3aXRoaW4gYW4gYXJyYXkuICovXHJcbmNsYXNzIEtleUZpZWxkTm90SW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUoXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmtleXMuc29tZShrZXkgPT4ga2V5LmlzRXF1YWwoZG9jLmtleSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShvcCwgdmFsdWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoKChfYSA9IHZhbHVlLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpIHx8IFtdKS5tYXAodiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHYucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMgb3BlcmF0b3IuICovXHJcbmNsYXNzIEFycmF5Q29udGFpbnNGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob3RoZXIpICYmIGFycmF5VmFsdWVDb250YWlucyhvdGhlci5hcnJheVZhbHVlLCB0aGlzLnZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBJTiBvcGVyYXRvci4gKi9cclxuY2xhc3MgSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBub3QtaW4gb3BlcmF0b3IuICovXHJcbmNsYXNzIE5vdEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGlmIChhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgIWFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucy1hbnkgb3BlcmF0b3IuICovXHJcbmNsYXNzIEFycmF5Q29udGFpbnNBbnlGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICBpZiAoIWlzQXJyYXkob3RoZXIpIHx8ICFvdGhlci5hcnJheVZhbHVlLnZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdGhlci5hcnJheVZhbHVlLnZhbHVlcy5zb21lKHZhbCA9PiBhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB2YWwpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmNsYXNzIFRhcmdldEltcGwge1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5vcmRlckJ5ID0gb3JkZXJCeTtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBzdGFydEF0O1xyXG4gICAgICAgIHRoaXMuZW5kQXQgPSBlbmRBdDtcclxuICAgICAgICB0aGlzLm1lbW9pemVkQ2Fub25pY2FsSWQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIFRhcmdldCB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cclxuICogUGF0aCBtdXN0IGN1cnJlbnRseSBiZSBlbXB0eSBpZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeS5cclxuICpcclxuICogTk9URTogeW91IHNob3VsZCBhbHdheXMgY29uc3RydWN0IGBUYXJnZXRgIGZyb20gYFF1ZXJ5LnRvVGFyZ2V0YCBpbnN0ZWFkIG9mXHJcbiAqIHVzaW5nIHRoaXMgZmFjdG9yeSBtZXRob2QsIGJlY2F1c2UgYFF1ZXJ5YCBwcm92aWRlcyBhbiBpbXBsaWNpdCBgb3JkZXJCeWBcclxuICogcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdUYXJnZXQocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG5ldyBUYXJnZXRJbXBsKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeSwgZmlsdGVycywgbGltaXQsIHN0YXJ0QXQsIGVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeVRhcmdldCh0YXJnZXQpIHtcclxuICAgIGNvbnN0IHRhcmdldEltcGwgPSBkZWJ1Z0Nhc3QodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQgPT09IG51bGwpIHtcclxuICAgICAgICBsZXQgc3RyID0gdGFyZ2V0SW1wbC5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xyXG4gICAgICAgIGlmICh0YXJnZXRJbXBsLmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdHIgKz0gJ3xjZzonICsgdGFyZ2V0SW1wbC5jb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0ciArPSAnfGY6JztcclxuICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5maWx0ZXJzLm1hcChmID0+IGNhbm9uaWZ5RmlsdGVyKGYpKS5qb2luKCcsJyk7XHJcbiAgICAgICAgc3RyICs9ICd8b2I6JztcclxuICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5vcmRlckJ5Lm1hcChvID0+IGNhbm9uaWZ5T3JkZXJCeShvKSkuam9pbignLCcpO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0SW1wbC5saW1pdCkpIHtcclxuICAgICAgICAgICAgc3RyICs9ICd8bDonO1xyXG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5saW1pdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldEltcGwuc3RhcnRBdCkge1xyXG4gICAgICAgICAgICBzdHIgKz0gJ3xsYjonO1xyXG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5zdGFydEF0LmluY2x1c2l2ZSA/ICdiOicgOiAnYTonO1xyXG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5zdGFydEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXRJbXBsLmVuZEF0KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnfHViOic7XHJcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmVuZEF0LmluY2x1c2l2ZSA/ICdhOicgOiAnYjonO1xyXG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5lbmRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQgPSBzdHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0SW1wbC5tZW1vaXplZENhbm9uaWNhbElkO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVRhcmdldCh0YXJnZXQpIHtcclxuICAgIGxldCBzdHIgPSB0YXJnZXQucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIGlmICh0YXJnZXQuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyICs9ICcgY29sbGVjdGlvbkdyb3VwPScgKyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5maWx0ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBzdHIgKz0gYCwgZmlsdGVyczogWyR7dGFyZ2V0LmZpbHRlcnNcclxuICAgICAgICAgICAgLm1hcChmID0+IHN0cmluZ2lmeUZpbHRlcihmKSlcclxuICAgICAgICAgICAgLmpvaW4oJywgJyl9XWA7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRhcmdldC5saW1pdCkpIHtcclxuICAgICAgICBzdHIgKz0gJywgbGltaXQ6ICcgKyB0YXJnZXQubGltaXQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0Lm9yZGVyQnkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHN0ciArPSBgLCBvcmRlckJ5OiBbJHt0YXJnZXQub3JkZXJCeVxyXG4gICAgICAgICAgICAubWFwKG8gPT4gc3RyaW5naWZ5T3JkZXJCeShvKSlcclxuICAgICAgICAgICAgLmpvaW4oJywgJyl9XWA7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0LnN0YXJ0QXQpIHtcclxuICAgICAgICBzdHIgKz0gJywgc3RhcnRBdDogJztcclxuICAgICAgICBzdHIgKz0gdGFyZ2V0LnN0YXJ0QXQuaW5jbHVzaXZlID8gJ2I6JyA6ICdhOic7XHJcbiAgICAgICAgc3RyICs9IHRhcmdldC5zdGFydEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0LmVuZEF0KSB7XHJcbiAgICAgICAgc3RyICs9ICcsIGVuZEF0OiAnO1xyXG4gICAgICAgIHN0ciArPSB0YXJnZXQuZW5kQXQuaW5jbHVzaXZlID8gJ2E6JyA6ICdiOic7XHJcbiAgICAgICAgc3RyICs9IHRhcmdldC5lbmRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBUYXJnZXQoJHtzdHJ9KWA7XHJcbn1cclxuZnVuY3Rpb24gdGFyZ2V0RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC5saW1pdCAhPT0gcmlnaHQubGltaXQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5vcmRlckJ5Lmxlbmd0aCAhPT0gcmlnaHQub3JkZXJCeS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQub3JkZXJCeS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb3JkZXJCeUVxdWFscyhsZWZ0Lm9yZGVyQnlbaV0sIHJpZ2h0Lm9yZGVyQnlbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5maWx0ZXJzLmxlbmd0aCAhPT0gcmlnaHQuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQuZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghZmlsdGVyRXF1YWxzKGxlZnQuZmlsdGVyc1tpXSwgcmlnaHQuZmlsdGVyc1tpXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsZWZ0LmNvbGxlY3Rpb25Hcm91cCAhPT0gcmlnaHQuY29sbGVjdGlvbkdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFsZWZ0LnBhdGguaXNFcXVhbChyaWdodC5wYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghYm91bmRFcXVhbHMobGVmdC5zdGFydEF0LCByaWdodC5zdGFydEF0KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBib3VuZEVxdWFscyhsZWZ0LmVuZEF0LCByaWdodC5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gdGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpIHtcclxuICAgIHJldHVybiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleSh0YXJnZXQucGF0aCkgJiZcclxuICAgICAgICB0YXJnZXQuY29sbGVjdGlvbkdyb3VwID09PSBudWxsICYmXHJcbiAgICAgICAgdGFyZ2V0LmZpbHRlcnMubGVuZ3RoID09PSAwKTtcclxufVxyXG4vKiogUmV0dXJucyB0aGUgZmllbGQgZmlsdGVycyB0aGF0IHRhcmdldCB0aGUgZ2l2ZW4gZmllbGQgcGF0aC4gKi9cclxuZnVuY3Rpb24gdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIHBhdGgpIHtcclxuICAgIHJldHVybiB0YXJnZXQuZmlsdGVycy5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiYgZi5maWVsZC5pc0VxdWFsKHBhdGgpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdmFsdWVzIHRoYXQgYXJlIHVzZWQgaW4gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZXHJcbiAqIGZpbHRlcnMuIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBzdWNoIGZpbHRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXRBcnJheVZhbHVlcyh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcclxuICAgIGNvbnN0IHNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpO1xyXG4gICAgaWYgKHNlZ21lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpKSB7XHJcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyLnZhbHVlLmFycmF5VmFsdWUudmFsdWVzIHx8IFtdO1xyXG4gICAgICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZmllbGRGaWx0ZXIudmFsdWVdO1xyXG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgZmlsdGVycyBhcmUgbm90IGFycmF5IGZpbHRlcnMuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIHRoYXQgYXJlIHVzZWQgaW4gIT0gb3IgTk9UX0lOIGZpbHRlcnMuIFJldHVybnNcclxuICogYG51bGxgIGlmIHRoZXJlIGFyZSBubyBzdWNoIGZpbHRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXROb3RJblZhbHVlcyh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcclxuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSBlcXVhbGl0eSBwcmVmaXgsIHdoaWNoIGlzIGVuY29kZWQgaW4gdGhlIGluZGV4IHZhbHVlIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbmVxdWFsaXR5IChlLmcuIGBhID09ICdhJyAmJiBiICE9ICdiJ2AgaXMgZW5jb2RlZCB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGB2YWx1ZSAhPSAnYWInYCkuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNldChzZWdtZW50LmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgZmllbGRGaWx0ZXIudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RJbi9Ob3RFcXVhbCBpcyBhbHdheXMgYSBzdWZmaXguIFRoZXJlIGNhbm5vdCBiZSBhbnkgcmVtYWluaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VnbWVudHMgYW5kIGhlbmNlIHdlIGNhbiByZXR1cm4gZWFybHkgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KHNlZ21lbnQuZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpLCBmaWVsZEZpbHRlci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWVzLnZhbHVlcygpKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGNhbm5vdCBiZSB1c2VkIGFzIG5vdEluIGJvdW5kcy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbG93ZXIgYm91bmQgb2YgZmllbGQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBzdGFydGluZyBwb2ludCB0b1xyXG4gKiBzY2FuIHRoZSBpbmRleCBkZWZpbmVkIGJ5IGBmaWVsZEluZGV4YC4gUmV0dXJucyBgTUlOX1ZBTFVFYCBpZiBubyBsb3dlciBib3VuZFxyXG4gKiBleGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXRMb3dlckJvdW5kKHRhcmdldCwgZmllbGRJbmRleCkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcclxuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQsIHJldHJpZXZlIGEgbG93ZXIgYm91bmQgaWYgdGhlcmUgaXMgYSBzdWl0YWJsZSBmaWx0ZXIgb3JcclxuICAgIC8vIHN0YXJ0QXQuXHJcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50Qm91bmQgPSBzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xyXG4gICAgICAgICAgICA/IHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5zdGFydEF0KVxyXG4gICAgICAgICAgICA6IHRhcmdldEdldERlc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuc3RhcnRBdCk7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goc2VnbWVudEJvdW5kLnZhbHVlKTtcclxuICAgICAgICBpbmNsdXNpdmUgJiYgKGluY2x1c2l2ZSA9IHNlZ21lbnRCb3VuZC5pbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBCb3VuZCh2YWx1ZXMsIGluY2x1c2l2ZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gdXBwZXIgYm91bmQgb2YgZmllbGQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kaW5nIHBvaW50XHJcbiAqIHdoZW4gc2Nhbm5pbmcgdGhlIGluZGV4IGRlZmluZWQgYnkgYGZpZWxkSW5kZXhgLiBSZXR1cm5zIGBNQVhfVkFMVUVgIGlmIG5vXHJcbiAqIHVwcGVyIGJvdW5kIGV4aXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHRhcmdldEdldFVwcGVyQm91bmQodGFyZ2V0LCBmaWVsZEluZGV4KSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xyXG4gICAgLy8gRm9yIGVhY2ggc2VnbWVudCwgcmV0cmlldmUgYW4gdXBwZXIgYm91bmQgaWYgdGhlcmUgaXMgYSBzdWl0YWJsZSBmaWx0ZXIgb3JcclxuICAgIC8vIGVuZEF0LlxyXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudEJvdW5kID0gc2VnbWVudC5raW5kID09PSAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cclxuICAgICAgICAgICAgPyB0YXJnZXRHZXREZXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LmVuZEF0KVxyXG4gICAgICAgICAgICA6IHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5lbmRBdCk7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goc2VnbWVudEJvdW5kLnZhbHVlKTtcclxuICAgICAgICBpbmNsdXNpdmUgJiYgKGluY2x1c2l2ZSA9IHNlZ21lbnRCb3VuZC5pbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBCb3VuZCh2YWx1ZXMsIGluY2x1c2l2ZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIHRvIHVzZSBhcyB0aGUgbG93ZXIgYm91bmQgZm9yIGFzY2VuZGluZyBpbmRleCBzZWdtZW50IGF0XHJcbiAqIHRoZSBwcm92aWRlZCBgZmllbGRQYXRoYCAob3IgdGhlIHVwcGVyIGJvdW5kIGZvciBhbiBkZXNjZW5kaW5nIHNlZ21lbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gdGFyZ2V0R2V0QXNjZW5kaW5nQm91bmQodGFyZ2V0LCBmaWVsZFBhdGgsIGJvdW5kKSB7XHJcbiAgICBsZXQgdmFsdWUgPSBNSU5fVkFMVUU7XHJcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcclxuICAgIC8vIFByb2Nlc3MgYWxsIGZpbHRlcnMgdG8gZmluZCBhIHZhbHVlIGZvciB0aGUgY3VycmVudCBmaWVsZCBzZWdtZW50XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlclZhbHVlID0gTUlOX1ZBTFVFO1xyXG4gICAgICAgIGxldCBmaWx0ZXJJbmNsdXNpdmUgPSB0cnVlO1xyXG4gICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcclxuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gdmFsdWVzR2V0TG93ZXJCb3VuZChmaWVsZEZpbHRlci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxyXG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZpbHRlckluY2x1c2l2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcclxuICAgICAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcclxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gTUlOX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGNhbm5vdCBiZSB1c2VkIGFzIGxvd2VyIGJvdW5kcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvd2VyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBmaWx0ZXJWYWx1ZSwgaW5jbHVzaXZlOiBmaWx0ZXJJbmNsdXNpdmUgfSkgPCAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyVmFsdWU7XHJcbiAgICAgICAgICAgIGluY2x1c2l2ZSA9IGZpbHRlckluY2x1c2l2ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGJvdW5kLCBjb21wYXJlIHRoZSB2YWx1ZXMgYWdhaW5zdCB0aGUgZXhpc3RpbmdcclxuICAgIC8vIHJhbmdlIHRvIHNlZSBpZiB3ZSBjYW4gbmFycm93IHRoZSBzY29wZS5cclxuICAgIGlmIChib3VuZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lm9yZGVyQnkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXJCeSA9IHRhcmdldC5vcmRlckJ5W2ldO1xyXG4gICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclZhbHVlID0gYm91bmQucG9zaXRpb25baV07XHJcbiAgICAgICAgICAgICAgICBpZiAobG93ZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGN1cnNvclZhbHVlLCBpbmNsdXNpdmU6IGJvdW5kLmluY2x1c2l2ZSB9KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnNvclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSA9IGJvdW5kLmluY2x1c2l2ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdmFsdWUsIGluY2x1c2l2ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSB0byB1c2UgYXMgdGhlIHVwcGVyIGJvdW5kIGZvciBhc2NlbmRpbmcgaW5kZXggc2VnbWVudCBhdFxyXG4gKiB0aGUgcHJvdmlkZWQgYGZpZWxkUGF0aGAgKG9yIHRoZSBsb3dlciBib3VuZCBmb3IgYSBkZXNjZW5kaW5nIHNlZ21lbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgZmllbGRQYXRoLCBib3VuZCkge1xyXG4gICAgbGV0IHZhbHVlID0gTUFYX1ZBTFVFO1xyXG4gICAgbGV0IGluY2x1c2l2ZSA9IHRydWU7XHJcbiAgICAvLyBQcm9jZXNzIGFsbCBmaWx0ZXJzIHRvIGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgZmllbGQgc2VnbWVudFxyXG4gICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgZmllbGRQYXRoKSkge1xyXG4gICAgICAgIGxldCBmaWx0ZXJWYWx1ZSA9IE1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgZmlsdGVySW5jbHVzaXZlID0gdHJ1ZTtcclxuICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcclxuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IHZhbHVlc0dldFVwcGVyQm91bmQoZmllbGRGaWx0ZXIudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxyXG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZpbHRlckluY2x1c2l2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcclxuICAgICAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcclxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGNhbm5vdCBiZSB1c2VkIGFzIHVwcGVyIGJvdW5kcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwcGVyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBmaWx0ZXJWYWx1ZSwgaW5jbHVzaXZlOiBmaWx0ZXJJbmNsdXNpdmUgfSkgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyVmFsdWU7XHJcbiAgICAgICAgICAgIGluY2x1c2l2ZSA9IGZpbHRlckluY2x1c2l2ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGJvdW5kLCBjb21wYXJlIHRoZSB2YWx1ZXMgYWdhaW5zdCB0aGUgZXhpc3RpbmdcclxuICAgIC8vIHJhbmdlIHRvIHNlZSBpZiB3ZSBjYW4gbmFycm93IHRoZSBzY29wZS5cclxuICAgIGlmIChib3VuZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lm9yZGVyQnkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXJCeSA9IHRhcmdldC5vcmRlckJ5W2ldO1xyXG4gICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclZhbHVlID0gYm91bmQucG9zaXRpb25baV07XHJcbiAgICAgICAgICAgICAgICBpZiAodXBwZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGN1cnNvclZhbHVlLCBpbmNsdXNpdmU6IGJvdW5kLmluY2x1c2l2ZSB9KSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnNvclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSA9IGJvdW5kLmluY2x1c2l2ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdmFsdWUsIGluY2x1c2l2ZSB9O1xyXG59XHJcbi8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2VnbWVudHMgb2YgYSBwZXJmZWN0IGluZGV4IGZvciB0aGlzIHRhcmdldC4gKi9cclxuZnVuY3Rpb24gdGFyZ2V0R2V0U2VnbWVudENvdW50KHRhcmdldCkge1xyXG4gICAgbGV0IGZpZWxkcyA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICBsZXQgaGFzQXJyYXlTZWdtZW50ID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0YXJnZXQuZmlsdGVycykge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIGZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCkpIHtcclxuICAgICAgICAgICAgLy8gX19uYW1lX18gaXMgbm90IGFuIGV4cGxpY2l0IHNlZ21lbnQgb2YgYW55IGluZGV4LCBzbyB3ZSBkb24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIGNvdW50IGl0LlxyXG4gICAgICAgICAgICBpZiAoc3ViRmlsdGVyLmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZIGZpbHRlcnMgbXVzdCBiZSBjb3VudGVkIHNlcGFyYXRlbHkuXHJcbiAgICAgICAgICAgIC8vIEZvciBpbnN0YW5jZSwgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhbiBpbmRleCBmb3IgXCJhIEFSUkFZIGEgQVNDXCIuIEV2ZW5cclxuICAgICAgICAgICAgLy8gdGhvdWdoIHRoZXNlIGFyZSBvbiB0aGUgc2FtZSBmaWVsZCwgdGhleSBzaG91bGQgYmUgY291bnRlZCBhcyB0d29cclxuICAgICAgICAgICAgLy8gc2VwYXJhdGUgc2VnbWVudHMgaW4gYW4gaW5kZXguXHJcbiAgICAgICAgICAgIGlmIChzdWJGaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fFxyXG4gICAgICAgICAgICAgICAgc3ViRmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xyXG4gICAgICAgICAgICAgICAgaGFzQXJyYXlTZWdtZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IGZpZWxkcy5hZGQoc3ViRmlsdGVyLmZpZWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiB0YXJnZXQub3JkZXJCeSkge1xyXG4gICAgICAgIC8vIF9fbmFtZV9fIGlzIG5vdCBhbiBleHBsaWNpdCBzZWdtZW50IG9mIGFueSBpbmRleCwgc28gd2UgZG9uJ3QgbmVlZCB0b1xyXG4gICAgICAgIC8vIGNvdW50IGl0LlxyXG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgZmllbGRzID0gZmllbGRzLmFkZChvcmRlckJ5LmZpZWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmllbGRzLnNpemUgKyAoaGFzQXJyYXlTZWdtZW50ID8gMSA6IDApO1xyXG59XHJcbmZ1bmN0aW9uIHRhcmdldEhhc0xpbWl0KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldC5saW1pdCAhPT0gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUXVlcnkgZW5jYXBzdWxhdGVzIGFsbCB0aGUgcXVlcnkgYXR0cmlidXRlcyB3ZSBzdXBwb3J0IGluIHRoZSBTREsuIEl0IGNhblxyXG4gKiBiZSBydW4gYWdhaW5zdCB0aGUgTG9jYWxTdG9yZSwgYXMgd2VsbCBhcyBiZSBjb252ZXJ0ZWQgdG8gYSBgVGFyZ2V0YCB0b1xyXG4gKiBxdWVyeSB0aGUgUmVtb3RlU3RvcmUgcmVzdWx0cy5cclxuICpcclxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5SW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGEgUXVlcnkgd2l0aCBhIHBhdGggYW5kIG9wdGlvbmFsIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAgICAgKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBleHBsaWNpdE9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIGxpbWl0VHlwZSA9IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLywgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5leHBsaWNpdE9yZGVyQnkgPSBleHBsaWNpdE9yZGVyQnk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgdGhpcy5saW1pdFR5cGUgPSBsaW1pdFR5cGU7XHJcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcclxuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID0gbnVsbDtcclxuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxyXG4gICAgICAgIC8vIG5vbi1hZ2dyZWdhdGUgcXVlcmllcy5cclxuICAgICAgICB0aGlzLm1lbW9pemVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxyXG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBxdWVyaWVzLiBVbmxpa2UgdGFyZ2V0cyBmb3Igbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLFxyXG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBxdWVyeSB0YXJnZXRzIGRvIG5vdCBjb250YWluIG5vcm1hbGl6ZWQgb3JkZXItYnlzLCB0aGV5IG9ubHlcclxuICAgICAgICAvLyBjb250YWluIGV4cGxpY2l0IG9yZGVyLWJ5cy5cclxuICAgICAgICB0aGlzLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5zdGFydEF0KSA7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kQXQpIDtcclxuICAgIH1cclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBpbnN0YW5jZSB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkLiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIGV4cGxpY2l0T3JkZXJCeSwgZmlsdGVycywgbGltaXQsIGxpbWl0VHlwZSwgc3RhcnRBdCwgZW5kQXQpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgZXhwbGljaXRPcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgbGltaXRUeXBlLCBzdGFydEF0LCBlbmRBdCk7XHJcbn1cclxuLyoqIENyZWF0ZXMgYSBuZXcgUXVlcnkgZm9yIGEgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgYXQgYHBhdGhgICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Rm9yUGF0aChwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IGludG8gYSBjb2xsZWN0aW9uIHF1ZXJ5IGF0IGFcclxuICogc3BlY2lmaWMgcGF0aC4gVGhpcyBpcyB1c2VkIHdoZW4gZXhlY3V0aW5nIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcmllcywgc2luY2VcclxuICogd2UgaGF2ZSB0byBzcGxpdCB0aGUgcXVlcnkgaW50byBhIHNldCBvZiBjb2xsZWN0aW9uIHF1ZXJpZXMgYXQgbXVsdGlwbGVcclxuICogcGF0aHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc0NvbGxlY3Rpb25RdWVyeUF0UGF0aChxdWVyeSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgXHJcbiAgICAvKmNvbGxlY3Rpb25Hcm91cD0qLyBudWxsLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHF1ZXJ5IGRvZXMgbm90IHNwZWNpZnkgYW55IHF1ZXJ5IGNvbnN0cmFpbnRzIHRoYXRcclxuICogY291bGQgcmVtb3ZlIHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpIHtcclxuICAgIHJldHVybiAocXVlcnkuZmlsdGVycy5sZW5ndGggPT09IDAgJiZcclxuICAgICAgICBxdWVyeS5saW1pdCA9PT0gbnVsbCAmJlxyXG4gICAgICAgIHF1ZXJ5LnN0YXJ0QXQgPT0gbnVsbCAmJlxyXG4gICAgICAgIHF1ZXJ5LmVuZEF0ID09IG51bGwgJiZcclxuICAgICAgICAocXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICAgICAocXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgcXVlcnkuZXhwbGljaXRPcmRlckJ5WzBdLmZpZWxkLmlzS2V5RmllbGQoKSkpKTtcclxufVxyXG4vLyBSZXR1cm5zIHRoZSBzb3J0ZWQgc2V0IG9mIGluZXF1YWxpdHkgZmlsdGVyIGZpZWxkcyB1c2VkIGluIHRoaXMgcXVlcnkuXHJcbmZ1bmN0aW9uIGdldEluZXF1YWxpdHlGaWx0ZXJGaWVsZHMocXVlcnkpIHtcclxuICAgIGxldCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xyXG4gICAgcXVlcnkuZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBzdWJGaWx0ZXJzID0gZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKTtcclxuICAgICAgICBzdWJGaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyLmlzSW5lcXVhbGl0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBRdWVyeSBmb3IgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzXHJcbiAqIHdpdGhpbiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBncm91cC5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Rm9yQ29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwoUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpLCBjb2xsZWN0aW9uSWQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgYSBzaW5nbGUgZG9jdW1lbnQgYnkgcGF0aCAocmF0aGVyIHRoYW4gYVxyXG4gKiBjb2xsZWN0aW9uKS5cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRRdWVyeSQxKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocXVlcnkucGF0aCkgJiZcclxuICAgICAgICBxdWVyeS5jb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgJiZcclxuICAgICAgICBxdWVyeS5maWx0ZXJzLmxlbmd0aCA9PT0gMCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcmF0aGVyIHRoYW4gYSBzcGVjaWZpY1xyXG4gKiBjb2xsZWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBvcmRlci1ieSBjb25zdHJhaW50IHRoYXQgaXMgdXNlZCB0byBleGVjdXRlIHRoZSBRdWVyeSxcclxuICogd2hpY2ggY2FuIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmRlci1ieSBjb25zdHJhaW50cyB0aGUgdXNlciBwcm92aWRlZCAoZS5nLlxyXG4gKiB0aGUgU0RLIGFuZCBiYWNrZW5kIGFsd2F5cyBvcmRlcnMgYnkgYF9fbmFtZV9fYCkuIFRoZSBub3JtYWxpemVkIG9yZGVyLWJ5XHJcbiAqIGluY2x1ZGVzIGltcGxpY2l0IG9yZGVyLWJ5cyBpbiBhZGRpdGlvbiB0byB0aGUgZXhwbGljaXQgdXNlciBwcm92aWRlZFxyXG4gKiBvcmRlci1ieXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xyXG4gICAgaWYgKHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPSBbXTtcclxuICAgICAgICBjb25zdCBmaWVsZHNOb3JtYWxpemVkID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vIEFueSBleHBsaWNpdCBvcmRlciBieSBmaWVsZHMgc2hvdWxkIGJlIGFkZGVkIGFzIGlzLlxyXG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gob3JkZXJCeSk7XHJcbiAgICAgICAgICAgIGZpZWxkc05vcm1hbGl6ZWQuYWRkKG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGltcGxpY2l0IG9yZGVyaW5nIGFsd2F5cyBtYXRjaGVzIHRoZSBsYXN0IGV4cGxpY2l0IG9yZGVyIGJ5LlxyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5W3F1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoIC0gMV0uZGlyXHJcbiAgICAgICAgICAgIDogXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xyXG4gICAgICAgIC8vIEFueSBpbmVxdWFsaXR5IGZpZWxkcyBub3QgZXhwbGljaXRseSBvcmRlcmVkIHNob3VsZCBiZSBpbXBsaWNpdGx5IG9yZGVyZWQgaW4gYSBsZXhpY29ncmFwaGljYWxcclxuICAgICAgICAvLyBvcmRlci4gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaW5lcXVhbGl0eSBmaWx0ZXJzIG9uIHRoZSBzYW1lIGZpZWxkLCB0aGUgZmllbGQgc2hvdWxkIGJlIGFkZGVkXHJcbiAgICAgICAgLy8gb25seSBvbmNlLlxyXG4gICAgICAgIC8vIE5vdGU6IGBTb3J0ZWRTZXQ8RmllbGRQYXRoPmAgc29ydHMgdGhlIGtleSBmaWVsZCBiZWZvcmUgb3RoZXIgZmllbGRzLiBIb3dldmVyLCB3ZSB3YW50IHRoZSBrZXlcclxuICAgICAgICAvLyBmaWVsZCB0byBiZSBzb3J0ZWQgbGFzdC5cclxuICAgICAgICBjb25zdCBpbmVxdWFsaXR5RmllbGRzID0gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeUltcGwpO1xyXG4gICAgICAgIGluZXF1YWxpdHlGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZmllbGRzTm9ybWFsaXplZC5oYXMoZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpICYmXHJcbiAgICAgICAgICAgICAgICAhZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeS5wdXNoKG5ldyBPcmRlckJ5KGZpZWxkLCBsYXN0RGlyZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBZGQgdGhlIGRvY3VtZW50IGtleSBmaWVsZCB0byB0aGUgbGFzdCBpZiBpdCBpcyBub3QgZXhwbGljaXRseSBvcmRlcmVkLlxyXG4gICAgICAgIGlmICghZmllbGRzTm9ybWFsaXplZC5oYXMoRmllbGRQYXRoJDEua2V5RmllbGQoKS5jYW5vbmljYWxTdHJpbmcoKSkpIHtcclxuICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLCBsYXN0RGlyZWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5O1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xyXG4gICAgaWYgKCFxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQpIHtcclxuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQgPSBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQ7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSB0byBpdHMgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCByZXByZXNlbnRhdGlvbixcclxuICogZm9yIHVzZSB3aXRoaW4gYW4gYWdncmVnYXRlIHF1ZXJ5LiBVbmxpa2UgdGFyZ2V0cyBmb3Igbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLFxyXG4gKiBhZ2dyZWdhdGUgcXVlcnkgdGFyZ2V0cyBkbyBub3QgY29udGFpbiBub3JtYWxpemVkIG9yZGVyLWJ5cywgdGhleSBvbmx5XHJcbiAqIGNvbnRhaW4gZXhwbGljaXQgb3JkZXItYnlzLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeSkge1xyXG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcclxuICAgIGlmICghcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgaW1wbGljaXQgb3JkZXItYnlzIGZvciBhZ2dyZWdhdGUgcXVlcmllcy5cclxuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQgPSBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgb3JkZXJCeXMpIHtcclxuICAgIGlmIChxdWVyeUltcGwubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pIHtcclxuICAgICAgICByZXR1cm4gbmV3VGFyZ2V0KHF1ZXJ5SW1wbC5wYXRoLCBxdWVyeUltcGwuY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5cywgcXVlcnlJbXBsLmZpbHRlcnMsIHF1ZXJ5SW1wbC5saW1pdCwgcXVlcnlJbXBsLnN0YXJ0QXQsIHF1ZXJ5SW1wbC5lbmRBdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBGbGlwIHRoZSBvcmRlckJ5IGRpcmVjdGlvbnMgc2luY2Ugd2Ugd2FudCB0aGUgbGFzdCByZXN1bHRzXHJcbiAgICAgICAgb3JkZXJCeXMgPSBvcmRlckJ5cy5tYXAob3JkZXJCeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqL1xyXG4gICAgICAgICAgICAgICAgPyBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi9cclxuICAgICAgICAgICAgICAgIDogXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3JkZXJCeShvcmRlckJ5LmZpZWxkLCBkaXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc3dhcCB0aGUgY3Vyc29ycyB0byBtYXRjaCB0aGUgbm93LWZsaXBwZWQgcXVlcnkgb3JkZXJpbmcuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHF1ZXJ5SW1wbC5lbmRBdFxyXG4gICAgICAgICAgICA/IG5ldyBCb3VuZChxdWVyeUltcGwuZW5kQXQucG9zaXRpb24sIHF1ZXJ5SW1wbC5lbmRBdC5pbmNsdXNpdmUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBlbmRBdCA9IHF1ZXJ5SW1wbC5zdGFydEF0XHJcbiAgICAgICAgICAgID8gbmV3IEJvdW5kKHF1ZXJ5SW1wbC5zdGFydEF0LnBvc2l0aW9uLCBxdWVyeUltcGwuc3RhcnRBdC5pbmNsdXNpdmUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAvLyBOb3cgcmV0dXJuIGFzIGEgTGltaXRUeXBlLkZpcnN0IHF1ZXJ5LlxyXG4gICAgICAgIHJldHVybiBuZXdUYXJnZXQocXVlcnlJbXBsLnBhdGgsIHF1ZXJ5SW1wbC5jb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnlzLCBxdWVyeUltcGwuZmlsdGVycywgcXVlcnlJbXBsLmxpbWl0LCBzdGFydEF0LCBlbmRBdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnksIGZpbHRlcikge1xyXG4gICAgY29uc3QgbmV3RmlsdGVycyA9IHF1ZXJ5LmZpbHRlcnMuY29uY2F0KFtmaWx0ZXJdKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIG5ld0ZpbHRlcnMsIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeVdpdGhBZGRlZE9yZGVyQnkocXVlcnksIG9yZGVyQnkpIHtcclxuICAgIC8vIFRPRE8oZGltb25kKTogdmFsaWRhdGUgdGhhdCBvcmRlckJ5IGRvZXMgbm90IGxpc3QgdGhlIHNhbWUga2V5IHR3aWNlLlxyXG4gICAgY29uc3QgbmV3T3JkZXJCeSA9IHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5jb25jYXQoW29yZGVyQnldKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgbmV3T3JkZXJCeSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoTGltaXQocXVlcnksIGxpbWl0LCBsaW1pdFR5cGUpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgbGltaXQsIGxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnksIGJvdW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIGJvdW5kLCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoRW5kQXQocXVlcnksIGJvdW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIGJvdW5kKTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeUVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuICh0YXJnZXRFcXVhbHMocXVlcnlUb1RhcmdldChsZWZ0KSwgcXVlcnlUb1RhcmdldChyaWdodCkpICYmXHJcbiAgICAgICAgbGVmdC5saW1pdFR5cGUgPT09IHJpZ2h0LmxpbWl0VHlwZSk7XHJcbn1cclxuLy8gVE9ETyhiLzI5MTgzMTY1KTogVGhpcyBpcyB1c2VkIHRvIGdldCBhIHVuaXF1ZSBzdHJpbmcgZnJvbSBhIHF1ZXJ5IHRvLCBmb3JcclxuLy8gZXhhbXBsZSwgdXNlIGFzIGEgZGljdGlvbmFyeSBrZXksIGJ1dCB0aGUgaW1wbGVtZW50YXRpb24gaXMgc3ViamVjdCB0b1xyXG4vLyBjb2xsaXNpb25zLiBNYWtlIGl0IGNvbGxpc2lvbi1mcmVlLlxyXG5mdW5jdGlvbiBjYW5vbmlmeVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gYCR7Y2Fub25pZnlUYXJnZXQocXVlcnlUb1RhcmdldChxdWVyeSkpfXxsdDoke3F1ZXJ5LmxpbWl0VHlwZX1gO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gYFF1ZXJ5KHRhcmdldD0ke3N0cmluZ2lmeVRhcmdldChxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSl9OyBsaW1pdFR5cGU9JHtxdWVyeS5saW1pdFR5cGV9KWA7XHJcbn1cclxuLyoqIFJldHVybnMgd2hldGhlciBgZG9jYCBtYXRjaGVzIHRoZSBjb25zdHJhaW50cyBvZiBgcXVlcnlgLiAqL1xyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXMocXVlcnksIGRvYykge1xyXG4gICAgcmV0dXJuIChkb2MuaXNGb3VuZERvY3VtZW50KCkgJiZcclxuICAgICAgICBxdWVyeU1hdGNoZXNQYXRoQW5kQ29sbGVjdGlvbkdyb3VwKHF1ZXJ5LCBkb2MpICYmXHJcbiAgICAgICAgcXVlcnlNYXRjaGVzT3JkZXJCeShxdWVyeSwgZG9jKSAmJlxyXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc0ZpbHRlcnMocXVlcnksIGRvYykgJiZcclxuICAgICAgICBxdWVyeU1hdGNoZXNCb3VuZHMocXVlcnksIGRvYykpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc1BhdGhBbmRDb2xsZWN0aW9uR3JvdXAocXVlcnksIGRvYykge1xyXG4gICAgY29uc3QgZG9jUGF0aCA9IGRvYy5rZXkucGF0aDtcclxuICAgIGlmIChxdWVyeS5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBOT1RFOiB0aGlzLnBhdGggaXMgY3VycmVudGx5IGFsd2F5cyBlbXB0eSBzaW5jZSB3ZSBkb24ndCBleHBvc2UgQ29sbGVjdGlvblxyXG4gICAgICAgIC8vIEdyb3VwIHF1ZXJpZXMgcm9vdGVkIGF0IGEgZG9jdW1lbnQgcGF0aCB5ZXQuXHJcbiAgICAgICAgcmV0dXJuIChkb2Mua2V5Lmhhc0NvbGxlY3Rpb25JZChxdWVyeS5jb2xsZWN0aW9uR3JvdXApICYmXHJcbiAgICAgICAgICAgIHF1ZXJ5LnBhdGguaXNQcmVmaXhPZihkb2NQYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHF1ZXJ5LnBhdGgpKSB7XHJcbiAgICAgICAgLy8gZXhhY3QgbWF0Y2ggZm9yIGRvY3VtZW50IHF1ZXJpZXNcclxuICAgICAgICByZXR1cm4gcXVlcnkucGF0aC5pc0VxdWFsKGRvY1BhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2hhbGxvdyBhbmNlc3RvciBxdWVyaWVzIGJ5IGRlZmF1bHRcclxuICAgICAgICByZXR1cm4gcXVlcnkucGF0aC5pc0ltbWVkaWF0ZVBhcmVudE9mKGRvY1BhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGRvY3VtZW50IG11c3QgaGF2ZSBhIHZhbHVlIGZvciBldmVyeSBvcmRlcmluZyBjbGF1c2UgaW4gb3JkZXIgdG8gc2hvdyB1cFxyXG4gKiBpbiB0aGUgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc09yZGVyQnkocXVlcnksIGRvYykge1xyXG4gICAgLy8gV2UgbXVzdCB1c2UgYHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkoKWAgdG8gZ2V0IHRoZSBsaXN0IG9mIGFsbCBvcmRlckJ5cyAoYm90aCBpbXBsaWNpdCBhbmQgZXhwbGljaXQpLlxyXG4gICAgLy8gTm90ZSB0aGF0IGZvciBPUiBxdWVyaWVzLCBvcmRlckJ5IGFwcGxpZXMgdG8gYWxsIGRpc2p1bmN0aW9uIHRlcm1zIGFuZCBpbXBsaWNpdCBvcmRlckJ5cyBtdXN0XHJcbiAgICAvLyBiZSB0YWtlbiBpbnRvIGFjY291bnQuIEZvciBleGFtcGxlLCB0aGUgcXVlcnkgXCJhID4gMSB8fCBiPT0xXCIgaGFzIGFuIGltcGxpY2l0IFwib3JkZXJCeSBhXCIgZHVlXHJcbiAgICAvLyB0byB0aGUgaW5lcXVhbGl0eSwgYW5kIGlzIGV2YWx1YXRlZCBhcyBcImEgPiAxIG9yZGVyQnkgYSB8fCBiPT0xIG9yZGVyQnkgYVwiLlxyXG4gICAgLy8gQSBkb2N1bWVudCB3aXRoIGNvbnRlbnQgb2Yge2I6MX0gbWF0Y2hlcyB0aGUgZmlsdGVycywgYnV0IGRvZXMgbm90IG1hdGNoIHRoZSBvcmRlckJ5IGJlY2F1c2VcclxuICAgIC8vIGl0J3MgbWlzc2luZyB0aGUgZmllbGQgJ2EnLlxyXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XHJcbiAgICAgICAgLy8gb3JkZXItYnkga2V5IGFsd2F5cyBtYXRjaGVzXHJcbiAgICAgICAgaWYgKCFvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSAmJiBkb2MuZGF0YS5maWVsZChvcmRlckJ5LmZpZWxkKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzRmlsdGVycyhxdWVyeSwgZG9jKSB7XHJcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBxdWVyeS5maWx0ZXJzKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXIubWF0Y2hlcyhkb2MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKiogTWFrZXMgc3VyZSBhIGRvY3VtZW50IGlzIHdpdGhpbiB0aGUgYm91bmRzLCBpZiBwcm92aWRlZC4gKi9cclxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzQm91bmRzKHF1ZXJ5LCBkb2MpIHtcclxuICAgIGlmIChxdWVyeS5zdGFydEF0ICYmXHJcbiAgICAgICAgIWJvdW5kU29ydHNCZWZvcmVEb2N1bWVudChxdWVyeS5zdGFydEF0LCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSwgZG9jKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeS5lbmRBdCAmJlxyXG4gICAgICAgICFib3VuZFNvcnRzQWZ0ZXJEb2N1bWVudChxdWVyeS5lbmRBdCwgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSksIGRvYykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBncm91cCB0aGF0IHRoaXMgcXVlcnkgdGFyZ2V0cy5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgV2ViIFNESyB0byBmYWNpbGl0YXRlIG11bHRpLXRhYlxyXG4gKiBzeW5jaHJvbml6YXRpb24gZm9yIHF1ZXJ5IHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeUNvbGxlY3Rpb25Hcm91cChxdWVyeSkge1xyXG4gICAgcmV0dXJuIChxdWVyeS5jb2xsZWN0aW9uR3JvdXAgfHxcclxuICAgICAgICAocXVlcnkucGF0aC5sZW5ndGggJSAyID09PSAxXHJcbiAgICAgICAgICAgID8gcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpXHJcbiAgICAgICAgICAgIDogcXVlcnkucGF0aC5nZXQocXVlcnkucGF0aC5sZW5ndGggLSAyKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wYXJlIHR3byBkb2N1bWVudHNcclxuICogYmFzZWQgb24gdGhlIFF1ZXJ5J3Mgb3JkZXJpbmcgY29uc3RyYWludC5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Q29tcGFyYXRvcihxdWVyeSkge1xyXG4gICAgcmV0dXJuIChkMSwgZDIpID0+IHtcclxuICAgICAgICBsZXQgY29tcGFyZWRPbktleUZpZWxkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlRG9jcyhvcmRlckJ5LCBkMSwgZDIpO1xyXG4gICAgICAgICAgICBpZiAoY29tcCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcGFyZWRPbktleUZpZWxkID0gY29tcGFyZWRPbktleUZpZWxkIHx8IG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZURvY3Mob3JkZXJCeSwgZDEsIGQyKSB7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKClcclxuICAgICAgICA/IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpXHJcbiAgICAgICAgOiBjb21wYXJlRG9jdW1lbnRzQnlGaWVsZChvcmRlckJ5LmZpZWxkLCBkMSwgZDIpO1xyXG4gICAgc3dpdGNoIChvcmRlckJ5LmRpcikge1xyXG4gICAgICAgIGNhc2UgXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcclxuICAgICAgICBjYXNlIFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovOlxyXG4gICAgICAgICAgICByZXR1cm4gLTEgKiBjb21wYXJpc29uO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgbWFwIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyBvYmplY3RzIGFzIGtleXMuIE9iamVjdHMgbXVzdCBoYXZlIGFuXHJcbiAqIGFzc29jaWF0ZWQgZXF1YWxzIGZ1bmN0aW9uIGFuZCBtdXN0IGJlIGltbXV0YWJsZS4gRW50cmllcyBpbiB0aGUgbWFwIGFyZVxyXG4gKiBzdG9yZWQgdG9nZXRoZXIgd2l0aCB0aGUga2V5IGJlaW5nIHByb2R1Y2VkIGZyb20gdGhlIG1hcEtleUZuLiBUaGlzIG1hcFxyXG4gKiBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgY29sbGlzaW9ucyBvZiBrZXlzLlxyXG4gKi9cclxuY2xhc3MgT2JqZWN0TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcEtleUZuLCBlcXVhbHNGbikge1xyXG4gICAgICAgIHRoaXMubWFwS2V5Rm4gPSBtYXBLZXlGbjtcclxuICAgICAgICB0aGlzLmVxdWFsc0ZuID0gZXF1YWxzRm47XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGlubmVyIG1hcCBmb3IgYSBrZXkvdmFsdWUgcGFpci4gRHVlIHRvIHRoZSBwb3NzaWJpbGl0eSBvZiBjb2xsaXNpb25zIHdlXHJcbiAgICAgICAgICoga2VlcCBhIGxpc3Qgb2YgZW50cmllcyB0aGF0IHdlIGRvIGEgbGluZWFyIHNlYXJjaCB0aHJvdWdoIHRvIGZpbmQgYW4gYWN0dWFsXHJcbiAgICAgICAgICogbWF0Y2guIE5vdGUgdGhhdCBjb2xsaXNpb25zIHNob3VsZCBiZSByYXJlLCBzbyB3ZSBzdGlsbCBleHBlY3QgbmVhclxyXG4gICAgICAgICAqIGNvbnN0YW50IHRpbWUgbG9va3VwcyBpbiBwcmFjdGljZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlubmVyID0ge307XHJcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgZW50cmllcyBzdG9yZWQgaW4gdGhlIG1hcCAqL1xyXG4gICAgICAgIHRoaXMuaW5uZXJTaXplID0gMDtcclxuICAgIH1cclxuICAgIC8qKiBHZXQgYSB2YWx1ZSBmb3IgdGhpcyBrZXksIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBleGlzdC4gKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5pbm5lcltpZF07XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IFtvdGhlcktleSwgdmFsdWVdIG9mIG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRm4ob3RoZXJLZXksIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgaGFzKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKiogUHV0IHRoaXMga2V5IGFuZCB2YWx1ZSBpbiB0aGUgbWFwLiAqL1xyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5pbm5lcltpZF07XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyW2lkXSA9IFtba2V5LCB2YWx1ZV1dO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyU2l6ZSsrO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihtYXRjaGVzW2ldWzBdLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGVudHJ5IGFuZCBkb2VzIG5vdCBpbmNyZWFzZSBgaW5uZXJTaXplYC5cclxuICAgICAgICAgICAgICAgIG1hdGNoZXNbaV0gPSBba2V5LCB2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgdGhpcy5pbm5lclNpemUrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoaXMga2V5IGZyb20gdGhlIG1hcC4gUmV0dXJucyBhIGJvb2xlYW4gaWYgYW55dGhpbmcgd2FzIGRlbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5pbm5lcltpZF07XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihtYXRjaGVzW2ldWzBdLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbm5lcltpZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJTaXplLS07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGZuKSB7XHJcbiAgICAgICAgZm9yRWFjaCh0aGlzLmlubmVyLCAoXywgZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmbihrLCB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmlubmVyKTtcclxuICAgIH1cclxuICAgIHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJTaXplO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuZnVuY3Rpb24gbXV0YWJsZURvY3VtZW50TWFwKCkge1xyXG4gICAgcmV0dXJuIEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQO1xyXG59XHJcbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX01BUCA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbmZ1bmN0aW9uIGRvY3VtZW50TWFwKC4uLmRvY3MpIHtcclxuICAgIGxldCBtYXAgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XHJcbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XHJcbiAgICAgICAgbWFwID0gbWFwLmluc2VydChkb2Mua2V5LCBkb2MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcDtcclxufVxyXG5mdW5jdGlvbiBuZXdPdmVybGF5ZWREb2N1bWVudE1hcCgpIHtcclxuICAgIHJldHVybiBuZXdEb2N1bWVudEtleU1hcCgpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAoY29sbGVjdGlvbikge1xyXG4gICAgbGV0IGRvY3VtZW50cyA9IEVNUFRZX0RPQ1VNRU5UX01BUDtcclxuICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgoaywgdikgPT4gKGRvY3VtZW50cyA9IGRvY3VtZW50cy5pbnNlcnQoaywgdi5vdmVybGF5ZWREb2N1bWVudCkpKTtcclxuICAgIHJldHVybiBkb2N1bWVudHM7XHJcbn1cclxuZnVuY3Rpb24gbmV3T3ZlcmxheU1hcCgpIHtcclxuICAgIHJldHVybiBuZXdEb2N1bWVudEtleU1hcCgpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld011dGF0aW9uTWFwKCkge1xyXG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XHJcbn1cclxuZnVuY3Rpb24gbmV3RG9jdW1lbnRLZXlNYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xyXG59XHJcbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX1ZFUlNJT05fTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuZnVuY3Rpb24gZG9jdW1lbnRWZXJzaW9uTWFwKCkge1xyXG4gICAgcmV0dXJuIEVNUFRZX0RPQ1VNRU5UX1ZFUlNJT05fTUFQO1xyXG59XHJcbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX0tFWV9TRVQgPSBuZXcgU29ydGVkU2V0KERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG5mdW5jdGlvbiBkb2N1bWVudEtleVNldCguLi5rZXlzKSB7XHJcbiAgICBsZXQgc2V0ID0gRU1QVFlfRE9DVU1FTlRfS0VZX1NFVDtcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICBzZXQgPSBzZXQuYWRkKGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2V0O1xyXG59XHJcbmNvbnN0IEVNUFRZX1RBUkdFVF9JRF9TRVQgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG5mdW5jdGlvbiB0YXJnZXRJZFNldCgpIHtcclxuICAgIHJldHVybiBFTVBUWV9UQVJHRVRfSURfU0VUO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIERvdWJsZVZhbHVlIGZvciBgdmFsdWVgIHRoYXQgaXMgZW5jb2RlZCBiYXNlZCB0aGUgc2VyaWFsaXplcidzXHJcbiAqIGB1c2VQcm90bzNKc29uYCBzZXR0aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9Eb3VibGUoc2VyaWFsaXplciwgdmFsdWUpIHtcclxuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnTmFOJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICdJbmZpbml0eScgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJy1JbmZpbml0eScgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogaXNOZWdhdGl2ZVplcm8odmFsdWUpID8gJy0wJyA6IHZhbHVlIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSW50ZWdlclZhbHVlIGZvciBgdmFsdWVgLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4geyBpbnRlZ2VyVmFsdWU6ICcnICsgdmFsdWUgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbHVlIGZvciBhIG51bWJlciB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG8gYSBwcm90by5cclxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBJbnRlZ2VyVmFsdWUgaWYgaXQgY2FuIHNhZmVseSByZXByZXNlbnQgdGhlIHZhbHVlLFxyXG4gKiBvdGhlcndpc2UgYSBEb3VibGVWYWx1ZSBpcyByZXR1cm5lZC5cclxuICovXHJcbmZ1bmN0aW9uIHRvTnVtYmVyKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNTYWZlSW50ZWdlcih2YWx1ZSkgPyB0b0ludGVnZXIodmFsdWUpIDogdG9Eb3VibGUoc2VyaWFsaXplciwgdmFsdWUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBVc2VkIHRvIHJlcHJlc2VudCBhIGZpZWxkIHRyYW5zZm9ybSBvbiBhIG11dGF0aW9uLiAqL1xyXG5jbGFzcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHN0cnVjdHVyYWwgdHlwZSBvZiBgVHJhbnNmb3JtT3BlcmF0aW9uYCBpcyB1bmlxdWUuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNTQ1MVxyXG4gICAgICAgIHRoaXMuXyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGxvY2FsIHRyYW5zZm9ybSByZXN1bHQgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYHByZXZpb3VzVmFsdWVgLFxyXG4gKiBvcHRpb25hbGx5IHVzaW5nIHRoZSBwcm92aWRlZCBsb2NhbFdyaXRlVGltZS5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlLCBsb2NhbFdyaXRlVGltZSkge1xyXG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xyXG4gICAgICAgIHJldHVybiBzZXJ2ZXJUaW1lc3RhbXAkMShsb2NhbFdyaXRlVGltZSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gYXBwbHlBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5TnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGEgZmluYWwgdHJhbnNmb3JtIHJlc3VsdCBhZnRlciB0aGUgdHJhbnNmb3JtIGhhcyBiZWVuIGFja25vd2xlZGdlZFxyXG4gKiBieSB0aGUgc2VydmVyLCBwb3RlbnRpYWxseSB1c2luZyB0aGUgc2VydmVyLXByb3ZpZGVkIHRyYW5zZm9ybVJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9SZW1vdGVEb2N1bWVudCh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIHRyYW5zZm9ybVJlc3VsdCkge1xyXG4gICAgLy8gVGhlIHNlcnZlciBqdXN0IHNlbmRzIG51bGwgYXMgdGhlIHRyYW5zZm9ybSByZXN1bHQgZm9yIGFycmF5IG9wZXJhdGlvbnMsXHJcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGNhbGN1bGF0ZSBhIHJlc3VsdCB0aGUgc2FtZSBhcyB3ZSBkbyBmb3IgbG9jYWxcclxuICAgIC8vIGFwcGxpY2F0aW9ucy5cclxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gYXBwbHlBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdDtcclxufVxyXG4vKipcclxuICogSWYgdGhpcyB0cmFuc2Zvcm0gb3BlcmF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvXHJcbiAqIHBlcnNpc3QgZm9yIHRoaXMgdHJhbnNmb3JtLiBJZiBhIGJhc2UgdmFsdWUgaXMgcmV0dXJuZWQsIHRoZSB0cmFuc2Zvcm1cclxuICogb3BlcmF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIHRvIHRoaXMgYmFzZSB2YWx1ZSwgZXZlbiBpZiBkb2N1bWVudCBoYXNcclxuICogYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXHJcbiAqXHJcbiAqIEJhc2UgdmFsdWVzIHByb3ZpZGUgY29uc2lzdGVudCBiZWhhdmlvciBmb3Igbm9uLWlkZW1wb3RlbnQgdHJhbnNmb3JtcyBhbmRcclxuICogYWxsb3cgdXMgdG8gcmV0dXJuIHRoZSBzYW1lIGxhdGVuY3ktY29tcGVuc2F0ZWQgdmFsdWUgZXZlbiBpZiB0aGUgYmFja2VuZFxyXG4gKiBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZSB0cmFuc2Zvcm0gb3BlcmF0aW9uLiBUaGUgYmFzZSB2YWx1ZSBpcyBudWxsIGZvclxyXG4gKiBpZGVtcG90ZW50IHRyYW5zZm9ybXMsIGFzIHRoZXkgY2FuIGJlIHJlLXBsYXllZCBldmVuIGlmIHRoZSBiYWNrZW5kIGhhc1xyXG4gKiBhbHJlYWR5IGFwcGxpZWQgdGhlbS5cclxuICpcclxuICogQHJldHVybnMgYSBiYXNlIHZhbHVlIHRvIHN0b3JlIGFsb25nIHdpdGggdGhlIG11dGF0aW9uLCBvciBudWxsIGZvclxyXG4gKiBpZGVtcG90ZW50IHRyYW5zZm9ybXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xyXG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gaXNOdW1iZXIocHJldmlvdXNWYWx1ZSkgPyBwcmV2aW91c1ZhbHVlIDogeyBpbnRlZ2VyVmFsdWU6IDAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbkVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uICYmXHJcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuZWxlbWVudHMsIHJpZ2h0LmVsZW1lbnRzLCB2YWx1ZUVxdWFscyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0IGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24gJiZcclxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuZWxlbWVudHMsIHJpZ2h0LmVsZW1lbnRzLCB2YWx1ZUVxdWFscyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0IGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbiAmJlxyXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZUVxdWFscyhsZWZ0Lm9wZXJhbmQsIHJpZ2h0Lm9wZXJhbmQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtICYmXHJcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pO1xyXG59XHJcbi8qKiBUcmFuc2Zvcm1zIGEgdmFsdWUgaW50byBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wLiAqL1xyXG5jbGFzcyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG59XHJcbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHVuaW9uIG9wZXJhdGlvbi4gKi9cclxuY2xhc3MgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbiBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5QXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpIHtcclxuICAgIGNvbnN0IHZhbHVlcyA9IGNvZXJjZWRGaWVsZFZhbHVlc0FycmF5KHByZXZpb3VzVmFsdWUpO1xyXG4gICAgZm9yIChjb25zdCB0b1VuaW9uIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xyXG4gICAgICAgIGlmICghdmFsdWVzLnNvbWUoZWxlbWVudCA9PiB2YWx1ZUVxdWFscyhlbGVtZW50LCB0b1VuaW9uKSkpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2godG9Vbmlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXMgfSB9O1xyXG59XHJcbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHJlbW92ZSBvcGVyYXRpb24uICovXHJcbmNsYXNzIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpIHtcclxuICAgIGxldCB2YWx1ZXMgPSBjb2VyY2VkRmllbGRWYWx1ZXNBcnJheShwcmV2aW91c1ZhbHVlKTtcclxuICAgIGZvciAoY29uc3QgdG9SZW1vdmUgb2YgdHJhbnNmb3JtLmVsZW1lbnRzKSB7XHJcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcihlbGVtZW50ID0+ICF2YWx1ZUVxdWFscyhlbGVtZW50LCB0b1JlbW92ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXMgfSB9O1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBiYWNrZW5kIHNlbWFudGljcyBmb3IgbG9jYWxseSBjb21wdXRlZCBOVU1FUklDX0FERCAoaW5jcmVtZW50KVxyXG4gKiB0cmFuc2Zvcm1zLiBDb252ZXJ0cyBhbGwgZmllbGQgdmFsdWVzIHRvIGludGVnZXJzIG9yIGRvdWJsZXMsIGJ1dCB1bmxpa2UgdGhlXHJcbiAqIGJhY2tlbmQgZG9lcyBub3QgY2FwIGludGVnZXIgdmFsdWVzIGF0IDJeNjMuIEluc3RlYWQsIEphdmFTY3JpcHQgbnVtYmVyXHJcbiAqIGFyaXRobWV0aWMgaXMgdXNlZCBhbmQgcHJlY2lzaW9uIGxvc3MgY2FuIG9jY3VyIGZvciB2YWx1ZXMgZ3JlYXRlciB0aGFuIDJeNTMuXHJcbiAqL1xyXG5jbGFzcyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIsIG9wZXJhbmQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy5vcGVyYW5kID0gb3BlcmFuZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseU51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpIHtcclxuICAgIC8vIFBPUlRJTkcgTk9URTogU2luY2UgSmF2YVNjcmlwdCdzIGludGVnZXIgYXJpdGhtZXRpYyBpcyBsaW1pdGVkIHRvIDUzIGJpdFxyXG4gICAgLy8gcHJlY2lzaW9uIGFuZCByZXNvbHZlcyBvdmVyZmxvd3MgYnkgcmVkdWNpbmcgcHJlY2lzaW9uLCB3ZSBkbyBub3RcclxuICAgIC8vIG1hbnVhbGx5IGNhcCBvdmVyZmxvd3MgYXQgMl42My5cclxuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIGNvbnN0IHN1bSA9IGFzTnVtYmVyKGJhc2VWYWx1ZSkgKyBhc051bWJlcih0cmFuc2Zvcm0ub3BlcmFuZCk7XHJcbiAgICBpZiAoaXNJbnRlZ2VyKGJhc2VWYWx1ZSkgJiYgaXNJbnRlZ2VyKHRyYW5zZm9ybS5vcGVyYW5kKSkge1xyXG4gICAgICAgIHJldHVybiB0b0ludGVnZXIoc3VtKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0b0RvdWJsZSh0cmFuc2Zvcm0uc2VyaWFsaXplciwgc3VtKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNvZXJjZWRGaWVsZFZhbHVlc0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXNcclxuICAgICAgICA/IHZhbHVlLmFycmF5VmFsdWUudmFsdWVzLnNsaWNlKClcclxuICAgICAgICA6IFtdO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBBIGZpZWxkIHBhdGggYW5kIHRoZSBUcmFuc2Zvcm1PcGVyYXRpb24gdG8gcGVyZm9ybSB1cG9uIGl0LiAqL1xyXG5jbGFzcyBGaWVsZFRyYW5zZm9ybSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpZWxkVHJhbnNmb3JtRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gKGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCkgJiZcclxuICAgICAgICB0cmFuc2Zvcm1PcGVyYXRpb25FcXVhbHMobGVmdC50cmFuc2Zvcm0sIHJpZ2h0LnRyYW5zZm9ybSkpO1xyXG59XHJcbmZ1bmN0aW9uIGZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQsIHJpZ2h0LCAobCwgcikgPT4gZmllbGRUcmFuc2Zvcm1FcXVhbHMobCwgcikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKiBUaGUgcmVzdWx0IG9mIHN1Y2Nlc3NmdWxseSBhcHBseWluZyBhIG11dGF0aW9uIHRvIHRoZSBiYWNrZW5kLiAqL1xyXG5jbGFzcyBNdXRhdGlvblJlc3VsdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZlcnNpb24gYXQgd2hpY2ggdGhlIG11dGF0aW9uIHdhcyBjb21taXR0ZWQ6XHJcbiAgICAgKlxyXG4gICAgICogLSBGb3IgbW9zdCBvcGVyYXRpb25zLCB0aGlzIGlzIHRoZSB1cGRhdGVUaW1lIGluIHRoZSBXcml0ZVJlc3VsdC5cclxuICAgICAqIC0gRm9yIGRlbGV0ZXMsIHRoZSBjb21taXRUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIChiZWNhdXNlIGRlbGV0ZXMgYXJlXHJcbiAgICAgKiAgIG5vdCBzdG9yZWQgYW5kIGhhdmUgbm8gdXBkYXRlVGltZSkuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHRoZXNlIHZlcnNpb25zIGNhbiBiZSBkaWZmZXJlbnQ6IE5vLW9wIHdyaXRlcyB3aWxsIG5vdCBjaGFuZ2VcclxuICAgICAqIHRoZSB1cGRhdGVUaW1lIGV2ZW4gdGhvdWdoIHRoZSBjb21taXRUaW1lIGFkdmFuY2VzLlxyXG4gICAgICovXHJcbiAgICB2ZXJzaW9uLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlc3VsdGluZyBmaWVsZHMgcmV0dXJuZWQgZnJvbSB0aGUgYmFja2VuZCBhZnRlciBhIG11dGF0aW9uXHJcbiAgICAgKiBjb250YWluaW5nIGZpZWxkIHRyYW5zZm9ybXMgaGFzIGJlZW4gY29tbWl0dGVkLiBDb250YWlucyBvbmUgRmllbGRWYWx1ZVxyXG4gICAgICogZm9yIGVhY2ggRmllbGRUcmFuc2Zvcm0gdGhhdCB3YXMgaW4gdGhlIG11dGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFdpbGwgYmUgZW1wdHkgaWYgdGhlIG11dGF0aW9uIGRpZCBub3QgY29udGFpbiBhbnkgZmllbGQgdHJhbnNmb3Jtcy5cclxuICAgICAqL1xyXG4gICAgdHJhbnNmb3JtUmVzdWx0cykge1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHRzID0gdHJhbnNmb3JtUmVzdWx0cztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRW5jb2RlcyBhIHByZWNvbmRpdGlvbiBmb3IgYSBtdXRhdGlvbi4gVGhpcyBmb2xsb3dzIHRoZSBtb2RlbCB0aGF0IHRoZVxyXG4gKiBiYWNrZW5kIGFjY2VwdHMgd2l0aCB0aGUgc3BlY2lhbCBjYXNlIG9mIGFuIGV4cGxpY2l0IFwiZW1wdHlcIiBwcmVjb25kaXRpb25cclxuICogKG1lYW5pbmcgbm8gcHJlY29uZGl0aW9uKS5cclxuICovXHJcbmNsYXNzIFByZWNvbmRpdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cGRhdGVUaW1lLCBleGlzdHMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSB1cGRhdGVUaW1lO1xyXG4gICAgICAgIHRoaXMuZXhpc3RzID0gZXhpc3RzO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZW1wdHkgUHJlY29uZGl0aW9uLiAqL1xyXG4gICAgc3RhdGljIG5vbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiB3aXRoIGFuIGV4aXN0cyBmbGFnLiAqL1xyXG4gICAgc3RhdGljIGV4aXN0cyhleGlzdHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih1bmRlZmluZWQsIGV4aXN0cyk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBQcmVjb25kaXRpb24gYmFzZWQgb24gYSB2ZXJzaW9uIGEgZG9jdW1lbnQgZXhpc3RzIGF0LiAqL1xyXG4gICAgc3RhdGljIHVwZGF0ZVRpbWUodmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlY29uZGl0aW9uKHZlcnNpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGlzIFByZWNvbmRpdGlvbiBpcyBlbXB0eS4gKi9cclxuICAgIGdldCBpc05vbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVGltZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZXhpc3RzID09PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmV4aXN0cyA9PT0gb3RoZXIuZXhpc3RzICYmXHJcbiAgICAgICAgICAgICh0aGlzLnVwZGF0ZVRpbWVcclxuICAgICAgICAgICAgICAgID8gISFvdGhlci51cGRhdGVUaW1lICYmIHRoaXMudXBkYXRlVGltZS5pc0VxdWFsKG90aGVyLnVwZGF0ZVRpbWUpXHJcbiAgICAgICAgICAgICAgICA6ICFvdGhlci51cGRhdGVUaW1lKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlY29uZGl0aW9ucyBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xyXG5mdW5jdGlvbiBwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQocHJlY29uZGl0aW9uLCBkb2N1bWVudCkge1xyXG4gICAgaWYgKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpICYmXHJcbiAgICAgICAgICAgIGRvY3VtZW50LnZlcnNpb24uaXNFcXVhbChwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZWNvbmRpdGlvbi5leGlzdHMgPT09IGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgbXV0YXRpb24gZGVzY3JpYmVzIGEgc2VsZi1jb250YWluZWQgY2hhbmdlIHRvIGEgZG9jdW1lbnQuIE11dGF0aW9ucyBjYW5cclxuICogY3JlYXRlLCByZXBsYWNlLCBkZWxldGUsIGFuZCB1cGRhdGUgc3Vic2V0cyBvZiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIE11dGF0aW9ucyBub3Qgb25seSBhY3Qgb24gdGhlIHZhbHVlIG9mIHRoZSBkb2N1bWVudCBidXQgYWxzbyBpdHMgdmVyc2lvbi5cclxuICpcclxuICogRm9yIGxvY2FsIG11dGF0aW9ucyAobXV0YXRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGNvbW1pdHRlZCB5ZXQpLCB3ZSBwcmVzZXJ2ZVxyXG4gKiB0aGUgZXhpc3RpbmcgdmVyc2lvbiBmb3IgU2V0IGFuZCBQYXRjaCBtdXRhdGlvbnMuIEZvciBEZWxldGUgbXV0YXRpb25zLCB3ZVxyXG4gKiByZXNldCB0aGUgdmVyc2lvbiB0byAwLlxyXG4gKlxyXG4gKiBIZXJlJ3MgdGhlIGV4cGVjdGVkIHRyYW5zaXRpb24gdGFibGUuXHJcbiAqXHJcbiAqIE1VVEFUSU9OICAgICAgICAgICBBUFBMSUVEIFRPICAgICAgICAgICAgUkVTVUxUUyBJTlxyXG4gKlxyXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgRG9jdW1lbnQodjMpICAgICAgICAgIERvY3VtZW50KHYzKVxyXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIERvY3VtZW50KHYwKVxyXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIERvY3VtZW50KHYwKVxyXG4gKiBQYXRjaE11dGF0aW9uICAgICAgRG9jdW1lbnQodjMpICAgICAgICAgIERvY3VtZW50KHYzKVxyXG4gKiBQYXRjaE11dGF0aW9uICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIE5vRG9jdW1lbnQodjMpXHJcbiAqIFBhdGNoTXV0YXRpb24gICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgVW5rbm93bkRvY3VtZW50KHYzKVxyXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgRG9jdW1lbnQodjMpICAgICAgICAgIE5vRG9jdW1lbnQodjApXHJcbiAqIERlbGV0ZU11dGF0aW9uICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MClcclxuICogRGVsZXRlTXV0YXRpb24gICAgIEludmFsaWREb2N1bWVudCh2MCkgICBOb0RvY3VtZW50KHYwKVxyXG4gKlxyXG4gKiBGb3IgYWNrbm93bGVkZ2VkIG11dGF0aW9ucywgd2UgdXNlIHRoZSB1cGRhdGVUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIGFzXHJcbiAqIHRoZSByZXN1bHRpbmcgdmVyc2lvbiBmb3IgU2V0IGFuZCBQYXRjaCBtdXRhdGlvbnMuIEFzIGRlbGV0ZXMgaGF2ZSBub1xyXG4gKiBleHBsaWNpdCB1cGRhdGUgdGltZSwgd2UgdXNlIHRoZSBjb21taXRUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIGZvclxyXG4gKiBEZWxldGUgbXV0YXRpb25zLlxyXG4gKlxyXG4gKiBJZiBhIG11dGF0aW9uIGlzIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZCBidXQgZmFpbHMgdGhlIHByZWNvbmRpdGlvbiBjaGVja1xyXG4gKiBsb2NhbGx5LCB3ZSB0cmFuc2l0aW9uIHRvIGFuIGBVbmtub3duRG9jdW1lbnRgIGFuZCByZWx5IG9uIFdhdGNoIHRvIHNlbmQgdXNcclxuICogdGhlIHVwZGF0ZWQgdmVyc2lvbi5cclxuICpcclxuICogRmllbGQgdHJhbnNmb3JtcyBhcmUgdXNlZCBvbmx5IHdpdGggUGF0Y2ggYW5kIFNldCBNdXRhdGlvbnMuIFdlIHVzZSB0aGVcclxuICogYHVwZGF0ZVRyYW5zZm9ybXNgIG1lc3NhZ2UgdG8gc3RvcmUgdHJhbnNmb3JtcywgcmF0aGVyIHRoYW4gdGhlIGB0cmFuc2Zvcm1zYHNcclxuICogbWVzc2FnZXMuXHJcbiAqXHJcbiAqICMjIFN1YmNsYXNzaW5nIE5vdGVzXHJcbiAqXHJcbiAqIEV2ZXJ5IHR5cGUgb2YgbXV0YXRpb24gbmVlZHMgdG8gaW1wbGVtZW50IGl0cyBvd24gYXBwbHlUb1JlbW90ZURvY3VtZW50KCkgYW5kXHJcbiAqIGFwcGx5VG9Mb2NhbFZpZXcoKSB0byBpbXBsZW1lbnQgdGhlIGFjdHVhbCBiZWhhdmlvciBvZiBhcHBseWluZyB0aGUgbXV0YXRpb25cclxuICogdG8gc29tZSBzb3VyY2UgZG9jdW1lbnQgKHNlZSBgc2V0TXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQoKWAgZm9yIGFuXHJcbiAqIGV4YW1wbGUpLlxyXG4gKi9cclxuY2xhc3MgTXV0YXRpb24ge1xyXG59XHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgbWV0aG9kIHRvIGNhbGN1bGF0ZSBhIGBNdXRhdGlvbmAgcmVwcmVzZW50aW5nIHRoZSBvdmVybGF5IGZyb20gdGhlXHJcbiAqIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgYW5kIGEgYEZpZWxkTWFza2AgcmVwcmVzZW50aW5nIHRoZSBmaWVsZHMgdGhhdFxyXG4gKiBhcmUgbXV0YXRlZCBieSB0aGUgbG9jYWwgbXV0YXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKGRvYywgbWFzaykge1xyXG4gICAgaWYgKCFkb2MuaGFzTG9jYWxNdXRhdGlvbnMgfHwgKG1hc2sgJiYgbWFzay5maWVsZHMubGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gbWFzayBpcyBudWxsIHdoZW4gc2V0cyBvciBkZWxldGVzIGFyZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50LlxyXG4gICAgaWYgKG1hc2sgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVsZXRlTXV0YXRpb24oZG9jLmtleSwgUHJlY29uZGl0aW9uLm5vbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldE11dGF0aW9uKGRvYy5rZXksIGRvYy5kYXRhLCBQcmVjb25kaXRpb24ubm9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBkb2NWYWx1ZSA9IGRvYy5kYXRhO1xyXG4gICAgICAgIGNvbnN0IHBhdGNoVmFsdWUgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xyXG4gICAgICAgIGxldCBtYXNrU2V0ID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIG1hc2suZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGlmICghbWFza1NldC5oYXMocGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRvY1ZhbHVlLmZpZWxkKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGRlbGV0aW5nIGEgbmVzdGVkIGZpZWxkLCB3ZSB0YWtlIHRoZSBpbW1lZGlhdGUgcGFyZW50IGFzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzayB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcmVzdWx0aW5nIG11dGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gSnVzdGlmaWNhdGlvbjogTmVzdGVkIGZpZWxkcyBjYW4gY3JlYXRlIHBhcmVudCBmaWVsZHMgaW1wbGljaXRseS4gSWZcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYSBsZWFmIGVudHJ5IGlzIGRlbGV0ZWQgaW4gbGF0ZXIgbXV0YXRpb25zLCB0aGUgcGFyZW50IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3RpbGwgcmVtYWluLCBidXQgd2UgbWF5IGhhdmUgbG9zdCB0aGlzIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbXV0YXRpb24gKGZvby5iYXIgMSksIHRoZW4gbXV0YXRpb24gKGZvby5iYXIgZGVsZXRlKCkpLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBsZWF2ZXMgdGhlIGZpbmFsIHJlc3VsdCAoZm9vLCB7fSkuIERlc3BpdGUgdGhlIGZhY3QgdGhhdCBgZG9jYFxyXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRoZSBjb3JyZWN0IHJlc3VsdCwgYGZvb2AgaXMgbm90IGluIGBtYXNrYCwgYW5kIHRoZSByZXN1bHRpbmdcclxuICAgICAgICAgICAgICAgIC8vIG11dGF0aW9uIHdvdWxkIG1pc3MgYGZvb2AuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgcGF0aC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZG9jVmFsdWUuZmllbGQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFZhbHVlLmRlbGV0ZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoVmFsdWUuc2V0KHBhdGgsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hc2tTZXQgPSBtYXNrU2V0LmFkZChwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oZG9jLmtleSwgcGF0Y2hWYWx1ZSwgbmV3IEZpZWxkTWFzayhtYXNrU2V0LnRvQXJyYXkoKSksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoaXMgbXV0YXRpb24gdG8gdGhlIGdpdmVuIGRvY3VtZW50IGZvciB0aGUgcHVycG9zZXMgb2YgY29tcHV0aW5nIGFcclxuICogbmV3IHJlbW90ZSBkb2N1bWVudC4gSWYgdGhlIGlucHV0IGRvY3VtZW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHN0YXRlXHJcbiAqIChlLmcuIGl0IGlzIGludmFsaWQgb3Igb3V0ZGF0ZWQpLCB0aGUgZG9jdW1lbnQgdHlwZSBtYXkgdHJhbnNpdGlvbiB0b1xyXG4gKiB1bmtub3duLlxyXG4gKlxyXG4gKiBAcGFyYW0gbXV0YXRpb24gLSBUaGUgbXV0YXRpb24gdG8gYXBwbHkuXHJcbiAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBtdXRhdGUuIFRoZSBpbnB1dCBkb2N1bWVudCBjYW4gYmUgYW5cclxuICogICAgIGludmFsaWQgZG9jdW1lbnQgaWYgdGhlIGNsaWVudCBoYXMgbm8ga25vd2xlZGdlIG9mIHRoZSBwcmUtbXV0YXRpb24gc3RhdGVcclxuICogICAgIG9mIHRoZSBkb2N1bWVudC5cclxuICogQHBhcmFtIG11dGF0aW9uUmVzdWx0IC0gVGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgbXV0YXRpb24gZnJvbSB0aGUgYmFja2VuZC5cclxuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcclxuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XHJcbiAgICAgICAgc2V0TXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFBhdGNoTXV0YXRpb24pIHtcclxuICAgICAgICBwYXRjaE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVsZXRlTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhpcyBtdXRhdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wdXRpbmdcclxuICogdGhlIG5ldyBsb2NhbCB2aWV3IG9mIGEgZG9jdW1lbnQuIElmIHRoZSBpbnB1dCBkb2N1bWVudCBkb2Vzbid0IG1hdGNoIHRoZVxyXG4gKiBleHBlY3RlZCBzdGF0ZSwgdGhlIGRvY3VtZW50IGlzIG5vdCBtb2RpZmllZC5cclxuICpcclxuICogQHBhcmFtIG11dGF0aW9uIC0gVGhlIG11dGF0aW9uIHRvIGFwcGx5LlxyXG4gKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gbXV0YXRlLiBUaGUgaW5wdXQgZG9jdW1lbnQgY2FuIGJlIGFuXHJcbiAqICAgICBpbnZhbGlkIGRvY3VtZW50IGlmIHRoZSBjbGllbnQgaGFzIG5vIGtub3dsZWRnZSBvZiB0aGUgcHJlLW11dGF0aW9uIHN0YXRlXHJcbiAqICAgICBvZiB0aGUgZG9jdW1lbnQuXHJcbiAqIEBwYXJhbSBwcmV2aW91c01hc2sgLSBUaGUgZmllbGRzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgYmVmb3JlIGFwcGx5aW5nIHRoaXMgbXV0YXRpb24uXHJcbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIEEgdGltZXN0YW1wIGluZGljYXRpbmcgdGhlIGxvY2FsIHdyaXRlIHRpbWUgb2YgdGhlXHJcbiAqICAgICBiYXRjaCB0aGlzIG11dGF0aW9uIGlzIGEgcGFydCBvZi5cclxuICogQHJldHVybnMgQSBgRmllbGRNYXNrYCByZXByZXNlbnRpbmcgdGhlIGZpZWxkcyB0aGF0IGFyZSBjaGFuZ2VkIGJ5IGFwcGx5aW5nIHRoaXMgbXV0YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKSB7XHJcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzayk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIElmIHRoaXMgbXV0YXRpb24gaXMgbm90IGlkZW1wb3RlbnQsIHJldHVybnMgdGhlIGJhc2UgdmFsdWUgdG8gcGVyc2lzdCB3aXRoXHJcbiAqIHRoaXMgbXV0YXRpb24uIElmIGEgYmFzZSB2YWx1ZSBpcyByZXR1cm5lZCwgdGhlIG11dGF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkXHJcbiAqIHRvIHRoaXMgYmFzZSB2YWx1ZSwgZXZlbiBpZiBkb2N1bWVudCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXHJcbiAqXHJcbiAqIFRoZSBiYXNlIHZhbHVlIGlzIGEgc3BhcnNlIG9iamVjdCB0aGF0IGNvbnNpc3RzIG9mIG9ubHkgdGhlIGRvY3VtZW50XHJcbiAqIGZpZWxkcyBmb3Igd2hpY2ggdGhpcyBtdXRhdGlvbiBjb250YWlucyBhIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybWF0aW9uXHJcbiAqIChlLmcuIGEgbnVtZXJpYyBpbmNyZW1lbnQpLiBUaGUgcHJvdmlkZWQgdmFsdWUgZ3VhcmFudGVlcyBjb25zaXN0ZW50XHJcbiAqIGJlaGF2aW9yIGZvciBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGFuZCBhbGxvdyB1cyB0byByZXR1cm4gdGhlIHNhbWVcclxuICogbGF0ZW5jeS1jb21wZW5zYXRlZCB2YWx1ZSBldmVuIGlmIHRoZSBiYWNrZW5kIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlXHJcbiAqIG11dGF0aW9uLiBUaGUgYmFzZSB2YWx1ZSBpcyBudWxsIGZvciBpZGVtcG90ZW50IG11dGF0aW9ucywgYXMgdGhleSBjYW4gYmVcclxuICogcmUtcGxheWVkIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzIGFscmVhZHkgYXBwbGllZCB0aGVtLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBhIGJhc2UgdmFsdWUgdG8gc3RvcmUgYWxvbmcgd2l0aCB0aGUgbXV0YXRpb24sIG9yIG51bGwgZm9yXHJcbiAqIGlkZW1wb3RlbnQgbXV0YXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gbXV0YXRpb25FeHRyYWN0QmFzZVZhbHVlKG11dGF0aW9uLCBkb2N1bWVudCkge1xyXG4gICAgbGV0IGJhc2VPYmplY3QgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMpIHtcclxuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XHJcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZShmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm0sIGV4aXN0aW5nVmFsdWUgfHwgbnVsbCk7XHJcbiAgICAgICAgaWYgKGNvZXJjZWRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlT2JqZWN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlT2JqZWN0ID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYXNlT2JqZWN0LnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgY29lcmNlZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmFzZU9iamVjdCA/IGJhc2VPYmplY3QgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIG11dGF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlICE9PSByaWdodC50eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFsZWZ0LmtleS5pc0VxdWFsKHJpZ2h0LmtleSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWxlZnQucHJlY29uZGl0aW9uLmlzRXF1YWwocmlnaHQucHJlY29uZGl0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghZmllbGRUcmFuc2Zvcm1zQXJlRXF1YWwobGVmdC5maWVsZFRyYW5zZm9ybXMsIHJpZ2h0LmZpZWxkVHJhbnNmb3JtcykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC50eXBlID09PSAwIC8qIE11dGF0aW9uVHlwZS5TZXQgKi8pIHtcclxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZS5pc0VxdWFsKHJpZ2h0LnZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IDEgLyogTXV0YXRpb25UeXBlLlBhdGNoICovKSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0LmRhdGEuaXNFcXVhbChyaWdodC5kYXRhKSAmJlxyXG4gICAgICAgICAgICBsZWZ0LmZpZWxkTWFzay5pc0VxdWFsKHJpZ2h0LmZpZWxkTWFzaykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEEgbXV0YXRpb24gdGhhdCBjcmVhdGVzIG9yIHJlcGxhY2VzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXHJcbiAqIG9iamVjdCB2YWx1ZSBjb250ZW50cy5cclxuICovXHJcbmNsYXNzIFNldE11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLztcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XHJcbiAgICAvLyBVbmxpa2Ugc2V0TXV0YXRpb25BcHBseVRvTG9jYWxWaWV3LCBpZiB3ZSdyZSBhcHBseWluZyBhIG11dGF0aW9uIHRvIGFcclxuICAgIC8vIHJlbW90ZSBkb2N1bWVudCB0aGUgc2VydmVyIGhhcyBhY2NlcHRlZCB0aGUgbXV0YXRpb24gc28gdGhlIHByZWNvbmRpdGlvblxyXG4gICAgLy8gbXVzdCBoYXZlIGhlbGQuXHJcbiAgICBjb25zdCBuZXdEYXRhID0gbXV0YXRpb24udmFsdWUuY2xvbmUoKTtcclxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMpO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAgIC5jb252ZXJ0VG9Gb3VuZERvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24sIG5ld0RhdGEpXHJcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xyXG59XHJcbmZ1bmN0aW9uIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpIHtcclxuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgLy8gVGhlIG11dGF0aW9uIGZhaWxlZCB0byBhcHBseSAoZS5nLiBhIGRvY3VtZW50IElEIGNyZWF0ZWQgd2l0aCBhZGQoKVxyXG4gICAgICAgIC8vIGNhdXNlZCBhIG5hbWUgY29sbGlzaW9uKS5cclxuICAgICAgICByZXR1cm4gcHJldmlvdXNNYXNrO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3RGF0YSA9IG11dGF0aW9uLnZhbHVlLmNsb25lKCk7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIGRvY3VtZW50KTtcclxuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxyXG4gICAgICAgIC5zZXRIYXNMb2NhbE11dGF0aW9ucygpO1xyXG4gICAgcmV0dXJuIG51bGw7IC8vIFNldE11dGF0aW9uIG92ZXJ3cml0ZXMgYWxsIGZpZWxkcy5cclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiB0aGF0IG1vZGlmaWVzIGZpZWxkcyBvZiB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoIHRoZVxyXG4gKiBnaXZlbiB2YWx1ZXMuIFRoZSB2YWx1ZXMgYXJlIGFwcGxpZWQgdGhyb3VnaCBhIGZpZWxkIG1hc2s6XHJcbiAqXHJcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBib3RoIHRoZSBtYXNrIGFuZCB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZFxyXG4gKiAgICBpcyB1cGRhdGVkLlxyXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgaW4gbmVpdGhlciB0aGUgbWFzayBub3IgdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogICAgZmllbGQgaXMgdW5tb2RpZmllZC5cclxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIHRoZSBtYXNrIGJ1dCBub3QgaW4gdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGRcclxuICogICAgaXMgZGVsZXRlZC5cclxuICogICogV2hlbiBhIGZpZWxkIGlzIG5vdCBpbiB0aGUgbWFzayBidXQgaXMgaW4gdGhlIHZhbHVlcywgdGhlIHZhbHVlcyBtYXAgaXNcclxuICogICAgaWdub3JlZC5cclxuICovXHJcbmNsYXNzIFBhdGNoTXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRhdGEsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzaztcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcclxuICAgICAgICB0aGlzLnR5cGUgPSAxIC8qIE11dGF0aW9uVHlwZS5QYXRjaCAqLztcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE1hc2s7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XHJcbiAgICBpZiAoIXByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChtdXRhdGlvbi5wcmVjb25kaXRpb24sIGRvY3VtZW50KSkge1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZSBtdXRhdGlvbiB3YXMgbm90IHJlamVjdGVkLCB3ZSBrbm93IHRoYXQgdGhlIHByZWNvbmRpdGlvblxyXG4gICAgICAgIC8vIG1hdGNoZWQgb24gdGhlIGJhY2tlbmQuIFdlIHRoZXJlZm9yZSBtdXN0IG5vdCBoYXZlIHRoZSBleHBlY3RlZCB2ZXJzaW9uXHJcbiAgICAgICAgLy8gb2YgdGhlIGRvY3VtZW50IGluIG91ciBjYWNoZSBhbmQgY29udmVydCB0byBhbiBVbmtub3duRG9jdW1lbnQgd2l0aCBhXHJcbiAgICAgICAgLy8ga25vd24gdXBkYXRlVGltZS5cclxuICAgICAgICBkb2N1bWVudC5jb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IHNlcnZlclRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQudHJhbnNmb3JtUmVzdWx0cyk7XHJcbiAgICBjb25zdCBuZXdEYXRhID0gZG9jdW1lbnQuZGF0YTtcclxuICAgIG5ld0RhdGEuc2V0QWxsKGdldFBhdGNoKG11dGF0aW9uKSk7XHJcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcclxuICAgICAgICAuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKSB7XHJcbiAgICBpZiAoIXByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChtdXRhdGlvbi5wcmVjb25kaXRpb24sIGRvY3VtZW50KSkge1xyXG4gICAgICAgIHJldHVybiBwcmV2aW91c01hc2s7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIGRvY3VtZW50KTtcclxuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwoZ2V0UGF0Y2gobXV0YXRpb24pKTtcclxuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxyXG4gICAgICAgIC5zZXRIYXNMb2NhbE11dGF0aW9ucygpO1xyXG4gICAgaWYgKHByZXZpb3VzTWFzayA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZXZpb3VzTWFza1xyXG4gICAgICAgIC51bmlvbldpdGgobXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcylcclxuICAgICAgICAudW5pb25XaXRoKG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IHRyYW5zZm9ybS5maWVsZCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgRmllbGRQYXRoL1ZhbHVlIG1hcCB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBQYXRjaE11dGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGF0Y2gobXV0YXRpb24pIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgIG11dGF0aW9uLmZpZWxkTWFzay5maWVsZHMuZm9yRWFjaChmaWVsZFBhdGggPT4ge1xyXG4gICAgICAgIGlmICghZmllbGRQYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG11dGF0aW9uLmRhdGEuZmllbGQoZmllbGRQYXRoKTtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChmaWVsZFBhdGgsIG5ld1ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIFwidHJhbnNmb3JtIHJlc3VsdHNcIiAoYSB0cmFuc2Zvcm0gcmVzdWx0IGlzIGEgZmllbGQgdmFsdWVcclxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2UgYWZ0ZXIgYSBtdXRhdGlvblxyXG4gKiBjb250YWluaW5nIHRyYW5zZm9ybXMgaGFzIGJlZW4gYWNrbm93bGVkZ2VkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxyXG4gKiBAcGFyYW0gbXV0YWJsZURvY3VtZW50IC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGFwcGx5aW5nIGFsbFxyXG4gKiBwcmV2aW91cyBtdXRhdGlvbnMuXHJcbiAqIEBwYXJhbSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzIC0gVGhlIHRyYW5zZm9ybSByZXN1bHRzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gcmVzdWx0cyBsaXN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhmaWVsZFRyYW5zZm9ybXMsIG11dGFibGVEb2N1bWVudCwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cykge1xyXG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IG5ldyBNYXAoKTtcclxuICAgIGhhcmRBc3NlcnQoZmllbGRUcmFuc2Zvcm1zLmxlbmd0aCA9PT0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRUcmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybXNbaV07XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XHJcbiAgICAgICAgdHJhbnNmb3JtUmVzdWx0cy5zZXQoZmllbGRUcmFuc2Zvcm0uZmllbGQsIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9SZW1vdGVEb2N1bWVudCh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIHNlcnZlclRyYW5zZm9ybVJlc3VsdHNbaV0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbGlzdCBvZiBcInRyYW5zZm9ybSByZXN1bHRzXCIgKGEgdHJhbnNmb3JtIHJlc3VsdCBpcyBhIGZpZWxkIHZhbHVlXHJcbiAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgdHJhbnNmb3JtKSBmb3IgdXNlIHdoZW4gYXBwbHlpbmcgYVxyXG4gKiB0cmFuc2Zvcm0gbG9jYWxseS5cclxuICpcclxuICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIFRoZSBmaWVsZCB0cmFuc2Zvcm1zIHRvIGFwcGx5IHRoZSByZXN1bHQgdG8uXHJcbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBsb2NhbCB0aW1lIG9mIHRoZSBtdXRhdGlvbiAodXNlZCB0b1xyXG4gKiAgICAgZ2VuZXJhdGUgU2VydmVyVGltZXN0YW1wVmFsdWVzKS5cclxuICogQHBhcmFtIG11dGFibGVEb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBhcHBseSB0cmFuc2Zvcm1zIG9uLlxyXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgbGlzdC5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsVHJhbnNmb3JtUmVzdWx0cyhmaWVsZFRyYW5zZm9ybXMsIGxvY2FsV3JpdGVUaW1lLCBtdXRhYmxlRG9jdW1lbnQpIHtcclxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkVHJhbnNmb3JtIG9mIGZpZWxkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gbXV0YWJsZURvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xyXG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdHMuc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgbG9jYWxXcml0ZVRpbWUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xyXG59XHJcbi8qKiBBIG11dGF0aW9uIHRoYXQgZGVsZXRlcyB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleS4gKi9cclxuY2xhc3MgRGVsZXRlTXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBNdXRhdGlvblR5cGUuRGVsZXRlICovO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRGaWVsZE1hc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xyXG4gICAgLy8gVW5saWtlIGFwcGx5VG9Mb2NhbFZpZXcsIGlmIHdlJ3JlIGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gYSByZW1vdGVcclxuICAgIC8vIGRvY3VtZW50IHRoZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHRoZSBtdXRhdGlvbiBzbyB0aGUgcHJlY29uZGl0aW9uIG11c3RcclxuICAgIC8vIGhhdmUgaGVsZC5cclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLmNvbnZlcnRUb05vRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbilcclxuICAgICAgICAuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlTXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrKSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChkb2N1bWVudC52ZXJzaW9uKS5zZXRIYXNMb2NhbE11dGF0aW9ucygpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZXZpb3VzTWFzaztcclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiB0aGF0IHZlcmlmaWVzIHRoZSBleGlzdGVuY2Ugb2YgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aFxyXG4gKiB0aGUgcHJvdmlkZWQgcHJlY29uZGl0aW9uLlxyXG4gKlxyXG4gKiBUaGUgYHZlcmlmeWAgb3BlcmF0aW9uIGlzIG9ubHkgdXNlZCBpbiBUcmFuc2FjdGlvbnMsIGFuZCB0aGlzIGNsYXNzIHNlcnZlc1xyXG4gKiBwcmltYXJpbHkgdG8gZmFjaWxpdGF0ZSBzZXJpYWxpemF0aW9uIGludG8gcHJvdG9zLlxyXG4gKi9cclxuY2xhc3MgVmVyaWZ5TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBNdXRhdGlvblR5cGUuVmVyaWZ5ICovO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRGaWVsZE1hc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYmF0Y2ggb2YgbXV0YXRpb25zIHRoYXQgd2lsbCBiZSBzZW50IGFzIG9uZSB1bml0IHRvIHRoZSBiYWNrZW5kLlxyXG4gKi9cclxuY2xhc3MgTXV0YXRpb25CYXRjaCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBiYXRjaElkIC0gVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIG11dGF0aW9uIGJhdGNoLlxyXG4gICAgICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gVGhlIG9yaWdpbmFsIHdyaXRlIHRpbWUgb2YgdGhpcyBtdXRhdGlvbi5cclxuICAgICAqIEBwYXJhbSBiYXNlTXV0YXRpb25zIC0gTXV0YXRpb25zIHRoYXQgYXJlIHVzZWQgdG8gcG9wdWxhdGUgdGhlIGJhc2VcclxuICAgICAqIHZhbHVlcyB3aGVuIHRoaXMgbXV0YXRpb24gaXMgYXBwbGllZCBsb2NhbGx5LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvY2FsbHlcclxuICAgICAqIG92ZXJ3cml0ZSB2YWx1ZXMgdGhhdCBhcmUgcGVyc2lzdGVkIGluIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuIEJhc2VcclxuICAgICAqIG11dGF0aW9ucyBhcmUgbmV2ZXIgc2VudCB0byB0aGUgYmFja2VuZC5cclxuICAgICAqIEBwYXJhbSBtdXRhdGlvbnMgLSBUaGUgdXNlci1wcm92aWRlZCBtdXRhdGlvbnMgaW4gdGhpcyBtdXRhdGlvbiBiYXRjaC5cclxuICAgICAqIFVzZXItcHJvdmlkZWQgbXV0YXRpb25zIGFyZSBhcHBsaWVkIGJvdGggbG9jYWxseSBhbmQgcmVtb3RlbHkgb24gdGhlXHJcbiAgICAgKiBiYWNrZW5kLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5iYXRjaElkID0gYmF0Y2hJZDtcclxuICAgICAgICB0aGlzLmxvY2FsV3JpdGVUaW1lID0gbG9jYWxXcml0ZVRpbWU7XHJcbiAgICAgICAgdGhpcy5iYXNlTXV0YXRpb25zID0gYmFzZU11dGF0aW9ucztcclxuICAgICAgICB0aGlzLm11dGF0aW9ucyA9IG11dGF0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhbGwgdGhlIG11dGF0aW9ucyBpbiB0aGlzIE11dGF0aW9uQmF0Y2ggdG8gdGhlIHNwZWNpZmllZCBkb2N1bWVudFxyXG4gICAgICogdG8gY29tcHV0ZSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBkb2N1bWVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBhcHBseSBtdXRhdGlvbnMgdG8uXHJcbiAgICAgKiBAcGFyYW0gYmF0Y2hSZXN1bHQgLSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBNdXRhdGlvbkJhdGNoIHRvIHRoZVxyXG4gICAgICogYmFja2VuZC5cclxuICAgICAqL1xyXG4gICAgYXBwbHlUb1JlbW90ZURvY3VtZW50KGRvY3VtZW50LCBiYXRjaFJlc3VsdCkge1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0cyA9IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0gdGhpcy5tdXRhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvblJlc3VsdCA9IG11dGF0aW9uUmVzdWx0c1tpXTtcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50IGdpdmVuIGFsbCB0aGUgbXV0YXRpb25zIGluIHRoaXNcclxuICAgICAqIGJhdGNoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBhcHBseSBtdXRhdGlvbnMgdG8uXHJcbiAgICAgKiBAcGFyYW0gbXV0YXRlZEZpZWxkcyAtIEZpZWxkcyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIGJlZm9yZSBhcHBseWluZyB0aGlzIG11dGF0aW9uIGJhdGNoLlxyXG4gICAgICogQHJldHVybnMgQSBgRmllbGRNYXNrYCByZXByZXNlbnRpbmcgYWxsIHRoZSBmaWVsZHMgdGhhdCBhcmUgbXV0YXRlZC5cclxuICAgICAqL1xyXG4gICAgYXBwbHlUb0xvY2FsVmlldyhkb2N1bWVudCwgbXV0YXRlZEZpZWxkcykge1xyXG4gICAgICAgIC8vIEZpcnN0LCBhcHBseSB0aGUgYmFzZSBzdGF0ZS4gVGhpcyBhbGxvd3MgdXMgdG8gYXBwbHkgbm9uLWlkZW1wb3RlbnRcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYWdhaW5zdCBhIGNvbnNpc3RlbnQgc2V0IG9mIHZhbHVlcy5cclxuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIHRoaXMuYmFzZU11dGF0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcyA9IG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMsIHRoaXMubG9jYWxXcml0ZVRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlY29uZCwgYXBwbHkgYWxsIHVzZXItcHJvdmlkZWQgbXV0YXRpb25zLlxyXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5tdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmtleS5pc0VxdWFsKGRvY3VtZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMgPSBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGVkRmllbGRzLCB0aGlzLmxvY2FsV3JpdGVUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXV0YXRlZEZpZWxkcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgZm9yIGFsbCBwcm92aWRlZCBkb2N1bWVudHMgZ2l2ZW4gdGhlIG11dGF0aW9ucyBpblxyXG4gICAgICogdGhpcyBiYXRjaC4gUmV0dXJucyBhIGBEb2N1bWVudEtleWAgdG8gYE11dGF0aW9uYCBtYXAgd2hpY2ggY2FuIGJlIHVzZWQgdG9cclxuICAgICAqIHJlcGxhY2UgYWxsIHRoZSBtdXRhdGlvbiBhcHBsaWNhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5VG9Mb2NhbERvY3VtZW50U2V0KGRvY3VtZW50TWFwLCBkb2N1bWVudHNXaXRob3V0UmVtb3RlVmVyc2lvbikge1xyXG4gICAgICAgIC8vIFRPRE8obXJzY2htaWR0KTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBPKG5eMikuIElmIHdlIGFwcGx5IHRoZSBtdXRhdGlvbnNcclxuICAgICAgICAvLyBkaXJlY3RseSAoYXMgZG9uZSBpbiBgYXBwbHlUb0xvY2FsVmlldygpYCksIHdlIGNhbiByZWR1Y2UgdGhlIGNvbXBsZXhpdHlcclxuICAgICAgICAvLyB0byBPKG4pLlxyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3TXV0YXRpb25NYXAoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9ucy5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ZWREb2N1bWVudCA9IGRvY3VtZW50TWFwLmdldChtLmtleSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8obXV0YWJsZWRvY3VtZW50cyk6IFRoaXMgbWV0aG9kIHNob3VsZCB0YWtlIGEgTXV0YWJsZURvY3VtZW50TWFwXHJcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBzaG91bGQgcmVtb3ZlIHRoaXMgY2FzdC5cclxuICAgICAgICAgICAgY29uc3QgbXV0YWJsZURvY3VtZW50ID0gb3ZlcmxheWVkRG9jdW1lbnQub3ZlcmxheWVkRG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBtdXRhdGVkRmllbGRzID0gdGhpcy5hcHBseVRvTG9jYWxWaWV3KG11dGFibGVEb2N1bWVudCwgb3ZlcmxheWVkRG9jdW1lbnQubXV0YXRlZEZpZWxkcyk7XHJcbiAgICAgICAgICAgIC8vIFNldCBtdXRhdGVkRmllbGRzIHRvIG51bGwgaWYgdGhlIGRvY3VtZW50IGlzIG9ubHkgZnJvbSBsb2NhbCBtdXRhdGlvbnMuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24sIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGNyZWF0ZSBhXHJcbiAgICAgICAgICAgIC8vIHBhdGNoIG11dGF0aW9uIGFzIHRoZSBvdmVybGF5LlxyXG4gICAgICAgICAgICBtdXRhdGVkRmllbGRzID0gZG9jdW1lbnRzV2l0aG91dFJlbW90ZVZlcnNpb24uaGFzKG0ua2V5KVxyXG4gICAgICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgICAgICA6IG11dGF0ZWRGaWVsZHM7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBjYWxjdWxhdGVPdmVybGF5TXV0YXRpb24obXV0YWJsZURvY3VtZW50LCBtdXRhdGVkRmllbGRzKTtcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJsYXlzLnNldChtLmtleSwgb3ZlcmxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFtdXRhYmxlRG9jdW1lbnQuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIG11dGFibGVEb2N1bWVudC5jb252ZXJ0VG9Ob0RvY3VtZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gb3ZlcmxheXM7XHJcbiAgICB9XHJcbiAgICBrZXlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoSWQgPT09IG90aGVyLmJhdGNoSWQgJiZcclxuICAgICAgICAgICAgYXJyYXlFcXVhbHModGhpcy5tdXRhdGlvbnMsIG90aGVyLm11dGF0aW9ucywgKGwsIHIpID0+IG11dGF0aW9uRXF1YWxzKGwsIHIpKSAmJlxyXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLmJhc2VNdXRhdGlvbnMsIG90aGVyLmJhc2VNdXRhdGlvbnMsIChsLCByKSA9PiBtdXRhdGlvbkVxdWFscyhsLCByKSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgbXV0YXRpb24gYmF0Y2ggdG8gdGhlIGJhY2tlbmQuICovXHJcbmNsYXNzIE11dGF0aW9uQmF0Y2hSZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIG11dGF0aW9uUmVzdWx0cywgXHJcbiAgICAvKipcclxuICAgICAqIEEgcHJlLWNvbXB1dGVkIG1hcHBpbmcgZnJvbSBlYWNoIG11dGF0ZWQgZG9jdW1lbnQgdG8gdGhlIHJlc3VsdGluZ1xyXG4gICAgICogdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgZG9jVmVyc2lvbnMpIHtcclxuICAgICAgICB0aGlzLmJhdGNoID0gYmF0Y2g7XHJcbiAgICAgICAgdGhpcy5jb21taXRWZXJzaW9uID0gY29tbWl0VmVyc2lvbjtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUmVzdWx0cyA9IG11dGF0aW9uUmVzdWx0cztcclxuICAgICAgICB0aGlzLmRvY1ZlcnNpb25zID0gZG9jVmVyc2lvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgTXV0YXRpb25CYXRjaFJlc3VsdCBmb3IgdGhlIGdpdmVuIGJhdGNoIGFuZCByZXN1bHRzLiBUaGVyZVxyXG4gICAgICogbXVzdCBiZSBvbmUgcmVzdWx0IGZvciBlYWNoIG11dGF0aW9uIGluIHRoZSBiYXRjaC4gVGhpcyBzdGF0aWMgZmFjdG9yeVxyXG4gICAgICogY2FjaGVzIGEgZG9jdW1lbnQ9Jmd0O3ZlcnNpb24gbWFwcGluZyAoZG9jVmVyc2lvbnMpLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShiYXRjaCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xyXG4gICAgICAgIGhhcmRBc3NlcnQoYmF0Y2gubXV0YXRpb25zLmxlbmd0aCA9PT0gcmVzdWx0cy5sZW5ndGgpO1xyXG4gICAgICAgIGxldCB2ZXJzaW9uTWFwID0gZG9jdW1lbnRWZXJzaW9uTWFwKCk7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25zID0gYmF0Y2gubXV0YXRpb25zO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlcnNpb25NYXAgPSB2ZXJzaW9uTWFwLmluc2VydChtdXRhdGlvbnNbaV0ua2V5LCByZXN1bHRzW2ldLnZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMsIHZlcnNpb25NYXApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhbiBvdmVybGF5IGNvbXB1dGVkIGJ5IEZpcmVzdG9yZS5cclxuICpcclxuICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYSBtdXRhdGlvbiBhbmQgdGhlIGxhcmdlc3QgYmF0Y2ggaWQgaW4gRmlyZXN0b3JlIHdoZW5cclxuICogdGhlIG11dGF0aW9uIHdhcyBjcmVhdGVkLlxyXG4gKi9cclxuY2xhc3MgT3ZlcmxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pIHtcclxuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbiA9IG11dGF0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9uLmtleTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgdGhpcy5tdXRhdGlvbiA9PT0gb3RoZXIubXV0YXRpb247XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYE92ZXJsYXl7XG4gICAgICBsYXJnZXN0QmF0Y2hJZDogJHt0aGlzLmxhcmdlc3RCYXRjaElkfSxcbiAgICAgIG11dGF0aW9uOiAke3RoaXMubXV0YXRpb24udG9TdHJpbmcoKX1cbiAgICB9YDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBFeGlzdGVuY2VGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY291bnQsIHVuY2hhbmdlZE5hbWVzKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xyXG4gICAgICAgIHRoaXMudW5jaGFuZ2VkTmFtZXMgPSB1bmNoYW5nZWROYW1lcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXJyb3IgQ29kZXMgZGVzY3JpYmluZyB0aGUgZGlmZmVyZW50IHdheXMgR1JQQyBjYW4gZmFpbC4gVGhlc2UgYXJlIGNvcGllZFxyXG4gKiBkaXJlY3RseSBmcm9tIEdSUEMncyBzb3VyY2VzIGhlcmU6XHJcbiAqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9iY2VlYzk0ZWE0ZmM1ZjAwODVkODEyMzVkOGUxYzA2Nzk4ZGMzNDFhL2luY2x1ZGUvZ3JwYyUyQiUyQi9pbXBsL2NvZGVnZW4vc3RhdHVzX2NvZGVfZW51bS5oXHJcbiAqXHJcbiAqIEltcG9ydGFudCEgVGhlIG5hbWVzIG9mIHRoZXNlIGlkZW50aWZpZXJzIG1hdHRlciBiZWNhdXNlIHRoZSBzdHJpbmcgZm9ybXNcclxuICogYXJlIHVzZWQgZm9yIHJldmVyc2UgbG9va3VwcyBmcm9tIHRoZSB3ZWJjaGFubmVsIHN0cmVhbS4gRG8gTk9UIGNoYW5nZSB0aGVcclxuICogbmFtZXMgb2YgdGhlc2UgaWRlbnRpZmllcnMgb3IgY2hhbmdlIHRoaXMgaW50byBhIGNvbnN0IGVudW0uXHJcbiAqL1xyXG52YXIgUnBjQ29kZTtcclxuKGZ1bmN0aW9uIChScGNDb2RlKSB7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkRFQURMSU5FX0VYQ0VFREVEXCJdID0gNF0gPSBcIkRFQURMSU5FX0VYQ0VFREVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiUEVSTUlTU0lPTl9ERU5JRURcIl0gPSA3XSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOQVVUSEVOVElDQVRFRFwiXSA9IDE2XSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJGQUlMRURfUFJFQ09ORElUSU9OXCJdID0gOV0gPSBcIkZBSUxFRF9QUkVDT05ESVRJT05cIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkFCT1JURURcIl0gPSAxMF0gPSBcIkFCT1JURURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTklNUExFTUVOVEVEXCJdID0gMTJdID0gXCJVTklNUExFTUVOVEVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJJTlRFUk5BTFwiXSA9IDEzXSA9IFwiSU5URVJOQUxcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiREFUQV9MT1NTXCJdID0gMTVdID0gXCJEQVRBX0xPU1NcIjtcclxufSkoUnBjQ29kZSB8fCAoUnBjQ29kZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXJyb3IgY29kZSByZXByZXNlbnRzIGEgcGVybWFuZW50IGVycm9yIHdoZW4gcmVjZWl2ZWRcclxuICogaW4gcmVzcG9uc2UgdG8gYSBub24td3JpdGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBTZWUgaXNQZXJtYW5lbnRXcml0ZUVycm9yIGZvciBjbGFzc2lmeWluZyB3cml0ZSBlcnJvcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Blcm1hbmVudEVycm9yKGNvZGUpIHtcclxuICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgIGNhc2UgQ29kZS5PSzpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgICAgICBjYXNlIENvZGUuQ0FOQ0VMTEVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5VTktOT1dOOlxyXG4gICAgICAgIGNhc2UgQ29kZS5ERUFETElORV9FWENFRURFRDpcclxuICAgICAgICBjYXNlIENvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5JTlRFUk5BTDpcclxuICAgICAgICBjYXNlIENvZGUuVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgLy8gVW5hdXRoZW50aWNhdGVkIG1lYW5zIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggb3VyIHRva2VuIGFuZCB3ZSBuZWVkXHJcbiAgICAgICAgLy8gdG8gcmV0cnkgd2l0aCBuZXcgY3JlZGVudGlhbHMgd2hpY2ggd2lsbCBoYXBwZW4gYXV0b21hdGljYWxseS5cclxuICAgICAgICBjYXNlIENvZGUuVU5BVVRIRU5USUNBVEVEOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgY2FzZSBDb2RlLklOVkFMSURfQVJHVU1FTlQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLk5PVF9GT1VORDpcclxuICAgICAgICBjYXNlIENvZGUuQUxSRUFEWV9FWElTVFM6XHJcbiAgICAgICAgY2FzZSBDb2RlLlBFUk1JU1NJT05fREVOSUVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OOlxyXG4gICAgICAgIC8vIEFib3J0ZWQgbWlnaHQgYmUgcmV0cmllZCBpbiBzb21lIHNjZW5hcmlvcywgYnV0IHRoYXQgaXMgZGVwZW5kYW50IG9uXHJcbiAgICAgICAgLy8gdGhlIGNvbnRleHQgYW5kIHNob3VsZCBoYW5kbGVkIGluZGl2aWR1YWxseSBieSB0aGUgY2FsbGluZyBjb2RlLlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZXJyb3JzLlxyXG4gICAgICAgIGNhc2UgQ29kZS5BQk9SVEVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5PVVRfT0ZfUkFOR0U6XHJcbiAgICAgICAgY2FzZSBDb2RlLlVOSU1QTEVNRU5URUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLkRBVEFfTE9TUzpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXHJcbiAqIGluIHJlc3BvbnNlIHRvIGEgd3JpdGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBXcml0ZSBvcGVyYXRpb25zIG11c3QgYmUgaGFuZGxlZCBzcGVjaWFsbHkgYmVjYXVzZSBhcyBvZiBiLzExOTQzNzc2NCwgQUJPUlRFRFxyXG4gKiBlcnJvcnMgb24gdGhlIHdyaXRlIHN0cmVhbSBzaG91bGQgYmUgcmV0cmllZCB0b28gKGV2ZW4gdGhvdWdoIEFCT1JURUQgZXJyb3JzXHJcbiAqIGFyZSBub3QgZ2VuZXJhbGx5IHJldHJ5YWJsZSkuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBkdXJpbmcgdGhlIGluaXRpYWwgaGFuZHNoYWtlIG9uIHRoZSB3cml0ZSBzdHJlYW0gYW4gQUJPUlRFRCBlcnJvclxyXG4gKiBzaWduYWxzIHRoYXQgd2Ugc2hvdWxkIGRpc2NhcmQgb3VyIHN0cmVhbSB0b2tlbiAoaS5lLiBpdCBpcyBwZXJtYW5lbnQpLiBUaGlzXHJcbiAqIG1lYW5zIGEgaGFuZHNoYWtlIGVycm9yIHNob3VsZCBiZSBjbGFzc2lmaWVkIHdpdGggaXNQZXJtYW5lbnRFcnJvciwgYWJvdmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Blcm1hbmVudFdyaXRlRXJyb3IoY29kZSkge1xyXG4gICAgcmV0dXJuIGlzUGVybWFuZW50RXJyb3IoY29kZSkgJiYgY29kZSAhPT0gQ29kZS5BQk9SVEVEO1xyXG59XHJcbi8qKlxyXG4gKiBNYXBzIGFuIGVycm9yIENvZGUgZnJvbSBHUlBDIHN0YXR1cyBjb2RlIG51bWJlciwgbGlrZSAwLCAxLCBvciAxNC4gVGhlc2VcclxuICogYXJlIG5vdCB0aGUgc2FtZSBhcyBIVFRQIHN0YXR1cyBjb2Rlcy5cclxuICpcclxuICogQHJldHVybnMgVGhlIENvZGUgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gR1JQQyBzdGF0dXMgY29kZS4gRmFpbHMgaWYgdGhlcmVcclxuICogICAgIGlzIG5vIG1hdGNoLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFwQ29kZUZyb21ScGNDb2RlKGNvZGUpIHtcclxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBub3JtYWxseSBoYXBwZW4sIGJ1dCBpbiBjZXJ0YWluIGVycm9yIGNhc2VzIChsaWtlIHRyeWluZ1xyXG4gICAgICAgIC8vIHRvIHNlbmQgaW52YWxpZCBwcm90byBtZXNzYWdlcykgd2UgbWF5IGdldCBhbiBlcnJvciB3aXRoIG5vIEdSUEMgY29kZS5cclxuICAgICAgICBsb2dFcnJvcignR1JQQyBlcnJvciBoYXMgbm8gLmNvZGUnKTtcclxuICAgICAgICByZXR1cm4gQ29kZS5VTktOT1dOO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLk9LOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5PSztcclxuICAgICAgICBjYXNlIFJwY0NvZGUuQ0FOQ0VMTEVEOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5DQU5DRUxMRUQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOS05PV046XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLkRFQURMSU5FX0VYQ0VFREVEOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5ERUFETElORV9FWENFRURFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLklOVEVSTkFMOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JTlRFUk5BTDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOQVZBSUxBQkxFO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFVVEhFTlRJQ0FURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOQVVUSEVOVElDQVRFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuSU5WQUxJRF9BUkdVTUVOVDpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuSU5WQUxJRF9BUkdVTUVOVDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuTk9UX0ZPVU5EOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5OT1RfRk9VTkQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLkFMUkVBRFlfRVhJU1RTOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5BTFJFQURZX0VYSVNUUztcclxuICAgICAgICBjYXNlIFJwY0NvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlBFUk1JU1NJT05fREVOSUVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5BQk9SVEVEOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5BQk9SVEVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5PVVRfT0ZfUkFOR0U6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9VVF9PRl9SQU5HRTtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuVU5JTVBMRU1FTlRFRDpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5JTVBMRU1FTlRFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuREFUQV9MT1NTOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5EQVRBX0xPU1M7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cclxuICovXHJcbmNsYXNzIEJhc2U2NERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnQmFzZTY0RGVjb2RlRXJyb3InO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZ2xvYmFsLCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVGVzdGluZ0hvb2tzU3BpLlxyXG4gKlxyXG4gKiBUaGlzIHZhcmlhYmxlIHdpbGwgYmUgYG51bGxgIGluIGFsbCBjYXNlcyBfZXhjZXB0XyB3aGVuIHJ1bm5pbmcgZnJvbVxyXG4gKiBpbnRlZ3JhdGlvbiB0ZXN0cyB0aGF0IGhhdmUgcmVnaXN0ZXJlZCBjYWxsYmFja3MgdG8gYmUgbm90aWZpZWQgb2YgZXZlbnRzXHJcbiAqIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgdGVzdCBleGVjdXRpb24uXHJcbiAqL1xyXG5sZXQgdGVzdGluZ0hvb2tzU3BpID0gbnVsbDtcclxuLyoqXHJcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgdGVzdGluZ0hvb2tzU3BpYCBvYmplY3QuXHJcbiAqIEBwYXJhbSBpbnN0YW5jZSB0aGUgaW5zdGFuY2UgdG8gc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VGVzdGluZ0hvb2tzU3BpKGluc3RhbmNlKSB7XHJcbiAgICBpZiAodGVzdGluZ0hvb2tzU3BpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIFRlc3RpbmdIb29rc1NwaSBpbnN0YW5jZSBpcyBhbHJlYWR5IHNldCcpO1xyXG4gICAgfVxyXG4gICAgdGVzdGluZ0hvb2tzU3BpID0gaW5zdGFuY2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBQbGF0Zm9ybSdzICdUZXh0RW5jb2RlcicgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdUZXh0RW5jb2RlcigpIHtcclxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKTtcclxufVxyXG4vKipcclxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFBsYXRmb3JtJ3MgJ1RleHREZWNvZGVyJyBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1RleHREZWNvZGVyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfNjRfQklUX1VOU0lHTkVEX0lOVEVHRVIgPSBuZXcgSW50ZWdlcihbMHhmZmZmZmZmZiwgMHhmZmZmZmZmZl0sIDApO1xyXG4vLyBIYXNoIGEgc3RyaW5nIHVzaW5nIG1kNSBoYXNoaW5nIGFsZ29yaXRobS5cclxuZnVuY3Rpb24gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKSB7XHJcbiAgICBjb25zdCBlbmNvZGVkVmFsdWUgPSBuZXdUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XHJcbiAgICBjb25zdCBtZDUgPSBuZXcgTWQ1KCk7XHJcbiAgICBtZDUudXBkYXRlKGVuY29kZWRWYWx1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWQ1LmRpZ2VzdCgpKTtcclxufVxyXG4vLyBJbnRlcnByZXQgdGhlIDE2IGJ5dGVzIGFycmF5IGFzIHR3byA2NC1iaXQgdW5zaWduZWQgaW50ZWdlcnMsIGVuY29kZWQgdXNpbmdcclxuLy8gMuKAmXMgY29tcGxlbWVudCB1c2luZyBsaXR0bGUgZW5kaWFuLlxyXG5mdW5jdGlvbiBnZXQ2NEJpdFVpbnRzKEJ5dGVzKSB7XHJcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhCeXRlcy5idWZmZXIpO1xyXG4gICAgY29uc3QgY2h1bmsxID0gZGF0YVZpZXcuZ2V0VWludDMyKDAsIC8qIGxpdHRsZUVuZGlhbj0gKi8gdHJ1ZSk7XHJcbiAgICBjb25zdCBjaHVuazIgPSBkYXRhVmlldy5nZXRVaW50MzIoNCwgLyogbGl0dGxlRW5kaWFuPSAqLyB0cnVlKTtcclxuICAgIGNvbnN0IGNodW5rMyA9IGRhdGFWaWV3LmdldFVpbnQzMig4LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xyXG4gICAgY29uc3QgY2h1bms0ID0gZGF0YVZpZXcuZ2V0VWludDMyKDEyLCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xyXG4gICAgY29uc3QgaW50ZWdlcjEgPSBuZXcgSW50ZWdlcihbY2h1bmsxLCBjaHVuazJdLCAwKTtcclxuICAgIGNvbnN0IGludGVnZXIyID0gbmV3IEludGVnZXIoW2NodW5rMywgY2h1bms0XSwgMCk7XHJcbiAgICByZXR1cm4gW2ludGVnZXIxLCBpbnRlZ2VyMl07XHJcbn1cclxuY2xhc3MgQmxvb21GaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoYml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpIHtcclxuICAgICAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xyXG4gICAgICAgIHRoaXMuaGFzaENvdW50ID0gaGFzaENvdW50O1xyXG4gICAgICAgIGlmIChwYWRkaW5nIDwgMCB8fCBwYWRkaW5nID49IDgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgcGFkZGluZzogJHtwYWRkaW5nfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzaENvdW50IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBoYXNoIGNvdW50OiAke2hhc2hDb3VudH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJpdG1hcC5sZW5ndGggPiAwICYmIHRoaXMuaGFzaENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgZW1wdHkgYmxvb20gZmlsdGVyIGNhbiBoYXZlIDAgaGFzaCBjb3VudC5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgaGFzaCBjb3VudDogJHtoYXNoQ291bnR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaXRtYXAubGVuZ3RoID09PSAwICYmIHBhZGRpbmcgIT09IDApIHtcclxuICAgICAgICAgICAgLy8gRW1wdHkgYmxvb20gZmlsdGVyIHNob3VsZCBoYXZlIDAgcGFkZGluZy5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgcGFkZGluZyB3aGVuIGJpdG1hcCBsZW5ndGggaXMgMDogJHtwYWRkaW5nfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJpdENvdW50ID0gYml0bWFwLmxlbmd0aCAqIDggLSBwYWRkaW5nO1xyXG4gICAgICAgIC8vIFNldCB0aGUgYml0IGNvdW50IGluIEludGVnZXIgdG8gYXZvaWQgcmVwZXRpdGlvbiBpbiBtaWdodENvbnRhaW4oKS5cclxuICAgICAgICB0aGlzLmJpdENvdW50SW5JbnRlZ2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKHRoaXMuYml0Q291bnQpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBpdGggaGFzaCB2YWx1ZSBiYXNlZCBvbiB0aGUgaGFzaGVkIDY0Yml0IGludGVnZXJzLFxyXG4gICAgLy8gYW5kIGNhbGN1bGF0ZSBpdHMgY29ycmVzcG9uZGluZyBiaXQgaW5kZXggaW4gdGhlIGJpdG1hcCB0byBiZSBjaGVja2VkLlxyXG4gICAgZ2V0Qml0SW5kZXgobnVtMSwgbnVtMiwgaGFzaEluZGV4KSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhhc2hlZCB2YWx1ZSBoKGkpID0gaDEgKyAoaSAqIGgyKS5cclxuICAgICAgICBsZXQgaGFzaFZhbHVlID0gbnVtMS5hZGQobnVtMi5tdWx0aXBseShJbnRlZ2VyLmZyb21OdW1iZXIoaGFzaEluZGV4KSkpO1xyXG4gICAgICAgIC8vIFdyYXAgaWYgaGFzaCB2YWx1ZSBvdmVyZmxvdyA2NGJpdC5cclxuICAgICAgICBpZiAoaGFzaFZhbHVlLmNvbXBhcmUoTUFYXzY0X0JJVF9VTlNJR05FRF9JTlRFR0VSKSA9PT0gMSkge1xyXG4gICAgICAgICAgICBoYXNoVmFsdWUgPSBuZXcgSW50ZWdlcihbaGFzaFZhbHVlLmdldEJpdHMoMCksIGhhc2hWYWx1ZS5nZXRCaXRzKDEpXSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNoVmFsdWUubW9kdWxvKHRoaXMuYml0Q291bnRJbkludGVnZXIpLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm4gd2hldGhlciB0aGUgYml0IG9uIHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgYml0bWFwIGlzIHNldCB0byAxLlxyXG4gICAgaXNCaXRTZXQoaW5kZXgpIHtcclxuICAgICAgICAvLyBUbyByZXRyaWV2ZSBiaXQgbiwgY2FsY3VsYXRlOiAoYml0bWFwW24gLyA4XSAmICgweDAxIDw8IChuICUgOCkpKS5cclxuICAgICAgICBjb25zdCBieXRlID0gdGhpcy5iaXRtYXBbTWF0aC5mbG9vcihpbmRleCAvIDgpXTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAlIDg7XHJcbiAgICAgICAgcmV0dXJuIChieXRlICYgKDB4MDEgPDwgb2Zmc2V0KSkgIT09IDA7XHJcbiAgICB9XHJcbiAgICBtaWdodENvbnRhaW4odmFsdWUpIHtcclxuICAgICAgICAvLyBFbXB0eSBiaXRtYXAgc2hvdWxkIGFsd2F5cyByZXR1cm4gZmFsc2Ugb24gbWVtYmVyc2hpcCBjaGVjay5cclxuICAgICAgICBpZiAodGhpcy5iaXRDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1kNUhhc2hlZFZhbHVlID0gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKTtcclxuICAgICAgICBjb25zdCBbaGFzaDEsIGhhc2gyXSA9IGdldDY0Qml0VWludHMobWQ1SGFzaGVkVmFsdWUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0Qml0SW5kZXgoaGFzaDEsIGhhc2gyLCBpKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQml0U2V0KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZSBibG9vbSBmaWx0ZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS4gKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoYml0Q291bnQsIGhhc2hDb3VudCwgY29udGFpbnMpIHtcclxuICAgICAgICBjb25zdCBwYWRkaW5nID0gYml0Q291bnQgJSA4ID09PSAwID8gMCA6IDggLSAoYml0Q291bnQgJSA4KTtcclxuICAgICAgICBjb25zdCBiaXRtYXAgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoYml0Q291bnQgLyA4KSk7XHJcbiAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoYml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpO1xyXG4gICAgICAgIGNvbnRhaW5zLmZvckVhY2goaXRlbSA9PiBibG9vbUZpbHRlci5pbnNlcnQoaXRlbSkpO1xyXG4gICAgICAgIHJldHVybiBibG9vbUZpbHRlcjtcclxuICAgIH1cclxuICAgIGluc2VydCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmJpdENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWQ1SGFzaGVkVmFsdWUgPSBnZXRNZDVIYXNoVmFsdWUodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRCaXRJbmRleChoYXNoMSwgaGFzaDIsIGkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEJpdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0Qml0KGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhPZkJ5dGUgPSBNYXRoLmZsb29yKGluZGV4IC8gOCk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggJSA4O1xyXG4gICAgICAgIHRoaXMuYml0bWFwW2luZGV4T2ZCeXRlXSB8PSAweDAxIDw8IG9mZnNldDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBCbG9vbUZpbHRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnQmxvb21GaWx0ZXJFcnJvcic7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGV2ZW50IGZyb20gdGhlIFJlbW90ZVN0b3JlLiBJdCBpcyBzcGxpdCBpbnRvIHRhcmdldENoYW5nZXMgKGNoYW5nZXMgdG8gdGhlXHJcbiAqIHN0YXRlIG9yIHRoZSBzZXQgb2YgZG9jdW1lbnRzIGluIG91ciB3YXRjaGVkIHRhcmdldHMpIGFuZCBkb2N1bWVudFVwZGF0ZXNcclxuICogKGNoYW5nZXMgdG8gdGhlIGFjdHVhbCBkb2N1bWVudHMpLlxyXG4gKi9cclxuY2xhc3MgUmVtb3RlRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzbmFwc2hvdCB2ZXJzaW9uIHRoaXMgZXZlbnQgYnJpbmdzIHVzIHVwIHRvLCBvciBNSU4gaWYgbm90IHNldC5cclxuICAgICAqL1xyXG4gICAgc25hcHNob3RWZXJzaW9uLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBtYXAgZnJvbSB0YXJnZXQgdG8gY2hhbmdlcyB0byB0aGUgdGFyZ2V0LiBTZWUgVGFyZ2V0Q2hhbmdlLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRDaGFuZ2VzLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBtYXAgb2YgdGFyZ2V0cyB0aGF0IGlzIGtub3duIHRvIGJlIGluY29uc2lzdGVudCwgYW5kIHRoZSBwdXJwb3NlIGZvclxyXG4gICAgICogcmUtbGlzdGVuaW5nLiBMaXN0ZW5zIGZvciB0aGVzZSB0YXJnZXRzIHNob3VsZCBiZSByZS1lc3RhYmxpc2hlZCB3aXRob3V0XHJcbiAgICAgKiByZXN1bWUgdG9rZW5zLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRNaXNtYXRjaGVzLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2Ygd2hpY2ggZG9jdW1lbnRzIGhhdmUgY2hhbmdlZCBvciBiZWVuIGRlbGV0ZWQsIGFsb25nIHdpdGggdGhlXHJcbiAgICAgKiBkb2MncyBuZXcgdmFsdWVzIChpZiBub3QgZGVsZXRlZCkuXHJcbiAgICAgKi9cclxuICAgIGRvY3VtZW50VXBkYXRlcywgXHJcbiAgICAvKipcclxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50IHVwZGF0ZXMgYXJlIGR1ZSBvbmx5IHRvIGxpbWJvIHJlc29sdXRpb24gdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cykge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RWZXJzaW9uID0gc25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q2hhbmdlcyA9IHRhcmdldENoYW5nZXM7XHJcbiAgICAgICAgdGhpcy50YXJnZXRNaXNtYXRjaGVzID0gdGFyZ2V0TWlzbWF0Y2hlcztcclxuICAgICAgICB0aGlzLmRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcztcclxuICAgICAgICB0aGlzLnJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIQUNLOiBWaWV3cyByZXF1aXJlIFJlbW90ZUV2ZW50cyBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgdmlldyBpc1xyXG4gICAgICogQ1VSUkVOVCwgYnV0IHNlY29uZGFyeSB0YWJzIGRvbid0IHJlY2VpdmUgcmVtb3RlIGV2ZW50cy4gU28gdGhpcyBtZXRob2QgaXNcclxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgUmVtb3RlRXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBhcHBseSBhXHJcbiAgICAgKiBDVVJSRU5UIHN0YXR1cyBjaGFuZ2UgdG8gYSBWaWV3LCBmb3IgcXVlcmllcyBleGVjdXRlZCBpbiBhIGRpZmZlcmVudCB0YWIuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcclxuICAgIHN0YXRpYyBjcmVhdGVTeW50aGVzaXplZFJlbW90ZUV2ZW50Rm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgY3VycmVudCwgcmVzdW1lVG9rZW4pIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRDaGFuZ2VzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCB0YXJnZXRDaGFuZ2VzLCBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpLCBtdXRhYmxlRG9jdW1lbnRNYXAoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgVGFyZ2V0Q2hhbmdlIHNwZWNpZmllcyB0aGUgc2V0IG9mIGNoYW5nZXMgZm9yIGEgc3BlY2lmaWMgdGFyZ2V0IGFzIHBhcnQgb2ZcclxuICogYSBSZW1vdGVFdmVudC4gVGhlc2UgY2hhbmdlcyB0cmFjayB3aGljaCBkb2N1bWVudHMgYXJlIGFkZGVkLCBtb2RpZmllZCBvclxyXG4gKiByZW1vdmVkLCBhcyB3ZWxsIGFzIHRoZSB0YXJnZXQncyByZXN1bWUgdG9rZW4gYW5kIHdoZXRoZXIgdGhlIHRhcmdldCBpc1xyXG4gKiBtYXJrZWQgQ1VSUkVOVC5cclxuICogVGhlIGFjdHVhbCBjaGFuZ2VzICp0byogZG9jdW1lbnRzIGFyZSBub3QgcGFydCBvZiB0aGUgVGFyZ2V0Q2hhbmdlIHNpbmNlXHJcbiAqIGRvY3VtZW50cyBtYXkgYmUgcGFydCBvZiBtdWx0aXBsZSB0YXJnZXRzLlxyXG4gKi9cclxuY2xhc3MgVGFyZ2V0Q2hhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHF1ZXJ5IHRvIGJlIHJlc3VtZWRcclxuICAgICAqIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdCBtYXRjaGVzIHRoZVxyXG4gICAgICogcXVlcnkuIFRoZSByZXN1bWUgdG9rZW4gZXNzZW50aWFsbHkgaWRlbnRpZmllcyBhIHBvaW50IGluIHRpbWUgZnJvbSB3aGljaFxyXG4gICAgICogdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lVG9rZW4sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgXCJjdXJyZW50XCIgKHN5bmNlZCkgc3RhdHVzIG9mIHRoaXMgdGFyZ2V0LiBOb3RlIHRoYXQgXCJjdXJyZW50XCJcclxuICAgICAqIGhhcyBzcGVjaWFsIG1lYW5pbmcgaW4gdGhlIFJQQyBwcm90b2NvbCB0aGF0IGltcGxpZXMgdGhhdCBhIHRhcmdldCBpc1xyXG4gICAgICogYm90aCB1cC10by1kYXRlIGFuZCBjb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHdhdGNoIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgY3VycmVudCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBuZXdseSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBhcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGlzIHJlbW90ZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgYWRkZWREb2N1bWVudHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgYWxyZWFkeSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBidXQgcmVjZWl2ZWRcclxuICAgICAqIGFuIHVwZGF0ZSBkdXJpbmcgdGhpcyByZW1vdGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIG1vZGlmaWVkRG9jdW1lbnRzLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIHRhcmdldCBhcyBwYXJ0IG9mIHRoaXNcclxuICAgICAqIHJlbW90ZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlZERvY3VtZW50cykge1xyXG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xyXG4gICAgICAgIHRoaXMuYWRkZWREb2N1bWVudHMgPSBhZGRlZERvY3VtZW50cztcclxuICAgICAgICB0aGlzLm1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHM7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVkRG9jdW1lbnRzID0gcmVtb3ZlZERvY3VtZW50cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgYSBzeW50aGVzaXplZCBUYXJnZXRDaGFuZ2VzIHRoYXQgY2FuIGJlIHVzZWQgdG9cclxuICAgICAqIGFwcGx5IGEgQ1VSUkVOVCBzdGF0dXMgY2hhbmdlIHRvIGEgVmlldyAoZm9yIHF1ZXJpZXMgZXhlY3V0ZWQgaW4gYSBkaWZmZXJlbnRcclxuICAgICAqIHRhYikgb3IgZm9yIG5ldyBxdWVyaWVzICh0byByYWlzZSBzbmFwc2hvdHMgd2l0aCBjb3JyZWN0IENVUlJFTlQgc3RhdHVzKS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlRm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgY3VycmVudCwgcmVzdW1lVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZShyZXN1bWVUb2tlbiwgY3VycmVudCwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjaGFuZ2VkIGRvY3VtZW50IGFuZCBhIGxpc3Qgb2YgdGFyZ2V0IGlkcyB0byB3aGljaCB0aGlzIGNoYW5nZVxyXG4gKiBhcHBsaWVzLlxyXG4gKlxyXG4gKiBJZiBkb2N1bWVudCBoYXMgYmVlbiBkZWxldGVkIE5vRG9jdW1lbnQgd2lsbCBiZSBwcm92aWRlZC5cclxuICovXHJcbmNsYXNzIERvY3VtZW50V2F0Y2hDaGFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIG5ldyBkb2N1bWVudCBhcHBsaWVzIHRvIGFsbCBvZiB0aGVzZSB0YXJnZXRzLiAqL1xyXG4gICAgdXBkYXRlZFRhcmdldElkcywgXHJcbiAgICAvKiogVGhlIG5ldyBkb2N1bWVudCBpcyByZW1vdmVkIGZyb20gYWxsIG9mIHRoZXNlIHRhcmdldHMuICovXHJcbiAgICByZW1vdmVkVGFyZ2V0SWRzLCBcclxuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBkb2N1bWVudCBmb3IgdGhpcyBjaGFuZ2UuICovXHJcbiAgICBrZXksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmV3IGRvY3VtZW50IG9yIE5vRG9jdW1lbnQgaWYgaXQgd2FzIGRlbGV0ZWQuIElzIG51bGwgaWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCB3ZW50IG91dCBvZiB2aWV3IHdpdGhvdXQgdGhlIHNlcnZlciBzZW5kaW5nIGEgbmV3IGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICBuZXdEb2MpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZWRUYXJnZXRJZHMgPSB1cGRhdGVkVGFyZ2V0SWRzO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlZFRhcmdldElkcyA9IHJlbW92ZWRUYXJnZXRJZHM7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5uZXdEb2MgPSBuZXdEb2M7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldElkLCBleGlzdGVuY2VGaWx0ZXIpIHtcclxuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy5leGlzdGVuY2VGaWx0ZXIgPSBleGlzdGVuY2VGaWx0ZXI7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgV2F0Y2hUYXJnZXRDaGFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogV2hhdCBraW5kIG9mIGNoYW5nZSBvY2N1cnJlZCB0byB0aGUgd2F0Y2ggdGFyZ2V0LiAqL1xyXG4gICAgc3RhdGUsIFxyXG4gICAgLyoqIFRoZSB0YXJnZXQgSURzIHRoYXQgd2VyZSBhZGRlZC9yZW1vdmVkL3NldC4gKi9cclxuICAgIHRhcmdldElkcywgXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9wYXF1ZSwgc2VydmVyLWFzc2lnbmVkIHRva2VuIHRoYXQgYWxsb3dzIHdhdGNoaW5nIGEgdGFyZ2V0IHRvIGJlXHJcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxyXG4gICAgICogbWF0Y2hlcyB0aGUgdGFyZ2V0LiBUaGUgcmVzdW1lIHRva2VuIGVzc2VudGlhbGx5IGlkZW50aWZpZXMgYSBwb2ludCBpblxyXG4gICAgICogdGltZSBmcm9tIHdoaWNoIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlc3VtZSBzZW5kaW5nIHJlc3VsdHMuXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORywgXHJcbiAgICAvKiogQW4gUlBDIGVycm9yIGluZGljYXRpbmcgd2h5IHRoZSB3YXRjaCBmYWlsZWQuICovXHJcbiAgICBjYXVzZSA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy50YXJnZXRJZHMgPSB0YXJnZXRJZHM7XHJcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xyXG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcclxuICAgIH1cclxufVxyXG4vKiogVHJhY2tzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhIFdhdGNoIHRhcmdldC4gKi9cclxuY2xhc3MgVGFyZ2V0U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBwZW5kaW5nIHJlc3BvbnNlcyAoYWRkcyBvciByZW1vdmVzKSB0aGF0IHdlIGFyZSB3YWl0aW5nIG9uLlxyXG4gICAgICAgICAqIFdlIG9ubHkgY29uc2lkZXIgdGFyZ2V0cyBhY3RpdmUgdGhhdCBoYXZlIG5vIHBlbmRpbmcgcmVzcG9uc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGRvY3VtZW50IGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgcmFpc2VkIHNuYXBzaG90LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlc2UgY2hhbmdlcyBhcmUgY29udGludW91c2x5IHVwZGF0ZWQgYXMgd2UgcmVjZWl2ZSBkb2N1bWVudCB1cGRhdGVzIGFuZFxyXG4gICAgICAgICAqIGFsd2F5cyByZWZsZWN0IHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzIGFnYWluc3QgdGhlIGxhc3QgaXNzdWVkIHNuYXBzaG90LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gc25hcHNob3RDaGFuZ2VzTWFwKCk7XHJcbiAgICAgICAgLyoqIFNlZSBwdWJsaWMgZ2V0dGVycyBmb3IgZXhwbGFuYXRpb25zIG9mIHRoZXNlIGZpZWxkcy4gKi9cclxuICAgICAgICB0aGlzLl9yZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkc7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyB0YXJnZXQgc3RhdGUgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBuZXh0IHNuYXBzaG90LiBXZVxyXG4gICAgICAgICAqIGluaXRpYWxpemUgdG8gdHJ1ZSBzbyB0aGF0IG5ld2x5LWFkZGVkIHRhcmdldHMgYXJlIGluY2x1ZGVkIGluIHRoZSBuZXh0XHJcbiAgICAgICAgICogUmVtb3RlRXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IGhhcyBiZWVuIG1hcmtlZCAnY3VycmVudCcuXHJcbiAgICAgKlxyXG4gICAgICogJ0N1cnJlbnQnIGhhcyBzcGVjaWFsIG1lYW5pbmcgaW4gdGhlIFJQQyBwcm90b2NvbDogSXQgaW1wbGllcyB0aGF0IHRoZVxyXG4gICAgICogV2F0Y2ggYmFja2VuZCBoYXMgc2VudCB1cyBhbGwgY2hhbmdlcyB1cCB0byB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIHRhcmdldFxyXG4gICAgICogd2FzIGFkZGVkIGFuZCB0aGF0IHRoZSB0YXJnZXQgaXMgY29uc2lzdGVudCB3aXRoIHRoZSByZXN0IG9mIHRoZSB3YXRjaFxyXG4gICAgICogc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICBnZXQgY3VycmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgbGFzdCByZXN1bWUgdG9rZW4gc2VudCB0byB1cyBmb3IgdGhpcyB0YXJnZXQuICovXHJcbiAgICBnZXQgcmVzdW1lVG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VtZVRva2VuO1xyXG4gICAgfVxyXG4gICAgLyoqIFdoZXRoZXIgdGhpcyB0YXJnZXQgaGFzIHBlbmRpbmcgdGFyZ2V0IGFkZHMgb3IgdGFyZ2V0IHJlbW92ZXMuICovXHJcbiAgICBnZXQgaXNQZW5kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXNwb25zZXMgIT09IDA7XHJcbiAgICB9XHJcbiAgICAvKiogV2hldGhlciB3ZSBoYXZlIG1vZGlmaWVkIGFueSBzdGF0ZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgc25hcHNob3QuICovXHJcbiAgICBnZXQgaGFzUGVuZGluZ0NoYW5nZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSByZXN1bWUgdG9rZW4gdG8gdGhlIFRhcmdldENoYW5nZSwgYnV0IG9ubHkgd2hlbiBpdCBoYXMgYSBuZXdcclxuICAgICAqIHZhbHVlLiBFbXB0eSByZXN1bWVUb2tlbnMgYXJlIGRpc2NhcmRlZC5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlUmVzdW1lVG9rZW4ocmVzdW1lVG9rZW4pIHtcclxuICAgICAgICBpZiAocmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc3VtZVRva2VuID0gcmVzdW1lVG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdGFyZ2V0IGNoYW5nZSBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIFRvIHJlc2V0IHRoZSBkb2N1bWVudCBjaGFuZ2VzIGFmdGVyIHJhaXNpbmcgdGhpcyBzbmFwc2hvdCwgY2FsbFxyXG4gICAgICogYGNsZWFyUGVuZGluZ0NoYW5nZXMoKWAuXHJcbiAgICAgKi9cclxuICAgIHRvVGFyZ2V0Q2hhbmdlKCkge1xyXG4gICAgICAgIGxldCBhZGRlZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBsZXQgcmVtb3ZlZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMuZm9yRWFjaCgoa2V5LCBjaGFuZ2VUeXBlKSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWREb2N1bWVudHMgPSBhZGRlZERvY3VtZW50cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHMgPSByZW1vdmVkRG9jdW1lbnRzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZSh0aGlzLl9yZXN1bWVUb2tlbiwgdGhpcy5fY3VycmVudCwgYWRkZWREb2N1bWVudHMsIG1vZGlmaWVkRG9jdW1lbnRzLCByZW1vdmVkRG9jdW1lbnRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBkb2N1bWVudCBjaGFuZ2VzIGFuZCBzZXRzIGBoYXNQZW5kaW5nQ2hhbmdlc2AgdG8gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyUGVuZGluZ0NoYW5nZXMoKSB7XHJcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHNuYXBzaG90Q2hhbmdlc01hcCgpO1xyXG4gICAgfVxyXG4gICAgYWRkRG9jdW1lbnRDaGFuZ2Uoa2V5LCBjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gdGhpcy5kb2N1bWVudENoYW5nZXMuaW5zZXJ0KGtleSwgY2hhbmdlVHlwZSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVEb2N1bWVudENoYW5nZShrZXkpIHtcclxuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSB0aGlzLmRvY3VtZW50Q2hhbmdlcy5yZW1vdmUoa2V5KTtcclxuICAgIH1cclxuICAgIHJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyArPSAxO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkVGFyZ2V0UmVzcG9uc2UoKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzIC09IDE7XHJcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnBlbmRpbmdSZXNwb25zZXMgPj0gMCk7XHJcbiAgICB9XHJcbiAgICBtYXJrQ3VycmVudCgpIHtcclxuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgTE9HX1RBRyRnID0gJ1dhdGNoQ2hhbmdlQWdncmVnYXRvcic7XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBjbGFzcyB0byBhY2N1bXVsYXRlIHdhdGNoIGNoYW5nZXMgaW50byBhIFJlbW90ZUV2ZW50LlxyXG4gKi9cclxuY2xhc3MgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhUHJvdmlkZXIgPSBtZXRhZGF0YVByb3ZpZGVyO1xyXG4gICAgICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgYWxsIHRyYWNrZWQgdGFyZ2V0cy4gKi9cclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGRvY3VtZW50cyB0byB1cGRhdGUgc2luY2UgdGhlIGxhc3QgcmFpc2VkIHNuYXBzaG90LiAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIC8qKiBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5cyB0byB0aGVpciBzZXQgb2YgdGFyZ2V0IElEcy4gKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPSBkb2N1bWVudFRhcmdldE1hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbWFwIG9mIHRhcmdldHMgd2l0aCBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuIFRoZXNlIHRhcmdldHMgYXJlXHJcbiAgICAgICAgICoga25vd24gdG8gYmUgaW5jb25zaXN0ZW50IGFuZCB0aGVpciBsaXN0ZW5zIG5lZWRzIHRvIGJlIHJlLWVzdGFibGlzaGVkIGJ5XHJcbiAgICAgICAgICogUmVtb3RlU3RvcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2Vzc2VzIGFuZCBhZGRzIHRoZSBEb2N1bWVudFdhdGNoQ2hhbmdlIHRvIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVEb2N1bWVudENoYW5nZShkb2NDaGFuZ2UpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIGRvY0NoYW5nZS51cGRhdGVkVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgICAgIGlmIChkb2NDaGFuZ2UubmV3RG9jICYmIGRvY0NoYW5nZS5uZXdEb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnRUb1RhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLm5ld0RvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLmtleSwgZG9jQ2hhbmdlLm5ld0RvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UucmVtb3ZlZFRhcmdldElkcykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLmtleSwgZG9jQ2hhbmdlLm5ld0RvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFByb2Nlc3NlcyBhbmQgYWRkcyB0aGUgV2F0Y2hUYXJnZXRDaGFuZ2UgdG8gdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMuICovXHJcbiAgICBoYW5kbGVUYXJnZXRDaGFuZ2UodGFyZ2V0Q2hhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoVGFyZ2V0KHRhcmdldENoYW5nZSwgdGFyZ2V0SWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRhcmdldENoYW5nZS5zdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuTm9DaGFuZ2UgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuQWRkZWQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFja3MgbmVlZGVkIGZyb20gd2F0Y2hcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhpcyB0YXJnZXRJZC5cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRUYXJnZXRSZXNwb25zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0U3RhdGUuaXNQZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBmcmVzaGx5IGFkZGVkIHRhcmdldCwgc28gd2UgbmVlZCB0byByZXNldCBhbnkgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3ZSBoYWQgcHJldmlvdXNseS4gVGhpcyBjYW4gaGFwcGVuIGUuZy4gd2hlbiByZW1vdmUgYW5kIGFkZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGEgdGFyZ2V0IGZvciBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLmNsZWFyUGVuZGluZ0NoYW5nZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLlJlbW92ZWQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHJlbW92ZWQgdGFyZ2V0cyB0byB3ZSBjYW4gcG9zdC1maWx0ZXIgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSB0YXJnZXQgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlY3JlbWVudCB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYWNrcyBuZWVkZWQgZnJvbSB3YXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGlzIHRhcmdldElkLlxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFRhcmdldFJlc3BvbnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS5pc1BlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLm1hcmtDdXJyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0YXJnZXQgYW5kIHN5bnRoZXNpemVzIHJlbW92ZXMgZm9yIGFsbCBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudHMuIFRoZSBiYWNrZW5kIHdpbGwgcmUtYWRkIGFueSBkb2N1bWVudHMgdGhhdCBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGUgdGFyZ2V0IGJlZm9yZSBpdCBzZW5kcyB0aGUgbmV4dCBnbG9iYWwgc25hcHNob3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIHRhcmdldElkcyB0aGF0IHRoZSB3YXRjaCBjaGFuZ2UgYXBwbGllcyB0bzogZWl0aGVyIHRoZVxyXG4gICAgICogdGFyZ2V0SWRzIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBjaGFuZ2Ugb3IgdGhlIHRhcmdldElkcyBvZiBhbGwgY3VycmVudGx5XHJcbiAgICAgKiBhY3RpdmUgdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaFRhcmdldCh0YXJnZXRDaGFuZ2UsIGZuKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldENoYW5nZS50YXJnZXRJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmZvckVhY2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGV4aXN0ZW5jZSBmaWx0ZXJzIGFuZCBzeW50aGVzaXplcyBkZWxldGVzIGZvciBmaWx0ZXIgbWlzbWF0Y2hlcy5cclxuICAgICAqIFRhcmdldHMgdGhhdCBhcmUgaW52YWxpZGF0ZWQgYnkgZmlsdGVyIG1pc21hdGNoZXMgYXJlIGFkZGVkIHRvXHJcbiAgICAgKiBgcGVuZGluZ1RhcmdldFJlc2V0c2AuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUV4aXN0ZW5jZUZpbHRlcih3YXRjaENoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gd2F0Y2hDaGFuZ2UudGFyZ2V0SWQ7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlci5jb3VudDtcclxuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXREYXRhLnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXhpc3RlbmNlIGZpbHRlciB0b2xkIHVzIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBleGlzdC4gV2UgZGVkdWNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0IGFuZCBhcHBseSBhIGRlbGV0ZWQgZG9jdW1lbnQgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyBvdXIgdXBkYXRlcy4gV2l0aG91dCBhcHBseWluZyB0aGlzIGRlbGV0ZWQgZG9jdW1lbnQgdGhlcmUgbWlnaHQgYmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbm90aGVyIHF1ZXJ5IHRoYXQgd2lsbCByYWlzZSB0aGlzIGRvY3VtZW50IGFzIHBhcnQgb2YgYSBzbmFwc2hvdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIGl0IGlzIHJlc29sdmVkLCBlc3NlbnRpYWxseSBleHBvc2luZyBpbmNvbnNpc3RlbmN5IGJldHdlZW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBxdWVyaWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleSh0YXJnZXQucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZXhwZWN0ZWRDb3VudCA9PT0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHRoaXMuZ2V0Q3VycmVudERvY3VtZW50Q291bnRGb3JUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gRXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC4gTWFyayB0aGUgZG9jdW1lbnRzIGFzIGJlaW5nIGluIGxpbWJvLCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIHJhaXNlIGEgc25hcHNob3Qgd2l0aCBgaXNGcm9tQ2FjaGU6dHJ1ZWAuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNpemUgIT09IGV4cGVjdGVkQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBibG9vbSBmaWx0ZXIgdG8gaWRlbnRpZnkgYW5kIG1hcmsgcmVtb3ZlZCBkb2N1bWVudHMuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSB0aGlzLnBhcnNlQmxvb21GaWx0ZXIod2F0Y2hDaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGJsb29tRmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5hcHBseUJsb29tRmlsdGVyKGJsb29tRmlsdGVyLCB3YXRjaENoYW5nZSwgY3VycmVudFNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlNraXBwZWQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlN1Y2Nlc3MgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYmxvb20gZmlsdGVyIGFwcGxpY2F0aW9uIGZhaWxzLCB3ZSByZXNldCB0aGUgbWFwcGluZyBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciByZS1ydW4gb2YgdGhlIHF1ZXJ5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVycG9zZSA9IHN0YXR1cyA9PT0gMiAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLkZhbHNlUG9zaXRpdmUgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hCbG9vbVwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hCbG9vbSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaFwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cyA9IHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cy5pbnNlcnQodGFyZ2V0SWQsIHB1cnBvc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZXN0aW5nSG9va3NTcGkgPT09IG51bGwgfHwgdGVzdGluZ0hvb2tzU3BpID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXN0aW5nSG9va3NTcGkubm90aWZ5T25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjcmVhdGVFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEluZm9Gb3JUZXN0aW5nSG9va3MoY3VycmVudFNpemUsIHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlciwgdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldERhdGFiYXNlSWQoKSwgYmxvb21GaWx0ZXIsIHN0YXR1cykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgYmxvb20gZmlsdGVyIGZyb20gdGhlIFwidW5jaGFuZ2VkX25hbWVzXCIgZmllbGQgb2YgYW4gZXhpc3RlbmNlXHJcbiAgICAgKiBmaWx0ZXIuXHJcbiAgICAgKi9cclxuICAgIHBhcnNlQmxvb21GaWx0ZXIod2F0Y2hDaGFuZ2UpIHtcclxuICAgICAgICBjb25zdCB1bmNoYW5nZWROYW1lcyA9IHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlci51bmNoYW5nZWROYW1lcztcclxuICAgICAgICBpZiAoIXVuY2hhbmdlZE5hbWVzIHx8ICF1bmNoYW5nZWROYW1lcy5iaXRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJpdHM6IHsgYml0bWFwID0gJycsIHBhZGRpbmcgPSAwIH0sIGhhc2hDb3VudCA9IDAgfSA9IHVuY2hhbmdlZE5hbWVzO1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkQml0bWFwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRCaXRtYXAgPSBub3JtYWxpemVCeXRlU3RyaW5nKGJpdG1hcCkudG9VaW50OEFycmF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJhc2U2NERlY29kZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdEZWNvZGluZyB0aGUgYmFzZTY0IGJsb29tIGZpbHRlciBpbiBleGlzdGVuY2UgZmlsdGVyIGZhaWxlZCAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgK1xyXG4gICAgICAgICAgICAgICAgICAgICcpOyBpZ25vcmluZyB0aGUgYmxvb20gZmlsdGVyIGFuZCBmYWxsaW5nIGJhY2sgdG8gZnVsbCByZS1xdWVyeS4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBibG9vbUZpbHRlcjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBCbG9vbUZpbHRlciB0aHJvd3MgZXJyb3IgaWYgdGhlIGlucHV0cyBhcmUgaW52YWxpZC5cclxuICAgICAgICAgICAgYmxvb21GaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIobm9ybWFsaXplZEJpdG1hcCwgcGFkZGluZywgaGFzaENvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQmxvb21GaWx0ZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgbG9nV2FybignQmxvb21GaWx0ZXIgZXJyb3I6ICcsIGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdBcHBseWluZyBibG9vbSBmaWx0ZXIgZmFpbGVkOiAnLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmxvb21GaWx0ZXIuYml0Q291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBibG9vbUZpbHRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYmxvb20gZmlsdGVyIHRvIHJlbW92ZSB0aGUgZGVsZXRlZCBkb2N1bWVudHMsIGFuZCByZXR1cm4gdGhlXHJcbiAgICAgKiBhcHBsaWNhdGlvbiBzdGF0dXMuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50Q291bnQpIHtcclxuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLmNvdW50O1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWREb2N1bWVudENvdW50ID0gdGhpcy5maWx0ZXJSZW1vdmVkRG9jdW1lbnRzKGJsb29tRmlsdGVyLCB3YXRjaENoYW5nZS50YXJnZXRJZCk7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQ291bnQgPT09IGN1cnJlbnRDb3VudCAtIHJlbW92ZWREb2N1bWVudENvdW50XHJcbiAgICAgICAgICAgID8gMCAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlN1Y2Nlc3MgKi9cclxuICAgICAgICAgICAgOiAyIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuRmFsc2VQb3NpdGl2ZSAqLztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmlsdGVyIG91dCByZW1vdmVkIGRvY3VtZW50cyBiYXNlZCBvbiBibG9vbSBmaWx0ZXIgbWVtYmVyc2hpcCByZXN1bHQgYW5kXHJcbiAgICAgKiByZXR1cm4gbnVtYmVyIG9mIGRvY3VtZW50cyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBmaWx0ZXJSZW1vdmVkRG9jdW1lbnRzKGJsb29tRmlsdGVyLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBsZXQgcmVtb3ZhbENvdW50ID0gMDtcclxuICAgICAgICBleGlzdGluZ0tleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldERhdGFiYXNlSWQoKTtcclxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRQYXRoID0gYHByb2plY3RzLyR7ZGF0YWJhc2VJZC5wcm9qZWN0SWR9YCArXHJcbiAgICAgICAgICAgICAgICBgL2RhdGFiYXNlcy8ke2RhdGFiYXNlSWQuZGF0YWJhc2V9YCArXHJcbiAgICAgICAgICAgICAgICBgL2RvY3VtZW50cy8ke2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpfWA7XHJcbiAgICAgICAgICAgIGlmICghYmxvb21GaWx0ZXIubWlnaHRDb250YWluKGRvY3VtZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIC8qdXBkYXRlZERvY3VtZW50PSovIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZhbENvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVtb3ZhbENvdW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudGx5IGFjY3VtdWxhdGVkIHN0YXRlIGludG8gYSByZW1vdGUgZXZlbnQgYXQgdGhlXHJcbiAgICAgKiBwcm92aWRlZCBzbmFwc2hvdCB2ZXJzaW9uLiBSZXNldHMgdGhlIGFjY3VtdWxhdGVkIGNoYW5nZXMgYmVmb3JlIHJldHVybmluZy5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5mb3JFYWNoKCh0YXJnZXRTdGF0ZSwgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U3RhdGUuY3VycmVudCAmJiB0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IHF1ZXJpZXMgZm9yIGRvY3VtZW50IHRoYXQgZG9uJ3QgZXhpc3QgY2FuIHByb2R1Y2UgYW4gZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgc2V0LiBUbyB1cGRhdGUgb3VyIGxvY2FsIGNhY2hlLCB3ZSBzeW50aGVzaXplIGEgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgaWYgd2UgaGF2ZSBub3QgcHJldmlvdXNseSByZWNlaXZlZCB0aGUgZG9jdW1lbnQuIFRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlcyB0aGUgbGltYm8gc3RhdGUgb2YgdGhlIGRvY3VtZW50LCByZW1vdmluZyBpdCBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGltYm9Eb2N1bWVudFJlZnMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhbiBleHBsaWNpdCBsb29rdXAgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCByZXN1bHRpbmcgaW4gYW4gZXhwbGljaXQgZGVsZXRlIG1lc3NhZ2UgYW5kIHdlIGNvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgc3BlY2lhbCBsb2dpYy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkodGFyZ2V0RGF0YS50YXJnZXQucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcy5nZXQoa2V5KSA9PT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXRlLmhhc1BlbmRpbmdDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlcy5zZXQodGFyZ2V0SWQsIHRhcmdldFN0YXRlLnRvVGFyZ2V0Q2hhbmdlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLmNsZWFyUGVuZGluZ0NoYW5nZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICAvLyBXZSBleHRyYWN0IHRoZSBzZXQgb2YgbGltYm8tb25seSBkb2N1bWVudCB1cGRhdGVzIGFzIHRoZSBHQyBsb2dpY1xyXG4gICAgICAgIC8vIHNwZWNpYWwtY2FzZXMgZG9jdW1lbnRzIHRoYXQgZG8gbm90IGFwcGVhciBpbiB0aGUgdGFyZ2V0IGNhY2hlLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVE9ETyhnc29sdGlzKTogRXhwYW5kIG9uIHRoaXMgY29tbWVudCBvbmNlIEdDIGlzIGF2YWlsYWJsZSBpbiB0aGUgSlNcclxuICAgICAgICAvLyBjbGllbnQuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmZvckVhY2goKGtleSwgdGFyZ2V0cykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaXNPbmx5TGltYm9UYXJnZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0YXJnZXRzLmZvckVhY2hXaGlsZSh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXREYXRhICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YS5wdXJwb3NlICE9PSBcIlRhcmdldFB1cnBvc2VMaW1ib1Jlc29sdXRpb25cIiAvKiBUYXJnZXRQdXJwb3NlLkxpbWJvUmVzb2x1dGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzT25seUxpbWJvVGFyZ2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNPbmx5TGltYm9UYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmZvckVhY2goKF8sIGRvYykgPT4gZG9jLnNldFJlYWRUaW1lKHNuYXBzaG90VmVyc2lvbikpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gbmV3IFJlbW90ZUV2ZW50KHNuYXBzaG90VmVyc2lvbiwgdGFyZ2V0Q2hhbmdlcywgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzLCB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMsIHJlc29sdmVkTGltYm9Eb2N1bWVudHMpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9IGRvY3VtZW50VGFyZ2V0TWFwKCk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlRXZlbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHByb3ZpZGVkIGRvY3VtZW50IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGRvY3VtZW50IHVwZGF0ZXMgYW5kXHJcbiAgICAgKiBpdHMgZG9jdW1lbnQga2V5IHRvIHRoZSBnaXZlbiB0YXJnZXQncyBtYXBwaW5nLlxyXG4gICAgICovXHJcbiAgICAvLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gICAgYWRkRG9jdW1lbnRUb1RhcmdldCh0YXJnZXRJZCwgZG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hhbmdlVHlwZSA9IHRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwgZG9jdW1lbnQua2V5KVxyXG4gICAgICAgICAgICA/IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqL1xyXG4gICAgICAgICAgICA6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLztcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xyXG4gICAgICAgIHRhcmdldFN0YXRlLmFkZERvY3VtZW50Q2hhbmdlKGRvY3VtZW50LmtleSwgY2hhbmdlVHlwZSk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuaW5zZXJ0KGRvY3VtZW50LmtleSwgdGhpcy5lbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoZG9jdW1lbnQua2V5KS5hZGQodGFyZ2V0SWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgZnJvbSB0aGUgdGFyZ2V0IG1hcHBpbmcuIElmIHRoZVxyXG4gICAgICogZG9jdW1lbnQgbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIHRhcmdldCwgYnV0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGlzIHN0aWxsXHJcbiAgICAgKiBrbm93biAoZS5nLiB3ZSBrbm93IHRoYXQgdGhlIGRvY3VtZW50IHdhcyBkZWxldGVkIG9yIHdlIHJlY2VpdmVkIHRoZSBjaGFuZ2VcclxuICAgICAqIHRoYXQgY2F1c2VkIHRoZSBmaWx0ZXIgbWlzbWF0Y2gpLCB0aGUgbmV3IGRvY3VtZW50IGNhbiBiZSBwcm92aWRlZFxyXG4gICAgICogdG8gdXBkYXRlIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIC8vIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbiAgICByZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgdXBkYXRlZERvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwga2V5KSkge1xyXG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShrZXksIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBtYXkgaGF2ZSBlbnRlcmVkIGFuZCBsZWZ0IHRoZSB0YXJnZXQgYmVmb3JlIHdlIHJhaXNlZCBhXHJcbiAgICAgICAgICAgIC8vIHNuYXBzaG90LCBzbyB3ZSBjYW4ganVzdCBpZ25vcmUgdGhlIGNoYW5nZS5cclxuICAgICAgICAgICAgdGFyZ2V0U3RhdGUucmVtb3ZlRG9jdW1lbnRDaGFuZ2Uoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChrZXksIHRoaXMuZW5zdXJlRG9jdW1lbnRUYXJnZXRNYXBwaW5nKGtleSkuZGVsZXRlKHRhcmdldElkKSk7XHJcbiAgICAgICAgaWYgKHVwZGF0ZWREb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGtleSwgdXBkYXRlZERvY3VtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvdW50IG9mIGRvY3VtZW50cyBpbiB0aGUgdGFyZ2V0LiBUaGlzIGluY2x1ZGVzIGJvdGhcclxuICAgICAqIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgdGhlIExvY2FsU3RvcmUgY29uc2lkZXJzIHRvIGJlIHBhcnQgb2YgdGhlXHJcbiAgICAgKiB0YXJnZXQgYXMgd2VsbCBhcyBhbnkgYWNjdW11bGF0ZWQgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudERvY3VtZW50Q291bnRGb3JUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IHRhcmdldFN0YXRlLnRvVGFyZ2V0Q2hhbmdlKCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCkuc2l6ZSArXHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplIC1cclxuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuc2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGFja3MgbmVlZGVkIGZyb20gd2F0Y2ggYmVmb3JlIHdlIGNhbiBjb25zaWRlciB0aGVcclxuICAgICAqIHNlcnZlciB0byBiZSAnaW4tc3luYycgd2l0aCB0aGUgY2xpZW50J3MgYWN0aXZlIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIHJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKSB7XHJcbiAgICAgICAgLy8gRm9yIGVhY2ggcmVxdWVzdCB3ZSBnZXQgd2UgbmVlZCB0byByZWNvcmQgd2UgbmVlZCBhIHJlc3BvbnNlIGZvciBpdC5cclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xyXG4gICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KCk7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnRhcmdldFN0YXRlcy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUYXJnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoa2V5KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRhcmdldE1hcHBpbmcgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChrZXksIHRhcmdldE1hcHBpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBpcyBzdGlsbCBpbnRlcmVzdGVkIGluIHRoaXMgdGFyZ2V0IChieSBjYWxsaW5nXHJcbiAgICAgKiBgZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCgpYCkgYW5kIHRoYXQgd2UgYXJlIG5vdCB3YWl0aW5nIGZvciBwZW5kaW5nIEFERHNcclxuICAgICAqIGZyb20gd2F0Y2guXHJcbiAgICAgKi9cclxuICAgIGlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0QWN0aXZlID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKSAhPT0gbnVsbDtcclxuICAgICAgICBpZiAoIXRhcmdldEFjdGl2ZSkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGcsICdEZXRlY3RlZCBpbmFjdGl2ZSB0YXJnZXQnLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXRBY3RpdmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgZm9yIGFuIGFjdGl2ZSB0YXJnZXQgKGkuZS4gYSB0YXJnZXQgdGhhdCB0aGUgdXNlclxyXG4gICAgICogaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGF0IGhhcyBubyBvdXRzdGFuZGluZyB0YXJnZXQgY2hhbmdlIHJlcXVlc3RzKS5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy50YXJnZXRTdGF0ZXMuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGUgJiYgdGFyZ2V0U3RhdGUuaXNQZW5kaW5nXHJcbiAgICAgICAgICAgID8gbnVsbFxyXG4gICAgICAgICAgICA6IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBzdGF0ZSBvZiBhIFdhdGNoIHRhcmdldCB0byBpdHMgaW5pdGlhbCBzdGF0ZSAoZS5nLiBzZXRzXHJcbiAgICAgKiAnY3VycmVudCcgdG8gZmFsc2UsIGNsZWFycyB0aGUgcmVzdW1lIHRva2VuIGFuZCByZW1vdmVzIGl0cyB0YXJnZXQgbWFwcGluZ1xyXG4gICAgICogZnJvbSBhbGwgZG9jdW1lbnRzKS5cclxuICAgICAqL1xyXG4gICAgcmVzZXRUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIG5ldyBUYXJnZXRTdGF0ZSgpKTtcclxuICAgICAgICAvLyBUcmlnZ2VyIHJlbW92YWwgZm9yIGFueSBkb2N1bWVudHMgY3VycmVudGx5IG1hcHBlZCB0byB0aGlzIHRhcmdldC5cclxuICAgICAgICAvLyBUaGVzZSByZW1vdmFscyB3aWxsIGJlIHBhcnQgb2YgdGhlIGluaXRpYWwgc25hcHNob3QgaWYgV2F0Y2ggZG9lcyBub3RcclxuICAgICAgICAvLyByZXNlbmQgdGhlc2UgZG9jdW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBleGlzdGluZ0tleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCAvKnVwZGF0ZWREb2N1bWVudD0qLyBudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBMb2NhbFN0b3JlIGNvbnNpZGVycyB0aGUgZG9jdW1lbnQgdG8gYmUgcGFydCBvZiB0aGVcclxuICAgICAqIHNwZWNpZmllZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXlzLmhhcyhrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvY3VtZW50VGFyZ2V0TWFwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gc25hcHNob3RDaGFuZ2VzTWFwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGxvY2FsQ2FjaGVDb3VudCwgZXhpc3RlbmNlRmlsdGVyLCBkYXRhYmFzZUlkLCBibG9vbUZpbHRlciwgYmxvb21GaWx0ZXJTdGF0dXMpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGxvY2FsQ2FjaGVDb3VudCxcclxuICAgICAgICBleGlzdGVuY2VGaWx0ZXJDb3VudDogZXhpc3RlbmNlRmlsdGVyLmNvdW50LFxyXG4gICAgICAgIGRhdGFiYXNlSWQ6IGRhdGFiYXNlSWQuZGF0YWJhc2UsXHJcbiAgICAgICAgcHJvamVjdElkOiBkYXRhYmFzZUlkLnByb2plY3RJZFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVuY2hhbmdlZE5hbWVzID0gZXhpc3RlbmNlRmlsdGVyLnVuY2hhbmdlZE5hbWVzO1xyXG4gICAgaWYgKHVuY2hhbmdlZE5hbWVzKSB7XHJcbiAgICAgICAgcmVzdWx0LmJsb29tRmlsdGVyID0ge1xyXG4gICAgICAgICAgICBhcHBsaWVkOiBibG9vbUZpbHRlclN0YXR1cyA9PT0gMCAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlN1Y2Nlc3MgKi8sXHJcbiAgICAgICAgICAgIGhhc2hDb3VudDogKF9hID0gdW5jaGFuZ2VkTmFtZXMgPT09IG51bGwgfHwgdW5jaGFuZ2VkTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuY2hhbmdlZE5hbWVzLmhhc2hDb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcclxuICAgICAgICAgICAgYml0bWFwTGVuZ3RoOiAoX2QgPSAoX2MgPSAoX2IgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuYml0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJpdG1hcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCxcclxuICAgICAgICAgICAgcGFkZGluZzogKF9mID0gKF9lID0gdW5jaGFuZ2VkTmFtZXMgPT09IG51bGwgfHwgdW5jaGFuZ2VkTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuY2hhbmdlZE5hbWVzLmJpdHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwLFxyXG4gICAgICAgICAgICBtaWdodENvbnRhaW46ICh2YWx1ZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBibG9vbUZpbHRlciA9PT0gbnVsbCB8fCBibG9vbUZpbHRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvb21GaWx0ZXIubWlnaHRDb250YWluKHZhbHVlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7IH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBESVJFQ1RJT05TID0gKCgpID0+IHtcclxuICAgIGNvbnN0IGRpcnMgPSB7fTtcclxuICAgIGRpcnNbXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXSA9ICdBU0NFTkRJTkcnO1xyXG4gICAgZGlyc1tcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqL10gPSAnREVTQ0VORElORyc7XHJcbiAgICByZXR1cm4gZGlycztcclxufSkoKTtcclxuY29uc3QgT1BFUkFUT1JTID0gKCgpID0+IHtcclxuICAgIGNvbnN0IG9wcyA9IHt9O1xyXG4gICAgb3BzW1wiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqL10gPSAnTEVTU19USEFOJztcclxuICAgIG9wc1tcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovXSA9ICdMRVNTX1RIQU5fT1JfRVFVQUwnO1xyXG4gICAgb3BzW1wiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqL10gPSAnR1JFQVRFUl9USEFOJztcclxuICAgIG9wc1tcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovXSA9ICdHUkVBVEVSX1RIQU5fT1JfRVFVQUwnO1xyXG4gICAgb3BzW1wiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqL10gPSAnRVFVQUwnO1xyXG4gICAgb3BzW1wiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi9dID0gJ05PVF9FUVVBTCc7XHJcbiAgICBvcHNbXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovXSA9ICdBUlJBWV9DT05UQUlOUyc7XHJcbiAgICBvcHNbXCJpblwiIC8qIE9wZXJhdG9yLklOICovXSA9ICdJTic7XHJcbiAgICBvcHNbXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dID0gJ05PVF9JTic7XHJcbiAgICBvcHNbXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi9dID0gJ0FSUkFZX0NPTlRBSU5TX0FOWSc7XHJcbiAgICByZXR1cm4gb3BzO1xyXG59KSgpO1xyXG5jb25zdCBDT01QT1NJVEVfT1BFUkFUT1JTID0gKCgpID0+IHtcclxuICAgIGNvbnN0IG9wcyA9IHt9O1xyXG4gICAgb3BzW1wiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovXSA9ICdBTkQnO1xyXG4gICAgb3BzW1wib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqL10gPSAnT1InO1xyXG4gICAgcmV0dXJuIG9wcztcclxufSkoKTtcclxuZnVuY3Rpb24gYXNzZXJ0UHJlc2VudCh2YWx1ZSwgZGVzY3JpcHRpb24pIHtcclxufVxyXG4vKipcclxuICogVGhpcyBjbGFzcyBnZW5lcmF0ZXMgSnNvbk9iamVjdCB2YWx1ZXMgZm9yIHRoZSBEYXRhc3RvcmUgQVBJIHN1aXRhYmxlIGZvclxyXG4gKiBzZW5kaW5nIHRvIGVpdGhlciBHUlBDIHN0dWIgbWV0aG9kcyBvciB2aWEgdGhlIEpTT04vSFRUUCBSRVNUIEFQSS5cclxuICpcclxuICogVGhlIHNlcmlhbGl6ZXIgc3VwcG9ydHMgYm90aCBQcm90b2J1Zi5qcyBhbmQgUHJvdG8zIEpTT04gZm9ybWF0cy4gQnlcclxuICogc2V0dGluZyBgdXNlUHJvdG8zSnNvbmAgdG8gdHJ1ZSwgdGhlIHNlcmlhbGl6ZXIgd2lsbCB1c2UgdGhlIFByb3RvMyBKU09OXHJcbiAqIGZvcm1hdC5cclxuICpcclxuICogRm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIFByb3RvMyBKU09OIGZvcm1hdCBjaGVja1xyXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cclxuICpcclxuICogVE9ETyhrbGltdCk6IFdlIGNhbiByZW1vdmUgdGhlIGRhdGFiYXNlSWQgYXJndW1lbnQgaWYgd2Uga2VlcCB0aGUgZnVsbFxyXG4gKiByZXNvdXJjZSBuYW1lIGluIGRvY3VtZW50cy5cclxuICovXHJcbmNsYXNzIEpzb25Qcm90b1NlcmlhbGl6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgdXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XHJcbiAgICAgICAgdGhpcy51c2VQcm90bzNKc29uID0gdXNlUHJvdG8zSnNvbjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tUnBjU3RhdHVzKHN0YXR1cykge1xyXG4gICAgY29uc3QgY29kZSA9IHN0YXR1cy5jb2RlID09PSB1bmRlZmluZWQgPyBDb2RlLlVOS05PV04gOiBtYXBDb2RlRnJvbVJwY0NvZGUoc3RhdHVzLmNvZGUpO1xyXG4gICAgcmV0dXJuIG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBzdGF0dXMubWVzc2FnZSB8fCAnJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgKG9yIG51bGwpIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50b1xyXG4gKiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIHByb3RvLlxyXG4gKiBETyBOT1QgVVNFIFRISVMgRk9SIEFOWVRISU5HIEVMU0UuXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWF0cy4gSXQncyB0eXBlZCBhcyByZXR1cm5pbmcgXCJudW1iZXJcIiBiZWNhdXNlIHRoYXQncyB3aGF0XHJcbiAqIG91ciBnZW5lcmF0ZWQgcHJvdG8gaW50ZXJmYWNlcyBzYXkgSW50MzJWYWx1ZSBtdXN0IGJlLiBCdXQgR1JQQyBhY3R1YWxseVxyXG4gKiBleHBlY3RzIGEgeyB2YWx1ZTogPG51bWJlcj4gfSBzdHJ1Y3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdmFsKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbCB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbnVtYmVyIChvciBudWxsKSBmcm9tIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgcHJvdG8uXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50MzJQcm90byh2YWwpIHtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXN1bHQgPSB2YWwudmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBEYXRlIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGltZXN0YW1wKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XHJcbiAgICAgICAgLy8gU2VyaWFsaXplIHRvIElTTy04NjAxIGRhdGUgZm9ybWF0LCBidXQgd2l0aCBmdWxsIG5hbm8gcmVzb2x1dGlvbi5cclxuICAgICAgICAvLyBTaW5jZSBKUyBEYXRlIGhhcyBvbmx5IG1pbGxpcywgbGV0J3Mgb25seSB1c2UgaXQgZm9yIHRoZSBzZWNvbmRzIGFuZFxyXG4gICAgICAgIC8vIHRoZW4gbWFudWFsbHkgYWRkIHRoZSBmcmFjdGlvbnMgdG8gdGhlIGVuZC5cclxuICAgICAgICBjb25zdCBqc0RhdGVTdHIgPSBuZXcgRGF0ZSh0aW1lc3RhbXAuc2Vjb25kcyAqIDEwMDApLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIC54eHggZnJhYyBwYXJ0IGFuZCBaIGluIHRoZSBlbmQuXHJcbiAgICAgICAgY29uc3Qgc3RyVW50aWxTZWNvbmRzID0ganNEYXRlU3RyLnJlcGxhY2UoL1xcLlxcZCovLCAnJykucmVwbGFjZSgnWicsICcnKTtcclxuICAgICAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIG91dCB0byA5IGRpZ2l0cyAobmFub3MpLlxyXG4gICAgICAgIGNvbnN0IG5hbm9TdHIgPSAoJzAwMDAwMDAwMCcgKyB0aW1lc3RhbXAubmFub3NlY29uZHMpLnNsaWNlKC05KTtcclxuICAgICAgICByZXR1cm4gYCR7c3RyVW50aWxTZWNvbmRzfS4ke25hbm9TdHJ9WmA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZWNvbmRzOiAnJyArIHRpbWVzdGFtcC5zZWNvbmRzLFxyXG4gICAgICAgICAgICBuYW5vczogdGltZXN0YW1wLm5hbm9zZWNvbmRzXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tVGltZXN0YW1wKGRhdGUpIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChkYXRlKTtcclxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcC5zZWNvbmRzLCB0aW1lc3RhbXAubmFub3MpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGJ5dGVzIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW4gYSBwcm90by5cclxuICpcclxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICovXHJcbmZ1bmN0aW9uIHRvQnl0ZXMoc2VyaWFsaXplciwgYnl0ZXMpIHtcclxuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcclxuICAgICAgICByZXR1cm4gYnl0ZXMudG9CYXNlNjQoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBieXRlcy50b1VpbnQ4QXJyYXkoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIEJ5dGVTdHJpbmcgYmFzZWQgb24gdGhlIHByb3RvIHN0cmluZyB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGZyb21CeXRlcyhzZXJpYWxpemVyLCB2YWx1ZSkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIGhhcmRBc3NlcnQodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKTtcclxuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKHZhbHVlID8gdmFsdWUgOiAnJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBoYXJkQXNzZXJ0KHZhbHVlID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGJvdGggQnVmZmVyIGFuZCBVaW50OEFycmF5LFxyXG4gICAgICAgICAgICAvLyBkZXNwaXRlIHRoZSBmYWN0IHRoYXQgQnVmZmVyIGV4dGVuZHMgVWludDhBcnJheS4gSW4gc29tZVxyXG4gICAgICAgICAgICAvLyBlbnZpcm9ubWVudHMsIHN1Y2ggYXMganNkb20sIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgQnVmZmVyXHJcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IGluZGljYXRlIHRoYXQgaXQgZXh0ZW5kcyBVaW50OEFycmF5LlxyXG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlciB8fFxyXG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KHZhbHVlID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSgpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1ZlcnNpb24oc2VyaWFsaXplciwgdmVyc2lvbikge1xyXG4gICAgcmV0dXJuIHRvVGltZXN0YW1wKHNlcmlhbGl6ZXIsIHZlcnNpb24udG9UaW1lc3RhbXAoKSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVZlcnNpb24odmVyc2lvbikge1xyXG4gICAgaGFyZEFzc2VydCghIXZlcnNpb24pO1xyXG4gICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKGZyb21UaW1lc3RhbXAodmVyc2lvbikpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmVzb3VyY2VOYW1lKGRhdGFiYXNlSWQsIHBhdGgpIHtcclxuICAgIHJldHVybiB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCBwYXRoKS5jYW5vbmljYWxTdHJpbmcoKTtcclxufVxyXG5mdW5jdGlvbiB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCBwYXRoKSB7XHJcbiAgICBjb25zdCByZXNvdXJjZVBhdGggPSBmdWxseVF1YWxpZmllZFByZWZpeFBhdGgoZGF0YWJhc2VJZCkuY2hpbGQoJ2RvY3VtZW50cycpO1xyXG4gICAgcmV0dXJuIHBhdGggPT09IHVuZGVmaW5lZCA/IHJlc291cmNlUGF0aCA6IHJlc291cmNlUGF0aC5jaGlsZChwYXRoKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc291cmNlID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcobmFtZSk7XHJcbiAgICBoYXJkQXNzZXJ0KGlzVmFsaWRSZXNvdXJjZU5hbWUocmVzb3VyY2UpKTtcclxuICAgIHJldHVybiByZXNvdXJjZTtcclxufVxyXG5mdW5jdGlvbiB0b05hbWUoc2VyaWFsaXplciwga2V5KSB7XHJcbiAgICByZXR1cm4gdG9SZXNvdXJjZU5hbWUoc2VyaWFsaXplci5kYXRhYmFzZUlkLCBrZXkucGF0aCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbU5hbWUoc2VyaWFsaXplciwgbmFtZSkge1xyXG4gICAgY29uc3QgcmVzb3VyY2UgPSBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpO1xyXG4gICAgaWYgKHJlc291cmNlLmdldCgxKSAhPT0gc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUcmllZCB0byBkZXNlcmlhbGl6ZSBrZXkgZnJvbSBkaWZmZXJlbnQgcHJvamVjdDogJyArXHJcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgxKSArXHJcbiAgICAgICAgICAgICcgdnMgJyArXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc291cmNlLmdldCgzKSAhPT0gc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RyaWVkIHRvIGRlc2VyaWFsaXplIGtleSBmcm9tIGRpZmZlcmVudCBkYXRhYmFzZTogJyArXHJcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgzKSArXHJcbiAgICAgICAgICAgICcgdnMgJyArXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlKSk7XHJcbn1cclxuZnVuY3Rpb24gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHRvUmVzb3VyY2VOYW1lKHNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgcGF0aCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVF1ZXJ5UGF0aChuYW1lKSB7XHJcbiAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpO1xyXG4gICAgLy8gSW4gdjFiZXRhMSBxdWVyaWVzIGZvciBjb2xsZWN0aW9ucyBhdCB0aGUgcm9vdCBkaWQgbm90IGhhdmUgYSB0cmFpbGluZ1xyXG4gICAgLy8gXCIvZG9jdW1lbnRzXCIuIEluIHYxIGFsbCByZXNvdXJjZSBwYXRocyBjb250YWluIFwiL2RvY3VtZW50c1wiLiBQcmVzZXJ2ZSB0aGVcclxuICAgIC8vIGFiaWxpdHkgdG8gcmVhZCB0aGUgdjFiZXRhMSBmb3JtIGZvciBjb21wYXRpYmlsaXR5IHdpdGggcXVlcmllcyBwZXJzaXN0ZWRcclxuICAgIC8vIGluIHRoZSBsb2NhbCB0YXJnZXQgY2FjaGUuXHJcbiAgICBpZiAocmVzb3VyY2VOYW1lLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lKTtcclxufVxyXG5mdW5jdGlvbiBnZXRFbmNvZGVkRGF0YWJhc2VJZChzZXJpYWxpemVyKSB7XHJcbiAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChbXHJcbiAgICAgICAgJ3Byb2plY3RzJyxcclxuICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQucHJvamVjdElkLFxyXG4gICAgICAgICdkYXRhYmFzZXMnLFxyXG4gICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZVxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gcGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBmdWxseVF1YWxpZmllZFByZWZpeFBhdGgoZGF0YWJhc2VJZCkge1xyXG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoW1xyXG4gICAgICAgICdwcm9qZWN0cycsXHJcbiAgICAgICAgZGF0YWJhc2VJZC5wcm9qZWN0SWQsXHJcbiAgICAgICAgJ2RhdGFiYXNlcycsXHJcbiAgICAgICAgZGF0YWJhc2VJZC5kYXRhYmFzZVxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lKSB7XHJcbiAgICBoYXJkQXNzZXJ0KHJlc291cmNlTmFtZS5sZW5ndGggPiA0ICYmIHJlc291cmNlTmFtZS5nZXQoNCkgPT09ICdkb2N1bWVudHMnKTtcclxuICAgIHJldHVybiByZXNvdXJjZU5hbWUucG9wRmlyc3QoNSk7XHJcbn1cclxuLyoqIENyZWF0ZXMgYSBEb2N1bWVudCBwcm90byBmcm9tIGtleSBhbmQgZmllbGRzIChidXQgbm8gY3JlYXRlL3VwZGF0ZSB0aW1lKSAqL1xyXG5mdW5jdGlvbiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwga2V5LCBmaWVsZHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogdG9OYW1lKHNlcmlhbGl6ZXIsIGtleSksXHJcbiAgICAgICAgZmllbGRzOiBmaWVsZHMudmFsdWUubWFwVmFsdWUuZmllbGRzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRvRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogdG9OYW1lKHNlcmlhbGl6ZXIsIGRvY3VtZW50LmtleSksXHJcbiAgICAgICAgZmllbGRzOiBkb2N1bWVudC5kYXRhLnZhbHVlLm1hcFZhbHVlLmZpZWxkcyxcclxuICAgICAgICB1cGRhdGVUaW1lOiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCBkb2N1bWVudC52ZXJzaW9uLnRvVGltZXN0YW1wKCkpLFxyXG4gICAgICAgIGNyZWF0ZVRpbWU6IHRvVGltZXN0YW1wKHNlcmlhbGl6ZXIsIGRvY3VtZW50LmNyZWF0ZVRpbWUudG9UaW1lc3RhbXAoKSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURvY3VtZW50KHNlcmlhbGl6ZXIsIGRvY3VtZW50LCBoYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcclxuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY3VtZW50Lm5hbWUpO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvY3VtZW50LnVwZGF0ZVRpbWUpO1xyXG4gICAgLy8gSWYgd2UgcmVhZCBhIGRvY3VtZW50IGZyb20gcGVyc2lzdGVuY2UgdGhhdCBpcyBtaXNzaW5nIGNyZWF0ZVRpbWUsIGl0J3MgZHVlXHJcbiAgICAvLyB0byBvbGRlciBTREsgdmVyc2lvbnMgbm90IHN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbi4gSW4gc3VjaCBjYXNlcywgd2UnbGxcclxuICAgIC8vIHNldCB0aGUgY3JlYXRlVGltZSB0byB6ZXJvLiBUaGlzIGNhbiBiZSByZW1vdmVkIGluIHRoZSBsb25nIHRlcm0uXHJcbiAgICBjb25zdCBjcmVhdGVUaW1lID0gZG9jdW1lbnQuY3JlYXRlVGltZVxyXG4gICAgICAgID8gZnJvbVZlcnNpb24oZG9jdW1lbnQuY3JlYXRlVGltZSlcclxuICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIGNvbnN0IGRhdGEgPSBuZXcgT2JqZWN0VmFsdWUoeyBtYXBWYWx1ZTogeyBmaWVsZHM6IGRvY3VtZW50LmZpZWxkcyB9IH0pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcclxuICAgIGlmIChoYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcclxuICAgICAgICByZXN1bHQuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzQ29tbWl0dGVkTXV0YXRpb25zID8gcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpIDogcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Gb3VuZChzZXJpYWxpemVyLCBkb2MpIHtcclxuICAgIGhhcmRBc3NlcnQoISFkb2MuZm91bmQpO1xyXG4gICAgYXNzZXJ0UHJlc2VudChkb2MuZm91bmQubmFtZSk7XHJcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcclxuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvYy5mb3VuZC5uYW1lKTtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihkb2MuZm91bmQudXBkYXRlVGltZSk7XHJcbiAgICBjb25zdCBjcmVhdGVUaW1lID0gZG9jLmZvdW5kLmNyZWF0ZVRpbWVcclxuICAgICAgICA/IGZyb21WZXJzaW9uKGRvYy5mb3VuZC5jcmVhdGVUaW1lKVxyXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jLmZvdW5kLmZpZWxkcyB9IH0pO1xyXG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgY3JlYXRlVGltZSwgZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbU1pc3Npbmcoc2VyaWFsaXplciwgcmVzdWx0KSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0Lm1pc3NpbmcpO1xyXG4gICAgaGFyZEFzc2VydCghIXJlc3VsdC5yZWFkVGltZSk7XHJcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCByZXN1bHQubWlzc2luZyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24ocmVzdWx0LnJlYWRUaW1lKTtcclxuICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKHNlcmlhbGl6ZXIsIHJlc3VsdCkge1xyXG4gICAgaWYgKCdmb3VuZCcgaW4gcmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21Gb3VuZChzZXJpYWxpemVyLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21pc3NpbmcnIGluIHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhaWwoKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tV2F0Y2hDaGFuZ2Uoc2VyaWFsaXplciwgY2hhbmdlKSB7XHJcbiAgICBsZXQgd2F0Y2hDaGFuZ2U7XHJcbiAgICBpZiAoJ3RhcmdldENoYW5nZScgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UudGFyZ2V0Q2hhbmdlKTtcclxuICAgICAgICAvLyBwcm90bzMgZGVmYXVsdCB2YWx1ZSBpcyB1bnNldCBpbiBKU09OICh1bmRlZmluZWQpLCBzbyB1c2UgJ05PX0NIQU5HRSdcclxuICAgICAgICAvLyBpZiB1bnNldFxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZnJvbVdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUoY2hhbmdlLnRhcmdldENoYW5nZS50YXJnZXRDaGFuZ2VUeXBlIHx8ICdOT19DSEFOR0UnKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJZHMgPSBjaGFuZ2UudGFyZ2V0Q2hhbmdlLnRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICBjb25zdCByZXN1bWVUb2tlbiA9IGZyb21CeXRlcyhzZXJpYWxpemVyLCBjaGFuZ2UudGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcclxuICAgICAgICBjb25zdCBjYXVzZVByb3RvID0gY2hhbmdlLnRhcmdldENoYW5nZS5jYXVzZTtcclxuICAgICAgICBjb25zdCBjYXVzZSA9IGNhdXNlUHJvdG8gJiYgZnJvbVJwY1N0YXR1cyhjYXVzZVByb3RvKTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBXYXRjaFRhcmdldENoYW5nZShzdGF0ZSwgdGFyZ2V0SWRzLCByZXN1bWVUb2tlbiwgY2F1c2UgfHwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnZG9jdW1lbnRDaGFuZ2UnIGluIGNoYW5nZSkge1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50Q2hhbmdlKTtcclxuICAgICAgICBjb25zdCBlbnRpdHlDaGFuZ2UgPSBjaGFuZ2UuZG9jdW1lbnRDaGFuZ2U7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChlbnRpdHlDaGFuZ2UuZG9jdW1lbnQpO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGVudGl0eUNoYW5nZS5kb2N1bWVudC5uYW1lKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBlbnRpdHlDaGFuZ2UuZG9jdW1lbnQuY3JlYXRlVGltZVxyXG4gICAgICAgICAgICA/IGZyb21WZXJzaW9uKGVudGl0eUNoYW5nZS5kb2N1bWVudC5jcmVhdGVUaW1lKVxyXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHtcclxuICAgICAgICAgICAgbWFwVmFsdWU6IHsgZmllbGRzOiBlbnRpdHlDaGFuZ2UuZG9jdW1lbnQuZmllbGRzIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUYXJnZXRJZHMgPSBlbnRpdHlDaGFuZ2UudGFyZ2V0SWRzIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBlbnRpdHlDaGFuZ2UucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKHVwZGF0ZWRUYXJnZXRJZHMsIHJlbW92ZWRUYXJnZXRJZHMsIGRvYy5rZXksIGRvYyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnZG9jdW1lbnREZWxldGUnIGluIGNoYW5nZSkge1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50RGVsZXRlKTtcclxuICAgICAgICBjb25zdCBkb2NEZWxldGUgPSBjaGFuZ2UuZG9jdW1lbnREZWxldGU7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChkb2NEZWxldGUuZG9jdW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY0RlbGV0ZS5kb2N1bWVudCk7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGRvY0RlbGV0ZS5yZWFkVGltZVxyXG4gICAgICAgICAgICA/IGZyb21WZXJzaW9uKGRvY0RlbGV0ZS5yZWFkVGltZSlcclxuICAgICAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICAgICAgY29uc3QgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCB2ZXJzaW9uKTtcclxuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0SWRzID0gZG9jRGVsZXRlLnJlbW92ZWRUYXJnZXRJZHMgfHwgW107XHJcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZShbXSwgcmVtb3ZlZFRhcmdldElkcywgZG9jLmtleSwgZG9jKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb2N1bWVudFJlbW92ZScgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnRSZW1vdmUpO1xyXG4gICAgICAgIGNvbnN0IGRvY1JlbW92ZSA9IGNoYW5nZS5kb2N1bWVudFJlbW92ZTtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY1JlbW92ZS5kb2N1bWVudCk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jUmVtb3ZlLmRvY3VtZW50KTtcclxuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0SWRzID0gZG9jUmVtb3ZlLnJlbW92ZWRUYXJnZXRJZHMgfHwgW107XHJcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZShbXSwgcmVtb3ZlZFRhcmdldElkcywga2V5LCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdmaWx0ZXInIGluIGNoYW5nZSkge1xyXG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogaW1wbGVtZW50IGV4aXN0ZW5jZSBmaWx0ZXIgcGFyc2luZyB3aXRoIHN0cmF0ZWd5LlxyXG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmZpbHRlcik7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gY2hhbmdlLmZpbHRlcjtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGZpbHRlci50YXJnZXRJZCk7XHJcbiAgICAgICAgY29uc3QgeyBjb3VudCA9IDAsIHVuY2hhbmdlZE5hbWVzIH0gPSBmaWx0ZXI7XHJcbiAgICAgICAgY29uc3QgZXhpc3RlbmNlRmlsdGVyID0gbmV3IEV4aXN0ZW5jZUZpbHRlcihjb3VudCwgdW5jaGFuZ2VkTmFtZXMpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZmlsdGVyLnRhcmdldElkO1xyXG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IEV4aXN0ZW5jZUZpbHRlckNoYW5nZSh0YXJnZXRJZCwgZXhpc3RlbmNlRmlsdGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2F0Y2hDaGFuZ2U7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUoc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZSA9PT0gJ05PX0NIQU5HRScpIHtcclxuICAgICAgICByZXR1cm4gMCAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLk5vQ2hhbmdlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdBREQnKSB7XHJcbiAgICAgICAgcmV0dXJuIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnUkVNT1ZFJykge1xyXG4gICAgICAgIHJldHVybiAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnQ1VSUkVOVCcpIHtcclxuICAgICAgICByZXR1cm4gMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ1JFU0VUJykge1xyXG4gICAgICAgIHJldHVybiA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZlcnNpb25Gcm9tTGlzdGVuUmVzcG9uc2UoY2hhbmdlKSB7XHJcbiAgICAvLyBXZSBoYXZlIG9ubHkgcmVhY2hlZCBhIGNvbnNpc3RlbnQgc25hcHNob3QgZm9yIHRoZSBlbnRpcmUgc3RyZWFtIGlmIHRoZXJlXHJcbiAgICAvLyBpcyBhIHJlYWRfdGltZSBzZXQgYW5kIGl0IGFwcGxpZXMgdG8gYWxsIHRhcmdldHMgKGkuZS4gdGhlIGxpc3Qgb2ZcclxuICAgIC8vIHRhcmdldHMgaXMgZW1wdHkpLiBUaGUgYmFja2VuZCBpcyBndWFyYW50ZWVkIHRvIHNlbmQgc3VjaCByZXNwb25zZXMuXHJcbiAgICBpZiAoISgndGFyZ2V0Q2hhbmdlJyBpbiBjaGFuZ2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IGNoYW5nZS50YXJnZXRDaGFuZ2U7XHJcbiAgICBpZiAodGFyZ2V0Q2hhbmdlLnRhcmdldElkcyAmJiB0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRhcmdldENoYW5nZS5yZWFkVGltZSkge1xyXG4gICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJvbVZlcnNpb24odGFyZ2V0Q2hhbmdlLnJlYWRUaW1lKTtcclxufVxyXG5mdW5jdGlvbiB0b011dGF0aW9uKHNlcmlhbGl6ZXIsIG11dGF0aW9uKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgU2V0TXV0YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZTogdG9NdXRhdGlvbkRvY3VtZW50KHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSwgbXV0YXRpb24udmFsdWUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgRGVsZXRlTXV0YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSB7IGRlbGV0ZTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdXBkYXRlOiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5LCBtdXRhdGlvbi5kYXRhKSxcclxuICAgICAgICAgICAgdXBkYXRlTWFzazogdG9Eb2N1bWVudE1hc2sobXV0YXRpb24uZmllbGRNYXNrKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFZlcmlmeU11dGF0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB2ZXJpZnk6IHRvTmFtZShzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXkpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXN1bHQudXBkYXRlVHJhbnNmb3JtcyA9IG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW11dGF0aW9uLnByZWNvbmRpdGlvbi5pc05vbmUpIHtcclxuICAgICAgICByZXN1bHQuY3VycmVudERvY3VtZW50ID0gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24ucHJlY29uZGl0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZnJvbU11dGF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvKSB7XHJcbiAgICBjb25zdCBwcmVjb25kaXRpb24gPSBwcm90by5jdXJyZW50RG9jdW1lbnRcclxuICAgICAgICA/IGZyb21QcmVjb25kaXRpb24ocHJvdG8uY3VycmVudERvY3VtZW50KVxyXG4gICAgICAgIDogUHJlY29uZGl0aW9uLm5vbmUoKTtcclxuICAgIGNvbnN0IGZpZWxkVHJhbnNmb3JtcyA9IHByb3RvLnVwZGF0ZVRyYW5zZm9ybXNcclxuICAgICAgICA/IHByb3RvLnVwZGF0ZVRyYW5zZm9ybXMubWFwKHRyYW5zZm9ybSA9PiBmcm9tRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSlcclxuICAgICAgICA6IFtdO1xyXG4gICAgaWYgKHByb3RvLnVwZGF0ZSkge1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQocHJvdG8udXBkYXRlLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLnVwZGF0ZS5uYW1lKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBPYmplY3RWYWx1ZSh7XHJcbiAgICAgICAgICAgIG1hcFZhbHVlOiB7IGZpZWxkczogcHJvdG8udXBkYXRlLmZpZWxkcyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByb3RvLnVwZGF0ZU1hc2spIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRNYXNrID0gZnJvbURvY3VtZW50TWFzayhwcm90by51cGRhdGVNYXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdmFsdWUsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHZhbHVlLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvdG8uZGVsZXRlKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8uZGVsZXRlKTtcclxuICAgICAgICByZXR1cm4gbmV3IERlbGV0ZU11dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3RvLnZlcmlmeSkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLnZlcmlmeSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZXJpZnlNdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvUHJlY29uZGl0aW9uKHNlcmlhbGl6ZXIsIHByZWNvbmRpdGlvbikge1xyXG4gICAgaWYgKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1cGRhdGVUaW1lOiB0b1ZlcnNpb24oc2VyaWFsaXplciwgcHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWNvbmRpdGlvbi5leGlzdHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB7IGV4aXN0czogcHJlY29uZGl0aW9uLmV4aXN0cyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tUHJlY29uZGl0aW9uKHByZWNvbmRpdGlvbikge1xyXG4gICAgaWYgKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUoZnJvbVZlcnNpb24ocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWNvbmRpdGlvbi5leGlzdHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24uZXhpc3RzKHByZWNvbmRpdGlvbi5leGlzdHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5ub25lKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdyaXRlUmVzdWx0KHByb3RvLCBjb21taXRUaW1lKSB7XHJcbiAgICAvLyBOT1RFOiBEZWxldGVzIGRvbid0IGhhdmUgYW4gdXBkYXRlVGltZS5cclxuICAgIGxldCB2ZXJzaW9uID0gcHJvdG8udXBkYXRlVGltZVxyXG4gICAgICAgID8gZnJvbVZlcnNpb24ocHJvdG8udXBkYXRlVGltZSlcclxuICAgICAgICA6IGZyb21WZXJzaW9uKGNvbW1pdFRpbWUpO1xyXG4gICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgLy8gVGhlIEZpcmVzdG9yZSBFbXVsYXRvciBjdXJyZW50bHkgcmV0dXJucyBhbiB1cGRhdGUgdGltZSBvZiAwIGZvclxyXG4gICAgICAgIC8vIGRlbGV0ZXMgb2Ygbm9uLWV4aXN0aW5nIGRvY3VtZW50cyAocmF0aGVyIHRoYW4gbnVsbCkuIFRoaXMgYnJlYWtzIHRoZVxyXG4gICAgICAgIC8vIHRlc3QgXCJnZXQgZGVsZXRlZCBkb2Mgd2hpbGUgb2ZmbGluZSB3aXRoIHNvdXJjZT1jYWNoZVwiIGFzIE5vRG9jdW1lbnRzXHJcbiAgICAgICAgLy8gd2l0aCB2ZXJzaW9uIDAgYXJlIGZpbHRlcmVkIGJ5IEluZGV4ZWREYidzIFJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAgICAgICAgLy8gVE9ETygjMjE0OSk6IFJlbW92ZSB0aGlzIHdoZW4gRW11bGF0b3IgaXMgZml4ZWRcclxuICAgICAgICB2ZXJzaW9uID0gZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uUmVzdWx0KHZlcnNpb24sIHByb3RvLnRyYW5zZm9ybVJlc3VsdHMgfHwgW10pO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Xcml0ZVJlc3VsdHMocHJvdG9zLCBjb21taXRUaW1lKSB7XHJcbiAgICBpZiAocHJvdG9zICYmIHByb3Rvcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChjb21taXRUaW1lICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybiBwcm90b3MubWFwKHByb3RvID0+IGZyb21Xcml0ZVJlc3VsdChwcm90bywgY29tbWl0VGltZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgZmllbGRUcmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybTtcclxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICBzZXRUb1NlcnZlclZhbHVlOiAnUkVRVUVTVF9USU1FJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmllbGRQYXRoOiBmaWVsZFRyYW5zZm9ybS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcclxuICAgICAgICAgICAgYXBwZW5kTWlzc2luZ0VsZW1lbnRzOiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmllbGRQYXRoOiBmaWVsZFRyYW5zZm9ybS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcclxuICAgICAgICAgICAgcmVtb3ZlQWxsRnJvbUFycmF5OiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICBpbmNyZW1lbnQ6IHRyYW5zZm9ybS5vcGVyYW5kXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgcHJvdG8pIHtcclxuICAgIGxldCB0cmFuc2Zvcm0gPSBudWxsO1xyXG4gICAgaWYgKCdzZXRUb1NlcnZlclZhbHVlJyBpbiBwcm90bykge1xyXG4gICAgICAgIGhhcmRBc3NlcnQocHJvdG8uc2V0VG9TZXJ2ZXJWYWx1ZSA9PT0gJ1JFUVVFU1RfVElNRScpO1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0oKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdhcHBlbmRNaXNzaW5nRWxlbWVudHMnIGluIHByb3RvKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvdG8uYXBwZW5kTWlzc2luZ0VsZW1lbnRzLnZhbHVlcyB8fCBbXTtcclxuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbih2YWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3JlbW92ZUFsbEZyb21BcnJheScgaW4gcHJvdG8pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcm90by5yZW1vdmVBbGxGcm9tQXJyYXkudmFsdWVzIHx8IFtdO1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbih2YWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2luY3JlbWVudCcgaW4gcHJvdG8pIHtcclxuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbihzZXJpYWxpemVyLCBwcm90by5pbmNyZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmllbGRQYXRoID0gRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChwcm90by5maWVsZFBhdGgpO1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShmaWVsZFBhdGgsIHRyYW5zZm9ybSk7XHJcbn1cclxuZnVuY3Rpb24gdG9Eb2N1bWVudHNUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KSB7XHJcbiAgICByZXR1cm4geyBkb2N1bWVudHM6IFt0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCB0YXJnZXQucGF0aCldIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURvY3VtZW50c1RhcmdldChkb2N1bWVudHNUYXJnZXQpIHtcclxuICAgIGNvbnN0IGNvdW50ID0gZG9jdW1lbnRzVGFyZ2V0LmRvY3VtZW50cy5sZW5ndGg7XHJcbiAgICBoYXJkQXNzZXJ0KGNvdW50ID09PSAxKTtcclxuICAgIGNvbnN0IG5hbWUgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzWzBdO1xyXG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQobmV3UXVlcnlGb3JQYXRoKGZyb21RdWVyeVBhdGgobmFtZSkpKTtcclxufVxyXG5mdW5jdGlvbiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkge1xyXG4gICAgLy8gRGlzc2VjdCB0aGUgcGF0aCBpbnRvIHBhcmVudCwgY29sbGVjdGlvbklkLCBhbmQgb3B0aW9uYWwga2V5IGZpbHRlci5cclxuICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0ID0geyBzdHJ1Y3R1cmVkUXVlcnk6IHt9IH07XHJcbiAgICBjb25zdCBwYXRoID0gdGFyZ2V0LnBhdGg7XHJcbiAgICBsZXQgcGFyZW50O1xyXG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcclxuICAgICAgICBwYXJlbnQgPSBwYXRoO1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5mcm9tID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsXHJcbiAgICAgICAgICAgICAgICBhbGxEZXNjZW5kYW50czogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5mcm9tID0gW3sgY29sbGVjdGlvbklkOiBwYXRoLmxhc3RTZWdtZW50KCkgfV07XHJcbiAgICB9XHJcbiAgICBxdWVyeVRhcmdldC5wYXJlbnQgPSB0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCBwYXJlbnQpO1xyXG4gICAgY29uc3Qgd2hlcmUgPSB0b0ZpbHRlcnModGFyZ2V0LmZpbHRlcnMpO1xyXG4gICAgaWYgKHdoZXJlKSB7XHJcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LndoZXJlID0gd2hlcmU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcmRlckJ5ID0gdG9PcmRlcih0YXJnZXQub3JkZXJCeSk7XHJcbiAgICBpZiAob3JkZXJCeSkge1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5vcmRlckJ5ID0gb3JkZXJCeTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpbWl0ID0gdG9JbnQzMlByb3RvKHNlcmlhbGl6ZXIsIHRhcmdldC5saW1pdCk7XHJcbiAgICBpZiAobGltaXQgIT09IG51bGwpIHtcclxuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkubGltaXQgPSBsaW1pdDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuc3RhcnRBdCkge1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5zdGFydEF0ID0gdG9TdGFydEF0Q3Vyc29yKHRhcmdldC5zdGFydEF0KTtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuZW5kQXQpIHtcclxuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZW5kQXQgPSB0b0VuZEF0Q3Vyc29yKHRhcmdldC5lbmRBdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBxdWVyeVRhcmdldCwgcGFyZW50IH07XHJcbn1cclxuZnVuY3Rpb24gdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdChzZXJpYWxpemVyLCB0YXJnZXQsIGFnZ3JlZ2F0ZXMsIHNraXBBbGlhc2luZykge1xyXG4gICAgY29uc3QgeyBxdWVyeVRhcmdldCwgcGFyZW50IH0gPSB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCk7XHJcbiAgICBjb25zdCBhbGlhc01hcCA9IHt9O1xyXG4gICAgY29uc3QgYWdncmVnYXRpb25zID0gW107XHJcbiAgICBsZXQgYWdncmVnYXRpb25OdW0gPSAwO1xyXG4gICAgYWdncmVnYXRlcy5mb3JFYWNoKGFnZ3JlZ2F0ZSA9PiB7XHJcbiAgICAgICAgLy8gTWFwIGFsbCBjbGllbnQtc2lkZSBhbGlhc2VzIHRvIGEgdW5pcXVlIHNob3J0LWZvcm1cclxuICAgICAgICAvLyBhbGlhcy4gVGhpcyBhdm9pZHMgaXNzdWVzIHdpdGggY2xpZW50LXNpZGUgYWxpYXNlcyB0aGF0XHJcbiAgICAgICAgLy8gZXhjZWVkIHRoZSAxNTAwLWJ5dGUgc3RyaW5nIHNpemUgbGltaXQuXHJcbiAgICAgICAgY29uc3Qgc2VydmVyQWxpYXMgPSBza2lwQWxpYXNpbmdcclxuICAgICAgICAgICAgPyBhZ2dyZWdhdGUuYWxpYXNcclxuICAgICAgICAgICAgOiBgYWdncmVnYXRlXyR7YWdncmVnYXRpb25OdW0rK31gO1xyXG4gICAgICAgIGFsaWFzTWFwW3NlcnZlckFsaWFzXSA9IGFnZ3JlZ2F0ZS5hbGlhcztcclxuICAgICAgICBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdjb3VudCcpIHtcclxuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxyXG4gICAgICAgICAgICAgICAgY291bnQ6IHt9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ2F2ZycpIHtcclxuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxyXG4gICAgICAgICAgICAgICAgYXZnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ3N1bScpIHtcclxuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxyXG4gICAgICAgICAgICAgICAgc3VtOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXF1ZXN0OiB7XHJcbiAgICAgICAgICAgIHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHF1ZXJ5VGFyZ2V0LnBhcmVudFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWxpYXNNYXAsXHJcbiAgICAgICAgcGFyZW50XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XHJcbiAgICBsZXQgcGF0aCA9IGZyb21RdWVyeVBhdGgodGFyZ2V0LnBhcmVudCk7XHJcbiAgICBjb25zdCBxdWVyeSA9IHRhcmdldC5zdHJ1Y3R1cmVkUXVlcnk7XHJcbiAgICBjb25zdCBmcm9tQ291bnQgPSBxdWVyeS5mcm9tID8gcXVlcnkuZnJvbS5sZW5ndGggOiAwO1xyXG4gICAgbGV0IGNvbGxlY3Rpb25Hcm91cCA9IG51bGw7XHJcbiAgICBpZiAoZnJvbUNvdW50ID4gMCkge1xyXG4gICAgICAgIGhhcmRBc3NlcnQoZnJvbUNvdW50ID09PSAxKTtcclxuICAgICAgICBjb25zdCBmcm9tID0gcXVlcnkuZnJvbVswXTtcclxuICAgICAgICBpZiAoZnJvbS5hbGxEZXNjZW5kYW50cykge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uR3JvdXAgPSBmcm9tLmNvbGxlY3Rpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkKGZyb20uY29sbGVjdGlvbklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgZmlsdGVyQnkgPSBbXTtcclxuICAgIGlmIChxdWVyeS53aGVyZSkge1xyXG4gICAgICAgIGZpbHRlckJ5ID0gZnJvbUZpbHRlcnMocXVlcnkud2hlcmUpO1xyXG4gICAgfVxyXG4gICAgbGV0IG9yZGVyQnkgPSBbXTtcclxuICAgIGlmIChxdWVyeS5vcmRlckJ5KSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IGZyb21PcmRlcihxdWVyeS5vcmRlckJ5KTtcclxuICAgIH1cclxuICAgIGxldCBsaW1pdCA9IG51bGw7XHJcbiAgICBpZiAocXVlcnkubGltaXQpIHtcclxuICAgICAgICBsaW1pdCA9IGZyb21JbnQzMlByb3RvKHF1ZXJ5LmxpbWl0KTtcclxuICAgIH1cclxuICAgIGxldCBzdGFydEF0ID0gbnVsbDtcclxuICAgIGlmIChxdWVyeS5zdGFydEF0KSB7XHJcbiAgICAgICAgc3RhcnRBdCA9IGZyb21TdGFydEF0Q3Vyc29yKHF1ZXJ5LnN0YXJ0QXQpO1xyXG4gICAgfVxyXG4gICAgbGV0IGVuZEF0ID0gbnVsbDtcclxuICAgIGlmIChxdWVyeS5lbmRBdCkge1xyXG4gICAgICAgIGVuZEF0ID0gZnJvbUVuZEF0Q3Vyc29yKHF1ZXJ5LmVuZEF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnksIGZpbHRlckJ5LCBsaW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0LCBlbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVF1ZXJ5VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQoY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh0YXJnZXQpKTtcclxufVxyXG5mdW5jdGlvbiB0b0xpc3RlblJlcXVlc3RMYWJlbHMoc2VyaWFsaXplciwgdGFyZ2V0RGF0YSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSB0b0xhYmVsKHRhcmdldERhdGEucHVycG9zZSk7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2dvb2ctbGlzdGVuLXRhZ3MnOiB2YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9MYWJlbChwdXJwb3NlKSB7XHJcbiAgICBzd2l0Y2ggKHB1cnBvc2UpIHtcclxuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUxpc3RlblwiIC8qIFRhcmdldFB1cnBvc2UuTGlzdGVuICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdleGlzdGVuY2UtZmlsdGVyLW1pc21hdGNoJztcclxuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb21cIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb20gKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnZXhpc3RlbmNlLWZpbHRlci1taXNtYXRjaC1ibG9vbSc7XHJcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VMaW1ib1Jlc29sdXRpb25cIiAvKiBUYXJnZXRQdXJwb3NlLkxpbWJvUmVzb2x1dGlvbiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdsaW1iby1kb2N1bWVudCc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0RGF0YS50YXJnZXQ7XHJcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0geyBkb2N1bWVudHM6IHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHsgcXVlcnk6IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KS5xdWVyeVRhcmdldCB9O1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgIGlmICh0YXJnZXREYXRhLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcclxuICAgICAgICByZXN1bHQucmVzdW1lVG9rZW4gPSB0b0J5dGVzKHNlcmlhbGl6ZXIsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcclxuICAgICAgICBpZiAoZXhwZWN0ZWRDb3VudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZXhwZWN0ZWRDb3VudCA9IGV4cGVjdGVkQ291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgPiAwKSB7XHJcbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBDb25zaWRlciByZW1vdmluZyBhYm92ZSBjaGVjayBiZWNhdXNlIGl0IGlzIG1vc3QgbGlrZWx5IHRydWUuXHJcbiAgICAgICAgLy8gUmlnaHQgbm93LCBtYW55IHRlc3RzIGRlcGVuZCBvbiB0aGlzIGJlaGF2aW91ciB0aG91Z2ggKGxlYXZpbmcgbWluKCkgb3V0XHJcbiAgICAgICAgLy8gb2Ygc2VyaWFsaXphdGlvbikuXHJcbiAgICAgICAgcmVzdWx0LnJlYWRUaW1lID0gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKSk7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXREYXRhLmV4cGVjdGVkQ291bnQpO1xyXG4gICAgICAgIGlmIChleHBlY3RlZENvdW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHRvRmlsdGVycyhmaWx0ZXJzKSB7XHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9GaWx0ZXIoQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWx0ZXJzKGZpbHRlcikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gZnJvbUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlciAmJlxyXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKHJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbcmVzdWx0XTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlci51bmFyeUZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlsdGVyLmZpZWxkRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUZpZWxkRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIuY29tcG9zaXRlRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b09yZGVyKG9yZGVyQnlzKSB7XHJcbiAgICBpZiAob3JkZXJCeXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9yZGVyQnlzLm1hcChvcmRlciA9PiB0b1Byb3BlcnR5T3JkZXIob3JkZXIpKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tT3JkZXIob3JkZXJCeXMpIHtcclxuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gZnJvbVByb3BlcnR5T3JkZXIob3JkZXIpKTtcclxufVxyXG5mdW5jdGlvbiB0b1N0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJlZm9yZTogY3Vyc29yLmluY2x1c2l2ZSxcclxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b0VuZEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBiZWZvcmU6ICFjdXJzb3IuaW5jbHVzaXZlLFxyXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21TdGFydEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgY29uc3QgaW5jbHVzaXZlID0gISFjdXJzb3IuYmVmb3JlO1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IudmFsdWVzIHx8IFtdO1xyXG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRW5kQXRDdXJzb3IoY3Vyc29yKSB7XHJcbiAgICBjb25zdCBpbmNsdXNpdmUgPSAhY3Vyc29yLmJlZm9yZTtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnZhbHVlcyB8fCBbXTtcclxuICAgIHJldHVybiBuZXcgQm91bmQocG9zaXRpb24sIGluY2x1c2l2ZSk7XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiB0b0RpcmVjdGlvbihkaXIpIHtcclxuICAgIHJldHVybiBESVJFQ1RJT05TW2Rpcl07XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiBmcm9tRGlyZWN0aW9uKGRpcikge1xyXG4gICAgc3dpdGNoIChkaXIpIHtcclxuICAgICAgICBjYXNlICdBU0NFTkRJTkcnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xyXG4gICAgICAgIGNhc2UgJ0RFU0NFTkRJTkcnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbmZ1bmN0aW9uIHRvT3BlcmF0b3JOYW1lKG9wKSB7XHJcbiAgICByZXR1cm4gT1BFUkFUT1JTW29wXTtcclxufVxyXG5mdW5jdGlvbiB0b0NvbXBvc2l0ZU9wZXJhdG9yTmFtZShvcCkge1xyXG4gICAgcmV0dXJuIENPTVBPU0lURV9PUEVSQVRPUlNbb3BdO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21PcGVyYXRvck5hbWUob3ApIHtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlICdFUVVBTCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi87XHJcbiAgICAgICAgY2FzZSAnTk9UX0VRVUFMJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi87XHJcbiAgICAgICAgY2FzZSAnR1JFQVRFUl9USEFOJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLztcclxuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU5fT1JfRVFVQUwnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLztcclxuICAgICAgICBjYXNlICdMRVNTX1RIQU4nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovO1xyXG4gICAgICAgIGNhc2UgJ0xFU1NfVEhBTl9PUl9FUVVBTCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovO1xyXG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLztcclxuICAgICAgICBjYXNlICdJTic6XHJcbiAgICAgICAgICAgIHJldHVybiBcImluXCIgLyogT3BlcmF0b3IuSU4gKi87XHJcbiAgICAgICAgY2FzZSAnTk9UX0lOJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovO1xyXG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TX0FOWSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLztcclxuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSAnQU5EJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xyXG4gICAgICAgIGNhc2UgJ09SJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvRmllbGRQYXRoUmVmZXJlbmNlKHBhdGgpIHtcclxuICAgIHJldHVybiB7IGZpZWxkUGF0aDogcGF0aC5jYW5vbmljYWxTdHJpbmcoKSB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmllbGRSZWZlcmVuY2UpIHtcclxuICAgIHJldHVybiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KGZpZWxkUmVmZXJlbmNlLmZpZWxkUGF0aCk7XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiB0b1Byb3BlcnR5T3JkZXIob3JkZXJCeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksXHJcbiAgICAgICAgZGlyZWN0aW9uOiB0b0RpcmVjdGlvbihvcmRlckJ5LmRpcilcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbVByb3BlcnR5T3JkZXIob3JkZXJCeSkge1xyXG4gICAgcmV0dXJuIG5ldyBPcmRlckJ5KGZyb21GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksIGZyb21EaXJlY3Rpb24ob3JkZXJCeS5kaXJlY3Rpb24pKTtcclxufVxyXG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbmZ1bmN0aW9uIHRvRmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gdG9Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICBjb25zdCBwcm90b3MgPSBmaWx0ZXIuZ2V0RmlsdGVycygpLm1hcChmaWx0ZXIgPT4gdG9GaWx0ZXIoZmlsdGVyKSk7XHJcbiAgICBpZiAocHJvdG9zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBwcm90b3NbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcjoge1xyXG4gICAgICAgICAgICBvcDogdG9Db21wb3NpdGVPcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcclxuICAgICAgICAgICAgZmlsdGVyczogcHJvdG9zXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b1VuYXJ5T3JGaWVsZEZpbHRlcihmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIub3AgPT09IFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLykge1xyXG4gICAgICAgIGlmIChpc05hblZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OQU4nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OVUxMJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZpbHRlci5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xyXG4gICAgICAgIGlmIChpc05hblZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OT1RfTkFOJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc051bGxWYWx1ZShmaWx0ZXIudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bmFyeUZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTk9UX05VTEwnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWVsZEZpbHRlcjoge1xyXG4gICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcclxuICAgICAgICAgICAgb3A6IHRvT3BlcmF0b3JOYW1lKGZpbHRlci5vcCksXHJcbiAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXIudmFsdWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHN3aXRjaCAoZmlsdGVyLnVuYXJ5RmlsdGVyLm9wKSB7XHJcbiAgICAgICAgY2FzZSAnSVNfTkFOJzpcclxuICAgICAgICAgICAgY29uc3QgbmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobmFuRmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdJU19OVUxMJzpcclxuICAgICAgICAgICAgY29uc3QgbnVsbEZpZWxkID0gZnJvbUZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIudW5hcnlGaWx0ZXIuZmllbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKG51bGxGaWVsZCwgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovLCB7XHJcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdJU19OT1RfTkFOJzpcclxuICAgICAgICAgICAgY29uc3Qgbm90TmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TmFuRmllbGQsIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sIHtcclxuICAgICAgICAgICAgICAgIGRvdWJsZVZhbHVlOiBOYU5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSAnSVNfTk9UX05VTEwnOlxyXG4gICAgICAgICAgICBjb25zdCBub3ROdWxsRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TnVsbEZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XHJcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkRmlsdGVyLmZpZWxkKSwgZnJvbU9wZXJhdG9yTmFtZShmaWx0ZXIuZmllbGRGaWx0ZXIub3ApLCBmaWx0ZXIuZmllbGRGaWx0ZXIudmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXIuY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMubWFwKGZpbHRlciA9PiBmcm9tRmlsdGVyKGZpbHRlcikpLCBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKGZpbHRlci5jb21wb3NpdGVGaWx0ZXIub3ApKTtcclxufVxyXG5mdW5jdGlvbiB0b0RvY3VtZW50TWFzayhmaWVsZE1hc2spIHtcclxuICAgIGNvbnN0IGNhbm9uaWNhbEZpZWxkcyA9IFtdO1xyXG4gICAgZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNhbm9uaWNhbEZpZWxkcy5wdXNoKGZpZWxkLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpZWxkUGF0aHM6IGNhbm9uaWNhbEZpZWxkc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRNYXNrKHByb3RvKSB7XHJcbiAgICBjb25zdCBwYXRocyA9IHByb3RvLmZpZWxkUGF0aHMgfHwgW107XHJcbiAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhwYXRocy5tYXAocGF0aCA9PiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHBhdGgpKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZFJlc291cmNlTmFtZShwYXRoKSB7XHJcbiAgICAvLyBSZXNvdXJjZSBuYW1lcyBoYXZlIGF0IGxlYXN0IDQgY29tcG9uZW50cyAocHJvamVjdCBJRCwgZGF0YWJhc2UgSUQpXHJcbiAgICByZXR1cm4gKHBhdGgubGVuZ3RoID49IDQgJiZcclxuICAgICAgICBwYXRoLmdldCgwKSA9PT0gJ3Byb2plY3RzJyAmJlxyXG4gICAgICAgIHBhdGguZ2V0KDIpID09PSAnZGF0YWJhc2VzJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBzZXQgb2YgbWV0YWRhdGEgdGhhdCB0aGUgbG9jYWwgc3RvcmUgdHJhY2tzIGZvciBlYWNoIHRhcmdldC5cclxuICovXHJcbmNsYXNzIFRhcmdldERhdGEge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIHRhcmdldCBiZWluZyBsaXN0ZW5lZCB0by4gKi9cclxuICAgIHRhcmdldCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgSUQgdG8gd2hpY2ggdGhlIHRhcmdldCBjb3JyZXNwb25kczsgQXNzaWduZWQgYnkgdGhlXHJcbiAgICAgKiBMb2NhbFN0b3JlIGZvciB1c2VyIGxpc3RlbnMgYW5kIGJ5IHRoZSBTeW5jRW5naW5lIGZvciBsaW1ibyB3YXRjaGVzLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRJZCwgXHJcbiAgICAvKiogVGhlIHB1cnBvc2Ugb2YgdGhlIHRhcmdldC4gKi9cclxuICAgIHB1cnBvc2UsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBsYXN0IHRyYW5zYWN0aW9uIGR1cmluZyB3aGljaCB0aGlzIHRhcmdldCBkYXRhXHJcbiAgICAgKiB3YXMgbW9kaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIHNlcXVlbmNlTnVtYmVyLCBcclxuICAgIC8qKiBUaGUgbGF0ZXN0IHNuYXBzaG90IHZlcnNpb24gc2VlbiBmb3IgdGhpcyB0YXJnZXQuICovXHJcbiAgICBzbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBzbmFwc2hvdCB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBhc3NvY2lhdGVkIHZpZXdcclxuICAgICAqIGNvbnRhaW5lZCBubyBsaW1ibyBkb2N1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHRhcmdldCB0byBiZVxyXG4gICAgICogcmVzdW1lZCBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXRcclxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cclxuICAgICAqIHRpbWUgZnJvbSB3aGljaCB0aGUgc2VydmVyIHNob3VsZCByZXN1bWUgc2VuZGluZyByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IGxhc3QgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIHJlc3VtZSB0b2tlbiBvclxyXG4gICAgICogcmVhZCB0aW1lLiBEb2N1bWVudHMgYXJlIGNvdW50ZWQgb25seSB3aGVuIG1ha2luZyBhIGxpc3RlbiByZXF1ZXN0IHdpdGhcclxuICAgICAqIHJlc3VtZSB0b2tlbiBvciByZWFkIHRpbWUsIG90aGVyd2lzZSwga2VlcCBpdCBudWxsLlxyXG4gICAgICovXHJcbiAgICBleHBlY3RlZENvdW50ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLnB1cnBvc2UgPSBwdXJwb3NlO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90VmVyc2lvbiA9IHNuYXBzaG90VmVyc2lvbjtcclxuICAgICAgICB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgICAgICB0aGlzLmV4cGVjdGVkQ291bnQgPSBleHBlY3RlZENvdW50O1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIHNlcXVlbmNlIG51bWJlci4gKi9cclxuICAgIHdpdGhTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCBzZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgdGhpcy5leHBlY3RlZENvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgcmVzdW1lIHRva2VuIGFuZFxyXG4gICAgICogc25hcHNob3QgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgd2l0aFJlc3VtZVRva2VuKHJlc3VtZVRva2VuLCBzbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgc25hcHNob3RWZXJzaW9uLCB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHJlc3VtZVRva2VuLCBcclxuICAgICAgICAvKiBleHBlY3RlZENvdW50PSAqLyBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgZXhwZWN0ZWQgY291bnQuXHJcbiAgICAgKi9cclxuICAgIHdpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgZXhwZWN0ZWRDb3VudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIGxhc3QgbGltYm8gZnJlZVxyXG4gICAgICogc25hcHNob3QgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHdpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4sIHRoaXMuZXhwZWN0ZWRDb3VudCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFNlcmlhbGl6ZXIgZm9yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIExvY2FsU3RvcmUuICovXHJcbmNsYXNzIExvY2FsU2VyaWFsaXplciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVTZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTZXJpYWxpemVyID0gcmVtb3RlU2VyaWFsaXplcjtcclxuICAgIH1cclxufVxyXG4vKiogRGVjb2RlcyBhIHJlbW90ZSBkb2N1bWVudCBmcm9tIHN0b3JhZ2UgbG9jYWxseSB0byBhIERvY3VtZW50LiAqL1xyXG5mdW5jdGlvbiBmcm9tRGJSZW1vdGVEb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIsIHJlbW90ZURvYykge1xyXG4gICAgbGV0IGRvYztcclxuICAgIGlmIChyZW1vdGVEb2MuZG9jdW1lbnQpIHtcclxuICAgICAgICBkb2MgPSBmcm9tRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHJlbW90ZURvYy5kb2N1bWVudCwgISFyZW1vdGVEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy5ub0RvY3VtZW50LnBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLm5vRG9jdW1lbnQucmVhZFRpbWUpO1xyXG4gICAgICAgIGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XHJcbiAgICAgICAgaWYgKHJlbW90ZURvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgZG9jLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC5wYXRoKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZnJvbURiVGltZXN0YW1wKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQudmVyc2lvbik7XHJcbiAgICAgICAgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld1Vua25vd25Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIGlmIChyZW1vdGVEb2MucmVhZFRpbWUpIHtcclxuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoZnJvbURiVGltZXN0YW1wS2V5KHJlbW90ZURvYy5yZWFkVGltZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvYztcclxufVxyXG4vKiogRW5jb2RlcyBhIGRvY3VtZW50IGZvciBzdG9yYWdlIGxvY2FsbHkuICovXHJcbmZ1bmN0aW9uIHRvRGJSZW1vdGVEb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIsIGRvY3VtZW50KSB7XHJcbiAgICBjb25zdCBrZXkgPSBkb2N1bWVudC5rZXk7XHJcbiAgICBjb25zdCByZW1vdGVEb2MgPSB7XHJcbiAgICAgICAgcHJlZml4UGF0aDoga2V5LmdldENvbGxlY3Rpb25QYXRoKCkucG9wTGFzdCgpLnRvQXJyYXkoKSxcclxuICAgICAgICBjb2xsZWN0aW9uR3JvdXA6IGtleS5jb2xsZWN0aW9uR3JvdXAsXHJcbiAgICAgICAgZG9jdW1lbnRJZDoga2V5LnBhdGgubGFzdFNlZ21lbnQoKSxcclxuICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcEtleShkb2N1bWVudC5yZWFkVGltZSksXHJcbiAgICAgICAgaGFzQ29tbWl0dGVkTXV0YXRpb25zOiBkb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcclxuICAgIH07XHJcbiAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICByZW1vdGVEb2MuZG9jdW1lbnQgPSB0b0RvY3VtZW50KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudC5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgIHJlbW90ZURvYy5ub0RvY3VtZW50ID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXHJcbiAgICAgICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wKGRvY3VtZW50LnZlcnNpb24pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzVW5rbm93bkRvY3VtZW50KCkpIHtcclxuICAgICAgICByZW1vdGVEb2MudW5rbm93bkRvY3VtZW50ID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXHJcbiAgICAgICAgICAgIHZlcnNpb246IHRvRGJUaW1lc3RhbXAoZG9jdW1lbnQudmVyc2lvbilcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVEb2M7XHJcbn1cclxuZnVuY3Rpb24gdG9EYlRpbWVzdGFtcEtleShzbmFwc2hvdFZlcnNpb24pIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHNuYXBzaG90VmVyc2lvbi50b1RpbWVzdGFtcCgpO1xyXG4gICAgcmV0dXJuIFt0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zZWNvbmRzXTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRGJUaW1lc3RhbXBLZXkoZGJUaW1lc3RhbXBLZXkpIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXBLZXlbMF0sIGRiVGltZXN0YW1wS2V5WzFdKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59XHJcbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXAoc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBzbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcclxuICAgIHJldHVybiB7IHNlY29uZHM6IHRpbWVzdGFtcC5zZWNvbmRzLCBuYW5vc2Vjb25kczogdGltZXN0YW1wLm5hbm9zZWNvbmRzIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURiVGltZXN0YW1wKGRiVGltZXN0YW1wKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKGRiVGltZXN0YW1wLnNlY29uZHMsIGRiVGltZXN0YW1wLm5hbm9zZWNvbmRzKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgYmF0Y2ggb2YgbXV0YXRpb25zIGludG8gYSBEYk11dGF0aW9uQmF0Y2ggZm9yIGxvY2FsIHN0b3JhZ2UuICovXHJcbmZ1bmN0aW9uIHRvRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBiYXRjaCkge1xyXG4gICAgY29uc3Qgc2VyaWFsaXplZEJhc2VNdXRhdGlvbnMgPSBiYXRjaC5iYXNlTXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWRNdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnMubWFwKG0gPT4gdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VySWQsXHJcbiAgICAgICAgYmF0Y2hJZDogYmF0Y2guYmF0Y2hJZCxcclxuICAgICAgICBsb2NhbFdyaXRlVGltZU1zOiBiYXRjaC5sb2NhbFdyaXRlVGltZS50b01pbGxpcygpLFxyXG4gICAgICAgIGJhc2VNdXRhdGlvbnM6IHNlcmlhbGl6ZWRCYXNlTXV0YXRpb25zLFxyXG4gICAgICAgIG11dGF0aW9uczogc2VyaWFsaXplZE11dGF0aW9uc1xyXG4gICAgfTtcclxufVxyXG4vKiogRGVjb2RlcyBhIERiTXV0YXRpb25CYXRjaCBpbnRvIGEgTXV0YXRpb25CYXRjaCAqL1xyXG5mdW5jdGlvbiBmcm9tRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgZGJCYXRjaCkge1xyXG4gICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IChkYkJhdGNoLmJhc2VNdXRhdGlvbnMgfHwgW10pLm1hcChtID0+IGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgLy8gU3F1YXNoIG9sZCB0cmFuc2Zvcm0gbXV0YXRpb25zIGludG8gZXhpc3RpbmcgcGF0Y2ggb3Igc2V0IG11dGF0aW9ucy5cclxuICAgIC8vIFRoZSByZXBsYWNlbWVudCBvZiByZXByZXNlbnRpbmcgYHRyYW5zZm9ybXNgIHdpdGggYHVwZGF0ZV90cmFuc2Zvcm1zYFxyXG4gICAgLy8gb24gdGhlIFNESyBtZWFucyB0aGF0IG9sZCBgdHJhbnNmb3JtYCBtdXRhdGlvbnMgc3RvcmVkIGluIEluZGV4ZWREQiBuZWVkXHJcbiAgICAvLyB0byBiZSB1cGRhdGVkIHRvIGB1cGRhdGVfdHJhbnNmb3Jtc2AuXHJcbiAgICAvLyBUT0RPKGIvMTc0NjA4Mzc0KTogUmVtb3ZlIHRoaXMgY29kZSBvbmNlIHdlIHBlcmZvcm0gYSBzY2hlbWEgbWlncmF0aW9uLlxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYkJhdGNoLm11dGF0aW9ucy5sZW5ndGggLSAxOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50TXV0YXRpb24gPSBkYkJhdGNoLm11dGF0aW9uc1tpXTtcclxuICAgICAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSBpICsgMSA8IGRiQmF0Y2gubXV0YXRpb25zLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICBkYkJhdGNoLm11dGF0aW9uc1tpICsgMV0udHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1NdXRhdGlvbiA9IGRiQmF0Y2gubXV0YXRpb25zW2kgKyAxXTtcclxuICAgICAgICAgICAgY3VycmVudE11dGF0aW9uLnVwZGF0ZVRyYW5zZm9ybXMgPVxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTXV0YXRpb24udHJhbnNmb3JtLmZpZWxkVHJhbnNmb3JtcztcclxuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnMuc3BsaWNlKGkgKyAxLCAxKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG11dGF0aW9ucyA9IGRiQmF0Y2gubXV0YXRpb25zLm1hcChtID0+IGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gVGltZXN0YW1wLmZyb21NaWxsaXMoZGJCYXRjaC5sb2NhbFdyaXRlVGltZU1zKTtcclxuICAgIHJldHVybiBuZXcgTXV0YXRpb25CYXRjaChkYkJhdGNoLmJhdGNoSWQsIHRpbWVzdGFtcCwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxufVxyXG4vKiogRGVjb2RlcyBhIERiVGFyZ2V0IGludG8gVGFyZ2V0RGF0YSAqL1xyXG5mdW5jdGlvbiBmcm9tRGJUYXJnZXQoZGJUYXJnZXQpIHtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAoZGJUYXJnZXQucmVhZFRpbWUpO1xyXG4gICAgY29uc3QgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pXHJcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICBsZXQgdGFyZ2V0O1xyXG4gICAgaWYgKGlzRG9jdW1lbnRRdWVyeShkYlRhcmdldC5xdWVyeSkpIHtcclxuICAgICAgICB0YXJnZXQgPSBmcm9tRG9jdW1lbnRzVGFyZ2V0KGRiVGFyZ2V0LnF1ZXJ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRhcmdldCA9IGZyb21RdWVyeVRhcmdldChkYlRhcmdldC5xdWVyeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGFyZ2V0LCBkYlRhcmdldC50YXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi8sIGRiVGFyZ2V0Lmxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgdmVyc2lvbiwgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGRiVGFyZ2V0LnJlc3VtZVRva2VuKSk7XHJcbn1cclxuLyoqIEVuY29kZXMgVGFyZ2V0RGF0YSBpbnRvIGEgRGJUYXJnZXQgZm9yIHN0b3JhZ2UgbG9jYWxseS4gKi9cclxuZnVuY3Rpb24gdG9EYlRhcmdldChsb2NhbFNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcclxuICAgIGNvbnN0IGRiVGltZXN0YW1wID0gdG9EYlRpbWVzdGFtcCh0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbik7XHJcbiAgICBjb25zdCBkYkxhc3RMaW1ib0ZyZWVUaW1lc3RhbXAgPSB0b0RiVGltZXN0YW1wKHRhcmdldERhdGEubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbik7XHJcbiAgICBsZXQgcXVlcnlQcm90bztcclxuICAgIGlmICh0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSkge1xyXG4gICAgICAgIHF1ZXJ5UHJvdG8gPSB0b0RvY3VtZW50c1RhcmdldChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgdGFyZ2V0RGF0YS50YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVlcnlQcm90byA9IHRvUXVlcnlUYXJnZXQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHRhcmdldERhdGEudGFyZ2V0KS5xdWVyeVRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIFdlIGNhbid0IHN0b3JlIHRoZSByZXN1bWVUb2tlbiBhcyBhIEJ5dGVTdHJpbmcgaW4gSW5kZXhlZERiLCBzbyB3ZVxyXG4gICAgLy8gY29udmVydCBpdCB0byBhIGJhc2U2NCBzdHJpbmcgZm9yIHN0b3JhZ2UuXHJcbiAgICBjb25zdCByZXN1bWVUb2tlbiA9IHRhcmdldERhdGEucmVzdW1lVG9rZW4udG9CYXNlNjQoKTtcclxuICAgIC8vIGxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciBpcyBhbHdheXMgMCB1bnRpbCB3ZSBkbyByZWFsIEdDLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YXJnZXRJZDogdGFyZ2V0RGF0YS50YXJnZXRJZCxcclxuICAgICAgICBjYW5vbmljYWxJZDogY2Fub25pZnlUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpLFxyXG4gICAgICAgIHJlYWRUaW1lOiBkYlRpbWVzdGFtcCxcclxuICAgICAgICByZXN1bWVUb2tlbixcclxuICAgICAgICBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI6IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIsXHJcbiAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjogZGJMYXN0TGltYm9GcmVlVGltZXN0YW1wLFxyXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVByb3RvXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZmlndXJpbmcgb3V0IHdoYXQga2luZCBvZiBxdWVyeSBoYXMgYmVlbiBzdG9yZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkoZGJRdWVyeSkge1xyXG4gICAgcmV0dXJuIGRiUXVlcnkuZG9jdW1lbnRzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqIEVuY29kZXMgYSBEYkJ1bmRsZSB0byBhIEJ1bmRsZU1ldGFkYXRhIG9iamVjdC4gKi9cclxuZnVuY3Rpb24gZnJvbURiQnVuZGxlKGRiQnVuZGxlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBkYkJ1bmRsZS5idW5kbGVJZCxcclxuICAgICAgICBjcmVhdGVUaW1lOiBmcm9tRGJUaW1lc3RhbXAoZGJCdW5kbGUuY3JlYXRlVGltZSksXHJcbiAgICAgICAgdmVyc2lvbjogZGJCdW5kbGUudmVyc2lvblxyXG4gICAgfTtcclxufVxyXG4vKiogRW5jb2RlcyBhIEJ1bmRsZU1ldGFkYXRhIHRvIGEgRGJCdW5kbGUuICovXHJcbmZ1bmN0aW9uIHRvRGJCdW5kbGUobWV0YWRhdGEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYnVuZGxlSWQ6IG1ldGFkYXRhLmlkLFxyXG4gICAgICAgIGNyZWF0ZVRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSkpLFxyXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb25cclxuICAgIH07XHJcbn1cclxuLyoqIEVuY29kZXMgYSBEYk5hbWVkUXVlcnkgdG8gYSBOYW1lZFF1ZXJ5LiAqL1xyXG5mdW5jdGlvbiBmcm9tRGJOYW1lZFF1ZXJ5KGRiTmFtZWRRdWVyeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBkYk5hbWVkUXVlcnkubmFtZSxcclxuICAgICAgICBxdWVyeTogZnJvbUJ1bmRsZWRRdWVyeShkYk5hbWVkUXVlcnkuYnVuZGxlZFF1ZXJ5KSxcclxuICAgICAgICByZWFkVGltZTogZnJvbURiVGltZXN0YW1wKGRiTmFtZWRRdWVyeS5yZWFkVGltZSlcclxuICAgIH07XHJcbn1cclxuLyoqIEVuY29kZXMgYSBOYW1lZFF1ZXJ5IGZyb20gYSBidW5kbGUgcHJvdG8gdG8gYSBEYk5hbWVkUXVlcnkuICovXHJcbmZ1bmN0aW9uIHRvRGJOYW1lZFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IHF1ZXJ5Lm5hbWUsXHJcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24ocXVlcnkucmVhZFRpbWUpKSxcclxuICAgICAgICBidW5kbGVkUXVlcnk6IHF1ZXJ5LmJ1bmRsZWRRdWVyeVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogRW5jb2RlcyBhIGBCdW5kbGVkUXVlcnlgIGZyb20gYnVuZGxlIHByb3RvIHRvIGEgUXVlcnkgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGlzIHJlY29uc3RydWN0cyB0aGUgb3JpZ2luYWwgcXVlcnkgdXNlZCB0byBidWlsZCB0aGUgYnVuZGxlIGJlaW5nIGxvYWRlZCxcclxuICogaW5jbHVkaW5nIGZlYXR1cmVzIGV4aXN0cyBvbmx5IGluIFNES3MgKGZvciBleGFtcGxlOiBsaW1pdC10by1sYXN0KS5cclxuICovXHJcbmZ1bmN0aW9uIGZyb21CdW5kbGVkUXVlcnkoYnVuZGxlZFF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeSA9IGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkoe1xyXG4gICAgICAgIHBhcmVudDogYnVuZGxlZFF1ZXJ5LnBhcmVudCxcclxuICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IGJ1bmRsZWRRdWVyeS5zdHJ1Y3R1cmVkUXVlcnlcclxuICAgIH0pO1xyXG4gICAgaWYgKGJ1bmRsZWRRdWVyeS5saW1pdFR5cGUgPT09ICdMQVNUJykge1xyXG4gICAgICAgIHJldHVybiBxdWVyeVdpdGhMaW1pdChxdWVyeSwgcXVlcnkubGltaXQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeTtcclxufVxyXG4vKiogRW5jb2RlcyBhIE5hbWVkUXVlcnkgcHJvdG8gb2JqZWN0IHRvIGEgTmFtZWRRdWVyeSBtb2RlbCBvYmplY3QuICovXHJcbmZ1bmN0aW9uIGZyb21Qcm90b05hbWVkUXVlcnkobmFtZWRRdWVyeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBuYW1lZFF1ZXJ5Lm5hbWUsXHJcbiAgICAgICAgcXVlcnk6IGZyb21CdW5kbGVkUXVlcnkobmFtZWRRdWVyeS5idW5kbGVkUXVlcnkpLFxyXG4gICAgICAgIHJlYWRUaW1lOiBmcm9tVmVyc2lvbihuYW1lZFF1ZXJ5LnJlYWRUaW1lKVxyXG4gICAgfTtcclxufVxyXG4vKiogRGVjb2RlcyBhIEJ1bmRsZU1ldGFkYXRhIHByb3RvIGludG8gYSBCdW5kbGVNZXRhZGF0YSBvYmplY3QuICovXHJcbmZ1bmN0aW9uIGZyb21CdW5kbGVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogbWV0YWRhdGEuaWQsXHJcbiAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvbixcclxuICAgICAgICBjcmVhdGVUaW1lOiBmcm9tVmVyc2lvbihtZXRhZGF0YS5jcmVhdGVUaW1lKVxyXG4gICAgfTtcclxufVxyXG4vKiogRW5jb2RlcyBhIERiRG9jdW1lbnRPdmVybGF5IG9iamVjdCB0byBhbiBPdmVybGF5IG1vZGVsIG9iamVjdC4gKi9cclxuZnVuY3Rpb24gZnJvbURiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgZGJEb2N1bWVudE92ZXJsYXkpIHtcclxuICAgIHJldHVybiBuZXcgT3ZlcmxheShkYkRvY3VtZW50T3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCwgZnJvbU11dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkYkRvY3VtZW50T3ZlcmxheS5vdmVybGF5TXV0YXRpb24pKTtcclxufVxyXG4vKiogRGVjb2RlcyBhbiBPdmVybGF5IG1vZGVsIG9iamVjdCBpbnRvIGEgRGJEb2N1bWVudE92ZXJsYXkgb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBvdmVybGF5KSB7XHJcbiAgICBjb25zdCBbXywgY29sbGVjdGlvblBhdGgsIGRvY3VtZW50SWRdID0gdG9EYkRvY3VtZW50T3ZlcmxheUtleSh1c2VySWQsIG92ZXJsYXkubXV0YXRpb24ua2V5KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlcklkLFxyXG4gICAgICAgIGNvbGxlY3Rpb25QYXRoLFxyXG4gICAgICAgIGRvY3VtZW50SWQsXHJcbiAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBvdmVybGF5Lm11dGF0aW9uLmtleS5nZXRDb2xsZWN0aW9uR3JvdXAoKSxcclxuICAgICAgICBsYXJnZXN0QmF0Y2hJZDogb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCxcclxuICAgICAgICBvdmVybGF5TXV0YXRpb246IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG92ZXJsYXkubXV0YXRpb24pXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBEYkRvY3VtZW50T3ZlcmxheUtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB1c2VyIGFuZFxyXG4gKiBkb2N1bWVudCBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5S2V5KHVzZXJJZCwgZG9jS2V5KSB7XHJcbiAgICBjb25zdCBkb2NJZCA9IGRvY0tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChkb2NLZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgcmV0dXJuIFt1c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBkb2NJZF07XHJcbn1cclxuZnVuY3Rpb24gdG9EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbmRleElkOiBpbmRleC5pbmRleElkLFxyXG4gICAgICAgIGNvbGxlY3Rpb25Hcm91cDogaW5kZXguY29sbGVjdGlvbkdyb3VwLFxyXG4gICAgICAgIGZpZWxkczogaW5kZXguZmllbGRzLm1hcChzID0+IFtzLmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgcy5raW5kXSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4LCBzdGF0ZSkge1xyXG4gICAgY29uc3QgZGVjb2RlZFN0YXRlID0gc3RhdGVcclxuICAgICAgICA/IG5ldyBJbmRleFN0YXRlKHN0YXRlLnNlcXVlbmNlTnVtYmVyLCBuZXcgSW5kZXhPZmZzZXQoZnJvbURiVGltZXN0YW1wKHN0YXRlLnJlYWRUaW1lKSwgbmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChzdGF0ZS5kb2N1bWVudEtleSkpLCBzdGF0ZS5sYXJnZXN0QmF0Y2hJZCkpXHJcbiAgICAgICAgOiBJbmRleFN0YXRlLmVtcHR5KCk7XHJcbiAgICBjb25zdCBkZWNvZGVkU2VnbWVudHMgPSBpbmRleC5maWVsZHMubWFwKChbZmllbGRQYXRoLCBraW5kXSkgPT4gbmV3IEluZGV4U2VnbWVudChGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KGZpZWxkUGF0aCksIGtpbmQpKTtcclxuICAgIHJldHVybiBuZXcgRmllbGRJbmRleChpbmRleC5pbmRleElkLCBpbmRleC5jb2xsZWN0aW9uR3JvdXAsIGRlY29kZWRTZWdtZW50cywgZGVjb2RlZFN0YXRlKTtcclxufVxyXG5mdW5jdGlvbiB0b0RiSW5kZXhTdGF0ZShpbmRleElkLCB1aWQsIHNlcXVlbmNlTnVtYmVyLCBvZmZzZXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5kZXhJZCxcclxuICAgICAgICB1aWQsXHJcbiAgICAgICAgc2VxdWVuY2VOdW1iZXIsXHJcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAob2Zmc2V0LnJlYWRUaW1lKSxcclxuICAgICAgICBkb2N1bWVudEtleTogZW5jb2RlUmVzb3VyY2VQYXRoKG9mZnNldC5kb2N1bWVudEtleS5wYXRoKSxcclxuICAgICAgICBsYXJnZXN0QmF0Y2hJZDogb2Zmc2V0Lmxhcmdlc3RCYXRjaElkXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYkJ1bmRsZUNhY2hlIHtcclxuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xyXG4gICAgICAgIHJldHVybiBidW5kbGVzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQoYnVuZGxlSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KGJ1bmRsZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJCdW5kbGUoYnVuZGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBidW5kbGVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiQnVuZGxlKGJ1bmRsZU1ldGFkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQocXVlcnlOYW1lKVxyXG4gICAgICAgICAgICAubmV4dChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk5hbWVkUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiTmFtZWRRdWVyeShxdWVyeSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGJ1bmRsZXMgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVuZGxlc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJCdW5kbGVTdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgbmFtZWRRdWVyaWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIG5hbWVkUXVlcmllc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJOYW1lZFF1ZXJ5U3RvcmUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBEb2N1bWVudE92ZXJsYXlDYWNoZSB1c2luZyBJbmRleGVkRGIuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIGRvY3VtZW50IHNlcmlhbGl6ZXIuXHJcbiAgICAgKiBAcGFyYW0gdXNlcklkIC0gVGhlIHVzZXJJZCBmb3Igd2hpY2ggd2UgYXJlIGFjY2Vzc2luZyBvdmVybGF5cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplciwgdXNlcklkKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmb3JVc2VyKHNlcmlhbGl6ZXIsIHVzZXIpIHtcclxuICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyLnVpZCB8fCAnJztcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYkRvY3VtZW50T3ZlcmxheUNhY2hlKHNlcmlhbGl6ZXIsIHVzZXJJZCk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQodG9EYkRvY3VtZW50T3ZlcmxheUtleSh0aGlzLnVzZXJJZCwga2V5KSlcclxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5ID0+IHtcclxuICAgICAgICAgICAgaWYgKGRiT3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwga2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpLm5leHQob3ZlcmxheSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2goKF8sIG11dGF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBzZXQgb2YgdW5pcXVlIGNvbGxlY3Rpb24gcGF0aHMuXHJcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goa2V5ID0+IGNvbGxlY3Rpb25QYXRocy5hZGQoZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5nZXRDb2xsZWN0aW9uUGF0aCgpKSkpO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgY29sbGVjdGlvblBhdGhzLmZvckVhY2goY29sbGVjdGlvblBhdGggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIGJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBiYXRjaElkICsgMV0sIFxyXG4gICAgICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKS5kZWxldGVBbGwoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgcmFuZ2UpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoY29sbGVjdGlvbik7XHJcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcclxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgc2luY2VCYXRjaElkXSwgW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSwgXHJcbiAgICAgICAgLypsb3dlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAubG9hZEFsbChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSlcclxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5cyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGJPdmVybGF5IG9mIGRiT3ZlcmxheXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgc2luY2VCYXRjaElkLCBjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICBsZXQgY3VycmVudEJhdGNoSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcclxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvbkdyb3VwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LFxyXG4gICAgICAgICAgICByYW5nZVxyXG4gICAgICAgIH0sIChfLCBkYk92ZXJsYXksIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmV0dXJuIHBhcnRpYWwgYmF0Y2ggb3ZlcmxheXMsIGV2ZW4gaWYgdGhlIHNpemVcclxuICAgICAgICAgICAgLy8gb2YgdGhlIHJlc3VsdCBzZXQgZXhjZWVkcyB0aGUgZ2l2ZW4gYGNvdW50YCBhcmd1bWVudC4gVGhlcmVmb3JlLCB3ZVxyXG4gICAgICAgICAgICAvLyBjb250aW51ZSB0byBhZ2dyZWdhdGUgcmVzdWx0cyBldmVuIGFmdGVyIHRoZSByZXN1bHQgc2l6ZSBleGNlZWRzXHJcbiAgICAgICAgICAgIC8vIGBjb3VudGAgaWYgdGhlcmUgYXJlIG1vcmUgb3ZlcmxheXMgZnJvbSB0aGUgYGN1cnJlbnRCYXRjaElkYC5cclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2l6ZSgpIDwgY291bnQgfHxcclxuICAgICAgICAgICAgICAgIG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQgPT09IGN1cnJlbnRCYXRjaElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJhdGNoSWQgPSBvdmVybGF5Lmxhcmdlc3RCYXRjaElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiRG9jdW1lbnRPdmVybGF5KHRoaXMuc2VyaWFsaXplciwgdGhpcy51c2VySWQsIG92ZXJsYXkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCBvdmVybGF5IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGRvY3VtZW50T3ZlcmxheVN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE92ZXJsYXlTdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTm90ZTogVGhpcyBjb2RlIGlzIGNvcGllZCBmcm9tIHRoZSBiYWNrZW5kLiBDb2RlIHRoYXQgaXMgbm90IHVzZWQgYnlcclxuLy8gRmlyZXN0b3JlIHdhcyByZW1vdmVkLlxyXG5jb25zdCBJTkRFWF9UWVBFX05VTEwgPSA1O1xyXG5jb25zdCBJTkRFWF9UWVBFX0JPT0xFQU4gPSAxMDtcclxuY29uc3QgSU5ERVhfVFlQRV9OQU4gPSAxMztcclxuY29uc3QgSU5ERVhfVFlQRV9OVU1CRVIgPSAxNTtcclxuY29uc3QgSU5ERVhfVFlQRV9USU1FU1RBTVAgPSAyMDtcclxuY29uc3QgSU5ERVhfVFlQRV9TVFJJTkcgPSAyNTtcclxuY29uc3QgSU5ERVhfVFlQRV9CTE9CID0gMzA7XHJcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFID0gMzc7XHJcbmNvbnN0IElOREVYX1RZUEVfR0VPUE9JTlQgPSA0NTtcclxuY29uc3QgSU5ERVhfVFlQRV9BUlJBWSA9IDUwO1xyXG5jb25zdCBJTkRFWF9UWVBFX01BUCA9IDU1O1xyXG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UID0gNjA7XHJcbi8vIEEgdGVybWluYXRvciB0aGF0IGluZGljYXRlcyB0aGF0IGEgdHJ1bmNhdGFibGUgdmFsdWUgd2FzIG5vdCB0cnVuY2F0ZWQuXHJcbi8vIFRoaXMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYWxsIG90aGVyIHR5cGUgbGFiZWxzLlxyXG5jb25zdCBOT1RfVFJVTkNBVEVEID0gMjtcclxuLyoqIEZpcmVzdG9yZSBpbmRleCB2YWx1ZSB3cml0ZXIuICAqL1xyXG5jbGFzcyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcbiAgICAvLyBUaGUgd3JpdGUgbWV0aG9kcyBiZWxvdyBzaG9ydC1jaXJjdWl0IHdyaXRpbmcgdGVybWluYXRvcnMgZm9yIHZhbHVlc1xyXG4gICAgLy8gY29udGFpbmluZyBhICh0ZXJtaW5hdGluZykgdHJ1bmNhdGVkIHZhbHVlLlxyXG4gICAgLy9cclxuICAgIC8vIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSByZXN1bHRpbmcgZW5jb2RpbmcgZm9yOlxyXG4gICAgLy9cclxuICAgIC8vIFtcImJhclwiLCBbMiwgXCJmb29cIl1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVEVSTSwgVEVSTSwgVEVSTSlcclxuICAgIC8vIFtcImJhclwiLCBbMiwgdHJ1bmNhdGVkKFwiZm9vXCIpXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBUUlVOQylcclxuICAgIC8vIFtcImJhclwiLCB0cnVuY2F0ZWQoW1wiZm9vXCJdKV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVkuIFNUUklORywgXCJmb29cIiwgVEVSTSwgVFJVTkMpXHJcbiAgICAvKiogV3JpdGVzIGFuIGluZGV4IHZhbHVlLiAgKi9cclxuICAgIHdyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KHZhbHVlLCBlbmNvZGVyKTtcclxuICAgICAgICAvLyBXcml0ZSBzZXBhcmF0b3IgdG8gc3BsaXQgaW5kZXggdmFsdWVzXHJcbiAgICAgICAgLy8gKHNlZSBnby9maXJlc3RvcmUtc3RvcmFnZS1mb3JtYXQjZW5jb2RpbmdzKS5cclxuICAgICAgICBlbmNvZGVyLndyaXRlSW5maW5pdHkoKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5kZXhWYWx1ZUF1eChpbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgaWYgKCdudWxsVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVMTCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQk9PTEVBTik7XHJcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoaW5kZXhWYWx1ZS5ib29sZWFuVmFsdWUgPyAxIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihub3JtYWxpemVOdW1iZXIoaW5kZXhWYWx1ZS5pbnRlZ2VyVmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVOdW1iZXIoaW5kZXhWYWx1ZS5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTkFOKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZVplcm8obikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAtMC4wLCAwIGFuZCAwLjAgYXJlIGFsbCBjb25zaWRlcmVkIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcigwLjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IGluZGV4VmFsdWUudGltZXN0YW1wVmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1RJTUVTVEFNUCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhgJHt0aW1lc3RhbXAuc2Vjb25kcyB8fCAnJ31gKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0aW1lc3RhbXAubmFub3MgfHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoaW5kZXhWYWx1ZS5zdHJpbmdWYWx1ZSwgZW5jb2Rlcik7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9CTE9CKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZUJ5dGVzKG5vcm1hbGl6ZUJ5dGVTdHJpbmcoaW5kZXhWYWx1ZS5ieXRlc1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4RW50aXR5UmVmKGluZGV4VmFsdWUucmVmZXJlbmNlVmFsdWUsIGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBnZW9Qb2ludCA9IGluZGV4VmFsdWUuZ2VvUG9pbnRWYWx1ZTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfR0VPUE9JTlQpO1xyXG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGdlb1BvaW50LmxhdGl0dWRlIHx8IDApO1xyXG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGdlb1BvaW50LmxvbmdpdHVkZSB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc01heFZhbHVlKGluZGV4VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4TWFwKGluZGV4VmFsdWUubWFwVmFsdWUsIGVuY29kZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4QXJyYXkoaW5kZXhWYWx1ZS5hcnJheVZhbHVlLCBlbmNvZGVyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleFN0cmluZyhzdHJpbmdJbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfU1RSSU5HKTtcclxuICAgICAgICB0aGlzLndyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSwgZW5jb2Rlcik7XHJcbiAgICB9XHJcbiAgICB3cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcclxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHN0cmluZ0luZGV4VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleE1hcChtYXBJbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gbWFwSW5kZXhWYWx1ZS5maWVsZHMgfHwge307XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTUFQKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXApKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhrZXksIGVuY29kZXIpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChtYXBba2V5XSwgZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleEFycmF5KGFycmF5SW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGFycmF5SW5kZXhWYWx1ZS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQVJSQVkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgoZWxlbWVudCwgZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleEVudGl0eVJlZihyZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1JFRkVSRU5DRSk7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IERvY3VtZW50S2V5LmZyb21OYW1lKHJlZmVyZW5jZVZhbHVlKS5wYXRoO1xyXG4gICAgICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfUkVGRVJFTkNFX1NFR01FTlQpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc2VnbWVudCwgZW5jb2Rlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIHR5cGVPcmRlcikge1xyXG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIodHlwZU9yZGVyKTtcclxuICAgIH1cclxuICAgIHdyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKSB7XHJcbiAgICAgICAgLy8gV2hpbGUgdGhlIFNESyBkb2VzIG5vdCBpbXBsZW1lbnQgdHJ1bmNhdGlvbiwgdGhlIHRydW5jYXRpb24gbWFya2VyIGlzXHJcbiAgICAgICAgLy8gdXNlZCB0byB0ZXJtaW5hdGUgYWxsIHZhcmlhYmxlIGxlbmd0aCB2YWx1ZXMgKHdoaWNoIGFyZSBzdHJpbmdzLCBieXRlcyxcclxuICAgICAgICAvLyByZWZlcmVuY2VzLCBhcnJheXMgYW5kIG1hcHMpLlxyXG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoTk9UX1RSVU5DQVRFRCk7XHJcbiAgICB9XHJcbn1cclxuRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRSA9IG5ldyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyB8IGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyB8IENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIHwgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBUaGVzZSBjb25zdGFudHMgYXJlIHRha2VuIGZyb20gdGhlIGJhY2tlbmQuICovXHJcbmNvbnN0IE1JTl9TVVJST0dBVEUgPSAnXFx1RDgwMCc7XHJcbmNvbnN0IE1BWF9TVVJST0dBVEUgPSAnXFx1REJGRic7XHJcbmNvbnN0IEVTQ0FQRTEgPSAweDAwO1xyXG5jb25zdCBOVUxMX0JZVEUgPSAweGZmOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTFcclxuY29uc3QgU0VQQVJBVE9SID0gMHgwMTsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUxXHJcbmNvbnN0IEVTQ0FQRTIgPSAweGZmO1xyXG5jb25zdCBJTkZJTklUWSA9IDB4ZmY7IC8vIENvbWJpbmVkIHdpdGggRVNDQVBFMlxyXG5jb25zdCBGRl9CWVRFID0gMHgwMDsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXHJcbmNvbnN0IExPTkdfU0laRSA9IDY0O1xyXG5jb25zdCBCWVRFX1NJWkUgPSA4O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgYnVmZmVyLiBUaGlzIGlzIGFyYml0cmFyeSwgYnV0IGxpa2VseSBsYXJnZXIgdGhhblxyXG4gKiBtb3N0IGluZGV4IHZhbHVlcyBzbyB0aGF0IGxlc3MgY29waWVzIG9mIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB3aWxsIGJlIG1hZGUuXHJcbiAqIEZvciBsYXJnZSB2YWx1ZXMsIGEgc2luZ2xlIGNvcHkgd2lsbCBtYWRlIHRvIGRvdWJsZSB0aGUgYnVmZmVyIGxlbmd0aC5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQlVGRkVSX1NJWkUgPSAxMDI0O1xyXG4vKiogQ29udmVydHMgYSBKYXZhU2NyaXB0IG51bWJlciB0byBhIGJ5dGUgYXJyYXkgKHVzaW5nIGJpZyBlbmRpYW4gZW5jb2RpbmcpLiAqL1xyXG5mdW5jdGlvbiBkb3VibGVUb0xvbmdCaXRzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xyXG4gICAgZHYuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgLyogbGl0dGxlRW5kaWFuPSAqLyBmYWxzZSk7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHYuYnVmZmVyKTtcclxufVxyXG4vKipcclxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgemVyb3MgaW4gYSBieXRlLlxyXG4gKlxyXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gbnVtYmVyT2ZMZWFkaW5nWmVyb3NJbkJ5dGUoeCkge1xyXG4gICAgaWYgKHggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gODtcclxuICAgIH1cclxuICAgIGxldCB6ZXJvcyA9IDA7XHJcbiAgICBpZiAoeCA+PiA0ID09PSAwKSB7XHJcbiAgICAgICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgZm91ciBiaXRzIGFyZSB6ZXJvLlxyXG4gICAgICAgIHplcm9zICs9IDQ7XHJcbiAgICAgICAgeCA9IHggPDwgNDtcclxuICAgIH1cclxuICAgIGlmICh4ID4+IDYgPT09IDApIHtcclxuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCB0d28gKG9yIG5leHQgdHdvKSBiaXRzIGFyZSB6ZXJvLlxyXG4gICAgICAgIHplcm9zICs9IDI7XHJcbiAgICAgICAgeCA9IHggPDwgMjtcclxuICAgIH1cclxuICAgIGlmICh4ID4+IDcgPT09IDApIHtcclxuICAgICAgICAvLyBUZXN0IGlmIHRoZSByZW1haW5pbmcgYml0IGlzIHplcm8uXHJcbiAgICAgICAgemVyb3MgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB6ZXJvcztcclxufVxyXG4vKiogQ291bnRzIHRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBpbiB0aGUgZ2l2ZW4gYnl0ZSBhcnJheS4gKi9cclxuZnVuY3Rpb24gbnVtYmVyT2ZMZWFkaW5nWmVyb3MoYnl0ZXMpIHtcclxuICAgIGxldCBsZWFkaW5nWmVyb3MgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyArK2kpIHtcclxuICAgICAgICBjb25zdCB6ZXJvcyA9IG51bWJlck9mTGVhZGluZ1plcm9zSW5CeXRlKGJ5dGVzW2ldICYgMHhmZik7XHJcbiAgICAgICAgbGVhZGluZ1plcm9zICs9IHplcm9zO1xyXG4gICAgICAgIGlmICh6ZXJvcyAhPT0gOCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVhZGluZ1plcm9zO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgXCJ2YWx1ZVwiLiBMZWFkaW5nIHplcm8gYnl0ZXNcclxuICogYXJlIHNraXBwZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSkge1xyXG4gICAgLy8gVGhpcyBpcyBqdXN0IHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxyXG4gICAgY29uc3QgbnVtQml0cyA9IExPTkdfU0laRSAtIG51bWJlck9mTGVhZGluZ1plcm9zKHZhbHVlKTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwobnVtQml0cyAvIEJZVEVfU0laRSk7XHJcbn1cclxuLyoqXHJcbiAqIE9yZGVyZWRDb2RlV3JpdGVyIGlzIGEgbWluaW1hbC1hbGxvY2F0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB3cml0aW5nXHJcbiAqIGJlaGF2aW9yIGRlZmluZWQgYnkgdGhlIGJhY2tlbmQuXHJcbiAqXHJcbiAqIFRoZSBjb2RlIGlzIHBvcnRlZCBmcm9tIGl0cyBKYXZhIGNvdW50ZXJwYXJ0LlxyXG4gKi9cclxuY2xhc3MgT3JkZXJlZENvZGVXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShERUZBVUxUX0JVRkZFUl9TSVpFKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgIH1cclxuICAgIHdyaXRlQnl0ZXNBc2NlbmRpbmcodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBpdCA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZyhieXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckFzY2VuZGluZygpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVCeXRlc0Rlc2NlbmRpbmcodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBpdCA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoYnl0ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIGJ5dGUgPSBpdC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdGVTZXBhcmF0b3JEZXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGFzY2VuZGluZy4gKi9cclxuICAgIHdyaXRlVXRmOEFzY2VuZGluZyhzZXF1ZW5jZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzZXF1ZW5jZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoY2hhckNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCBNSU5fU1VSUk9HQVRFIHx8IE1BWF9TVVJST0dBVEUgPCBjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjaGFyQ29kZSA+Pj4gNikpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNvZGVQb2ludCA+Pj4gMTIpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiA2KSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckFzY2VuZGluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqIFdyaXRlcyB1dGY4IGJ5dGVzIGludG8gdGhpcyBieXRlIHNlcXVlbmNlLCBkZXNjZW5kaW5nICovXHJcbiAgICB3cml0ZVV0ZjhEZXNjZW5kaW5nKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoY2hhckNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA2KSB8IChjaGFyQ29kZSA+Pj4gNikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IE1JTl9TVVJST0dBVEUgfHwgTUFYX1NVUlJPR0FURSA8IGMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY2hhckNvZGUgPj4+IDYpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDEyKSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDYpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcclxuICAgIH1cclxuICAgIHdyaXRlTnVtYmVyQXNjZW5kaW5nKHZhbCkge1xyXG4gICAgICAgIC8vIFZhbHVlcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIGJ5dGUgbGVuZ3RoIHByZWZpeCwgZm9sbG93ZWQgYnkgdGhlXHJcbiAgICAgICAgLy8gYWN0dWFsIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvT3JkZXJlZEJpdHModmFsKTtcclxuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XHJcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGxlbiAmIDB4ZmY7IC8vIFdyaXRlIHRoZSBsZW5ndGhcclxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IHZhbHVlW2ldICYgMHhmZjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cml0ZU51bWJlckRlc2NlbmRpbmcodmFsKSB7XHJcbiAgICAgICAgLy8gVmFsdWVzIGFyZSBlbmNvZGVkIHdpdGggYSBzaW5nbGUgYnl0ZSBsZW5ndGggcHJlZml4LCBmb2xsb3dlZCBieSB0aGVcclxuICAgICAgICAvLyBpbnZlcnRlZCB2YWx1ZSBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aXRoIGxlYWRpbmcgMCBieXRlcyBkcm9wcGVkLlxyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b09yZGVyZWRCaXRzKHZhbCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdW5zaWduZWROdW1MZW5ndGgodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEgKyBsZW4pO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KGxlbiAmIDB4ZmYpOyAvLyBXcml0ZSB0aGUgbGVuZ3RoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHZhbHVlLmxlbmd0aCAtIGxlbjsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KHZhbHVlW2ldICYgMHhmZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYWZ0ZXIgYWxsIG90aGVyIGJ5dGVcclxuICAgICAqIHNlcXVlbmNlcyB3cml0dGVuIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmZpbml0eUFzY2VuZGluZygpIHtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMik7XHJcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKElORklOSVRZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHRoZSBcImluZmluaXR5XCIgYnl0ZSBzZXF1ZW5jZSB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgb3RoZXIgYnl0ZVxyXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gZGVzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmZpbml0eURlc2NlbmRpbmcoKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKElORklOSVRZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBidWZmZXIgc3VjaCB0aGF0IGl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gaXQgd2FzIG5ld2x5XHJcbiAgICAgKiBjb25zdHJ1Y3RlZC5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICB9XHJcbiAgICBzZWVkKGVuY29kZWRCeXRlcykge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKGVuY29kZWRCeXRlcy5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyLnNldChlbmNvZGVkQnl0ZXMsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gZW5jb2RlZEJ5dGVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGVuY29kZWQgYnl0ZXMgaW4gdGhpcyBidWZmZXIuICAqL1xyXG4gICAgZW5jb2RlZEJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBgdmFsYCBpbnRvIGFuIGVuY29kaW5nIHNvIHRoYXQgdGhlIG9yZGVyIG1hdGNoZXMgdGhlIElFRUUgNzU0XHJcbiAgICAgKiBmbG9hdGluZy1wb2ludCBjb21wYXJpc29uIHJlc3VsdHMgd2l0aCB0aGUgZm9sbG93aW5nIGV4Y2VwdGlvbnM6XHJcbiAgICAgKiAgIC0wLjAgPCAwLjBcclxuICAgICAqICAgYWxsIG5vbi1OYU4gPCBOYU5cclxuICAgICAqICAgTmFOID0gTmFOXHJcbiAgICAgKi9cclxuICAgIHRvT3JkZXJlZEJpdHModmFsKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb3VibGVUb0xvbmdCaXRzKHZhbCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGJpdCBpcyBzZXQuIFdlIHVzZSBhIGJpdCBtYXNrIHNpbmNlIHZhbHVlWzBdIGlzXHJcbiAgICAgICAgLy8gZW5jb2RlZCBhcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1LlxyXG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodmFsdWVbMF0gJiAweDgwKSAhPT0gMDtcclxuICAgICAgICAvLyBSZXZlcnQgdGhlIHR3byBjb21wbGVtZW50IHRvIGdldCBuYXR1cmFsIG9yZGVyaW5nXHJcbiAgICAgICAgdmFsdWVbMF0gXj0gaXNOZWdhdGl2ZSA/IDB4ZmYgOiAweDgwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFsdWVbaV0gXj0gaXNOZWdhdGl2ZSA/IDB4ZmYgOiAweDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgYXNjZW5kaW5nIHRvIHRoZSBidWZmZXIuICovXHJcbiAgICB3cml0ZUJ5dGVBc2NlbmRpbmcoYikge1xyXG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IGIgJiAweGZmO1xyXG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTEpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoTlVMTF9CWVRFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEZGX0JZVEUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKG1hc2tlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFdyaXRlcyBhIHNpbmdsZSBieXRlIGRlc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gICovXHJcbiAgICB3cml0ZUJ5dGVEZXNjZW5kaW5nKGIpIHtcclxuICAgICAgICBjb25zdCBtYXNrZWQgPSBiICYgMHhmZjtcclxuICAgICAgICBpZiAobWFza2VkID09PSBFU0NBUEUxKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoTlVMTF9CWVRFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMik7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRkZfQllURSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCkge1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUxKTtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoU0VQQVJBVE9SKTtcclxuICAgIH1cclxuICAgIHdyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpIHtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTEpO1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoU0VQQVJBVE9SKTtcclxuICAgIH1cclxuICAgIHdyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoYikge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBiO1xyXG4gICAgfVxyXG4gICAgd3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYikge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+YjtcclxuICAgIH1cclxuICAgIGVuc3VyZUF2YWlsYWJsZShieXRlcykge1xyXG4gICAgICAgIGNvbnN0IG1pbkNhcGFjaXR5ID0gYnl0ZXMgKyB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChtaW5DYXBhY2l0eSA8PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgZG91YmxpbmcuXHJcbiAgICAgICAgbGV0IG5ld0xlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAqIDI7XHJcbiAgICAgICAgLy8gU3RpbGwgbm90IGJpZyBlbm91Z2g/IEp1c3QgYWxsb2NhdGUgdGhlIHJpZ2h0IHNpemUuXHJcbiAgICAgICAgaWYgKG5ld0xlbmd0aCA8IG1pbkNhcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG1pbkNhcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBidWZmZXIuXHJcbiAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcclxuICAgICAgICBuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTsgLy8gY29weSBvbGQgZGF0YVxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3JkZXJlZENvZGUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XHJcbiAgICB9XHJcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzQXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhBc2NlbmRpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVOdW1iZXIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlTnVtYmVyQXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5maW5pdHkoKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5QXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3JkZXJlZENvZGUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XHJcbiAgICB9XHJcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzRGVzY2VuZGluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVVdGY4RGVzY2VuZGluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZU51bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVOdW1iZXJEZXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5maW5pdHkoKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5RGVzY2VuZGluZygpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBEaXJlY3Rpb25hbEluZGV4Qnl0ZUVuY29kZXJgIHVzaW5nIGBPcmRlcmVkQ29kZVdyaXRlcmAgZm9yIHRoZVxyXG4gKiBhY3R1YWwgZW5jb2RpbmcuXHJcbiAqL1xyXG5jbGFzcyBJbmRleEJ5dGVFbmNvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBuZXcgT3JkZXJlZENvZGVXcml0ZXIoKTtcclxuICAgICAgICB0aGlzLmFzY2VuZGluZyA9IG5ldyBBc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xyXG4gICAgICAgIHRoaXMuZGVzY2VuZGluZyA9IG5ldyBEZXNjZW5kaW5nSW5kZXhCeXRlRW5jb2Rlcih0aGlzLm9yZGVyZWRDb2RlKTtcclxuICAgIH1cclxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS5zZWVkKGVuY29kZWRCeXRlcyk7XHJcbiAgICB9XHJcbiAgICBmb3JLaW5kKGtpbmQpIHtcclxuICAgICAgICByZXR1cm4ga2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovID8gdGhpcy5hc2NlbmRpbmcgOiB0aGlzLmRlc2NlbmRpbmc7XHJcbiAgICB9XHJcbiAgICBlbmNvZGVkQnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJlZENvZGUuZW5jb2RlZEJ5dGVzKCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLnJlc2V0KCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFJlcHJlc2VudHMgYW4gaW5kZXggZW50cnkgc2F2ZWQgYnkgdGhlIFNESyBpbiBwZXJzaXN0ZWQgc3RvcmFnZS4gKi9cclxuY2xhc3MgSW5kZXhFbnRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleElkLCBkb2N1bWVudEtleSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXhJZCA9IGluZGV4SWQ7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xyXG4gICAgICAgIHRoaXMuYXJyYXlWYWx1ZSA9IGFycmF5VmFsdWU7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25hbFZhbHVlID0gZGlyZWN0aW9uYWxWYWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBJbmRleEVudHJ5IGVudHJ5IHRoYXQgc29ydHMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGN1cnJlbnRcclxuICAgICAqIGRpcmVjdGlvbmFsIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBzdWNjZXNzb3IoKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudExlbmd0aCA9IHRoaXMuZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gY3VycmVudExlbmd0aCA9PT0gMCB8fCB0aGlzLmRpcmVjdGlvbmFsVmFsdWVbY3VycmVudExlbmd0aCAtIDFdID09PSAyNTVcclxuICAgICAgICAgICAgPyBjdXJyZW50TGVuZ3RoICsgMVxyXG4gICAgICAgICAgICA6IGN1cnJlbnRMZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc29yID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcclxuICAgICAgICBzdWNjZXNzb3Iuc2V0KHRoaXMuZGlyZWN0aW9uYWxWYWx1ZSwgMCk7XHJcbiAgICAgICAgaWYgKG5ld0xlbmd0aCAhPT0gY3VycmVudExlbmd0aCkge1xyXG4gICAgICAgICAgICBzdWNjZXNzb3Iuc2V0KFswXSwgdGhpcy5kaXJlY3Rpb25hbFZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICArK3N1Y2Nlc3NvcltzdWNjZXNzb3IubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhFbnRyeSh0aGlzLmluZGV4SWQsIHRoaXMuZG9jdW1lbnRLZXksIHRoaXMuYXJyYXlWYWx1ZSwgc3VjY2Vzc29yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmRleEVudHJ5Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xyXG4gICAgbGV0IGNtcCA9IGxlZnQuaW5kZXhJZCAtIHJpZ2h0LmluZGV4SWQ7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuYXJyYXlWYWx1ZSwgcmlnaHQuYXJyYXlWYWx1ZSk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuZGlyZWN0aW9uYWxWYWx1ZSwgcmlnaHQuZGlyZWN0aW9uYWxWYWx1ZSk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuZG9jdW1lbnRLZXksIHJpZ2h0LmRvY3VtZW50S2V5KTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlQnl0ZUFycmF5cyhsZWZ0LCByaWdodCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aCAmJiBpIDwgcmlnaHQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjb21wYXJlID0gbGVmdFtpXSAtIHJpZ2h0W2ldO1xyXG4gICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0Lmxlbmd0aCAtIHJpZ2h0Lmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBsaWdodCBxdWVyeSBwbGFubmVyIGZvciBGaXJlc3RvcmUuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgbWF0Y2hlcyBhIGBGaWVsZEluZGV4YCBhZ2FpbnN0IGEgRmlyZXN0b3JlIFF1ZXJ5IGBUYXJnZXRgLiBJdFxyXG4gKiBkZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgc3BlY2lmaWVkIHRhcmdldC5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyB0YWJsZSBzaG93Y2FzZXMgc29tZSBwb3NzaWJsZSBpbmRleCBjb25maWd1cmF0aW9uczpcclxuICpcclxuICogUXVlcnkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSW5kZXhcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogd2hlcmUoJ2EnLCAnPT0nLCAnYScpLndoZXJlKCdiJywgJz09JywgJ2InKSAgICAgICAgIHwgYSBBU0MsIGIgREVTQ1xyXG4gKiB3aGVyZSgnYScsICc9PScsICdhJykud2hlcmUoJ2InLCAnPT0nLCAnYicpICAgICAgICAgfCBhIEFTQ1xyXG4gKiB3aGVyZSgnYScsICc9PScsICdhJykud2hlcmUoJ2InLCAnPT0nLCAnYicpICAgICAgICAgfCBiIERFU0NcclxuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKSAgICAgICAgICAgICAgICAgIHwgYSBBU0NcclxuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnLCAnZGVzYycpICAgICAgICAgIHwgYSBERVNDXHJcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJykub3JkZXJCeSgnYicpICAgICB8IGEgQVNDLCBiIEFTQ1xyXG4gKiB3aGVyZSgnYScsICc+PScsICdhJykub3JkZXJCeSgnYScpLm9yZGVyQnkoJ2InKSAgICAgfCBhIEFTQ1xyXG4gKiB3aGVyZSgnYScsICdhcnJheS1jb250YWlucycsICdhJykub3JkZXJCeSgnYicpICAgICAgfCBhIENPTlRBSU5TLCBiIEFTQ0VORElOR1xyXG4gKiB3aGVyZSgnYScsICdhcnJheS1jb250YWlucycsICdhJykub3JkZXJCeSgnYicpICAgICAgfCBhIENPTlRBSU5TXHJcbiAqL1xyXG5jbGFzcyBUYXJnZXRJbmRleE1hdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gVGhlIGluZXF1YWxpdHkgZmlsdGVycyBvZiB0aGUgdGFyZ2V0IChpZiBpdCBleGlzdHMpLlxyXG4gICAgICAgIC8vIE5vdGU6IFRoZSBzb3J0IG9uIEZpZWxkRmlsdGVycyBpcyBub3QgcmVxdWlyZWQuIFVzaW5nIFNvcnRlZFNldCBoZXJlIGp1c3QgdG8gdXRpbGl6ZSB0aGUgY3VzdG9tXHJcbiAgICAgICAgLy8gY29tcGFyYXRvci5cclxuICAgICAgICB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzID0gbmV3IFNvcnRlZFNldCgobGhzLCByaHMpID0+IEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IobGhzLmZpZWxkLCByaHMuZmllbGQpKTtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25JZCA9XHJcbiAgICAgICAgICAgIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwXHJcbiAgICAgICAgICAgICAgICA6IHRhcmdldC5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICAgICAgdGhpcy5vcmRlckJ5cyA9IHRhcmdldC5vcmRlckJ5O1xyXG4gICAgICAgIHRoaXMuZXF1YWxpdHlGaWx0ZXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGFyZ2V0LmZpbHRlcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRGaWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZEZpbHRlci5pc0luZXF1YWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVxdWFsaXR5RmlsdGVycyA9IHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuYWRkKGZpZWxkRmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YWxpdHlGaWx0ZXJzLnB1c2goZmllbGRGaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGhhc011bHRpcGxlSW5lcXVhbGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgVGFyZ2V0SW5kZXhNYXRjaGVyJ3NcclxuICAgICAqIHRhcmdldC5cclxuICAgICAqXHJcbiAgICAgKiBBbiBpbmRleCBpcyBjb25zaWRlcmVkIGNhcGFibGUgb2Ygc2VydmluZyB0aGUgdGFyZ2V0IHdoZW46XHJcbiAgICAgKiAtIFRoZSB0YXJnZXQgdXNlcyBhbGwgaW5kZXggc2VnbWVudHMgZm9yIGl0cyBmaWx0ZXJzIGFuZCBvcmRlckJ5IGNsYXVzZXMuXHJcbiAgICAgKiAgIFRoZSB0YXJnZXQgY2FuIGhhdmUgYWRkaXRpb25hbCBmaWx0ZXIgYW5kIG9yZGVyQnkgY2xhdXNlcywgYnV0IG5vdFxyXG4gICAgICogICBmZXdlci5cclxuICAgICAqIC0gSWYgYW4gQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55ZmlsdGVyIGlzIHVzZWQsIHRoZSBpbmRleCBtdXN0IGFsc29cclxuICAgICAqICAgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgYENPTlRBSU5TYCBzZWdtZW50LlxyXG4gICAgICogLSBBbGwgZGlyZWN0aW9uYWwgaW5kZXggc2VnbWVudHMgY2FuIGJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0IGFzIGEgc2VyaWVzIG9mXHJcbiAgICAgKiAgIGVxdWFsaXR5IGZpbHRlcnMsIGEgc2luZ2xlIGluZXF1YWxpdHkgZmlsdGVyIGFuZCBhIHNlcmllcyBvZiBvcmRlckJ5XHJcbiAgICAgKiAgIGNsYXVzZXMuXHJcbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGUgZXF1YWxpdHkgZmlsdGVycyBtYXkgYXBwZWFyIG91dCBvZiBvcmRlci5cclxuICAgICAqIC0gVGhlIG9wdGlvbmFsIHNlZ21lbnQgZm9yIHRoZSBpbmVxdWFsaXR5IGZpbHRlciBtdXN0IGFwcGVhciBhZnRlciBhbGxcclxuICAgICAqICAgZXF1YWxpdHkgc2VnbWVudHMuXHJcbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGF0IG9yZGVyQnkgY2xhdXNlIG9mIHRoZSB0YXJnZXQgbXVzdCBhcHBlYXJcclxuICAgICAqICAgaW4gb3JkZXIgYWZ0ZXIgYWxsIGVxdWFsaXR5IGFuZCBpbmVxdWFsaXR5IHNlZ21lbnRzLiBTaW5nbGUgb3JkZXJCeVxyXG4gICAgICogICBjbGF1c2VzIGNhbm5vdCBiZSBza2lwcGVkLCBidXQgYSBjb250aW51b3VzIG9yZGVyQnkgc3VmZml4IG1heSBiZVxyXG4gICAgICogICBvbWl0dGVkLlxyXG4gICAgICovXHJcbiAgICBzZXJ2ZWRCeUluZGV4KGluZGV4KSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChpbmRleC5jb2xsZWN0aW9uR3JvdXAgPT09IHRoaXMuY29sbGVjdGlvbklkKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNNdWx0aXBsZUluZXF1YWxpdHkpIHtcclxuICAgICAgICAgICAgLy8gT25seSBzaW5nbGUgaW5lcXVhbGl0eSBpcyBzdXBwb3J0ZWQgZm9yIG5vdy5cclxuICAgICAgICAgICAgLy8gVE9ETyhBZGQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgaW5lcXVhbGl0eSBxdWVyeSk6IGIvMjk4NDQxMDQzXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gYXJyYXkgZWxlbWVudCwgZmluZCBhIG1hdGNoaW5nIGZpbHRlci5cclxuICAgICAgICBjb25zdCBhcnJheVNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGluZGV4KTtcclxuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgIXRoaXMuaGFzTWF0Y2hpbmdFcXVhbGl0eUZpbHRlcihhcnJheVNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhpbmRleCk7XHJcbiAgICAgICAgbGV0IGVxdWFsaXR5U2VnbWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IHNlZ21lbnRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IG9yZGVyQnlzSW5kZXggPSAwO1xyXG4gICAgICAgIC8vIFByb2Nlc3MgYWxsIGVxdWFsaXRpZXMgZmlyc3QuIEVxdWFsaXRpZXMgY2FuIGFwcGVhciBvdXQgb2Ygb3JkZXIuXHJcbiAgICAgICAgZm9yICg7IHNlZ21lbnRJbmRleCA8IHNlZ21lbnRzLmxlbmd0aDsgKytzZWdtZW50SW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gV2UgYXR0ZW1wdCB0byBncmVlZGlseSBtYXRjaCBhbGwgc2VnbWVudHMgdG8gZXF1YWxpdHkgZmlsdGVycy4gSWYgYVxyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgbWF0Y2hlcyBhbiBpbmRleCBzZWdtZW50LCB3ZSBjYW4gbWFyayB0aGUgc2VnbWVudCBhcyB1c2VkLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNNYXRjaGluZ0VxdWFsaXR5RmlsdGVyKHNlZ21lbnRzW3NlZ21lbnRJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBlcXVhbGl0eVNlZ21lbnRzID0gZXF1YWxpdHlTZWdtZW50cy5hZGQoc2VnbWVudHNbc2VnbWVudEluZGV4XS5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgYSBtYXRjaGluZyBmaWx0ZXIsIHdlIG5lZWQgdG8gdmVyaWZ5IHdoZXRoZXIgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyByZW1haW5pbmcgc2VnbWVudHMgbWFwIHRvIHRoZSB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBpdHMgb3JkZXJCeVxyXG4gICAgICAgICAgICAgICAgLy8gY2xhdXNlcy5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBwcm9jZXNzZWQgYWxsIHNlZ21lbnRzLCBhbGwgc2VnbWVudHMgYXJlIHVzZWQgdG8gc2VydmVcclxuICAgICAgICAvLyB0aGUgZXF1YWxpdHkgZmlsdGVycyBhbmQgd2UgZG8gbm90IG5lZWQgdG8gbWFwIGFueSBzZWdtZW50cyB0byB0aGVcclxuICAgICAgICAvLyB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBvcmRlckJ5IGNsYXVzZXMuXHJcbiAgICAgICAgaWYgKHNlZ21lbnRJbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIGluZXF1YWxpdHkgaXMgY3VycmVudGx5IHN1cHBvcnRlZC4gR2V0IHRoZSBvbmx5IGVudHJ5IGluIHRoZSBzZXQuXHJcbiAgICAgICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWx0ZXIgPSB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLmdldEl0ZXJhdG9yKCkuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbmVxdWFsaXR5IGZpbHRlciBhbmQgdGhlIGZpZWxkIHdhcyBub3QgaW4gb25lIG9mIHRoZVxyXG4gICAgICAgICAgICAvLyBlcXVhbGl0eSBmaWx0ZXJzIGFib3ZlLCB0aGUgbmV4dCBzZWdtZW50IG11c3QgbWF0Y2ggYm90aCB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZmlyc3Qgb3JkZXJCeSBjbGF1c2UuXHJcbiAgICAgICAgICAgIGlmICghZXF1YWxpdHlTZWdtZW50cy5oYXMoaW5lcXVhbGl0eUZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXNGaWx0ZXIoaW5lcXVhbGl0eUZpbHRlciwgc2VnbWVudCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaGVzT3JkZXJCeSh0aGlzLm9yZGVyQnlzW29yZGVyQnlzSW5kZXgrK10sIHNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICsrc2VnbWVudEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbGwgcmVtYWluaW5nIHNlZ21lbnRzIG5lZWQgdG8gcmVwcmVzZW50IHRoZSBwcmVmaXggb2YgdGhlIHRhcmdldCdzXHJcbiAgICAgICAgLy8gb3JkZXJCeS5cclxuICAgICAgICBmb3IgKDsgc2VnbWVudEluZGV4IDwgc2VnbWVudHMubGVuZ3RoOyArK3NlZ21lbnRJbmRleCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKG9yZGVyQnlzSW5kZXggPj0gdGhpcy5vcmRlckJ5cy5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNPcmRlckJ5KHRoaXMub3JkZXJCeXNbb3JkZXJCeXNJbmRleCsrXSwgc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZ1bGwgbWF0Y2hlZCBmaWVsZCBpbmRleCBmb3IgdGhpcyB0YXJnZXQuIEN1cnJlbnRseSBtdWx0aXBsZVxyXG4gICAgICogaW5lcXVhbGl0eSBxdWVyeSBpcyBub3Qgc3VwcG9ydGVkIHNvIGZ1bmN0aW9uIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgYnVpbGRUYXJnZXRJbmRleCgpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNNdWx0aXBsZUluZXF1YWxpdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIG9ubHkgb25lIHNlZ21lbnQgY3JlYXRlZCBmb3Igb25lIGZpZWxkLiBGb3IgZXhhbXBsZSxcclxuICAgICAgICAvLyBpbiBjYXNlIGxpa2UgYSA9PSAzIGFuZCBhID4gMiwgSW5kZXgge2EgQVNDRU5ESU5HfSB3aWxsIG9ubHkgYmUgY3JlYXRlZFxyXG4gICAgICAgIC8vIG9uY2UuXHJcbiAgICAgICAgbGV0IHVuaXF1ZUZpZWxkcyA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLmVxdWFsaXR5RmlsdGVycykge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyLmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaXNBcnJheU9wZXJhdG9yID0gZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHxcclxuICAgICAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5T3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWx0ZXIuZmllbGQsIDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlRmllbGRzLmhhcyhmaWx0ZXIuZmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bmlxdWVGaWVsZHMgPSB1bmlxdWVGaWVsZHMuYWRkKGZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmlsdGVyLmZpZWxkLCAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3RlOiBXZSBkbyBub3QgZXhwbGljaXRseSBjaGVjayBgdGhpcy5pbmVxdWFsaXR5RmlsdGVyYCBidXQgcmF0aGVyIHJlbHlcclxuICAgICAgICAvLyBvbiB0aGUgdGFyZ2V0IGRlZmluaW5nIGFuIGFwcHJvcHJpYXRlIFwib3JkZXIgYnlcIiB0byBlbnN1cmUgdGhhdCB0aGVcclxuICAgICAgICAvLyByZXF1aXJlZCBpbmRleCBzZWdtZW50IGlzIGFkZGVkLiBUaGUgcXVlcnkgZW5naW5lIHdvdWxkIHJlamVjdCBhIHF1ZXJ5XHJcbiAgICAgICAgLy8gd2l0aCBhbiBpbmVxdWFsaXR5IGZpbHRlciB0aGF0IGxhY2tzIHRoZSByZXF1aXJlZCBvcmRlci1ieSBjbGF1c2UuXHJcbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHRoaXMub3JkZXJCeXMpIHtcclxuICAgICAgICAgICAgLy8gU3RvcCBhZGRpbmcgbW9yZSBzZWdtZW50cyBpZiB3ZSBzZWUgYSBvcmRlci1ieSBvbiBrZXkuIFR5cGljYWxseSB0aGlzXHJcbiAgICAgICAgICAgIC8vIGlzIHRoZSBkZWZhdWx0IGltcGxpY2l0IG9yZGVyLWJ5IHdoaWNoIGlzIGNvdmVyZWQgaW4gdGhlIGluZGV4X2VudHJ5XHJcbiAgICAgICAgICAgIC8vIHRhYmxlIGFzIGEgc2VwYXJhdGUgY29sdW1uLiBJZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgb3JkZXItYnksIHRoZVxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgaW5kZXggd2lsbCBiZSBtaXNzaW5nIHNvbWUgc2VnbWVudHMgb3B0aW1pemVkIGZvciBvcmRlci1ieXMsXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIHByb2JhYmx5IGZpbmUuXHJcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVuaXF1ZUZpZWxkcy5oYXMob3JkZXJCeS5maWVsZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuaXF1ZUZpZWxkcyA9IHVuaXF1ZUZpZWxkcy5hZGQob3JkZXJCeS5maWVsZCk7XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChvcmRlckJ5LmZpZWxkLCBvcmRlckJ5LmRpciA9PT0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXHJcbiAgICAgICAgICAgICAgICA/IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xyXG4gICAgICAgICAgICAgICAgOiAxIC8qIEluZGV4S2luZC5ERVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIHRoaXMuY29sbGVjdGlvbklkLCBzZWdtZW50cywgSW5kZXhTdGF0ZS5lbXB0eSgpKTtcclxuICAgIH1cclxuICAgIGhhc01hdGNoaW5nRXF1YWxpdHlGaWx0ZXIoc2VnbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZXF1YWxpdHlGaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoZXNGaWx0ZXIoZmlsdGVyLCBzZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlc0ZpbHRlcihmaWx0ZXIsIHNlZ21lbnQpIHtcclxuICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQgfHwgIWZpbHRlci5maWVsZC5pc0VxdWFsKHNlZ21lbnQuZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzQXJyYXlPcGVyYXRvciA9IGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XHJcbiAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XHJcbiAgICAgICAgcmV0dXJuIChzZWdtZW50LmtpbmQgPT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSA9PT0gaXNBcnJheU9wZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlc09yZGVyQnkob3JkZXJCeSwgc2VnbWVudCkge1xyXG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0VxdWFsKHNlZ21lbnQuZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovICYmXHJcbiAgICAgICAgICAgIG9yZGVyQnkuZGlyID09PSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8pIHx8XHJcbiAgICAgICAgICAgIChzZWdtZW50LmtpbmQgPT09IDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8gJiZcclxuICAgICAgICAgICAgICAgIG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLykpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGhlbHAgd2l0aCBib29sZWFuIGxvZ2ljIHRyYW5zZm9ybWF0aW9ucyBuZWVkZWQgZm9yIGhhbmRsaW5nXHJcbiAqIGNvbXBsZXggZmlsdGVycyB1c2VkIGluIHF1ZXJpZXMuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGBpbmAgZmlsdGVyIGlzIG9ubHkgYSBzeW50YWN0aWMgc3VnYXIgb3ZlciBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXRpZXMuIEZvciBpbnN0YW5jZTogYGEgaW5cclxuICogWzEsMiwzXWAgaXMgaW4gZmFjdCBgYT09MSB8fCBhPT0yIHx8IGE9PTNgLiBUaGlzIG1ldGhvZCBleHBhbmRzIGFueSBgaW5gIGZpbHRlciBpbiB0aGUgZ2l2ZW5cclxuICogaW5wdXQgaW50byBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXR5IGZpbHRlcnMgYW5kIHJldHVybnMgdGhlIGV4cGFuZGVkIGZpbHRlci5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XHJcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgSW5GaWx0ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gKChfYiA9IChfYSA9IGZpbHRlci52YWx1ZS5hcnJheVZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKHZhbHVlID0+IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWx0ZXIuZmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywgdmFsdWUpKSkgfHwgW107XHJcbiAgICAgICAgICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKGV4cGFuZGVkRmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCBvdGhlciBraW5kcyBvZiBmaWVsZCBmaWx0ZXJzLlxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFdlIGhhdmUgYSBjb21wb3NpdGUgZmlsdGVyLlxyXG4gICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlSW5FeHBhbnNpb24oc3ViZmlsdGVyKSk7XHJcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShleHBhbmRlZEZpbHRlcnMsIGZpbHRlci5vcCk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgY29tcG9zaXRlIGZpbHRlciwgcmV0dXJucyB0aGUgbGlzdCBvZiB0ZXJtcyBpbiBpdHMgZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0uXHJcbiAqXHJcbiAqIDxwPkVhY2ggZWxlbWVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIGlzIG9uZSB0ZXJtIG9mIHRoZSByZXN1bHRpbmcgRE5GLiBGb3IgaW5zdGFuY2U6IEZvciB0aGVcclxuICogaW5wdXQ6IChBIHx8IEIpICYmIEMsIHRoZSBETkYgZm9ybSBpczogKEEgJiYgQykgfHwgKEIgJiYgQyksIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGlzIGEgbGlzdFxyXG4gKiB3aXRoIHR3byBlbGVtZW50czogYSBjb21wb3NpdGUgZmlsdGVyIHRoYXQgcGVyZm9ybXMgKEEgJiYgQyksIGFuZCBhIGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdFxyXG4gKiBwZXJmb3JtcyAoQiAmJiBDKS5cclxuICpcclxuICogQHBhcmFtIGZpbHRlciB0aGUgY29tcG9zaXRlIGZpbHRlciB0byBjYWxjdWxhdGUgRE5GIHRyYW5zZm9ybSBmb3IuXHJcbiAqIEByZXR1cm4gdGhlIHRlcm1zIGluIHRoZSBETkYgdHJhbnNmb3JtLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG5mVGVybXMoZmlsdGVyKSB7XHJcbiAgICBpZiAoZmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpKTtcclxuICAgIGhhcmRBc3NlcnQoaXNEaXNqdW5jdGl2ZU5vcm1hbEZvcm0ocmVzdWx0KSk7XHJcbiAgICBpZiAoaXNTaW5nbGVGaWVsZEZpbHRlcihyZXN1bHQpIHx8IGlzRmxhdENvbmp1bmN0aW9uKHJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgYSBzaW5nbGUgZmllbGQgZmlsdGVyLiBlLmcuIChhID09IDEwKS4gKi9cclxuZnVuY3Rpb24gaXNTaW5nbGVGaWVsZEZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHJldHVybiBmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcjtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGNvbmp1bmN0aW9uIG9mIG9uZSBvciBtb3JlIGZpZWxkIGZpbHRlcnMuIGUuZy4gKGEgPT0gMTBcclxuICogJiYgYiA9PSAyMClcclxuICovXHJcbmZ1bmN0aW9uIGlzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcclxuICAgICAgICBjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gZmlsdGVyIGlzIGluIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpLlxyXG4gKlxyXG4gKiA8cD5JbiBib29sZWFuIGxvZ2ljLCBhIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpIGlzIGEgY2Fub25pY2FsIG5vcm1hbCBmb3JtIG9mIGEgbG9naWNhbFxyXG4gKiBmb3JtdWxhIGNvbnNpc3Rpbmcgb2YgYSBkaXNqdW5jdGlvbiBvZiBjb25qdW5jdGlvbnM7IGl0IGNhbiBhbHNvIGJlIGRlc2NyaWJlZCBhcyBhbiBPUiBvZiBBTkRzLlxyXG4gKlxyXG4gKiA8cD5Gb3IgbW9yZSBpbmZvLCB2aXNpdDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzanVuY3RpdmVfbm9ybWFsX2Zvcm1cclxuICovXHJcbmZ1bmN0aW9uIGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIChpc1NpbmdsZUZpZWxkRmlsdGVyKGZpbHRlcikgfHxcclxuICAgICAgICBpc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpIHx8XHJcbiAgICAgICAgaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGRpc2p1bmN0aW9uIG9mIG9uZSBvciBtb3JlIFwiZmxhdCBjb25qdW5jdGlvbnNcIiBhbmRcclxuICogZmllbGQgZmlsdGVycy4gZS5nLiAoYSA9PSAxMCkgfHwgKGI9PTIwICYmIGM9PTMwKVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIGZpbHRlci5nZXRGaWx0ZXJzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTaW5nbGVGaWVsZEZpbHRlcihzdWJGaWx0ZXIpICYmICFpc0ZsYXRDb25qdW5jdGlvbihzdWJGaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGZpbHRlcikge1xyXG4gICAgaGFyZEFzc2VydChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXIuZmlsdGVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShmaWx0ZXIuZmlsdGVyc1swXSk7XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlIERORiBmb3IgZWFjaCBvZiB0aGUgc3ViZmlsdGVycyBmaXJzdFxyXG4gICAgY29uc3QgcmVzdWx0ID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKHN1YmZpbHRlcikpO1xyXG4gICAgbGV0IG5ld0ZpbHRlciA9IENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocmVzdWx0LCBmaWx0ZXIub3ApO1xyXG4gICAgbmV3RmlsdGVyID0gYXBwbHlBc3NvY2lhdGlvbihuZXdGaWx0ZXIpO1xyXG4gICAgaWYgKGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKG5ld0ZpbHRlcikpIHtcclxuICAgICAgICByZXR1cm4gbmV3RmlsdGVyO1xyXG4gICAgfVxyXG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xyXG4gICAgaGFyZEFzc2VydChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKG5ld0ZpbHRlcikpO1xyXG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIuZmlsdGVycy5sZW5ndGggPiAxKTtcclxuICAgIHJldHVybiBuZXdGaWx0ZXIuZmlsdGVycy5yZWR1Y2UoKHJ1bm5pbmdSZXN1bHQsIGZpbHRlcikgPT4gYXBwbHlEaXN0cmlidXRpb24ocnVubmluZ1Jlc3VsdCwgZmlsdGVyKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb24obGhzLCByaHMpIHtcclxuICAgIGhhcmRBc3NlcnQobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgbGhzIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcclxuICAgIGhhcmRBc3NlcnQocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgcmhzIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICBpZiAocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgRmllbGRGaWx0ZXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEZpbHRlcnMobGhzLCByaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgQ29tcG9zaXRlRmlsdGVyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5RGlzdHJpYnV0aW9uRmllbGRBbmRDb21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgLy8gQ29tcG9zaXRlRmlsdGVyIEZpZWxkRmlsdGVyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5RGlzdHJpYnV0aW9uRmllbGRBbmRDb21wb3NpdGVGaWx0ZXJzKHJocywgbGhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBvc2l0ZUZpbHRlciBDb21wb3NpdGVGaWx0ZXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25Db21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwbHlBc3NvY2lhdGlvbihyZXN1bHQpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uRmllbGRGaWx0ZXJzKGxocywgcmhzKSB7XHJcbiAgICAvLyBDb25qdW5jdGlvbiBkaXN0cmlidXRpb24gZm9yIHR3byBmaWVsZCBmaWx0ZXJzIGlzIHRoZSBjb25qdW5jdGlvbiBvZiB0aGVtLlxyXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoW2xocywgcmhzXSwgXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uQ29tcG9zaXRlRmlsdGVycyhsaHMsIHJocykge1xyXG4gICAgaGFyZEFzc2VydChsaHMuZmlsdGVycy5sZW5ndGggPiAwICYmIHJocy5maWx0ZXJzLmxlbmd0aCA+IDApO1xyXG4gICAgLy8gVGhlcmUgYXJlIGZvdXIgY2FzZXM6XHJcbiAgICAvLyAoQSAmIEIpICYgKEMgJiBEKSAtLT4gKEEgJiBCICYgQyAmIEQpXHJcbiAgICAvLyAoQSAmIEIpICYgKEMgfCBEKSAtLT4gKEEgJiBCICYgQykgfCAoQSAmIEIgJiBEKVxyXG4gICAgLy8gKEEgfCBCKSAmIChDICYgRCkgLS0+IChDICYgRCAmIEEpIHwgKEMgJiBEICYgQilcclxuICAgIC8vIChBIHwgQikgJiAoQyB8IEQpIC0tPiAoQSAmIEMpIHwgKEEgJiBEKSB8IChCICYgQykgfCAoQiAmIEQpXHJcbiAgICAvLyBDYXNlIDEgaXMgYSBtZXJnZS5cclxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGxocykgJiYgY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMobGhzLCByaHMuZ2V0RmlsdGVycygpKTtcclxuICAgIH1cclxuICAgIC8vIENhc2UgMiwzLDQgYWxsIGhhdmUgYXQgbGVhc3Qgb25lIHNpZGUgKGxocyBvciByaHMpIHRoYXQgaXMgYSBkaXNqdW5jdGlvbi4gSW4gYWxsIHRocmVlIGNhc2VzXHJcbiAgICAvLyB3ZSBzaG91bGQgdGFrZSBlYWNoIGVsZW1lbnQgb2YgdGhlIGRpc2p1bmN0aW9uIGFuZCBkaXN0cmlidXRlIGl0IG92ZXIgdGhlIG90aGVyIHNpZGUsIGFuZFxyXG4gICAgLy8gcmV0dXJuIHRoZSBkaXNqdW5jdGlvbiBvZiB0aGUgZGlzdHJpYnV0aW9uIHJlc3VsdHMuXHJcbiAgICBjb25zdCBkaXNqdW5jdGlvblNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyBsaHMgOiByaHM7XHJcbiAgICBjb25zdCBvdGhlclNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyByaHMgOiBsaHM7XHJcbiAgICBjb25zdCByZXN1bHRzID0gZGlzanVuY3Rpb25TaWRlLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseURpc3RyaWJ1dGlvbihzdWJmaWx0ZXIsIG90aGVyU2lkZSkpO1xyXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocmVzdWx0cywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhmaWVsZEZpbHRlciwgY29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAvLyBUaGVyZSBhcmUgdHdvIGNhc2VzOlxyXG4gICAgLy8gQSAmIChCICYgQykgLS0+IChBICYgQiAmIEMpXHJcbiAgICAvLyBBICYgKEIgfCBDKSAtLT4gKEEgJiBCKSB8IChBICYgQylcclxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikpIHtcclxuICAgICAgICAvLyBDYXNlIDFcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyV2l0aEFkZGVkRmlsdGVycyhjb21wb3NpdGVGaWx0ZXIsIGZpZWxkRmlsdGVyLmdldEZpbHRlcnMoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBDYXNlIDJcclxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJzID0gY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseURpc3RyaWJ1dGlvbihmaWVsZEZpbHRlciwgc3ViZmlsdGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobmV3RmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGUgYXNzb2NpYXRpdml0eSBwcm9wZXJ0eSB0byB0aGUgZ2l2ZW4gZmlsdGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZmlsdGVyLlxyXG4gKlxyXG4gKiA8dWw+XHJcbiAqICAgPGxpPkEgfCAoQiB8IEMpID09IChBIHwgQikgfCBDID09IChBIHwgQiB8IEMpXHJcbiAqICAgPGxpPkEgJiAoQiAmIEMpID09IChBICYgQikgJiBDID09IChBICYgQiAmIEMpXHJcbiAqIDwvdWw+XHJcbiAqXHJcbiAqIDxwPkZvciBtb3JlIGluZm8sIHZpc2l0OiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc3NvY2lhdGl2ZV9wcm9wZXJ0eSNQcm9wb3NpdGlvbmFsX2xvZ2ljXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcikge1xyXG4gICAgaGFyZEFzc2VydChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmlsdGVycygpO1xyXG4gICAgLy8gSWYgdGhlIGNvbXBvc2l0ZSBmaWx0ZXIgb25seSBjb250YWlucyAxIGZpbHRlciwgYXBwbHkgYXNzb2NpYXRpdml0eSB0byBpdC5cclxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcnNbMF0pO1xyXG4gICAgfVxyXG4gICAgLy8gQXNzb2NpYXRpdml0eSBhcHBsaWVkIHRvIGEgZmxhdCBjb21wb3NpdGUgZmlsdGVyIHJlc3VsdHMgaXMgaXRzZWxmLlxyXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRmxhdChmaWx0ZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIC8vIEZpcnN0IGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gYWxsIHN1YmZpbHRlcnMuIFRoaXMgd2lsbCBpbiB0dXJuIHJlY3Vyc2l2ZWx5IGFwcGx5XHJcbiAgICAvLyBhc3NvY2lhdGl2aXR5IHRvIGFsbCBuZXN0ZWQgY29tcG9zaXRlIGZpbHRlcnMgYW5kIGZpZWxkIGZpbHRlcnMuXHJcbiAgICBjb25zdCB1cGRhdGVkRmlsdGVycyA9IGZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseUFzc29jaWF0aW9uKHN1YmZpbHRlcikpO1xyXG4gICAgLy8gRm9yIGNvbXBvc2l0ZSBzdWJmaWx0ZXJzIHRoYXQgcGVyZm9ybSB0aGUgc2FtZSBraW5kIG9mIGxvZ2ljYWwgb3BlcmF0aW9uIGFzIGBjb21wb3NpdGVGaWx0ZXJgXHJcbiAgICAvLyB0YWtlIG91dCB0aGVpciBmaWx0ZXJzIGFuZCBhZGQgdGhlbSB0byBgY29tcG9zaXRlRmlsdGVyYC4gRm9yIGV4YW1wbGU6XHJcbiAgICAvLyBjb21wb3NpdGVGaWx0ZXIgPSAoQSB8IChCIHwgQyB8IEQpKVxyXG4gICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyID0gKEIgfCBDIHwgRClcclxuICAgIC8vIFJlc3VsdDogKEEgfCBCIHwgQyB8IEQpXHJcbiAgICAvLyBOb3RlIHRoYXQgdGhlIGBjb21wb3NpdGVTdWJmaWx0ZXJgIGhhcyBiZWVuIGVsaW1pbmF0ZWQsIGFuZCBpdHMgZmlsdGVycyAoQiwgQywgRCkgaGF2ZSBiZWVuXHJcbiAgICAvLyBhZGRlZCB0byB0aGUgdG9wLWxldmVsIFwiY29tcG9zaXRlRmlsdGVyXCIuXHJcbiAgICBjb25zdCBuZXdTdWJmaWx0ZXJzID0gW107XHJcbiAgICB1cGRhdGVkRmlsdGVycy5mb3JFYWNoKHN1YmZpbHRlciA9PiB7XHJcbiAgICAgICAgaWYgKHN1YmZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIG5ld1N1YmZpbHRlcnMucHVzaChzdWJmaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdWJmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHN1YmZpbHRlci5vcCA9PT0gZmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGVGaWx0ZXI6IChBIHwgKEIgfCBDKSlcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZVN1YmZpbHRlcjogKEIgfCBDKVxyXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0OiAoQSB8IEIgfCBDKVxyXG4gICAgICAgICAgICAgICAgbmV3U3ViZmlsdGVycy5wdXNoKC4uLnN1YmZpbHRlci5maWx0ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZUZpbHRlcjogKEEgfCAoQiAmIEMpKVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyOiAoQiAmIEMpXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHQ6IChBIHwgKEIgJiBDKSlcclxuICAgICAgICAgICAgICAgIG5ld1N1YmZpbHRlcnMucHVzaChzdWJmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAobmV3U3ViZmlsdGVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gbmV3U3ViZmlsdGVyc1swXTtcclxuICAgIH1cclxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG5ld1N1YmZpbHRlcnMsIGZpbHRlci5vcCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlJbmRleE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXggPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XHJcbiAgICB9XHJcbiAgICBhZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5hZGQoY29sbGVjdGlvblBhdGgpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5nZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkpO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlQWxsRmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1RhcmdldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKDAgLyogSW5kZXhUeXBlLk5PTkUgKi8pO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKEluZGV4T2Zmc2V0Lm1pbigpKTtcclxuICAgIH1cclxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShJbmRleE9mZnNldC5taW4oKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzKSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbGxlY3Rpb24tcGFyZW50IGluZGV4IGV4cG9zZWQgYnkgTWVtb3J5SW5kZXhNYW5hZ2VyLlxyXG4gKiBBbHNvIHVzZWQgZm9yIGluLW1lbW9yeSBjYWNoaW5nIGJ5IEluZGV4ZWREYkluZGV4TWFuYWdlciBhbmQgaW5pdGlhbCBpbmRleCBwb3B1bGF0aW9uXHJcbiAqIGluIGluZGV4ZWRkYl9zY2hlbWEudHNcclxuICovXHJcbmNsYXNzIE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0ge307XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbnRyeSBhbHJlYWR5IGV4aXN0ZWQuXHJcbiAgICBhZGQoY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJlbnRzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdIHx8XHJcbiAgICAgICAgICAgIG5ldyBTb3J0ZWRTZXQoUmVzb3VyY2VQYXRoLmNvbXBhcmF0b3IpO1xyXG4gICAgICAgIGNvbnN0IGFkZGVkID0gIWV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XHJcbiAgICAgICAgdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdID0gZXhpc3RpbmdQYXJlbnRzLmFkZChwYXJlbnRQYXRoKTtcclxuICAgICAgICByZXR1cm4gYWRkZWQ7XHJcbiAgICB9XHJcbiAgICBoYXMoY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJlbnRzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1BhcmVudHMgJiYgZXhpc3RpbmdQYXJlbnRzLmhhcyhwYXJlbnRQYXRoKTtcclxuICAgIH1cclxuICAgIGdldEVudHJpZXMoY29sbGVjdGlvbklkKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aHMgPSB0aGlzLmluZGV4W2NvbGxlY3Rpb25JZF0gfHxcclxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzLnRvQXJyYXkoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJGYgPSAnSW5kZXhlZERiSW5kZXhNYW5hZ2VyJztcclxuY29uc3QgRU1QVFlfVkFMVUUgPSBuZXcgVWludDhBcnJheSgwKTtcclxuLyoqXHJcbiAqIEEgcGVyc2lzdGVkIGltcGxlbWVudGF0aW9uIG9mIEluZGV4TWFuYWdlci5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBVbmxpa2UgaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2ViIFNESyBkb2VzIG5vdCBtZW1vaXplIGluZGV4XHJcbiAqIGRhdGEgYXMgaXQgc3VwcG9ydHMgbXVsdGktdGFiIGFjY2Vzcy5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYkluZGV4TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1c2VyLCBkYXRhYmFzZUlkKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBpbi1tZW1vcnkgY29weSBvZiB0aGUgaW5kZXggZW50cmllcyB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc2luY2UgdGhlIFNES1xyXG4gICAgICAgICAqIGxhdW5jaGVkLiBVc2VkIHRvIGF2b2lkIHJlLXdyaXRpbmcgdGhlIHNhbWUgZW50cnkgcmVwZWF0ZWRseS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgKk5PVCogYSBjb21wbGV0ZSBjYWNoZSBvZiB3aGF0J3MgaW4gcGVyc2lzdGVuY2UgYW5kIHNvIGNhbiBuZXZlciBiZVxyXG4gICAgICAgICAqIHVzZWQgdG8gc2F0aXNmeSByZWFkcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUgPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFwcyBmcm9tIGEgdGFyZ2V0IHRvIGl0cyBlcXVpdmFsZW50IGxpc3Qgb2Ygc3ViLXRhcmdldHMuIEVhY2ggc3ViLXRhcmdldFxyXG4gICAgICAgICAqIGNvbnRhaW5zIG9ubHkgb25lIHRlcm0gZnJvbSB0aGUgdGFyZ2V0J3MgZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0gKERORikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIChsLCByKSA9PiB0YXJnZXRFcXVhbHMobCwgcikpO1xyXG4gICAgICAgIHRoaXMudWlkID0gdXNlci51aWQgfHwgJyc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGNvbGxlY3Rpb24gcGFyZW50IGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIFJlcGVhdGVkIGNhbGxzIGZvciB0aGUgc2FtZSBjb2xsZWN0aW9uUGF0aCBzaG91bGQgYmUgYXZvaWRlZCB3aXRoaW4gYVxyXG4gICAgICogdHJhbnNhY3Rpb24gYXMgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIG9ubHkgY2FjaGVzIHdyaXRlcyBvbmNlIGEgdHJhbnNhY3Rpb25cclxuICAgICAqIGhhcyBiZWVuIGNvbW1pdHRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25QYXRoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUuaGFzKGNvbGxlY3Rpb25QYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRPbkNvbW1pdHRlZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29sbGVjdGlvbiB0byB0aGUgaW4gbWVtb3J5IGNhY2hlIG9ubHkgaWYgdGhlIHRyYW5zYWN0aW9uIHdhc1xyXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvblBhcmVudHNDYWNoZS5hZGQoY29sbGVjdGlvblBhdGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhcmVudFBhdGgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlKHRyYW5zYWN0aW9uKS5wdXQoY29sbGVjdGlvblBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGhzID0gW107XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY29sbGVjdGlvbklkLCAnJ10sIFtpbW1lZGlhdGVTdWNjZXNzb3IoY29sbGVjdGlvbklkKSwgJyddLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5sb2FkQWxsKHJhbmdlKVxyXG4gICAgICAgICAgICAubmV4dChlbnRyaWVzID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbGxlY3Rpb25JZCBndWFyZCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IChhbmQgaXNuJ3QgYXMgbG9uZ1xyXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UncmUgcnVubmluZyBpbiBhIHJlYWwgYnJvd3NlciksIGJ1dCB0aGVyZSdzIGEgYnVnIGluXHJcbiAgICAgICAgICAgICAgICAvLyBpbmRleGVkZGJzaGltIHRoYXQgYnJlYWtzIG91ciByYW5nZSBpbiBvdXIgdGVzdHMgcnVubmluZyBpbiBub2RlOlxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltL2lzc3Vlcy8zMzRcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jb2xsZWN0aW9uSWQgIT09IGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50UGF0aHMucHVzaChkZWNvZGVSZXNvdXJjZVBhdGgoZW50cnkucGFyZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTogVmVyaWZ5IHRoYXQgdGhlIGF1dG8taW5jcmVtZW50aW5nIGluZGV4IElEIHdvcmtzIGluXHJcbiAgICAgICAgLy8gU2FmYXJpICYgRmlyZWZveC5cclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGRiSW5kZXggPSB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KTtcclxuICAgICAgICBkZWxldGUgZGJJbmRleC5pbmRleElkOyAvLyBgaW5kZXhJZGAgaXMgYXV0by1wb3B1bGF0ZWQgYnkgSW5kZXhlZERiXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhlcy5hZGQoZGJJbmRleCk7XHJcbiAgICAgICAgaWYgKGluZGV4LmluZGV4U3RhdGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0KGluZGV4SWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShpbmRleElkLCB0aGlzLnVpZCwgaW5kZXguaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlciwgaW5kZXguaW5kZXhTdGF0ZS5vZmZzZXQpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBlbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBpbmRleGVzXHJcbiAgICAgICAgICAgIC5kZWxldGUoaW5kZXguaW5kZXhJZClcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gc3RhdGVzLmRlbGV0ZShJREJLZXlSYW5nZS5ib3VuZChbaW5kZXguaW5kZXhJZF0sIFtpbmRleC5pbmRleElkICsgMV0sIFxyXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcclxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKSkpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVudHJpZXMuZGVsZXRlKElEQktleVJhbmdlLmJvdW5kKFtpbmRleC5pbmRleElkXSwgW2luZGV4LmluZGV4SWQgKyAxXSwgXHJcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxyXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpKSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gaW5kZXhlc1xyXG4gICAgICAgICAgICAuZGVsZXRlQWxsKClcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGVBbGwoKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gc3RhdGVzLmRlbGV0ZUFsbCgpKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KSwgKHN1YlRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dCh0eXBlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovIHx8IHR5cGUgPT09IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleE1hdGNoZXIgPSBuZXcgVGFyZ2V0SW5kZXhNYXRjaGVyKHN1YlRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleCA9IHRhcmdldEluZGV4TWF0Y2hlci5idWlsZFRhcmdldEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBsZXQgY2FuU2VydmVUYXJnZXQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMuZ2V0U3ViVGFyZ2V0cyh0YXJnZXQpLCAoc3ViVGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dChpbmRleCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYW5TZXJ2ZVRhcmdldCAmJiAoY2FuU2VydmVUYXJnZXQgPSAhIWluZGV4KTtcclxuICAgICAgICAgICAgICAgIGluZGV4ZXMuc2V0KHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjYW5TZXJ2ZVRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmRleGVzLCAoaW5kZXgsIHN1YlRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgYFVzaW5nIGluZGV4ICR7ZmllbGRJbmRleFRvU3RyaW5nKGluZGV4KX0gdG8gZXhlY3V0ZSAke2Nhbm9uaWZ5VGFyZ2V0KHRhcmdldCl9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZXMgPSB0YXJnZXRHZXRBcnJheVZhbHVlcyhzdWJUYXJnZXQsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RJblZhbHVlcyA9IHRhcmdldEdldE5vdEluVmFsdWVzKHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0YXJnZXRHZXRMb3dlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0YXJnZXRHZXRVcHBlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmRFbmNvZGVkID0gdGhpcy5lbmNvZGVCb3VuZChpbmRleCwgc3ViVGFyZ2V0LCBsb3dlckJvdW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRW5jb2RlZCA9IHRoaXMuZW5jb2RlQm91bmQoaW5kZXgsIHN1YlRhcmdldCwgdXBwZXJCb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90SW5FbmNvZGVkID0gdGhpcy5lbmNvZGVWYWx1ZXMoaW5kZXgsIHN1YlRhcmdldCwgbm90SW5WYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gdGhpcy5nZW5lcmF0ZUluZGV4UmFuZ2VzKGluZGV4LmluZGV4SWQsIGFycmF5VmFsdWVzLCBsb3dlckJvdW5kRW5jb2RlZCwgbG93ZXJCb3VuZC5pbmNsdXNpdmUsIHVwcGVyQm91bmRFbmNvZGVkLCB1cHBlckJvdW5kLmluY2x1c2l2ZSwgbm90SW5FbmNvZGVkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhSYW5nZXMsIChpbmRleFJhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5sb2FkRmlyc3QoaW5kZXhSYW5nZSwgdGFyZ2V0LmxpbWl0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50S2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGVudHJ5LmRvY3VtZW50S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nS2V5cy5oYXMoZG9jdW1lbnRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nS2V5cyA9IGV4aXN0aW5nS2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkb2N1bWVudEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRTdWJUYXJnZXRzKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBzdWJUYXJnZXRzID0gdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHN1YlRhcmdldHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YlRhcmdldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQuZmlsdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc3ViVGFyZ2V0cyA9IFt0YXJnZXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYW4gaW1wbGljaXQgQU5EIG9wZXJhdGlvbiBiZXR3ZWVuIGFsbCB0aGUgZmlsdGVycyBzdG9yZWQgaW4gdGhlIHRhcmdldFxyXG4gICAgICAgICAgICBjb25zdCBkbmYgPSBnZXREbmZUZXJtcyhDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHRhcmdldC5maWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xyXG4gICAgICAgICAgICBzdWJUYXJnZXRzID0gZG5mLm1hcCh0ZXJtID0+IG5ld1RhcmdldCh0YXJnZXQucGF0aCwgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCwgdGFyZ2V0Lm9yZGVyQnksIHRlcm0uZ2V0RmlsdGVycygpLCB0YXJnZXQubGltaXQsIHRhcmdldC5zdGFydEF0LCB0YXJnZXQuZW5kQXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuc2V0KHRhcmdldCwgc3ViVGFyZ2V0cyk7XHJcbiAgICAgICAgcmV0dXJuIHN1YlRhcmdldHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBrZXkgcmFuZ2UgcXVlcnkgb24gYERiSW5kZXhFbnRyeVN0b3JlYCB0aGF0IHVuaW9ucyBhbGxcclxuICAgICAqIGJvdW5kcy5cclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVJbmRleFJhbmdlcyhpbmRleElkLCBhcnJheVZhbHVlcywgbG93ZXJCb3VuZHMsIGxvd2VyQm91bmRJbmNsdXNpdmUsIHVwcGVyQm91bmRzLCB1cHBlckJvdW5kSW5jbHVzaXZlLCBub3RJblZhbHVlcykge1xyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgdG90YWwgaW5kZXggc2NhbnMgd2UgdW5pb24gdG9nZXRoZXIuIFRoaXMgaXMgc2ltaWxhciB0byBhXHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZWQgbm9ybWFsIGZvcm0sIGJ1dCBhZGFwdGVkIGZvciBhcnJheSB2YWx1ZXMuIFdlIGNyZWF0ZSBhIHNpbmdsZVxyXG4gICAgICAgIC8vIGluZGV4IHJhbmdlIHBlciB2YWx1ZSBpbiBhbiBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTlkgZmlsdGVyXHJcbiAgICAgICAgLy8gY29tYmluZWQgd2l0aCB0aGUgdmFsdWVzIGZyb20gdGhlIHF1ZXJ5IGJvdW5kcy5cclxuICAgICAgICBjb25zdCB0b3RhbFNjYW5zID0gKGFycmF5VmFsdWVzICE9IG51bGwgPyBhcnJheVZhbHVlcy5sZW5ndGggOiAxKSAqXHJcbiAgICAgICAgICAgIE1hdGgubWF4KGxvd2VyQm91bmRzLmxlbmd0aCwgdXBwZXJCb3VuZHMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBzY2Fuc1BlckFycmF5RWxlbWVudCA9IHRvdGFsU2NhbnMgLyAoYXJyYXlWYWx1ZXMgIT0gbnVsbCA/IGFycmF5VmFsdWVzLmxlbmd0aCA6IDEpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNjYW5zOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IGFycmF5VmFsdWVzXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlc1tpIC8gc2NhbnNQZXJBcnJheUVsZW1lbnRdKVxyXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9WQUxVRTtcclxuICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IHRoaXMuZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGxvd2VyQm91bmRzW2kgJSBzY2Fuc1BlckFycmF5RWxlbWVudF0sIGxvd2VyQm91bmRJbmNsdXNpdmUpO1xyXG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5nZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgdXBwZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgdXBwZXJCb3VuZEluY2x1c2l2ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdEluQm91bmQgPSBub3RJblZhbHVlcy5tYXAobm90SW4gPT4gdGhpcy5nZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgbm90SW4sIFxyXG4gICAgICAgICAgICAvKiBpbmNsdXNpdmU9ICovIHRydWUpKTtcclxuICAgICAgICAgICAgaW5kZXhSYW5nZXMucHVzaCguLi50aGlzLmNyZWF0ZVJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIG5vdEluQm91bmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZGV4UmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgLyoqIEdlbmVyYXRlcyB0aGUgbG93ZXIgYm91bmQgZm9yIGBhcnJheVZhbHVlYCBhbmQgYGRpcmVjdGlvbmFsVmFsdWVgLiAqL1xyXG4gICAgZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUsIGluY2x1c2l2ZSkge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEluZGV4RW50cnkoaW5kZXhJZCwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGluY2x1c2l2ZSA/IGVudHJ5IDogZW50cnkuc3VjY2Vzc29yKCk7XHJcbiAgICB9XHJcbiAgICAvKiogR2VuZXJhdGVzIHRoZSB1cHBlciBib3VuZCBmb3IgYGFycmF5VmFsdWVgIGFuZCBgZGlyZWN0aW9uYWxWYWx1ZWAuICovXHJcbiAgICBnZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSwgaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgSW5kZXhFbnRyeShpbmRleElkLCBEb2N1bWVudEtleS5lbXB0eSgpLCBhcnJheVZhbHVlLCBkaXJlY3Rpb25hbFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gaW5jbHVzaXZlID8gZW50cnkuc3VjY2Vzc29yKCkgOiBlbnRyeTtcclxuICAgIH1cclxuICAgIGdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4TWF0Y2hlciA9IG5ldyBUYXJnZXRJbmRleE1hdGNoZXIodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXAgPSB0YXJnZXQuY29sbGVjdGlvbkdyb3VwICE9IG51bGxcclxuICAgICAgICAgICAgPyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkubmV4dChpbmRleGVzID0+IHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBpbmRleCB3aXRoIHRoZSBtb3N0IG51bWJlciBvZiBzZWdtZW50cy5cclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaW5kZXhlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRhcmdldEluZGV4TWF0Y2hlci5zZXJ2ZWRCeUluZGV4KGNhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghaW5kZXggfHwgY2FuZGlkYXRlLmZpZWxkcy5sZW5ndGggPiBpbmRleC5maWVsZHMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgbGV0IGluZGV4VHlwZSA9IDIgLyogSW5kZXhUeXBlLkZVTEwgKi87XHJcbiAgICAgICAgY29uc3Qgc3ViVGFyZ2V0cyA9IHRoaXMuZ2V0U3ViVGFyZ2V0cyh0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChzdWJUYXJnZXRzLCAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkubmV4dChpbmRleCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUeXBlID0gMCAvKiBJbmRleFR5cGUuTk9ORSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4VHlwZSAhPT0gMCAvKiBJbmRleFR5cGUuTk9ORSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmZpZWxkcy5sZW5ndGggPCB0YXJnZXRHZXRTZWdtZW50Q291bnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBPUiBxdWVyaWVzIGhhdmUgbW9yZSB0aGFuIG9uZSBzdWItdGFyZ2V0IChvbmUgc3ViLXRhcmdldCBwZXIgRE5GIHRlcm0pLiBXZSBjdXJyZW50bHkgY29uc2lkZXJcclxuICAgICAgICAgICAgLy8gT1IgcXVlcmllcyB0aGF0IGhhdmUgYSBgbGltaXRgIHRvIGhhdmUgYSBwYXJ0aWFsIGluZGV4LiBGb3Igc3VjaCBxdWVyaWVzIHdlIHBlcmZvcm0gc29ydGluZ1xyXG4gICAgICAgICAgICAvLyBhbmQgYXBwbHkgdGhlIGxpbWl0IGluIG1lbW9yeSBhcyBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwLlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SGFzTGltaXQodGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVGFyZ2V0cy5sZW5ndGggPiAxICYmXHJcbiAgICAgICAgICAgICAgICBpbmRleFR5cGUgPT09IDIgLyogSW5kZXhUeXBlLkZVTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleFR5cGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJ5dGUgZW5jb2RlZCBmb3JtIG9mIHRoZSBkaXJlY3Rpb25hbCB2YWx1ZXMgaW4gdGhlIGZpZWxkIGluZGV4LlxyXG4gICAgICogUmV0dXJucyBgbnVsbGAgaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgYWxsIGZpZWxkcyBzcGVjaWZpZWQgaW4gdGhlXHJcbiAgICAgKiBpbmRleC5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlRGlyZWN0aW9uYWxFbGVtZW50cyhmaWVsZEluZGV4LCBkb2N1bWVudCkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGRvY3VtZW50LmRhdGEuZmllbGQoc2VnbWVudC5maWVsZFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxFbmNvZGVyID0gZW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCk7XHJcbiAgICAgICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKGZpZWxkLCBkaXJlY3Rpb25hbEVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcclxuICAgIH1cclxuICAgIC8qKiBFbmNvZGVzIGEgc2luZ2xlIHZhbHVlIHRvIHRoZSBhc2NlbmRpbmcgaW5kZXggZm9ybWF0LiAqL1xyXG4gICAgZW5jb2RlU2luZ2xlRWxlbWVudCh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xyXG4gICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKHZhbHVlLCBlbmNvZGVyLmZvcktpbmQoMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlZEJ5dGVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZW5jb2RlZCBmb3JtIG9mIHRoZSBkb2N1bWVudCBrZXkgdGhhdCBzb3J0cyBiYXNlZCBvbiB0aGUga2V5XHJcbiAgICAgKiBvcmRlcmluZyBvZiB0aGUgZmllbGQgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIGVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XHJcbiAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUocmVmVmFsdWUodGhpcy5kYXRhYmFzZUlkLCBkb2N1bWVudEtleSksIGVuY29kZXIuZm9yS2luZChmaWVsZEluZGV4R2V0S2V5T3JkZXIoZmllbGRJbmRleCkpKTtcclxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gZmllbGQgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC5cclxuICAgICAqIEZvciBJTiBxdWVyaWVzLCBhIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzIGlzIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodmFsdWVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuY29kZXJzID0gW107XHJcbiAgICAgICAgZW5jb2RlcnMucHVzaChuZXcgSW5kZXhCeXRlRW5jb2RlcigpKTtcclxuICAgICAgICBsZXQgdmFsdWVJZHggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeCsrXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIGVuY29kZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luRmlsdGVyKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpICYmIGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlcnMgPSB0aGlzLmV4cGFuZEluZGV4VmFsdWVzKGVuY29kZXJzLCBzZWdtZW50LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25hbEVuY29kZXIgPSBlbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVkQnl0ZXMoZW5jb2RlcnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBib3VuZHMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGluIGB0YXJnZXRgLiBGb3IgSU5cclxuICAgICAqIHF1ZXJpZXMsIGEgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUJvdW5kKGZpZWxkSW5kZXgsIHRhcmdldCwgYm91bmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCBib3VuZC5wb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgYnl0ZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGVuY29kZXJzLiAqL1xyXG4gICAgZ2V0RW5jb2RlZEJ5dGVzKGVuY29kZXJzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBlbmNvZGVyc1tpXS5lbmNvZGVkQnl0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNlcGFyYXRlIGVuY29kZXIgZm9yIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbWV0aG9kIGFwcGVuZHMgZWFjaCB2YWx1ZSB0byBhbGwgZXhpc3RpbmcgZW5jb2RlcnMgKGUuZy4gZmlsdGVyKFwiYVwiLFxyXG4gICAgICogXCI9PVwiLCBcImExXCIpLmZpbHRlcihcImJcIiwgXCJpblwiLCBbXCJiMVwiLCBcImIyXCJdKSBiZWNvbWVzIFtcImExLGIxXCIsIFwiYTEsYjJcIl0pLiBBXHJcbiAgICAgKiBsaXN0IG9mIG5ldyBlbmNvZGVycyBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgZXhwYW5kSW5kZXhWYWx1ZXMoZW5jb2RlcnMsIHNlZ21lbnQsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcHJlZml4ZXMgPSBbLi4uZW5jb2RlcnNdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGFycmF5RWxlbWVudCBvZiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkRW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRFbmNvZGVyLnNlZWQocHJlZml4LmVuY29kZWRCeXRlcygpKTtcclxuICAgICAgICAgICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKGFycmF5RWxlbWVudCwgY2xvbmVkRW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNsb25lZEVuY29kZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgaXNJbkZpbHRlcih0YXJnZXQsIGZpZWxkUGF0aCkge1xyXG4gICAgICAgIHJldHVybiAhIXRhcmdldC5maWx0ZXJzLmZpbmQoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcclxuICAgICAgICAgICAgZi5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkgJiZcclxuICAgICAgICAgICAgKGYub3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fCBmLm9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykpO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uR3JvdXBcclxuICAgICAgICAgICAgPyBpbmRleGVzLmxvYWRBbGwoRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleCwgSURCS2V5UmFuZ2UuYm91bmQoY29sbGVjdGlvbkdyb3VwLCBjb2xsZWN0aW9uR3JvdXApKVxyXG4gICAgICAgICAgICA6IGluZGV4ZXMubG9hZEFsbCgpKS5uZXh0KGluZGV4Q29uZmlncyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhDb25maWdzLCAoaW5kZXhDb25maWcpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0KFtpbmRleENvbmZpZy5pbmRleElkLCB0aGlzLnVpZF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaW5kZXhTdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4Q29uZmlnLCBpbmRleFN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TmV4dENvbGxlY3Rpb25Hcm91cFRvVXBkYXRlKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKS5uZXh0KGluZGV4ZXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGV4ZXMuc29ydCgobCwgcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY21wID0gbC5pbmRleFN0YXRlLnNlcXVlbmNlTnVtYmVyIC0gci5pbmRleFN0YXRlLnNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcCAhPT0gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gY21wXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcmltaXRpdmVDb21wYXJhdG9yKGwuY29sbGVjdGlvbkdyb3VwLCByLmNvbGxlY3Rpb25Hcm91cCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlc1swXS5jb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHRTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikubmV4dChuZXh0U2VxdWVuY2VOdW1iZXIgPT4gaW5kZXhlc1xyXG4gICAgICAgICAgICAubG9hZEFsbChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBJREJLZXlSYW5nZS5ib3VuZChjb2xsZWN0aW9uR3JvdXAsIGNvbGxlY3Rpb25Hcm91cCkpXHJcbiAgICAgICAgICAgIC5uZXh0KGNvbmZpZ3MgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goY29uZmlncywgKGNvbmZpZykgPT4gc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShjb25maWcuaW5kZXhJZCwgdGhpcy51aWQsIG5leHRTZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSkpKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50cykge1xyXG4gICAgICAgIC8vIFBvcnRpbmcgTm90ZTogYGdldEZpZWxkSW5kZXhlcygpYCBvbiBXZWIgZG9lcyBub3QgY2FjaGUgaW5kZXggbG9va3VwcyBhc1xyXG4gICAgICAgIC8vIGl0IGNvdWxkIGJlIHVzZWQgYWNyb3NzIGRpZmZlcmVudCBJbmRleGVkREIgdHJhbnNhY3Rpb25zLiBBcyBhbnkgY2FjaGVkXHJcbiAgICAgICAgLy8gZGF0YSBtaWdodCBiZSBpbnZhbGlkYXRlZCBieSBvdGhlciBtdWx0aS10YWIgY2xpZW50cywgd2UgY2FuIG9ubHkgdHJ1c3RcclxuICAgICAgICAvLyBkYXRhIHdpdGhpbiBhIHNpbmdsZSBJbmRleGVkREIgdHJhbnNhY3Rpb24uIFdlIHRoZXJlZm9yZSBhZGQgYSBjYWNoZVxyXG4gICAgICAgIC8vIGhlcmUuXHJcbiAgICAgICAgY29uc3QgbWVtb2l6ZWRJbmRleGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkb2N1bWVudHMsIChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzID0gbWVtb2l6ZWRJbmRleGVzLmdldChrZXkuY29sbGVjdGlvbkdyb3VwKTtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleGVzID0gbWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgPyBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwga2V5LmNvbGxlY3Rpb25Hcm91cCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZEluZGV4ZXMubmV4dChmaWVsZEluZGV4ZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRJbmRleGVzLnNldChrZXkuY29sbGVjdGlvbkdyb3VwLCBmaWVsZEluZGV4ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGZpZWxkSW5kZXhlcywgKGZpZWxkSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFeGlzdGluZ0luZGV4RW50cmllcyh0cmFuc2FjdGlvbiwga2V5LCBmaWVsZEluZGV4KS5uZXh0KGV4aXN0aW5nRW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB0aGlzLmNvbXB1dGVJbmRleEVudHJpZXMoZG9jLCBmaWVsZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0VudHJpZXMuaXNFcXVhbChuZXdFbnRyaWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jLCBmaWVsZEluZGV4LCBleGlzdGluZ0VudHJpZXMsIG5ld0VudHJpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcclxuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5wdXQoe1xyXG4gICAgICAgICAgICBpbmRleElkOiBpbmRleEVudHJ5LmluZGV4SWQsXHJcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXHJcbiAgICAgICAgICAgIGFycmF5VmFsdWU6IGluZGV4RW50cnkuYXJyYXlWYWx1ZSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uYWxWYWx1ZTogaW5kZXhFbnRyeS5kaXJlY3Rpb25hbFZhbHVlLFxyXG4gICAgICAgICAgICBvcmRlcmVkRG9jdW1lbnRLZXk6IHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnQua2V5KSxcclxuICAgICAgICAgICAgZG9jdW1lbnRLZXk6IGRvY3VtZW50LmtleS5wYXRoLnRvQXJyYXkoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcclxuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5kZWxldGUoW1xyXG4gICAgICAgICAgICBpbmRleEVudHJ5LmluZGV4SWQsXHJcbiAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICBpbmRleEVudHJ5LmFycmF5VmFsdWUsXHJcbiAgICAgICAgICAgIGluZGV4RW50cnkuZGlyZWN0aW9uYWxWYWx1ZSxcclxuICAgICAgICAgICAgdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudC5rZXkpLFxyXG4gICAgICAgICAgICBkb2N1bWVudC5rZXkucGF0aC50b0FycmF5KClcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSwgZmllbGRJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCxcclxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoW1xyXG4gICAgICAgICAgICAgICAgZmllbGRJbmRleC5pbmRleElkLFxyXG4gICAgICAgICAgICAgICAgdGhpcy51aWQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KVxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgIH0sIChfLCBlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudEtleSwgZW50cnkuYXJyYXlWYWx1ZSwgZW50cnkuZGlyZWN0aW9uYWxWYWx1ZSkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgdGhlIGluZGV4IGVudHJpZXMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC4gKi9cclxuICAgIGNvbXB1dGVJbmRleEVudHJpZXMoZG9jdW1lbnQsIGZpZWxkSW5kZXgpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsVmFsdWUgPSB0aGlzLmVuY29kZURpcmVjdGlvbmFsRWxlbWVudHMoZmllbGRJbmRleCwgZG9jdW1lbnQpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25hbFZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFycmF5U2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCk7XHJcbiAgICAgICAgaWYgKGFycmF5U2VnbWVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuZGF0YS5maWVsZChhcnJheVNlZ21lbnQuZmllbGRQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlKSwgZGlyZWN0aW9uYWxWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIEVNUFRZX1ZBTFVFLCBkaXJlY3Rpb25hbFZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBpbmRleCBlbnRyaWVzIGZvciB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgYnkgZGVsZXRpbmcgZW50cmllc1xyXG4gICAgICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlZmVyZW5jZWQgaW4gYG5ld0VudHJpZXNgIGFuZCBhZGRpbmcgYWxsIG5ld2x5IGFkZGVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRmLCBcIlVwZGF0aW5nIGluZGV4IGVudHJpZXMgZm9yIGRvY3VtZW50ICclcydcIiwgZG9jdW1lbnQua2V5KTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGRpZmZTb3J0ZWRTZXRzKGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcywgaW5kZXhFbnRyeUNvbXBhcmF0b3IsIFxyXG4gICAgICAgIC8qIG9uQWRkPSAqLyBlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5hZGRJbmRleEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZW50cnkpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvKiBvblJlbW92ZT0gKi8gZW50cnkgPT4ge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGVudHJ5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIGdldE5leHRTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGxldCBuZXh0U2VxdWVuY2VOdW1iZXIgPSAxO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlc1xyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XHJcbiAgICAgICAgICAgIGluZGV4OiBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4LFxyXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlLFxyXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2UudXBwZXJCb3VuZChbdGhpcy51aWQsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSlcclxuICAgICAgICB9LCAoXywgc3RhdGUsIGNvbnRyb2xsZXIpID0+IHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5kb25lKCk7XHJcbiAgICAgICAgICAgIG5leHRTZXF1ZW5jZU51bWJlciA9IHN0YXRlLnNlcXVlbmNlTnVtYmVyICsgMTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBuZXh0U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNldCBvZiBJREIgcmFuZ2VzIHRoYXQgc3BsaXRzIHRoZSBleGlzdGluZyByYW5nZSBhbmQgZXhjbHVkZXNcclxuICAgICAqIGFueSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGUgYG5vdEluVmFsdWVgIGZyb20gdGhlc2UgcmFuZ2VzLiBBcyBhbiBleGFtcGxlLFxyXG4gICAgICogJ1tmb28gPiAyICYmIGZvbyAhPSAzXWAgYmVjb21lcyAgYFtmb28gPiAyICYmIDwgMywgZm9vID4gM11gLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIG5vdEluVmFsdWVzKSB7XHJcbiAgICAgICAgLy8gVGhlIG5vdEluIHZhbHVlcyBuZWVkIHRvIGJlIHNvcnRlZCBhbmQgdW5pcXVlIHNvIHRoYXQgd2UgY2FuIHJldHVybiBhXHJcbiAgICAgICAgLy8gc29ydGVkIHNldCBvZiBub24tb3ZlcmxhcHBpbmcgcmFuZ2VzLlxyXG4gICAgICAgIG5vdEluVmFsdWVzID0gbm90SW5WYWx1ZXNcclxuICAgICAgICAgICAgLnNvcnQoKGwsIHIpID0+IGluZGV4RW50cnlDb21wYXJhdG9yKGwsIHIpKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChlbCwgaSwgdmFsdWVzKSA9PiAhaSB8fCBpbmRleEVudHJ5Q29tcGFyYXRvcihlbCwgdmFsdWVzW2kgLSAxXSkgIT09IDApO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IFtdO1xyXG4gICAgICAgIGJvdW5kcy5wdXNoKGxvd2VyKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vdEluVmFsdWUgb2Ygbm90SW5WYWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wVG9Mb3dlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIGxvd2VyKTtcclxuICAgICAgICAgICAgY29uc3QgY21wVG9VcHBlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIHVwcGVyKTtcclxuICAgICAgICAgICAgaWYgKGNtcFRvTG93ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGBub3RJblZhbHVlYCBpcyB0aGUgbG93ZXIgYm91bmQuIFdlIHRoZXJlZm9yZSBuZWVkIHRvIHJhaXNlIHRoZSBib3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIG5leHQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICBib3VuZHNbMF0gPSBsb3dlci5zdWNjZXNzb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXBUb0xvd2VyID4gMCAmJiBjbXBUb1VwcGVyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYG5vdEluVmFsdWVgIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICBib3VuZHMucHVzaChub3RJblZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5wdXNoKG5vdEluVmFsdWUuc3VjY2Vzc29yKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcFRvVXBwZXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgbm90SW5WYWx1ZWAgKGFuZCBhbGwgZm9sbG93aW5nIHZhbHVlcykgYXJlIG91dCBvZiB0aGUgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvdW5kcy5wdXNoKHVwcGVyKTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgdHdvIGJvdW5kcyB0aGF0IHdpbGwgY3JlYXRlIGFuIHVubWF0Y2hhYmxlIGtleSByYW5nZSxcclxuICAgICAgICAgICAgLy8gdGhlbiB3ZSByZXR1cm4gYW4gZW1wdHkgc2V0IG9mIGtleSByYW5nZXMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmFuZ2VNYXRjaGFibGUoYm91bmRzW2ldLCBib3VuZHNbaSArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSBbXHJcbiAgICAgICAgICAgICAgICBib3VuZHNbaV0uaW5kZXhJZCxcclxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzW2ldLmFycmF5VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBib3VuZHNbaV0uZGlyZWN0aW9uYWxWYWx1ZSxcclxuICAgICAgICAgICAgICAgIEVNUFRZX1ZBTFVFLFxyXG4gICAgICAgICAgICAgICAgW11cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IFtcclxuICAgICAgICAgICAgICAgIGJvdW5kc1tpICsgMV0uaW5kZXhJZCxcclxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5hcnJheVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5kaXJlY3Rpb25hbFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgRU1QVFlfVkFMVUUsXHJcbiAgICAgICAgICAgICAgICBbXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaChJREJLZXlSYW5nZS5ib3VuZChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcbiAgICBpc1JhbmdlTWF0Y2hhYmxlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcclxuICAgICAgICAvLyBJZiBsb3dlciBib3VuZCBpcyBncmVhdGVyIHRoYW4gdGhlIHVwcGVyIGJvdW5kLCB0aGVuIHRoZSBrZXlcclxuICAgICAgICAvLyByYW5nZSBjYW4gbmV2ZXIgYmUgbWF0Y2hlZC5cclxuICAgICAgICByZXR1cm4gaW5kZXhFbnRyeUNvbXBhcmF0b3IobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgPiAwO1xyXG4gICAgfVxyXG4gICAgZ2V0TWluT2Zmc2V0RnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoZ2V0TWluT2Zmc2V0RnJvbUZpZWxkSW5kZXhlcyk7XHJcbiAgICB9XHJcbiAgICBnZXRNaW5PZmZzZXQodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UubWFwQXJyYXkodGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHRoaXMuZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KGluZGV4ID0+IGluZGV4ID8gaW5kZXggOiBmYWlsKCkpKS5uZXh0KGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGNvbGxlY3Rpb25QYXJlbnRzXHJcbiAqIGRvY3VtZW50IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQ29sbGVjdGlvblBhcmVudFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBlbnRyeSBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleEVudHJpZXNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhFbnRyeVN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBjb25maWd1cmF0aW9uIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggc3RhdGUgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXhTdGF0ZVN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJJbmRleFN0YXRlU3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMoZmllbGRJbmRleGVzKSB7XHJcbiAgICBoYXJkQXNzZXJ0KGZpZWxkSW5kZXhlcy5sZW5ndGggIT09IDApO1xyXG4gICAgbGV0IG1pbk9mZnNldCA9IGZpZWxkSW5kZXhlc1swXS5pbmRleFN0YXRlLm9mZnNldDtcclxuICAgIGxldCBtYXhCYXRjaElkID0gbWluT2Zmc2V0Lmxhcmdlc3RCYXRjaElkO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWVsZEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmaWVsZEluZGV4ZXNbaV0uaW5kZXhTdGF0ZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdPZmZzZXQsIG1pbk9mZnNldCkgPCAwKSB7XHJcbiAgICAgICAgICAgIG1pbk9mZnNldCA9IG5ld09mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heEJhdGNoSWQgPCBuZXdPZmZzZXQubGFyZ2VzdEJhdGNoSWQpIHtcclxuICAgICAgICAgICAgbWF4QmF0Y2hJZCA9IG5ld09mZnNldC5sYXJnZXN0QmF0Y2hJZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KG1pbk9mZnNldC5yZWFkVGltZSwgbWluT2Zmc2V0LmRvY3VtZW50S2V5LCBtYXhCYXRjaElkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVsZXRlIGEgbXV0YXRpb24gYmF0Y2ggYW5kIHRoZSBhc3NvY2lhdGVkIGRvY3VtZW50IG11dGF0aW9ucy5cclxuICogQHJldHVybnMgQSBQZXJzaXN0ZW5jZVByb21pc2Ugb2YgdGhlIGRvY3VtZW50IG11dGF0aW9ucyB0aGF0IHdlcmUgcmVtb3ZlZC5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCB1c2VySWQsIGJhdGNoKSB7XHJcbiAgICBjb25zdCBtdXRhdGlvblN0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgIGNvbnN0IGluZGV4VHhuID0gdHhuLnN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcclxuICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLm9ubHkoYmF0Y2guYmF0Y2hJZCk7XHJcbiAgICBsZXQgbnVtRGVsZXRlZCA9IDA7XHJcbiAgICBjb25zdCByZW1vdmVQcm9taXNlID0gbXV0YXRpb25TdG9yZS5pdGVyYXRlKHsgcmFuZ2UgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcclxuICAgICAgICBudW1EZWxldGVkKys7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuZGVsZXRlKCk7XHJcbiAgICB9KTtcclxuICAgIHByb21pc2VzLnB1c2gocmVtb3ZlUHJvbWlzZS5uZXh0KCgpID0+IHtcclxuICAgICAgICBoYXJkQXNzZXJ0KG51bURlbGV0ZWQgPT09IDEpO1xyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgcmVtb3ZlZERvY3VtZW50cyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBiYXRjaC5tdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh1c2VySWQsIG11dGF0aW9uLmtleS5wYXRoLCBiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4VHhuLmRlbGV0ZShpbmRleEtleSkpO1xyXG4gICAgICAgIHJlbW92ZWREb2N1bWVudHMucHVzaChtdXRhdGlvbi5rZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHJlbW92ZWREb2N1bWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIHNpemUgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGRiRG9jdW1lbnRTaXplKGRvYykge1xyXG4gICAgaWYgKCFkb2MpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGxldCB2YWx1ZTtcclxuICAgIGlmIChkb2MuZG9jdW1lbnQpIHtcclxuICAgICAgICB2YWx1ZSA9IGRvYy5kb2N1bWVudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvYy51bmtub3duRG9jdW1lbnQpIHtcclxuICAgICAgICB2YWx1ZSA9IGRvYy51bmtub3duRG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2Mubm9Eb2N1bWVudCkge1xyXG4gICAgICAgIHZhbHVlID0gZG9jLm5vRG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQSBtdXRhdGlvbiBxdWV1ZSBmb3IgYSBzcGVjaWZpYyB1c2VyLCBiYWNrZWQgYnkgSW5kZXhlZERCLiAqL1xyXG5jbGFzcyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFsaXplZCB1c2VySWQgKGUuZy4gbnVsbCBVSUQgPT4gXCJcIiB1c2VySWQpIHVzZWQgdG8gc3RvcmUgL1xyXG4gICAgICogcmV0cmlldmUgbXV0YXRpb25zLlxyXG4gICAgICovXHJcbiAgICB1c2VySWQsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcclxuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWNoZXMgdGhlIGRvY3VtZW50IGtleXMgZm9yIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcy4gSWYgdGhlIG11dGF0aW9uXHJcbiAgICAgICAgICogaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIEluZGV4ZWREYiwgdGhlIGNhY2hlZCB2YWx1ZSBtYXkgY29udGludWUgdG9cclxuICAgICAgICAgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBiYXRjaCdzIGRvY3VtZW50IGtleXMuIFRvIHJlbW92ZSBhIGNhY2hlZCB2YWx1ZVxyXG4gICAgICAgICAqIGxvY2FsbHksIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgc2hvdWxkIGJlIGludm9rZWQgZWl0aGVyIGRpcmVjdGx5XHJcbiAgICAgICAgICogb3IgdGhyb3VnaCBgcmVtb3ZlTXV0YXRpb25CYXRjaGVzKClgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2l0aCBtdWx0aS10YWIsIHdoZW4gdGhlIHByaW1hcnkgY2xpZW50IGFja25vd2xlZGdlcyBvciByZWplY3RzIGEgbXV0YXRpb24sXHJcbiAgICAgICAgICogdGhpcyBjYWNoZSBpcyB1c2VkIGJ5IHNlY29uZGFyeSBjbGllbnRzIHRvIGludmFsaWRhdGUgdGhlIGxvY2FsXHJcbiAgICAgICAgICogdmlldyBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGFmZmVjdGVkIGJ5IHRoZSBtdXRhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbXV0YXRpb24gcXVldWUgZm9yIHRoZSBnaXZlbiB1c2VyLlxyXG4gICAgICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlciBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgbXV0YXRpb24gcXVldWUuXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciAtIFRoZSBzZXJpYWxpemVyIHRvIHVzZSB3aGVuIHBlcnNpc3RpbmcgdG8gSW5kZXhlZERiLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9yVXNlcih1c2VyLCBzZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XHJcbiAgICAgICAgLy8gVE9ETyhtY2cpOiBGaWd1cmUgb3V0IHdoYXQgY29uc3RyYWludHMgdGhlcmUgYXJlIG9uIHVzZXJJRHNcclxuICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBhcmUgdGhlcmUgYW55IHJlc2VydmVkIGNoYXJhY3RlcnM/IGFyZSBlbXB0eSBpZHMgYWxsb3dlZD9cclxuICAgICAgICAvLyBGb3IgdGhlIG1vbWVudCBzdG9yZSB0aGVzZSB0b2dldGhlciBpbiB0aGUgc2FtZSBtdXRhdGlvbnMgdGFibGUgYXNzdW1pbmdcclxuICAgICAgICAvLyB0aGF0IGVtcHR5IHVzZXJJRHMgYXJlbid0IGFsbG93ZWQuXHJcbiAgICAgICAgaGFyZEFzc2VydCh1c2VyLnVpZCAhPT0gJycpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHVzZXIuaXNBdXRoZW50aWNhdGVkKCkgPyB1c2VyLnVpZCA6ICcnO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiTXV0YXRpb25RdWV1ZSh1c2VySWQsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGxldCBlbXB0eSA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVtcHR5KTtcclxuICAgIH1cclxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25TdG9yZSA9IG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAvLyBUaGUgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uIGluIENocm9tZSAoYW5kIEZpcmVmb3gpIGRvZXMgbm90IGhhbmRsZVxyXG4gICAgICAgIC8vIGNvbXBvdW5kIGluZGljZXMgdGhhdCBpbmNsdWRlIGF1dG8tZ2VuZXJhdGVkIGtleXMgY29ycmVjdGx5LiBUbyBlbnN1cmVcclxuICAgICAgICAvLyB0aGF0IHRoZSBpbmRleCBlbnRyeSBpcyBhZGRlZCBjb3JyZWN0bHkgaW4gYWxsIGJyb3dzZXJzLCB3ZSBwZXJmb3JtIHR3b1xyXG4gICAgICAgIC8vIHdyaXRlczogVGhlIGZpcnN0IHdyaXRlIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIG5leHQgYXV0by1nZW5lcmF0ZWQgQmF0Y2hcclxuICAgICAgICAvLyBJRCwgYW5kIHRoZSBzZWNvbmQgd3JpdGUgcG9wdWxhdGVzIHRoZSBpbmRleCBhbmQgc3RvcmVzIHRoZSBhY3R1YWxcclxuICAgICAgICAvLyBtdXRhdGlvbiBiYXRjaC5cclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTcwMTk3MlxyXG4gICAgICAgIC8vIFdlIHdyaXRlIGFuIGVtcHR5IG9iamVjdCB0byBvYnRhaW4ga2V5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25TdG9yZS5hZGQoe30pLm5leHQoYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIGJhdGNoSWQgPT09ICdudW1iZXInKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTXV0YXRpb25CYXRjaChiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZGJCYXRjaCA9IHRvRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgdGhpcy51c2VySWQsIGJhdGNoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh0aGlzLnVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQobXV0YXRpb24ua2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobXV0YXRpb25TdG9yZS5wdXQoZGJCYXRjaCkpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFN0b3JlLnB1dChpbmRleEtleSwgRGJEb2N1bWVudE11dGF0aW9uUGxhY2Vob2xkZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uUGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBiYXRjaC5rZXlzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gYmF0Y2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldChiYXRjaElkKVxyXG4gICAgICAgICAgICAubmV4dChkYkJhdGNoID0+IHtcclxuICAgICAgICAgICAgaWYgKGRiQmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRvY3VtZW50IGtleXMgZm9yIHRoZSBtdXRhdGlvbiBiYXRjaCB3aXRoIHRoZSBnaXZlbiBiYXRjaElkLlxyXG4gICAgICogRm9yIHByaW1hcnkgY2xpZW50cywgdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAgYWZ0ZXJcclxuICAgICAqIGByZW1vdmVNdXRhdGlvbkJhdGNoZXMoKWAgaGFzIGJlZW4gY2FsbGVkLiBTZWNvbmRhcnkgY2xpZW50cyByZXR1cm4gYVxyXG4gICAgICogY2FjaGVkIHJlc3VsdCB1bnRpbCBgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKClgIGlzIGludm9rZWQuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBsb29rdXBNdXRhdGlvbktleXModHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcclxuICAgICAgICBpZiAodGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpLm5leHQoYmF0Y2ggPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGJhdGNoLmtleXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSA9IGtleXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBuZXh0QmF0Y2hJZCA9IGJhdGNoSWQgKyAxO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChbdGhpcy51c2VySWQsIG5leHRCYXRjaElkXSk7XHJcbiAgICAgICAgbGV0IGZvdW5kQmF0Y2ggPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkYkJhdGNoLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC5iYXRjaElkID49IG5leHRCYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvdW5kQmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZm91bmRCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS51cHBlckJvdW5kKFtcclxuICAgICAgICAgICAgdGhpcy51c2VySWQsXHJcbiAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxldCBiYXRjaElkID0gQkFUQ0hJRF9VTktOT1dOO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSwgcmV2ZXJzZTogdHJ1ZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGJhdGNoSWQgPSBkYkJhdGNoLmJhdGNoSWQ7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGJhdGNoSWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIEJBVENISURfVU5LTk9XTl0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAubG9hZEFsbChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlKVxyXG4gICAgICAgICAgICAubmV4dChkYkJhdGNoZXMgPT4gZGJCYXRjaGVzLm1hcChkYkJhdGNoID0+IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgLy8gU2NhbiB0aGUgZG9jdW1lbnQtbXV0YXRpb24gaW5kZXggc3RhcnRpbmcgd2l0aCBhIHByZWZpeCBzdGFydGluZyB3aXRoXHJcbiAgICAgICAgLy8gdGhlIGdpdmVuIGRvY3VtZW50S2V5LlxyXG4gICAgICAgIGNvbnN0IGluZGV4UHJlZml4ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgZG9jdW1lbnRLZXkucGF0aCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgcm93cyBtYXRjaGluZyBleGFjdGx5IHRoZSBzcGVjaWZpYyBrZXkgb2ZcclxuICAgICAgICAgICAgLy8gaW50ZXJlc3QuIE5vdGUgdGhhdCBiZWNhdXNlIHdlIG9yZGVyIGJ5IHBhdGggZmlyc3QsIGFuZCB3ZVxyXG4gICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXHJcbiAgICAgICAgICAgIC8vIHRoZSBpbmRleCByb3dzIGZvciBkb2N1bWVudEtleSBjb250aWd1b3VzbHkuIEluIHBhcnRpY3VsYXIsIGFsbFxyXG4gICAgICAgICAgICAvLyB0aGUgcm93cyBmb3IgZG9jdW1lbnRLZXkgd2lsbCBvY2N1ciBiZWZvcmUgYW55IHJvd3MgZm9yXHJcbiAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcclxuICAgICAgICAgICAgLy8gY2FuIHN0b3AgYXMgc29vbiBhcyB3ZSBoaXQgYW55IHN1Y2ggcm93LlxyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcclxuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgbXV0YXRpb24gYmF0Y2ggaW4gdGhlIHN0b3JlLlxyXG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChtdXRhdGlvbi51c2VySWQgPT09IHRoaXMudXNlcklkKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHRoaXMudXNlcklkLCBkb2N1bWVudEtleS5wYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4U3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbikuaXRlcmF0ZSh7IHJhbmdlIH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHJvd3MgbWF0Y2hpbmcgZXhhY3RseSB0aGUgc3BlY2lmaWMga2V5IG9mXHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmVzdC4gTm90ZSB0aGF0IGJlY2F1c2Ugd2Ugb3JkZXIgYnkgcGF0aCBmaXJzdCwgYW5kIHdlXHJcbiAgICAgICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggcm93cyBmb3IgZG9jdW1lbnRLZXkgY29udGlndW91c2x5LiBJbiBwYXJ0aWN1bGFyLCBhbGxcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByb3dzIGZvciBkb2N1bWVudEtleSB3aWxsIG9jY3VyIGJlZm9yZSBhbnkgcm93cyBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBzdG9wIGFzIHNvb24gYXMgd2UgaGl0IGFueSBzdWNoIHJvdy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKGJhdGNoSUQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIHVuaXF1ZUJhdGNoSURzKSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSBxdWVyeS5wYXRoO1xyXG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuTGVuZ3RoID0gcXVlcnlQYXRoLmxlbmd0aCArIDE7XHJcbiAgICAgICAgLy8gVE9ETyhtY2cpOiBBY3R1YWxseSBpbXBsZW1lbnQgYSBzaW5nbGUtY29sbGVjdGlvbiBxdWVyeVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhpcyBpcyBhY3R1YWxseSBleGVjdXRpbmcgYW4gYW5jZXN0b3IgcXVlcnksIHRyYXZlcnNpbmcgdGhlIHdob2xlXHJcbiAgICAgICAgLy8gc3VidHJlZSBiZWxvdyB0aGUgY29sbGVjdGlvbiB3aGljaCBjYW4gYmUgaG9ycmlmaWNhbGx5IGluZWZmaWNpZW50IGZvclxyXG4gICAgICAgIC8vIHNvbWUgc3RydWN0dXJlcy4gVGhlIHJpZ2h0IHdheSB0byBzb2x2ZSB0aGlzIGlzIHRvIGltcGxlbWVudCB0aGUgZnVsbFxyXG4gICAgICAgIC8vIHZhbHVlIGluZGV4LCBidXQgdGhhdCdzIG5vdCBpbiB0aGUgY2FyZHMgaW4gdGhlIG5lYXIgZnV0dXJlIHNvIHRoaXMgaXNcclxuICAgICAgICAvLyB0aGUgYmVzdCB3ZSBjYW4gZG8gZm9yIHRoZSBtb21lbnQuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCB5ZXQgaW5kZXggdGhlIGFjdHVhbCBwcm9wZXJ0aWVzIGluIHRoZSBtdXRhdGlvbnMsIG91clxyXG4gICAgICAgIC8vIGN1cnJlbnQgYXBwcm9hY2ggaXMgdG8ganVzdCByZXR1cm4gYWxsIG11dGF0aW9uIGJhdGNoZXMgdGhhdCBhZmZlY3RcclxuICAgICAgICAvLyBkb2N1bWVudHMgaW4gdGhlIGNvbGxlY3Rpb24gYmVpbmcgcXVlcmllZC5cclxuICAgICAgICBjb25zdCBpbmRleFByZWZpeCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIHF1ZXJ5UGF0aCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xyXG4gICAgICAgIC8vIENvbGxlY3QgdXAgdW5pcXVlIGJhdGNoSURzIGVuY291bnRlcmVkIGR1cmluZyBhIHNjYW4gb2YgdGhlIGluZGV4LiBVc2UgYVxyXG4gICAgICAgIC8vIFNvcnRlZFNldCB0byBhY2N1bXVsYXRlIGJhdGNoIElEcyBzbyB0aGV5IGNhbiBiZSB0cmF2ZXJzZWQgaW4gb3JkZXIgaW4gYVxyXG4gICAgICAgIC8vIHNjYW4gb2YgdGhlIG1haW4gdGFibGUuXHJcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCB8fCAhcXVlcnlQYXRoLmlzUHJlZml4T2YocGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJvd3Mgd2l0aCBkb2N1bWVudCBrZXlzIG1vcmUgdGhhbiBvbmUgc2VnbWVudCBsb25nZXIgdGhhbiB0aGVcclxuICAgICAgICAgICAgLy8gcXVlcnkgcGF0aCBjYW4ndCBiZSBtYXRjaGVzLiBGb3IgZXhhbXBsZSwgYSBxdWVyeSBvbiAncm9vbXMnXHJcbiAgICAgICAgICAgIC8vIGNhbid0IG1hdGNoIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cclxuICAgICAgICAgICAgLy8gVE9ETyhtY2cpOiB3ZSdsbCBuZWVkIGEgZGlmZmVyZW50IHNjYW5uZXIgd2hlbiB3ZSBpbXBsZW1lbnRcclxuICAgICAgICAgICAgLy8gYW5jZXN0b3IgcXVlcmllcy5cclxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSBpbW1lZGlhdGVDaGlsZHJlbkxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKGJhdGNoSUQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMubG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCB1bmlxdWVCYXRjaElEcykpO1xyXG4gICAgfVxyXG4gICAgbG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCBiYXRjaElEcykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIC8vIFRPRE8ocm9ja3dvb2QpOiBJbXBsZW1lbnQgdGhpcyB1c2luZyBpdGVyYXRlLlxyXG4gICAgICAgIGJhdGNoSURzLmZvckVhY2goYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KG11dGF0aW9uLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBtdXRhdGlvbikpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbi5zaW1wbGVEYlRyYW5zYWN0aW9uLCB0aGlzLnVzZXJJZCwgYmF0Y2gpLm5leHQocmVtb3ZlZERvY3VtZW50cyA9PiB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2guYmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocmVtb3ZlZERvY3VtZW50cywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUubWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHJhbnNhY3Rpb24sIGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBrZXlzIGZvciBhIG11dGF0aW9uIGJhdGNoLiBUaGlzIG1ldGhvZCBzaG91bGQgYmVcclxuICAgICAqIGNhbGxlZCBieSBzZWNvbmRhcnkgY2xpZW50cyBhZnRlciB0aGV5IHByb2Nlc3MgbXV0YXRpb24gdXBkYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSB0byBiZSBjYWxsZWQgZnJvbSBwcmltYXJ5IGNsaWVudHMgYXNcclxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIGVudHJpZXMgYXJlIGNsZWFyZWQgd2hlbiBhbiBhY2tub3dsZWRnZWQgb3JcclxuICAgICAqIHJlamVjdGVkIGJhdGNoIGlzIHJlbW92ZWQgZnJvbSB0aGUgbXV0YXRpb24gcXVldWUuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcclxuICAgIHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdO1xyXG4gICAgfVxyXG4gICAgcGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbXB0eSh0eG4pLm5leHQoZW1wdHkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBhcmUgbm8gZW50cmllcyBpbiB0aGUgZG9jdW1lbnRNdXRhdGlvbnMgaW5kZXggaWZcclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXVlIGlzIGVtcHR5LlxyXG4gICAgICAgICAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JVc2VyKHRoaXMudXNlcklkKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhbmdsaW5nTXV0YXRpb25SZWZlcmVuY2VzID0gW107XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bilcclxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UgfSwgKGtleSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklEID0ga2V5WzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB0aGlzLnVzZXJJZCwga2V5KTtcclxuICAgIH1cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkgKHN0YXRlIGlzIGhlbGQgaW4gbWVtb3J5IGluIG90aGVyIGNsaWVudHMpLlxyXG4gICAgLyoqIFJldHVybnMgdGhlIG11dGF0aW9uIHF1ZXVlJ3MgbWV0YWRhdGEgZnJvbSBJbmRleGVkRGIuICovXHJcbiAgICBnZXRNdXRhdGlvblF1ZXVlTWV0YWRhdGEodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldCh0aGlzLnVzZXJJZClcclxuICAgICAgICAgICAgLm5leHQoKG1ldGFkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAobWV0YWRhdGEgfHwge1xyXG4gICAgICAgICAgICAgICAgdXNlcklkOiB0aGlzLnVzZXJJZCxcclxuICAgICAgICAgICAgICAgIGxhc3RBY2tub3dsZWRnZWRCYXRjaElkOiBCQVRDSElEX1VOS05PV04sXHJcbiAgICAgICAgICAgICAgICBsYXN0U3RyZWFtVG9rZW46ICcnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIgY29udGFpbnMgYSBwZW5kaW5nXHJcbiAqICAgICAgICAgbXV0YXRpb24gZm9yIHRoZSBnaXZlbiBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGtleSkge1xyXG4gICAgY29uc3QgaW5kZXhLZXkgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHVzZXJJZCwga2V5LnBhdGgpO1xyXG4gICAgY29uc3QgZW5jb2RlZFBhdGggPSBpbmRleEtleVsxXTtcclxuICAgIGNvbnN0IHN0YXJ0UmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4S2V5KTtcclxuICAgIGxldCBjb250YWluc0tleSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxyXG4gICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3VzZXJJRCwga2V5UGF0aCwgLypiYXRjaElEKi8gX10gPSBrZXk7XHJcbiAgICAgICAgaWYgKHVzZXJJRCA9PT0gdXNlcklkICYmIGtleVBhdGggPT09IGVuY29kZWRQYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5zS2V5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICB9KVxyXG4gICAgICAgIC5uZXh0KCgpID0+IGNvbnRhaW5zS2V5KTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGFueSBtdXRhdGlvbiBxdWV1ZSBjb250YWlucyB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGRvY0tleSkge1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0eG4pXHJcbiAgICAgICAgLml0ZXJhdGVTZXJpYWwodXNlcklkID0+IHtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdXNlcklkLCBkb2NLZXkpLm5leHQoY29udGFpbnNLZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnNLZXkpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoIWNvbnRhaW5zS2V5KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pXHJcbiAgICAgICAgLm5leHQoKCkgPT4gZm91bmQpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9ucyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvbnNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvblF1ZXVlcyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9uUXVldWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uUXVldWVTdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIE9mZnNldCB0byBlbnN1cmUgbm9uLW92ZXJsYXBwaW5nIHRhcmdldCBpZHMuICovXHJcbmNvbnN0IE9GRlNFVCA9IDI7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHRhcmdldCBJRHMgZm9yIHNlbmRpbmcgdGFyZ2V0cyB0byB0aGVcclxuICogd2F0Y2ggc3RyZWFtLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGNvbnN0cnVjdHMgdHdvIGdlbmVyYXRvcnMsIG9uZSBmb3IgdGhlIHRhcmdldCBjYWNoZSwgYW5kIG9uZSBmb3JcclxuICogZm9yIHRoZSBzeW5jIGVuZ2luZSAodG8gZ2VuZXJhdGUgbGltYm8gZG9jdW1lbnRzIHRhcmdldHMpLiBUaGVzZVxyXG4gKiBnZW5lcmF0b3JzIHByb2R1Y2Ugbm9uLW92ZXJsYXBwaW5nIElEcyAoYnkgdXNpbmcgZXZlbiBhbmQgb2RkIElEc1xyXG4gKiByZXNwZWN0aXZlbHkpLlxyXG4gKlxyXG4gKiBCeSBzZXBhcmF0aW5nIHRoZSB0YXJnZXQgSUQgc3BhY2UsIHRoZSBxdWVyeSBjYWNoZSBjYW4gZ2VuZXJhdGUgdGFyZ2V0IElEc1xyXG4gKiB0aGF0IHBlcnNpc3QgYWNyb3NzIGNsaWVudCByZXN0YXJ0cywgd2hpbGUgc3luYyBlbmdpbmUgY2FuIGluZGVwZW5kZW50bHlcclxuICogZ2VuZXJhdGUgaW4tbWVtb3J5IHRhcmdldCBJRHMgdGhhdCBhcmUgdHJhbnNpZW50IGFuZCBjYW4gYmUgcmV1c2VkIGFmdGVyIGFcclxuICogcmVzdGFydC5cclxuICovXHJcbmNsYXNzIFRhcmdldElkR2VuZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGxhc3RJZCkge1xyXG4gICAgICAgIHRoaXMubGFzdElkID0gbGFzdElkO1xyXG4gICAgfVxyXG4gICAgbmV4dCgpIHtcclxuICAgICAgICB0aGlzLmxhc3RJZCArPSBPRkZTRVQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdElkO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZvclRhcmdldENhY2hlKCkge1xyXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgY2FjaGUgZ2VuZXJhdG9yIG11c3QgcmV0dXJuICcyJyBpbiBpdHMgZmlyc3QgY2FsbCB0byBgbmV4dCgpYFxyXG4gICAgICAgIC8vIGFzIHRoZXJlIGlzIG5vIGRpZmZlcmVudGlhdGlvbiBpbiB0aGUgcHJvdG9jb2wgbGF5ZXIgYmV0d2VlbiBhbiB1bnNldFxyXG4gICAgICAgIC8vIG51bWJlciBhbmQgdGhlIG51bWJlciAnMCcuIElmIHdlIHdlcmUgdG8gc2VudCBhIHRhcmdldCB3aXRoIHRhcmdldCBJRFxyXG4gICAgICAgIC8vICcwJywgdGhlIGJhY2tlbmQgd291bGQgY29uc2lkZXIgaXQgdW5zZXQgYW5kIHJlcGxhY2UgaXQgd2l0aCBpdHMgb3duIElELlxyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IoMiAtIE9GRlNFVCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZm9yU3luY0VuZ2luZSgpIHtcclxuICAgICAgICAvLyBTeW5jIGVuZ2luZSBhc3NpZ25zIHRhcmdldCBJRHMgZm9yIGxpbWJvIGRvY3VtZW50IGRldGVjdGlvbi5cclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDEgLSBPRkZTRVQpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYlRhcmdldENhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlZmVyZW5jZURlbGVnYXRlLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICB9XHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IFdlIGRvbid0IGNhY2hlIGdsb2JhbCBtZXRhZGF0YSBmb3IgdGhlIHRhcmdldCBjYWNoZSwgc2luY2VcclxuICAgIC8vIHNvbWUgb2YgaXQgKGluIHBhcnRpY3VsYXIgYGhpZ2hlc3RUYXJnZXRJZGApIGNhbiBiZSBtb2RpZmllZCBieSBzZWNvbmRhcnlcclxuICAgIC8vIHRhYnMuIFdlIGNvdWxkIHBlcmhhcHMgYmUgbW9yZSBncmFudWxhciAoYW5kIGUuZy4gc3RpbGwgY2FjaGVcclxuICAgIC8vIGBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uYCBpbiBtZW1vcnkpIGJ1dCBmb3Igc2ltcGxpY2l0eSB3ZSBjdXJyZW50bHkgZ29cclxuICAgIC8vIHRvIEluZGV4ZWREYiB3aGVuZXZlciB3ZSBuZWVkIHRvIHJlYWQgbWV0YWRhdGEuIFdlIGNhbiByZXZpc2l0IGlmIGl0IHR1cm5zXHJcbiAgICAvLyBvdXQgdG8gaGF2ZSBhIG1lYW5pbmdmdWwgcGVyZm9ybWFuY2UgaW1wYWN0LlxyXG4gICAgYWxsb2NhdGVUYXJnZXRJZCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJZEdlbmVyYXRvciA9IG5ldyBUYXJnZXRJZEdlbmVyYXRvcihtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpLm5leHQoKCkgPT4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKG5ldyBUaW1lc3RhbXAobWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbi5zZWNvbmRzLCBtZXRhZGF0YS5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLm5hbm9zZWNvbmRzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KHRhcmdldEdsb2JhbCA9PiB0YXJnZXRHbG9iYWwuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKTtcclxuICAgIH1cclxuICAgIHNldFRhcmdldHNNZXRhZGF0YSh0cmFuc2FjdGlvbiwgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICAgICAgaWYgKGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID4gbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnRhcmdldENvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YS50YXJnZXRJZClcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gdGFyZ2V0c1N0b3JlKHRyYW5zYWN0aW9uKS5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXRJZCkpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikpXHJcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgaGFyZEFzc2VydChtZXRhZGF0YS50YXJnZXRDb3VudCA+IDApO1xyXG4gICAgICAgICAgICBtZXRhZGF0YS50YXJnZXRDb3VudCAtPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJvcHMgYW55IHRhcmdldHMgd2l0aCBzZXF1ZW5jZSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB1cHBlciBib3VuZCwgZXhjZXB0aW5nIHRob3NlXHJcbiAgICAgKiBwcmVzZW50IGluIGBhY3RpdmVUYXJnZXRJZHNgLiBEb2N1bWVudCBhc3NvY2lhdGlvbnMgZm9yIHRoZSByZW1vdmVkIHRhcmdldHMgYXJlIGFsc28gcmVtb3ZlZC5cclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0YXJnZXRzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBmcm9tRGJUYXJnZXQodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHMuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCBwcm92aWRlZCBmdW5jdGlvbiB3aXRoIGVhY2ggYFRhcmdldERhdGFgIHRoYXQgd2UgaGF2ZSBjYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pLml0ZXJhdGUoKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGYodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuZ2V0KERiVGFyZ2V0R2xvYmFsS2V5KVxyXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQobWV0YWRhdGEgIT09IG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIHNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluLXBsYWNlIHVwZGF0ZXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbiB0aGUgZ2l2ZW5cclxuICAgICAqIFRhcmdldERhdGEuIFNhdmluZyBpcyBkb25lIHNlcGFyYXRlbHkuIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSB3ZXJlIGFueVxyXG4gICAgICogY2hhbmdlcyB0byB0aGUgbWV0YWRhdGEuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpIHtcclxuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YXJnZXREYXRhLnRhcmdldElkID4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRUYXJnZXRDb3VudCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEudGFyZ2V0Q291bnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gSXRlcmF0aW5nIGJ5IHRoZSBjYW5vbmljYWxJZCBtYXkgeWllbGQgbW9yZSB0aGFuIG9uZSByZXN1bHQgYmVjYXVzZVxyXG4gICAgICAgIC8vIGNhbm9uaWNhbElkIHZhbHVlcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHVuaXF1ZSBwZXIgdGFyZ2V0LiBUaGlzIHF1ZXJ5XHJcbiAgICAgICAgLy8gZGVwZW5kcyBvbiB0aGUgcXVlcnlUYXJnZXRzIGluZGV4IHRvIGJlIGVmZmljaWVudC5cclxuICAgICAgICBjb25zdCBjYW5vbmljYWxJZCA9IGNhbm9uaWZ5VGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2Fub25pY2FsSWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFtjYW5vbmljYWxJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZSwgaW5kZXg6IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcclxuICAgICAgICAgICAgLy8gQWZ0ZXIgZmluZGluZyBhIHBvdGVudGlhbCBtYXRjaCwgY2hlY2sgdGhhdCB0aGUgdGFyZ2V0IGlzXHJcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGVxdWFsIHRvIHRoZSByZXF1ZXN0ZWQgdGFyZ2V0LlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RXF1YWxzKHRhcmdldCwgZm91bmQudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm91bmQ7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBhZGRNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcclxuICAgICAgICAvLyBJbmRleGVkRGIuXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcclxuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3RvcmUucHV0KHsgdGFyZ2V0SWQsIHBhdGggfSkpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMucmVmZXJlbmNlRGVsZWdhdGUuYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcclxuICAgICAgICAvLyBJbmRleGVkRGIuXHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihbXHJcbiAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoW3RhcmdldElkLCBwYXRoXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RhcmdldElkXSwgW3RhcmdldElkICsgMV0sIFxyXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcclxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICByZXR1cm4gc3RvcmUuZGVsZXRlKHJhbmdlKTtcclxuICAgIH1cclxuICAgIGdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChrZXlbMV0pO1xyXG4gICAgICAgICAgICBjb25zdCBkb2NLZXkgPSBuZXcgRG9jdW1lbnRLZXkocGF0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZG9jS2V5KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcclxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtwYXRoXSwgW2ltbWVkaWF0ZVN1Y2Nlc3NvcihwYXRoKV0sIFxyXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcclxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bilcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0luZGV4LFxyXG4gICAgICAgICAgICBrZXlzT25seTogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2VcclxuICAgICAgICB9LCAoW3RhcmdldElkLCBwYXRoXSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBIYXZpbmcgYSBzZW50aW5lbCByb3cgZm9yIGEgZG9jdW1lbnQgZG9lcyBub3QgY291bnQgYXMgY29udGFpbmluZyB0aGF0IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAvLyBGb3IgdGhlIHRhcmdldCBjYWNoZSwgY29udGFpbmluZyB0aGUgZG9jdW1lbnQgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHBhcnQgb2Ygc29tZVxyXG4gICAgICAgICAgICAvLyB0YXJnZXQuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRJZCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY291bnQgPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgYSBUYXJnZXREYXRhIGVudHJ5IGJ5IHRhcmdldCBJRC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0SWQgLSBUaGUgdGFyZ2V0IElEIG9mIHRoZSBUYXJnZXREYXRhIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIFRhcmdldERhdGEgZW50cnksIG9yIG51bGwgaWYgdGhlIGNhY2hlIGhhcyBubyBlbnRyeSBmb3JcclxuICAgICAqIHRoZSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBnZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQodGFyZ2V0SWQpXHJcbiAgICAgICAgICAgIC5uZXh0KGZvdW5kID0+IHtcclxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiVGFyZ2V0KGZvdW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcXVlcmllcyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlRhcmdldFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSB0YXJnZXQgZ2xvYmFscyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnbG9iYWxUYXJnZXRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGRvY3VtZW50IHRhcmdldCBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBHQ19ESURfTk9UX1JVTiA9IHtcclxuICAgIGRpZFJ1bjogZmFsc2UsXHJcbiAgICBzZXF1ZW5jZU51bWJlcnNDb2xsZWN0ZWQ6IDAsXHJcbiAgICB0YXJnZXRzUmVtb3ZlZDogMCxcclxuICAgIGRvY3VtZW50c1JlbW92ZWQ6IDBcclxufTtcclxuY29uc3QgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgPSAtMTtcclxuY29uc3QgTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUyA9IDQwICogMTAyNCAqIDEwMjQ7XHJcbmNsYXNzIExydVBhcmFtcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8vIFdoZW4gd2UgYXR0ZW1wdCB0byBjb2xsZWN0LCB3ZSB3aWxsIG9ubHkgZG8gc28gaWYgdGhlIGNhY2hlIHNpemUgaXMgZ3JlYXRlciB0aGFuIHRoaXNcclxuICAgIC8vIHRocmVzaG9sZC4gUGFzc2luZyBgQ09MTEVDVElPTl9ESVNBQkxFRGAgaGVyZSB3aWxsIGNhdXNlIGNvbGxlY3Rpb24gdG8gYWx3YXlzIGJlIHNraXBwZWQuXHJcbiAgICBjYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkLCBcclxuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3ZSB3aWxsIGF0dGVtcHQgdG8gY29sbGVjdFxyXG4gICAgcGVyY2VudGlsZVRvQ29sbGVjdCwgXHJcbiAgICAvLyBBIGNhcCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3aWxsIGJlIGNvbGxlY3RlZC4gVGhpcyBwcmV2ZW50c1xyXG4gICAgLy8gdXMgZnJvbSBjb2xsZWN0aW5nIGEgaHVnZSBudW1iZXIgb2Ygc2VxdWVuY2UgbnVtYmVycyBpZiB0aGUgY2FjaGUgaGFzIGdyb3duIHZlcnkgbGFyZ2UuXHJcbiAgICBtYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkID0gY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZDtcclxuICAgICAgICB0aGlzLnBlcmNlbnRpbGVUb0NvbGxlY3QgPSBwZXJjZW50aWxlVG9Db2xsZWN0O1xyXG4gICAgICAgIHRoaXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9IG1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd2l0aENhY2hlU2l6ZShjYWNoZVNpemUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExydVBhcmFtcyhjYWNoZVNpemUsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XHJcbiAgICB9XHJcbn1cclxuTHJ1UGFyYW1zLkRFRkFVTFRfQ09MTEVDVElPTl9QRVJDRU5USUxFID0gMTA7XHJcbkxydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QgPSAxMDAwO1xyXG5McnVQYXJhbXMuREVGQVVMVCA9IG5ldyBMcnVQYXJhbXMoTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUywgTHJ1UGFyYW1zLkRFRkFVTFRfQ09MTEVDVElPTl9QRVJDRU5USUxFLCBMcnVQYXJhbXMuREVGQVVMVF9NQVhfU0VRVUVOQ0VfTlVNQkVSU19UT19DT0xMRUNUKTtcclxuTHJ1UGFyYW1zLkRJU0FCTEVEID0gbmV3IExydVBhcmFtcyhMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCwgMCwgMCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckZSA9ICdMcnVHYXJiYWdlQ29sbGVjdG9yJztcclxuY29uc3QgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUyA9IDEgKiAxMDI0ICogMTAyNDtcclxuLyoqIEhvdyBsb25nIHdlIHdhaXQgdG8gdHJ5IHJ1bm5pbmcgTFJVIEdDIGFmdGVyIFNESyBpbml0aWFsaXphdGlvbi4gKi9cclxuY29uc3QgSU5JVElBTF9HQ19ERUxBWV9NUyA9IDEgKiA2MCAqIDEwMDA7XHJcbi8qKiBNaW5pbXVtIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gR0MgY2hlY2tzLCBhZnRlciB0aGUgZmlyc3Qgb25lLiAqL1xyXG5jb25zdCBSRUdVTEFSX0dDX0RFTEFZX01TID0gNSAqIDYwICogMTAwMDtcclxuZnVuY3Rpb24gYnVmZmVyRW50cnlDb21wYXJhdG9yKFthU2VxdWVuY2UsIGFJbmRleF0sIFtiU2VxdWVuY2UsIGJJbmRleF0pIHtcclxuICAgIGNvbnN0IHNlcUNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IoYVNlcXVlbmNlLCBiU2VxdWVuY2UpO1xyXG4gICAgaWYgKHNlcUNtcCA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRoaXMgb3JkZXIgZG9lc24ndCBtYXR0ZXIsIGJ1dCB3ZSBjYW4gYmlhcyBhZ2FpbnN0IGNodXJuIGJ5IHNvcnRpbmdcclxuICAgICAgICAvLyBlbnRyaWVzIGNyZWF0ZWQgZWFybGllciBhcyBsZXNzIHRoYW4gbmV3ZXIgZW50cmllcy5cclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihhSW5kZXgsIGJJbmRleCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VxQ21wO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnRoIHNlcXVlbmNlIG51bWJlci4gS2VlcHMgYSByb2xsaW5nIGJ1ZmZlciBvZiB0aGVcclxuICogbG93ZXN0IG4gdmFsdWVzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAsIGFuZCBmaW5hbGx5IHJlcG9ydHMgdGhlIGxhcmdlc3Qgb2ZcclxuICogdGhlbSBpbiBgbWF4VmFsdWVgLlxyXG4gKi9cclxuY2xhc3MgUm9sbGluZ1NlcXVlbmNlTnVtYmVyQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5tYXhFbGVtZW50cyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFNvcnRlZFNldChidWZmZXJFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICBuZXh0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuICsrdGhpcy5wcmV2aW91c0luZGV4O1xyXG4gICAgfVxyXG4gICAgYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gW3NlcXVlbmNlTnVtYmVyLCB0aGlzLm5leHRJbmRleCgpXTtcclxuICAgICAgICBpZiAodGhpcy5idWZmZXIuc2l6ZSA8IHRoaXMubWF4RWxlbWVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5hZGQoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaGVzdFZhbHVlID0gdGhpcy5idWZmZXIubGFzdCgpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyRW50cnlDb21wYXJhdG9yKGVudHJ5LCBoaWdoZXN0VmFsdWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5kZWxldGUoaGlnaGVzdFZhbHVlKS5hZGQoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdG8gYmUgbm9uLWVtcHR5LiBJZiB3ZSBkZWNpZGUgd2UgYXJlIG5vdCBjb2xsZWN0aW5nIGFueVxyXG4gICAgICAgIC8vIHNlcXVlbmNlIG51bWJlcnMsIG50aFNlcXVlbmNlTnVtYmVyIGJlbG93IHNob3J0LWNpcmN1aXRzLiBJZiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gZGVjaWRlZCB0aGF0IHdlIGFyZSBjb2xsZWN0aW5nIG4gc2VxdWVuY2UgbnVtYmVycywgaXQncyBiZWNhdXNlIG4gaXMgc29tZVxyXG4gICAgICAgIC8vIHBlcmNlbnRhZ2Ugb2YgdGhlIGV4aXN0aW5nIHNlcXVlbmNlIG51bWJlcnMuIFRoYXQgbWVhbnMgd2Ugc2hvdWxkIG5ldmVyXHJcbiAgICAgICAgLy8gYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIGNvbGxlY3Rpbmcgc2VxdWVuY2UgbnVtYmVycyBidXQgZG9uJ3RcclxuICAgICAgICAvLyBhY3R1YWxseSBoYXZlIGFueS5cclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGFzdCgpWzBdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLiBJdCBoYW5kbGVzIGNoZWNraW5nXHJcbiAqIHdoZXRoZXIgb3Igbm90IEdDIGlzIGVuYWJsZWQsIGFzIHdlbGwgYXMgd2hpY2ggZGVsYXkgdG8gdXNlIGJlZm9yZSB0aGUgbmV4dCBydW4uXHJcbiAqL1xyXG5jbGFzcyBMcnVTY2hlZHVsZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2FyYmFnZUNvbGxlY3RvciwgYXN5bmNRdWV1ZSwgbG9jYWxTdG9yZSkge1xyXG4gICAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3RvciA9IGdhcmJhZ2VDb2xsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMuZ2NUYXNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdhcmJhZ2VDb2xsZWN0b3IucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQgIT09XHJcbiAgICAgICAgICAgIExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVHQyhJTklUSUFMX0dDX0RFTEFZX01TKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdjVGFzaykge1xyXG4gICAgICAgICAgICB0aGlzLmdjVGFzay5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzdGFydGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdjVGFzayAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIHNjaGVkdWxlR0MoZGVsYXkpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGUsIGBHYXJiYWdlIGNvbGxlY3Rpb24gc2NoZWR1bGVkIGluICR7ZGVsYXl9bXNgKTtcclxuICAgICAgICB0aGlzLmdjVGFzayA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImxydV9nYXJiYWdlX2NvbGxlY3Rpb25cIiAvKiBUaW1lcklkLkxydUdhcmJhZ2VDb2xsZWN0aW9uICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvY2FsU3RvcmUuY29sbGVjdEdhcmJhZ2UodGhpcy5nYXJiYWdlQ29sbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgJ0lnbm9yaW5nIEluZGV4ZWREQiBlcnJvciBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uOiAnLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlR0MoUkVHVUxBUl9HQ19ERUxBWV9NUyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gKi9cclxuY2xhc3MgTHJ1R2FyYmFnZUNvbGxlY3RvckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZVRhcmdldENvdW50KHR4biwgcGVyY2VudGlsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmdldFNlcXVlbmNlTnVtYmVyQ291bnQodHhuKS5uZXh0KHRhcmdldENvdW50ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHBlcmNlbnRpbGUgLyAxMDAuMCkgKiB0YXJnZXRDb3VudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBudGhTZXF1ZW5jZU51bWJlcih0eG4sIG4pIHtcclxuICAgICAgICBpZiAobiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBSb2xsaW5nU2VxdWVuY2VOdW1iZXJCdWZmZXIobik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVcclxuICAgICAgICAgICAgLmZvckVhY2hUYXJnZXQodHhuLCB0YXJnZXQgPT4gYnVmZmVyLmFkZEVsZW1lbnQodGFyZ2V0LnNlcXVlbmNlTnVtYmVyKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXIgPT4gYnVmZmVyLmFkZEVsZW1lbnQoc2VxdWVuY2VOdW1iZXIpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBidWZmZXIubWF4VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKTtcclxuICAgIH1cclxuICAgIGNvbGxlY3QodHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCA9PT0gTFJVX0NPTExFQ1RJT05fRElTQUJMRUQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCAnR2FyYmFnZSBjb2xsZWN0aW9uIHNraXBwZWQ7IGRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShHQ19ESURfTk9UX1JVTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENhY2hlU2l6ZSh0eG4pLm5leHQoY2FjaGVTaXplID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhY2hlU2l6ZSA8IHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgYEdhcmJhZ2UgY29sbGVjdGlvbiBza2lwcGVkOyBDYWNoZSBzaXplICR7Y2FjaGVTaXplfSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaXMgbG93ZXIgdGhhbiB0aHJlc2hvbGQgJHt0aGlzLnBhcmFtcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkfWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdDX0RJRF9OT1RfUlVOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0Q2FjaGVTaXplKHR4bik7XHJcbiAgICB9XHJcbiAgICBydW5HYXJiYWdlQ29sbGVjdGlvbih0eG4sIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIGxldCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgbGV0IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCwgdGFyZ2V0c1JlbW92ZWQ7XHJcbiAgICAgICAgLy8gVGltZXN0YW1wcyBmb3IgdmFyaW91cyBwaWVjZXMgb2YgdGhlIHByb2Nlc3NcclxuICAgICAgICBsZXQgY291bnRlZFRhcmdldHNUcywgZm91bmRVcHBlckJvdW5kVHMsIHJlbW92ZWRUYXJnZXRzVHMsIHJlbW92ZWREb2N1bWVudHNUcztcclxuICAgICAgICBjb25zdCBzdGFydFRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVUYXJnZXRDb3VudCh0eG4sIHRoaXMucGFyYW1zLnBlcmNlbnRpbGVUb0NvbGxlY3QpXHJcbiAgICAgICAgICAgIC5uZXh0KHNlcXVlbmNlTnVtYmVycyA9PiB7XHJcbiAgICAgICAgICAgIC8vIENhcCBhdCB0aGUgY29uZmlndXJlZCBtYXhcclxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVycyA+IHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgJ0NhcHBpbmcgc2VxdWVuY2UgbnVtYmVycyB0byBjb2xsZWN0IGRvd24gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRvIHRoZSBtYXhpbXVtIG9mICR7dGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGZyb20gJHtzZXF1ZW5jZU51bWJlcnN9YCk7XHJcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBzZXF1ZW5jZU51bWJlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY291bnRlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm50aFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCh1cHBlckJvdW5kID0+IHtcclxuICAgICAgICAgICAgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyID0gdXBwZXJCb3VuZDtcclxuICAgICAgICAgICAgZm91bmRVcHBlckJvdW5kVHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KG51bVRhcmdldHNSZW1vdmVkID0+IHtcclxuICAgICAgICAgICAgdGFyZ2V0c1JlbW92ZWQgPSBudW1UYXJnZXRzUmVtb3ZlZDtcclxuICAgICAgICAgICAgcmVtb3ZlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHNSZW1vdmVkID0+IHtcclxuICAgICAgICAgICAgcmVtb3ZlZERvY3VtZW50c1RzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSAnTFJVIEdhcmJhZ2UgQ29sbGVjdGlvblxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXHRDb3VudGVkIHRhcmdldHMgaW4gJHtjb3VudGVkVGFyZ2V0c1RzIC0gc3RhcnRUc31tc1xcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXHREZXRlcm1pbmVkIGxlYXN0IHJlY2VudGx5IHVzZWQgJHtzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3R9IGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAke2ZvdW5kVXBwZXJCb3VuZFRzIC0gY291bnRlZFRhcmdldHNUc31tc1xcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXHRSZW1vdmVkICR7dGFyZ2V0c1JlbW92ZWR9IHRhcmdldHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7cmVtb3ZlZFRhcmdldHNUcyAtIGZvdW5kVXBwZXJCb3VuZFRzfW1zXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcdFJlbW92ZWQgJHtkb2N1bWVudHNSZW1vdmVkfSBkb2N1bWVudHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7cmVtb3ZlZERvY3VtZW50c1RzIC0gcmVtb3ZlZFRhcmdldHNUc31tc1xcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBUb3RhbCBEdXJhdGlvbjogJHtyZW1vdmVkRG9jdW1lbnRzVHMgLSBzdGFydFRzfW1zYDtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgZGVzYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgIGRpZFJ1bjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc0NvbGxlY3RlZDogc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0c1JlbW92ZWQsXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1vdmVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0xydUdhcmJhZ2VDb2xsZWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIG5ldyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbChkZWxlZ2F0ZSwgcGFyYW1zKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogUHJvdmlkZXMgTFJVIGZ1bmN0aW9uYWxpdHkgZm9yIEluZGV4ZWREQiBwZXJzaXN0ZW5jZS4gKi9cclxuY2xhc3MgSW5kZXhlZERiTHJ1RGVsZWdhdGVJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGRiLCBwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmRiID0gZGI7XHJcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2VxdWVuY2VOdW1iZXJDb3VudCh0eG4pIHtcclxuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENvdW50UHJvbWlzZSA9IHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5nZXRUYXJnZXRDb3VudCh0eG4pO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRDb3VudFByb21pc2UubmV4dCh0YXJnZXRDb3VudCA9PiBkb2NDb3VudFByb21pc2UubmV4dChkb2NDb3VudCA9PiB0YXJnZXRDb3VudCArIGRvY0NvdW50KSk7XHJcbiAgICB9XHJcbiAgICBvcnBoYW5lZERvY3VtZW50Q291bnQodHhuKSB7XHJcbiAgICAgICAgbGV0IG9ycGhhbmVkQ291bnQgPSAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBfID0+IHtcclxuICAgICAgICAgICAgb3JwaGFuZWRDb3VudCsrO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gb3JwaGFuZWRDb3VudCk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkuZm9yRWFjaFRhcmdldCh0eG4sIGYpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudCh0eG4sIChkb2NLZXksIHNlcXVlbmNlTnVtYmVyKSA9PiBmKHNlcXVlbmNlTnVtYmVyKSk7XHJcbiAgICB9XHJcbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRUYXJnZXRDYWNoZSgpLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgfVxyXG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbnl0aGluZyB3b3VsZCBwcmV2ZW50IHRoaXMgZG9jdW1lbnQgZnJvbSBiZWluZyBnYXJiYWdlXHJcbiAgICAgKiBjb2xsZWN0ZWQsIGdpdmVuIHRoYXQgdGhlIGRvY3VtZW50IGluIHF1ZXN0aW9uIGlzIG5vdCBwcmVzZW50IGluIGFueVxyXG4gICAgICogdGFyZ2V0cyBhbmQgaGFzIGEgc2VxdWVuY2UgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdXBwZXIgYm91bmQgZm9yXHJcbiAgICAgKiB0aGUgY29sbGVjdGlvbiBydW4uXHJcbiAgICAgKi9cclxuICAgIGlzUGlubmVkKHR4biwgZG9jS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGRvY0tleSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudENhY2hlID0gdGhpcy5kYi5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gZG9jdW1lbnRDYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGxldCBkb2N1bWVudENvdW50ID0gMDtcclxuICAgICAgICBjb25zdCBpdGVyYXRpb24gPSB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyIDw9IHVwcGVyQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmlzUGlubmVkKHR4biwgZG9jS2V5KS5uZXh0KGlzUGlubmVkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Q291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3VyIHNpemUgYWNjb3VudGluZyByZXF1aXJlcyB1cyB0byByZWFkIGFsbCBkb2N1bWVudHMgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQnVmZmVyLnJlbW92ZUVudHJ5KGRvY0tleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikuZGVsZXRlKHNlbnRpbmVsS2V5JDEoZG9jS2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRpb25cclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRDb3VudCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHRhcmdldERhdGEud2l0aFNlcXVlbmNlTnVtYmVyKHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkudXBkYXRlVGFyZ2V0RGF0YSh0eG4sIHVwZGF0ZWQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudCh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCBwcm92aWRlZCBmdW5jdGlvbiBmb3IgZWFjaCBkb2N1bWVudCBpbiB0aGUgY2FjaGUgdGhhdCBpcyAnb3JwaGFuZWQnLiBPcnBoYW5lZFxyXG4gICAgICogbWVhbnMgbm90IGEgcGFydCBvZiBhbnkgdGFyZ2V0LCBzbyB0aGUgb25seSBlbnRyeSBpbiB0aGUgdGFyZ2V0LWRvY3VtZW50IGluZGV4IGZvclxyXG4gICAgICogdGhhdCBkb2N1bWVudCB3aWxsIGJlIHRoZSBzZW50aW5lbCByb3cgKHRhcmdldElkIDApLCB3aGljaCB3aWxsIGFsc28gaGF2ZSB0aGUgc2VxdWVuY2VcclxuICAgICAqIG51bWJlciBmb3IgdGhlIGxhc3QgdGltZSB0aGUgZG9jdW1lbnQgd2FzIGFjY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoT3JwaGFuZWREb2N1bWVudCh0eG4sIGYpIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcclxuICAgICAgICBsZXQgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcclxuICAgICAgICBsZXQgbmV4dFBhdGg7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleFxyXG4gICAgICAgIH0sIChbdGFyZ2V0SWQsIGRvY0tleV0sIHsgcGF0aCwgc2VxdWVuY2VOdW1iZXIgfSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5leHRUb1JlcG9ydCBpcyB2YWxpZCwgcmVwb3J0IGl0LCB0aGlzIGlzIGEgbmV3IGtleSBzbyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGxhc3Qgb25lIG11c3Qgbm90IGJlIGEgbWVtYmVyIG9mIGFueSB0YXJnZXRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYobmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChuZXh0UGF0aCkpLCBuZXh0VG9SZXBvcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSB0aGlzIHNlcXVlbmNlIG51bWJlci4gSXQncyB0aGUgbmV4dCBvbmUgd2VcclxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IHJlcG9ydCwgaWYgd2UgZG9uJ3QgZmluZCBhbnkgdGFyZ2V0cyBmb3IgdGhpcyBkb2N1bWVudC5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VxdWVuY2UgbnVtYmVyIG11c3QgYmUgZGVmaW5lZCB3aGVuIHRoZSB0YXJnZXRJZFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgMC5cclxuICAgICAgICAgICAgICAgIG5leHRUb1JlcG9ydCA9IHNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgbmV4dFBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSBpbnZhbGlkLCB3ZSBrbm93IHdlIGRvbid0IG5lZWQgdG8gcmVwb3J0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBzaW5jZSB3ZSBmb3VuZCBhIHRhcmdldCBmb3IgaXQuXHJcbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSByZXBvcnQgc2VxdWVuY2UgbnVtYmVycyBhZnRlciBnZXR0aW5nIHRvIHRoZSBuZXh0IGtleSwgd2VcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBrZXkgd2UgaXRlcmF0ZWQgb3ZlciB3YXMgYW4gb3JwaGFuZWRcclxuICAgICAgICAgICAgLy8gZG9jdW1lbnQgYW5kIHJlcG9ydCBpdC5cclxuICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xyXG4gICAgICAgICAgICAgICAgZihuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKG5leHRQYXRoKSksIG5leHRUb1JlcG9ydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCkuZ2V0U2l6ZSh0eG4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlbnRpbmVsS2V5JDEoa2V5KSB7XHJcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCldO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBBIHZhbHVlIHN1aXRhYmxlIGZvciB3cml0aW5nIGEgc2VudGluZWwgcm93IGluIHRoZSB0YXJnZXQtZG9jdW1lbnRcclxuICogc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW50aW5lbFJvdyhrZXksIHNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICByZXR1cm4geyB0YXJnZXRJZDogMCwgcGF0aDogZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKSwgc2VxdWVuY2VOdW1iZXIgfTtcclxufVxyXG5mdW5jdGlvbiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pLnB1dChzZW50aW5lbFJvdyhrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IGJ1ZmZlciBvZiBlbnRyaWVzIHRvIGJlIHdyaXR0ZW4gdG8gYSBSZW1vdGVEb2N1bWVudENhY2hlLlxyXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cCBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIGNhY2hlLCBidXRcclxuICogYWRkaXRpb25hbGx5IHN1cHBvcnRzIHJlYWRpbmcgZW50cmllcyBiYWNrIHdpdGggdGhlIGBnZXRFbnRyeSgpYCBtZXRob2QsXHJcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgdW5kZXJseWluZyBSZW1vdGVEb2N1bWVudENhY2hlIGlmIG5vIGVudHJ5IGlzXHJcbiAqIGJ1ZmZlcmVkLlxyXG4gKlxyXG4gKiBFbnRyaWVzIGFkZGVkIHRvIHRoZSBjYWNoZSAqbXVzdCogYmUgcmVhZCBmaXJzdC4gVGhpcyBpcyB0byBmYWNpbGl0YXRlXHJcbiAqIGNhbGN1bGF0aW5nIHRoZSBzaXplIGRlbHRhIG9mIHRoZSBwZW5kaW5nIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBjbGFzcyB3YXMgaW1wbGVtZW50ZWQgdGhlbiByZW1vdmVkIGZyb20gb3RoZXIgcGxhdGZvcm1zLlxyXG4gKiBJZiBieXRlLWNvdW50aW5nIGVuZHMgdXAgYmVpbmcgbmVlZGVkIG9uIHRoZSBvdGhlciBwbGF0Zm9ybXMsIGNvbnNpZGVyXHJcbiAqIHBvcnRpbmcgdGhpcyBjbGFzcyBhcyBwYXJ0IG9mIHRoYXQgaW1wbGVtZW50YXRpb24gd29yay5cclxuICovXHJcbmNsYXNzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIEEgbWFwcGluZyBvZiBkb2N1bWVudCBrZXkgdG8gdGhlIG5ldyBjYWNoZSBlbnRyeSB0aGF0IHNob3VsZCBiZSB3cml0dGVuLlxyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlcnMgYSBgUmVtb3RlRG9jdW1lbnRDYWNoZS5hZGRFbnRyeSgpYCBjYWxsLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gb25seSBtb2RpZnkgZG9jdW1lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmV0cmlldmVkIHZpYVxyXG4gICAgICogYGdldEVudHJ5KCkvZ2V0RW50cmllcygpYCAoZW5mb3JjZWQgdmlhIEluZGV4ZWREYnMgYGFwcGx5KClgKS5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkoZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWZmZXJzIGEgYFJlbW90ZURvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkoKWAgY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIG9ubHkgcmVtb3ZlIGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcclxuICAgICAqIGBnZXRFbnRyeSgpL2dldEVudHJpZXMoKWAgKGVuZm9yY2VkIHZpYSBJbmRleGVkRGJzIGBhcHBseSgpYCkuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVudHJ5KGtleSwgcmVhZFRpbWUpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpLnNldFJlYWRUaW1lKHJlYWRUaW1lKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS4gVGhlIGJ1ZmZlcmVkIGNoYW5nZXMgd2lsbCBmaXJzdCBiZSBjaGVja2VkLFxyXG4gICAgICogYW5kIGlmIG5vIGJ1ZmZlcmVkIGNoYW5nZSBhcHBsaWVzLCB0aGlzIHdpbGwgZm9yd2FyZCB0b1xyXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXHJcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWYgd2UgaGF2ZSBub3RoaW5nXHJcbiAgICAgKiBjYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90QXBwbGllZCgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkRW50cnkgPSB0aGlzLmNoYW5nZXMuZ2V0KGRvY3VtZW50S2V5KTtcclxuICAgICAgICBpZiAoYnVmZmVyZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShidWZmZXJlZEVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgc2V2ZXJhbCBlbnRyaWVzIGluIHRoZSBjYWNoZSwgZm9yd2FyZGluZyB0b1xyXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXHJcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleXMgLSBUaGUga2V5cyBvZiB0aGUgZW50cmllcyB0byBsb29rIHVwLlxyXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgY2FjaGVkIGRvY3VtZW50cywgaW5kZXhlZCBieSBrZXkuIElmIGFuIGVudHJ5IGNhbm5vdCBiZVxyXG4gICAgICogICAgIGZvdW5kLCB0aGUgY29ycmVzcG9uZGluZyBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gYW4gaW52YWxpZCBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGJ1ZmZlcmVkIGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSwgdXNpbmdcclxuICAgICAqIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgYXBwbHkodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXModHJhbnNhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIEhlbHBlciB0byBhc3NlcnQgdGhpcy5jaGFuZ2VzIGlzIG5vdCBudWxsICAqL1xyXG4gICAgYXNzZXJ0Tm90QXBwbGllZCgpIHtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcclxuICogYG5ld0luZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUoKWAuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHNldEluZGV4TWFuYWdlcihpbmRleE1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgZW50cmllcyB0byB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIGNhbGxzIG9mIGBhZGRFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZG9jKSB7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRTdG9yZS5wdXQoZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGRvY3VtZW50IGZyb20gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcclxuICAgICAqIHJldHVybmVkIGJ5IGBuZXdDaGFuZ2VCdWZmZXIoKWAgdG8gZW5zdXJlIHByb3BlciBhY2NvdW50aW5nIG9mIG1ldGFkYXRhLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShkYlJlYWRUaW1lS2V5KGRvY3VtZW50S2V5LCByZWFkVGltZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNhY2hlIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQ2FsbGVycyB0byBgYWRkRW50cnkoKWAgYW5kIGByZW1vdmVFbnRyeSgpYCAqbXVzdCogY2FsbCB0aGlzIGFmdGVyd2FyZHMgdG8gdXBkYXRlIHRoZVxyXG4gICAgICogY2FjaGUncyBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlTWV0YWRhdGEodHJhbnNhY3Rpb24sIHNpemVEZWx0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgbWV0YWRhdGEuYnl0ZVNpemUgKz0gc2l6ZURlbHRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgbGV0IGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsXHJcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcclxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgZG9jID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgYW4gZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IGVudHJ5IGFuZCBpdHMgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBzaXplOiAwLFxyXG4gICAgICAgICAgICBkb2N1bWVudDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsXHJcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcclxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChkb2N1bWVudEtleSwgZGJSZW1vdGVEb2MpLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogZGJEb2N1bWVudFNpemUoZGJSZW1vdGVEb2MpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG9jID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGtleSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIHNldmVyYWwgZW50cmllcyBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5cyAtIFRoZSBzZXQgb2Yga2V5cyBlbnRyaWVzIHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBkb2N1bWVudHMgaW5kZXhlZCBieSBrZXkgYW5kIGEgbWFwIG9mIHNpemVzIGluZGV4ZWQgYnlcclxuICAgICAqICAgICBrZXkgKHplcm8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0KS5cclxuICAgICAqL1xyXG4gICAgZ2V0U2l6ZWRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIGxldCBzaXplTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoRGJFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCAoa2V5LCBkYlJlbW90ZURvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoa2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIHNpemVNYXAgPSBzaXplTWFwLmluc2VydChrZXksIGRiRG9jdW1lbnRTaXplKGRiUmVtb3RlRG9jKSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50czogcmVzdWx0cywgc2l6ZU1hcCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnRLZXlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNvcnRlZEtleXMgPSBuZXcgU29ydGVkU2V0KGRiS2V5Q29tcGFyYXRvcik7XHJcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZSA9PiAoc29ydGVkS2V5cyA9IHNvcnRlZEtleXMuYWRkKGUpKSk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChkYktleShzb3J0ZWRLZXlzLmZpcnN0KCkpLCBkYktleShzb3J0ZWRLZXlzLmxhc3QoKSkpO1xyXG4gICAgICAgIGNvbnN0IGtleUl0ZXIgPSBzb3J0ZWRLZXlzLmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgbGV0IG5leHRLZXkgPSBrZXlJdGVyLmdldE5leHQoKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LCByYW5nZSB9LCAoXywgZGJSZW1vdGVEb2MsIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsS2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKFtcclxuICAgICAgICAgICAgICAgIC4uLmRiUmVtb3RlRG9jLnByZWZpeFBhdGgsXHJcbiAgICAgICAgICAgICAgICBkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsXHJcbiAgICAgICAgICAgICAgICBkYlJlbW90ZURvYy5kb2N1bWVudElkXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGtleXMgbm90IGZvdW5kIGluIGNhY2hlLlxyXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSAmJiBkYktleUNvbXBhcmF0b3IobmV4dEtleSwgcG90ZW50aWFsS2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgbmV4dEtleSA9IGtleUl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0S2V5ICYmIG5leHRLZXkuaXNFcXVhbChwb3RlbnRpYWxLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBLZXkgZm91bmQgaW4gY2FjaGUuXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXh0S2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2tpcCB0byB0aGUgbmV4dCBrZXkgKGlmIHRoZXJlIGlzIG9uZSkuXHJcbiAgICAgICAgICAgIGlmIChuZXh0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnNraXAoZGJLZXkobmV4dEtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBrZXlzIGFyZSBub3QgaW4gdGhlIGNhY2hlLiBPbmUgY2FzZSB3aGVyZSBgaXRlcmF0ZWBcclxuICAgICAgICAgICAgLy8gYWJvdmUgd29uJ3QgZ28gdGhyb3VnaCB0aGVtIGlzIHdoZW4gdGhlIGNhY2hlIGlzIGVtcHR5LlxyXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV4dEtleSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIG11dGF0ZWREb2NzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHF1ZXJ5LnBhdGg7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBbXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgY29sbGVjdGlvbi5sYXN0U2VnbWVudCgpLFxyXG4gICAgICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXHJcbiAgICAgICAgICAgIG9mZnNldC5kb2N1bWVudEtleS5wYXRoLmlzRW1wdHkoKVxyXG4gICAgICAgICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgICAgICAgOiBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5sYXN0U2VnbWVudCgpXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBlbmRLZXkgPSBbXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgY29sbGVjdGlvbi5sYXN0U2VnbWVudCgpLFxyXG4gICAgICAgICAgICBbTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSxcclxuICAgICAgICAgICAgJydcclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmxvYWRBbGwoSURCS2V5UmFuZ2UuYm91bmQoc3RhcnRLZXksIGVuZEtleSwgdHJ1ZSkpXHJcbiAgICAgICAgICAgIC5uZXh0KGRiUmVtb3RlRG9jcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5pbmNyZW1lbnREb2N1bWVudFJlYWRDb3VudChkYlJlbW90ZURvY3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBkYlJlbW90ZURvYyBvZiBkYlJlbW90ZURvY3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhkYlJlbW90ZURvYy5wcmVmaXhQYXRoLmNvbmNhdChkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsIGRiUmVtb3RlRG9jLmRvY3VtZW50SWQpKSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpIHx8IG11dGF0ZWREb2NzLmhhcyhkb2N1bWVudC5rZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciB0aGUgZG9jdW1lbnQgbWF0Y2hlcyB0aGUgZ2l2ZW4gcXVlcnksIG9yIGl0IGlzIG11dGF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGxpbWl0KSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBjb25zdCBzdGFydEtleSA9IGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KTtcclxuICAgICAgICBjb25zdCBlbmRLZXkgPSBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIEluZGV4T2Zmc2V0Lm1heCgpKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCxcclxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLmJvdW5kKHN0YXJ0S2V5LCBlbmRLZXksIHRydWUpXHJcbiAgICAgICAgfSwgKF8sIGRiUmVtb3RlRG9jLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhkYlJlbW90ZURvYy5wcmVmaXhQYXRoLmNvbmNhdChkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsIGRiUmVtb3RlRG9jLmRvY3VtZW50SWQpKSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLnNpemUgPT09IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgbmV3Q2hhbmdlQnVmZmVyKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMsICEhb3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrUmVtb3ZhbHMpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSh0eG4pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEuYnl0ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWV0YWRhdGEodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKVxyXG4gICAgICAgICAgICAuZ2V0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXkpXHJcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgaGFyZEFzc2VydCghIW1ldGFkYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0TWV0YWRhdGEodHhuLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudEdsb2JhbFN0b3JlKHR4bikucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBgZGJSZW1vdGVEb2NgIGFuZCByZXR1cm5zIHRoZSBkb2N1bWVudCAob3IgYW4gaW52YWxpZCBkb2N1bWVudCBpZlxyXG4gICAgICogdGhlIGRvY3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBmb3JtYXQgdXNlZCBmb3Igc2VudGluZWwgZGVsZXRlcykuXHJcbiAgICAgKi9cclxuICAgIG1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKSB7XHJcbiAgICAgICAgaWYgKGRiUmVtb3RlRG9jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGZyb21EYlJlbW90ZURvY3VtZW50KHRoaXMuc2VyaWFsaXplciwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRoZSBkb2N1bWVudCBpcyBhIHNlbnRpbmVsIHJlbW92YWwgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcclxuICAgICAgICAgICAgY29uc3QgaXNTZW50aW5lbFJlbW92YWwgPSBkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgICAgICAgICBpZiAoIWlzU2VudGluZWxSZW1vdmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KTtcclxuICAgIH1cclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlLiAqL1xyXG5mdW5jdGlvbiBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHNlcmlhbGl6ZXIpIHtcclxuICAgIHJldHVybiBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZUltcGwoc2VyaWFsaXplcik7XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZXMgdGhlIGRldGFpbHMgb2YgYWRkaW5nIGFuZCB1cGRhdGluZyBkb2N1bWVudHMgaW4gdGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAqXHJcbiAqIFVubGlrZSB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIsIHRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gY29tcHV0ZXMgdGhlIHNpemVcclxuICogZGVsdGEgZm9yIGFsbCBzdWJtaXR0ZWQgY2hhbmdlcy4gVGhpcyBhdm9pZHMgaGF2aW5nIHRvIHJlLXJlYWQgYWxsIGRvY3VtZW50cyBmcm9tIEluZGV4ZWREYlxyXG4gKiB3aGVuIHdlIGFwcGx5IHRoZSBjaGFuZ2VzLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudENhY2hlIC0gVGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXHJcbiAgICAgKiBAcGFyYW0gdHJhY2tSZW1vdmFscyAtIFdoZXRoZXIgdG8gY3JlYXRlIHNlbnRpbmVsIGRlbGV0ZXMgdGhhdCBjYW4gYmUgdHJhY2tlZCBieVxyXG4gICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSwgdHJhY2tSZW1vdmFscykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlID0gZG9jdW1lbnRDYWNoZTtcclxuICAgICAgICB0aGlzLnRyYWNrUmVtb3ZhbHMgPSB0cmFja1JlbW92YWxzO1xyXG4gICAgICAgIC8vIEEgbWFwIG9mIGRvY3VtZW50IHNpemVzIGFuZCByZWFkIHRpbWVzIHByaW9yIHRvIGFwcGx5aW5nIHRoZSBjaGFuZ2VzIGluXHJcbiAgICAgICAgLy8gdGhpcyBidWZmZXIuXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgIH1cclxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgbGV0IHNpemVEZWx0YSA9IDA7XHJcbiAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnRDaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNEb2MgPSB0aGlzLmRvY3VtZW50U3RhdGVzLmdldChrZXkpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5yZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBwcmV2aW91c0RvYy5yZWFkVGltZSkpO1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRDaGFuZ2UuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQoa2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhICs9IHNpemUgLSBwcmV2aW91c0RvYy5zaXplO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRGVsdGEgLT0gcHJldmlvdXNEb2Muc2l6ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmVtb3ZhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byB0cmFjayByZW1vdmFscywgd2Ugc3RvcmUgYSBcInNlbnRpbmVsIGRlbGV0ZVwiIGluIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW90ZURvY3VtZW50Q2FjaGUuIFRoaXMgZW50cnkgaXMgcmVwcmVzZW50ZWQgYnkgYSBOb0RvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBhIHZlcnNpb24gb2YgMCBhbmQgaWdub3JlZCBieSBgbWF5YmVEZWNvZGVEb2N1bWVudCgpYCBidXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZWQgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVkRG9jID0gdG9EYlJlbW90ZURvY3VtZW50KHRoaXMuZG9jdW1lbnRDYWNoZS5zZXJpYWxpemVyLCBkb2N1bWVudENoYW5nZS5jb252ZXJ0VG9Ob0RvY3VtZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIGRlbGV0ZWREb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS51cGRhdGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgc2l6ZURlbHRhKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICAvLyBSZWNvcmQgdGhlIHNpemUgb2YgZXZlcnl0aGluZyB3ZSBsb2FkIGZyb20gdGhlIGNhY2hlIHNvIHdlIGNhbiBjb21wdXRlIGEgZGVsdGEgbGF0ZXIuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpXHJcbiAgICAgICAgICAgIC5uZXh0KGdldFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZXMuc2V0KGRvY3VtZW50S2V5LCB7XHJcbiAgICAgICAgICAgICAgICBzaXplOiBnZXRSZXN1bHQuc2l6ZSxcclxuICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBnZXRSZXN1bHQuZG9jdW1lbnQucmVhZFRpbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXN1bHQuZG9jdW1lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIC8vIFJlY29yZCB0aGUgc2l6ZSBvZiBldmVyeXRoaW5nIHdlIGxvYWQgZnJvbSB0aGUgY2FjaGUgc28gd2UgY2FuIGNvbXB1dGVcclxuICAgICAgICAvLyBhIGRlbHRhIGxhdGVyLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcclxuICAgICAgICAgICAgLmdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxyXG4gICAgICAgICAgICAubmV4dCgoeyBkb2N1bWVudHMsIHNpemVNYXAgfSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBgZ2V0QWxsRnJvbUNhY2hlYCByZXR1cm5zIHR3byBtYXBzIGluc3RlYWQgb2YgYSBzaW5nbGUgbWFwIGZyb21cclxuICAgICAgICAgICAgLy8ga2V5cyB0byBgRG9jdW1lbnRTaXplRW50cnlgcy4gVGhpcyBpcyB0byBhbGxvdyByZXR1cm5pbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIGBNdXRhYmxlRG9jdW1lbnRNYXBgIGRpcmVjdGx5LCB3aXRob3V0IGEgY29udmVyc2lvbi5cclxuICAgICAgICAgICAgc2l6ZU1hcC5mb3JFYWNoKChkb2N1bWVudEtleSwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcy5zZXQoZG9jdW1lbnRLZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBkb2N1bWVudHMuZ2V0KGRvY3VtZW50S2V5KS5yZWFkVGltZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHJlbW90ZURvY3VtZW50cyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdGVEb2N1bWVudHNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUmVtb3RlRG9jdW1lbnRTdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcclxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4YCBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGRiS2V5KGRvY3VtZW50S2V5KSB7XHJcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcclxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyB2aWEgdGhlIHByaW1hcnkga2V5IG9mXHJcbiAqIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGRiUmVhZFRpbWVLZXkoZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XHJcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcclxuICAgICAgICB0b0RiVGltZXN0YW1wS2V5KHJlYWRUaW1lKSxcclxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcclxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4YCBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBwYXRoID0gb2Zmc2V0LmRvY3VtZW50S2V5LnBhdGgudG9BcnJheSgpO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIGNvbGxlY3Rpb25Hcm91cCxcclxuICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXHJcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxyXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGgubGVuZ3RoID4gMCA/IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA6ICcnXHJcbiAgICBdO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJhdG9yIHRoYXQgY29tcGFyZXMgZG9jdW1lbnQga2V5cyBhY2NvcmRpbmcgdG8gdGhlIHByaW1hcnkga2V5IHNvcnRpbmdcclxuICogdXNlZCBieSB0aGUgYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudGAgc3RvcmUgKGJ5IHByZWZpeCBwYXRoLCBjb2xsZWN0aW9uIGlkXHJcbiAqIGFuZCB0aGVuIGRvY3VtZW50IElEKS5cclxuICpcclxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGRiS2V5Q29tcGFyYXRvcihsLCByKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gbC5wYXRoLnRvQXJyYXkoKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gci5wYXRoLnRvQXJyYXkoKTtcclxuICAgIC8vIFRoZSBvcmRlcmluZyBpcyBiYXNlZCBvbiBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vYmxpbmsvKy9mZTVjMjFmZWY5NGRhZTcxYzFjMzM0NDc3NWI4ZDhhN2Y3ZTZkOWVjL1NvdXJjZS9tb2R1bGVzL2luZGV4ZWRkYi9JREJLZXkuY3BwIzc0XHJcbiAgICBsZXQgY21wID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggLSAyICYmIGkgPCByaWdodC5sZW5ndGggLSAyOyArK2kpIHtcclxuICAgICAgICBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRbaV0sIHJpZ2h0W2ldKTtcclxuICAgICAgICBpZiAoY21wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcclxuICAgIGlmIChjbXApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2xlZnQubGVuZ3RoIC0gMl0sIHJpZ2h0W3JpZ2h0Lmxlbmd0aCAtIDJdKTtcclxuICAgIGlmIChjbXApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtsZWZ0Lmxlbmd0aCAtIDFdLCByaWdodFtyaWdodC5sZW5ndGggLSAxXSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFNjaGVtYSBWZXJzaW9uIGZvciB0aGUgV2ViIGNsaWVudDpcclxuICogMS4gIEluaXRpYWwgdmVyc2lvbiBpbmNsdWRpbmcgTXV0YXRpb24gUXVldWUsIFF1ZXJ5IENhY2hlLCBhbmQgUmVtb3RlXHJcbiAqICAgICBEb2N1bWVudCBDYWNoZVxyXG4gKiAyLiAgVXNlZCB0byBlbnN1cmUgYSB0YXJnZXRHbG9iYWwgb2JqZWN0IGV4aXN0cyBhbmQgYWRkIHRhcmdldENvdW50IHRvIGl0LiBOb1xyXG4gKiAgICAgbG9uZ2VyIHJlcXVpcmVkIGJlY2F1c2UgbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cclxuICogMy4gIERyb3BwZWQgYW5kIHJlLWNyZWF0ZWQgUXVlcnkgQ2FjaGUgdG8gZGVhbCB3aXRoIGNhY2hlIGNvcnJ1cHRpb24gcmVsYXRlZFxyXG4gKiAgICAgdG8gbGltYm8gcmVzb2x1dGlvbi4gQWRkcmVzc2VzXHJcbiAqICAgICBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtaW9zLXNkay9pc3N1ZXMvMTU0OFxyXG4gKiA0LiAgTXVsdGktVGFiIFN1cHBvcnQuXHJcbiAqIDUuICBSZW1vdmFsIG9mIGhlbGQgd3JpdGUgYWNrcy5cclxuICogNi4gIENyZWF0ZSBkb2N1bWVudCBnbG9iYWwgZm9yIHRyYWNraW5nIGRvY3VtZW50IGNhY2hlIHNpemUuXHJcbiAqIDcuICBFbnN1cmUgZXZlcnkgY2FjaGVkIGRvY3VtZW50IGhhcyBhIHNlbnRpbmVsIHJvdyB3aXRoIGEgc2VxdWVuY2UgbnVtYmVyLlxyXG4gKiA4LiAgQWRkIGNvbGxlY3Rpb24tcGFyZW50IGluZGV4IGZvciBDb2xsZWN0aW9uIEdyb3VwIHF1ZXJpZXMuXHJcbiAqIDkuICBDaGFuZ2UgUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIHN0b3JlIHRvIGJlIGtleWVkIGJ5IHJlYWRUaW1lIHJhdGhlciB0aGFuXHJcbiAqICAgICBhbiBhdXRvLWluY3JlbWVudGluZyBJRC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgSW5kZXgtRnJlZSBxdWVyaWVzLlxyXG4gKiAxMC4gUmV3cml0ZSB0aGUgY2Fub25pY2FsIElEcyB0byB0aGUgZXhwbGljaXQgUHJvdG9idWYtYmFzZWQgZm9ybWF0LlxyXG4gKiAxMS4gQWRkIGJ1bmRsZXMgYW5kIG5hbWVkX3F1ZXJpZXMgZm9yIGJ1bmRsZSBzdXBwb3J0LlxyXG4gKiAxMi4gQWRkIGRvY3VtZW50IG92ZXJsYXlzLlxyXG4gKiAxMy4gUmV3cml0ZSB0aGUga2V5cyBvZiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIHRvIGFsbG93IGZvciBlZmZpY2llbnRcclxuICogICAgIGRvY3VtZW50IGxvb2t1cCB2aWEgYGdldEFsbCgpYC5cclxuICogMTQuIEFkZCBvdmVybGF5cy5cclxuICogMTUuIEFkZCBpbmRleGluZyBzdXBwb3J0LlxyXG4gKiAxNi4gUGFyc2UgdGltZXN0YW1wIHN0cmluZ3MgYmVmb3JlIGNyZWF0aW5nIGluZGV4IGVudHJpZXMuXHJcbiAqL1xyXG5jb25zdCBTQ0hFTUFfVkVSU0lPTiA9IDE2O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGxvY2FsIHZpZXcgKG92ZXJsYXkpIG9mIGEgZG9jdW1lbnQsIGFuZCB0aGUgZmllbGRzIHRoYXQgYXJlXHJcbiAqIGxvY2FsbHkgbXV0YXRlZC5cclxuICovXHJcbmNsYXNzIE92ZXJsYXllZERvY3VtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKG92ZXJsYXllZERvY3VtZW50LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpZWxkcyB0aGF0IGFyZSBsb2NhbGx5IG11dGF0ZWQgYnkgcGF0Y2ggbXV0YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBvdmVybGF5ZWRcdGRvY3VtZW50IGlzIGZyb20gc2V0IG9yIGRlbGV0ZSBtdXRhdGlvbnMsIHRoaXMgaXMgYG51bGxgLlxyXG4gICAgICogSWYgdGhlcmUgaXMgbm8gb3ZlcmxheSAobXV0YXRpb24pIGZvciB0aGUgZG9jdW1lbnQsIHRoaXMgaXMgYW4gZW1wdHkgYEZpZWxkTWFza2AuXHJcbiAgICAgKi9cclxuICAgIG11dGF0ZWRGaWVsZHMpIHtcclxuICAgICAgICB0aGlzLm92ZXJsYXllZERvY3VtZW50ID0gb3ZlcmxheWVkRG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5tdXRhdGVkRmllbGRzID0gbXV0YXRlZEZpZWxkcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSByZWFkb25seSB2aWV3IG9mIHRoZSBsb2NhbCBzdGF0ZSBvZiBhbGwgZG9jdW1lbnRzIHdlJ3JlIHRyYWNraW5nIChpLmUuIHdlXHJcbiAqIGhhdmUgYSBjYWNoZWQgdmVyc2lvbiBpbiByZW1vdGVEb2N1bWVudENhY2hlIG9yIGxvY2FsIG11dGF0aW9ucyBmb3IgdGhlXHJcbiAqIGRvY3VtZW50KS4gVGhlIHZpZXcgaXMgY29tcHV0ZWQgYnkgYXBwbHlpbmcgdGhlIG11dGF0aW9ucyBpbiB0aGVcclxuICogTXV0YXRpb25RdWV1ZSB0byB0aGUgUmVtb3RlRG9jdW1lbnRDYWNoZS5cclxuICovXHJcbmNsYXNzIExvY2FsRG9jdW1lbnRzVmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVEb2N1bWVudENhY2hlLCBtdXRhdGlvblF1ZXVlLCBkb2N1bWVudE92ZXJsYXlDYWNoZSwgaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlID0gcmVtb3RlRG9jdW1lbnRDYWNoZTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSBtdXRhdGlvblF1ZXVlO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUgPSBkb2N1bWVudE92ZXJsYXlDYWNoZTtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudCBpZGVudGlmaWVkIGJ5IGBrZXlgLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIExvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50IG9yIG51bGwgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkXHJcbiAgICAgKiBzdGF0ZSBmb3IgaXQuXHJcbiAgICAgKi9cclxuICAgIGdldERvY3VtZW50KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcclxuICAgICAgICAgICAgLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSlcclxuICAgICAgICAgICAgLm5leHQodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBvdmVybGF5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGtleSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoZG9jdW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG92ZXJsYXkubXV0YXRpb24sIGRvY3VtZW50LCBGaWVsZE1hc2suZW1wdHkoKSwgVGltZXN0YW1wLm5vdygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBpZGVudGlmaWVkIGJ5IGBrZXlzYC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzdGF0ZSBmb3IgYSBkb2N1bWVudCBpbiBga2V5c2AsIGEgTm9Eb2N1bWVudCB3aWxsXHJcbiAgICAgKiBiZSBzdG9yZWQgZm9yIHRoYXQga2V5IGluIHRoZSByZXN1bHRpbmcgc2V0LlxyXG4gICAgICovXHJcbiAgICBnZXREb2N1bWVudHModHJhbnNhY3Rpb24sIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXHJcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXlzKVxyXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHJhbnNhY3Rpb24sIGRvY3MsIGRvY3VtZW50S2V5U2V0KCkpLm5leHQoKCkgPT4gZG9jcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1pbGFyIHRvIGBnZXREb2N1bWVudHNgLCBidXQgY3JlYXRlcyB0aGUgbG9jYWwgdmlldyBmcm9tIHRoZSBnaXZlblxyXG4gICAgICogYGJhc2VEb2NzYCB3aXRob3V0IHJldHJpZXZpbmcgZG9jdW1lbnRzIGZyb20gdGhlIGxvY2FsIHN0b3JlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0aGlzIG9wZXJhdGlvbiBpcyBzY29wZWQgdG8uXHJcbiAgICAgKiBAcGFyYW0gZG9jcyAtIFRoZSBkb2N1bWVudHMgdG8gYXBwbHkgbG9jYWwgbXV0YXRpb25zIHRvIGdldCB0aGUgbG9jYWwgdmlld3MuXHJcbiAgICAgKiBAcGFyYW0gZXhpc3RlbmNlU3RhdGVDaGFuZ2VkIC0gVGhlIHNldCBvZiBkb2N1bWVudCBrZXlzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZVxyXG4gICAgICogICBpcyBjaGFuZ2VkLiBUaGlzIGlzIHVzZWZ1bCB0byBkZXRlcm1pbmUgaWYgc29tZSBkb2N1bWVudHMgb3ZlcmxheSBuZWVkc1xyXG4gICAgICogICB0byBiZSByZWNhbGN1bGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldExvY2FsVmlld09mRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgPSBkb2N1bWVudEtleVNldCgpKSB7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIGRvY3MpLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpLm5leHQoY29tcHV0ZVZpZXdzUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVZpZXdzUmVzdWx0LmZvckVhY2goKGRvY3VtZW50S2V5LCBvdmVybGF5ZWREb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnRLZXksIG92ZXJsYXllZERvY3VtZW50Lm92ZXJsYXllZERvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG92ZXJsYXllZCBkb2N1bWVudHMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBtYXAsIHdoaWNoIHdpbGwgaW5jbHVkZVxyXG4gICAgICogdGhlIGxvY2FsIHZpZXcgb2YgdGhvc2UgZG9jdW1lbnRzIGFuZCBhIGBGaWVsZE1hc2tgIGluZGljYXRpbmcgd2hpY2ggZmllbGRzXHJcbiAgICAgKiBhcmUgbXV0YXRlZCBsb2NhbGx5LCBgbnVsbGAgaWYgb3ZlcmxheSBpcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldE92ZXJsYXllZERvY3VtZW50cyh0cmFuc2FjdGlvbiwgZG9jcykge1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3T3ZlcmxheU1hcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBkb2NzKS5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBkb2NzLCBvdmVybGF5cywgZG9jdW1lbnRLZXlTZXQoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIHRoZSBvdmVybGF5cyBmb3Ige0Bjb2RlIGRvY3N9IGFuZCBhZGRzIHRoZW0gdG8gcHJvdmlkZWQgb3ZlcmxheSBtYXBcclxuICAgICAqIGlmIHRoZSBtYXAgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFuIGVudHJ5IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5LlxyXG4gICAgICovXHJcbiAgICBwb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykge1xyXG4gICAgICAgIGNvbnN0IG1pc3NpbmdPdmVybGF5cyA9IFtdO1xyXG4gICAgICAgIGRvY3MuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXlzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNzaW5nT3ZlcmxheXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcclxuICAgICAgICAgICAgLmdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBtaXNzaW5nT3ZlcmxheXMpXHJcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKChrZXksIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgdmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2NzIC0gVGhlIGRvY3VtZW50cyB0byBjb21wdXRlIHZpZXdzIGZvci4gSXQgYWxzbyBoYXMgdGhlIGJhc2VcclxuICAgICAqICAgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRzLlxyXG4gICAgICogQHBhcmFtIG92ZXJsYXlzIC0gVGhlIG92ZXJsYXlzIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBnaXZlbiBiYXNlXHJcbiAgICAgKiAgIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50cy5cclxuICAgICAqIEBwYXJhbSBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgLSBBIHNldCBvZiBkb2N1bWVudHMgd2hvc2UgZXhpc3RlbmNlIHN0YXRlc1xyXG4gICAgICogICBtaWdodCBoYXZlIGNoYW5nZWQuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byByZS1jYWxjdWxhdGVcclxuICAgICAqICAgb3ZlcmxheXMgZnJvbSBtdXRhdGlvbiBxdWV1ZXMuXHJcbiAgICAgKiBAcmV0dXJuIEEgbWFwIHJlcHJlc2VudHMgdGhlIGxvY2FsIGRvY3VtZW50cyB2aWV3LlxyXG4gICAgICovXHJcbiAgICBjb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICBsZXQgcmVjYWxjdWxhdGVEb2N1bWVudHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBjb25zdCBtdXRhdGVkRmllbGRzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3T3ZlcmxheWVkRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBkb2NzLmZvckVhY2goKF8sIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheXMuZ2V0KGRvYy5rZXkpO1xyXG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBhbiBvdmVybGF5IGlmIHRoZSBkb2N1bWVudCdzIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2VkIGR1ZSB0b1xyXG4gICAgICAgICAgICAvLyBhIHJlbW90ZSBldmVudCAqYW5kKiB0aGUgb3ZlcmxheSBpcyBhIFBhdGNoTXV0YXRpb24uIFRoaXMgaXMgYmVjYXVzZVxyXG4gICAgICAgICAgICAvLyBkb2N1bWVudCBleGlzdGVuY2Ugc3RhdGUgY2FuIGNoYW5nZSBpZiBzb21lIHBhdGNoIG11dGF0aW9uJ3NcclxuICAgICAgICAgICAgLy8gcHJlY29uZGl0aW9ucyBhcmUgbWV0LlxyXG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSByZWNhbGN1bGF0ZSB3aGVuIGBvdmVybGF5YCBpcyB1bmRlZmluZWQgYXMgd2VsbCwgYmVjYXVzZSB0aGVyZVxyXG4gICAgICAgICAgICAvLyBtaWdodCBiZSBhIHBhdGNoIG11dGF0aW9uIHdob3NlIHByZWNvbmRpdGlvbiBkb2VzIG5vdCBtYXRjaCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgIC8vIGNoYW5nZSAoaGVuY2Ugb3ZlcmxheSBpcyB1bmRlZmluZWQpLCBidXQgd291bGQgbm93IG1hdGNoLlxyXG4gICAgICAgICAgICBpZiAoZXhpc3RlbmNlU3RhdGVDaGFuZ2VkLmhhcyhkb2Mua2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgKG92ZXJsYXkgPT09IHVuZGVmaW5lZCB8fCBvdmVybGF5Lm11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlRG9jdW1lbnRzID0gcmVjYWxjdWxhdGVEb2N1bWVudHMuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzLnNldChkb2Mua2V5LCBvdmVybGF5Lm11dGF0aW9uLmdldEZpZWxkTWFzaygpKTtcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhvdmVybGF5Lm11dGF0aW9uLCBkb2MsIG92ZXJsYXkubXV0YXRpb24uZ2V0RmllbGRNYXNrKCksIFRpbWVzdGFtcC5ub3coKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBvdmVybGF5IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgRU1QVFkgdG8gaW5kaWNhdGUgdGhlcmUgaXMgbm8gb3ZlcmxheSBmb3IgdGhlIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcy5zZXQoZG9jLmtleSwgRmllbGRNYXNrLmVtcHR5KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIHJlY2FsY3VsYXRlRG9jdW1lbnRzKS5uZXh0KHJlY2FsY3VsYXRlZEZpZWxkcyA9PiB7XHJcbiAgICAgICAgICAgIHJlY2FsY3VsYXRlZEZpZWxkcy5mb3JFYWNoKChkb2N1bWVudEtleSwgbWFzaykgPT4gbXV0YXRlZEZpZWxkcy5zZXQoZG9jdW1lbnRLZXksIG1hc2spKTtcclxuICAgICAgICAgICAgZG9jcy5mb3JFYWNoKChkb2N1bWVudEtleSwgZG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzLnNldChkb2N1bWVudEtleSwgbmV3IE92ZXJsYXllZERvY3VtZW50KGRvY3VtZW50LCAoX2EgPSBtdXRhdGVkRmllbGRzLmdldChkb2N1bWVudEtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGRvY3MpIHtcclxuICAgICAgICBjb25zdCBtYXNrcyA9IG5ld0RvY3VtZW50S2V5TWFwKCk7XHJcbiAgICAgICAgLy8gQSByZXZlcnNlIGxvb2t1cCBtYXAgZnJvbSBiYXRjaCBpZCB0byB0aGUgZG9jdW1lbnRzIHdpdGhpbiB0aGF0IGJhdGNoLlxyXG4gICAgICAgIGxldCBkb2N1bWVudHNCeUJhdGNoSWQgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XHJcbiAgICAgICAgbGV0IHByb2Nlc3NlZCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25RdWV1ZVxyXG4gICAgICAgICAgICAuZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXlzKHRyYW5zYWN0aW9uLCBkb2NzKVxyXG4gICAgICAgICAgICAubmV4dChiYXRjaGVzID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5rZXlzKCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VEb2MgPSBkb2NzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlRG9jID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2sgPSBtYXNrcy5nZXQoa2V5KSB8fCBGaWVsZE1hc2suZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXNrID0gYmF0Y2guYXBwbHlUb0xvY2FsVmlldyhiYXNlRG9jLCBtYXNrKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXNrcy5zZXQoa2V5LCBtYXNrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAoZG9jdW1lbnRzQnlCYXRjaElkLmdldChiYXRjaC5iYXRjaElkKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudHNCeUJhdGNoSWQgPSBkb2N1bWVudHNCeUJhdGNoSWQuaW5zZXJ0KGJhdGNoLmJhdGNoSWQsIG5ld1NldCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIGJhdGNoIElEcywgYW5kIHNraXAgZG9jdW1lbnRzIHRoYXQgYXJlXHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgc2F2ZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBkb2N1bWVudHNCeUJhdGNoSWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoSWQgPSBlbnRyeS5rZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gZW50cnkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5cyA9IG5ld011dGF0aW9uTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5TXV0YXRpb24gPSBjYWxjdWxhdGVPdmVybGF5TXV0YXRpb24oZG9jcy5nZXQoa2V5KSwgbWFza3MuZ2V0KGtleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheU11dGF0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5cy5zZXQoa2V5LCBvdmVybGF5TXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGJhdGNoSWQsIG92ZXJsYXlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBtYXNrcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyBvdmVybGF5cyBieSByZWFkaW5nIHRoZSBkb2N1bWVudHMgZnJvbSByZW1vdGUgZG9jdW1lbnQgY2FjaGVcclxuICAgICAqIGZpcnN0LCBhbmQgc2F2ZXMgdGhlbSBhZnRlciB0aGV5IGFyZSBjYWxjdWxhdGVkLlxyXG4gICAgICovXHJcbiAgICByZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxyXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGRvY3MpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCB2aWV3IG9mIGFsbCBkb2N1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIG1hdGNoIGRvY3VtZW50cyBhZ2FpbnN0LlxyXG4gICAgICogQHBhcmFtIG9mZnNldCAtIFJlYWQgdGltZSBhbmQga2V5IHRvIHN0YXJ0IHNjYW5uaW5nIGJ5IChleGNsdXNpdmUpLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBIG9wdGlvbmFsIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlsc1xyXG4gICAgICogICBkdXJpbmcgZGF0YWJhc2UgbG9jYWwgcXVlcnkgZXhlY3V0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRRdWVyeSQxKHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0RvY3VtZW50UXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29sbGVjdGlvbiBncm91cCwgcmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudHMgdGhhdCBmb2xsb3cgdGhlIHByb3ZpZGVkIG9mZnNldCwgYWxvbmdcclxuICAgICAqIHdpdGggYW4gdXBkYXRlZCBiYXRjaCBJRC5cclxuICAgICAqXHJcbiAgICAgKiA8cD5UaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFyZSBvcmRlcmVkIGJ5IHJlbW90ZSB2ZXJzaW9uIGZyb20gdGhlIHByb3ZpZGVkXHJcbiAgICAgKiBvZmZzZXQuIElmIHRoZXJlIGFyZSBubyBtb3JlIHJlbW90ZSBkb2N1bWVudHMgYWZ0ZXIgdGhlIHByb3ZpZGVkIG9mZnNldCwgZG9jdW1lbnRzIHdpdGhcclxuICAgICAqIG11dGF0aW9ucyBpbiBvcmRlciBvZiBiYXRjaCBpZCBmcm9tIHRoZSBvZmZzZXQgYXJlIHJldHVybmVkLiBTaW5jZSBhbGwgZG9jdW1lbnRzIGluIGEgYmF0Y2ggYXJlXHJcbiAgICAgKiByZXR1cm5lZCB0b2dldGhlciwgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgY2FuIGV4Y2VlZCB7QGNvZGUgY291bnR9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvblxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25Hcm91cCBUaGUgY29sbGVjdGlvbiBncm91cCBmb3IgdGhlIGRvY3VtZW50cy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBpbmRleCBpbnRvLlxyXG4gICAgICogQHBhcmFtIGNvdW50IFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRvIHJldHVyblxyXG4gICAgICogQHJldHVybiBBIExvY2FsV3JpdGVSZXN1bHQgd2l0aCB0aGUgZG9jdW1lbnRzIHRoYXQgZm9sbG93IHRoZSBwcm92aWRlZCBvZmZzZXQgYW5kIHRoZSBsYXN0IHByb2Nlc3NlZCBiYXRjaCBpZC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV4dERvY3VtZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGNvdW50KVxyXG4gICAgICAgICAgICAubmV4dCgob3JpZ2luYWxEb2NzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzUHJvbWlzZSA9IGNvdW50IC0gb3JpZ2luYWxEb2NzLnNpemUgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUuZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0Lmxhcmdlc3RCYXRjaElkLCBjb3VudCAtIG9yaWdpbmFsRG9jcy5zaXplKVxyXG4gICAgICAgICAgICAgICAgOiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShuZXdPdmVybGF5TWFwKCkpO1xyXG4gICAgICAgICAgICAvLyBUaGUgY2FsbHNpdGUgd2lsbCB1c2UgdGhlIGxhcmdlc3QgYmF0Y2ggSUQgdG9nZXRoZXIgd2l0aCB0aGUgbGF0ZXN0IHJlYWQgdGltZSB0byBjcmVhdGVcclxuICAgICAgICAgICAgLy8gYSBuZXcgaW5kZXggb2Zmc2V0LiBTaW5jZSB3ZSBvbmx5IHByb2Nlc3MgYmF0Y2ggSURzIGlmIGFsbCByZW1vdGUgZG9jdW1lbnRzIGhhdmUgYmVlbiByZWFkLFxyXG4gICAgICAgICAgICAvLyBubyBvdmVybGF5IHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGwgcmVhZCB0aW1lLiBUaGlzIGlzIHdoeSB3ZSBvbmx5IG5lZWQgdG8gc3BlY2lhbCBjYXNlXHJcbiAgICAgICAgICAgIC8vIHRoZSBiYXRjaCBpZC5cclxuICAgICAgICAgICAgbGV0IGxhcmdlc3RCYXRjaElkID0gSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWREb2NzID0gb3JpZ2luYWxEb2NzO1xyXG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxheXNQcm9taXNlLm5leHQob3ZlcmxheXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKG92ZXJsYXlzLCAoa2V5LCBvdmVybGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhcmdlc3RCYXRjaElkIDwgb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0QmF0Y2hJZCA9IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbERvY3MuZ2V0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jcyA9IG1vZGlmaWVkRG9jcy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBvcmlnaW5hbERvY3MpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBtb2RpZmllZERvY3MsIG92ZXJsYXlzLCBkb2N1bWVudEtleVNldCgpKSlcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChsb2NhbERvY3MgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaElkOiBsYXJnZXN0QmF0Y2hJZCxcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBjb252ZXJ0T3ZlcmxheWVkRG9jdW1lbnRNYXBUb0RvY3VtZW50TWFwKGxvY2FsRG9jcylcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0RvY3VtZW50UXVlcnkodHJhbnNhY3Rpb24sIGRvY1BhdGgpIHtcclxuICAgICAgICAvLyBKdXN0IGRvIGEgc2ltcGxlIGRvY3VtZW50IGxvb2t1cC5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudCh0cmFuc2FjdGlvbiwgbmV3IERvY3VtZW50S2V5KGRvY1BhdGgpKS5uZXh0KGRvY3VtZW50ID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uR3JvdXBRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IGRvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXHJcbiAgICAgICAgICAgIC5nZXRDb2xsZWN0aW9uUGFyZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbklkKVxyXG4gICAgICAgICAgICAubmV4dChwYXJlbnRzID0+IHtcclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGNvbGxlY3Rpb24gcXVlcnkgYWdhaW5zdCBlYWNoIHBhcmVudCB0aGF0IGNvbnRhaW5zIHRoZVxyXG4gICAgICAgICAgICAvLyBjb2xsZWN0aW9uSWQgYW5kIGFnZ3JlZ2F0ZSB0aGUgcmVzdWx0cy5cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHBhcmVudHMsIChwYXJlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25RdWVyeSA9IGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXJlbnQuY2hpbGQoY29sbGVjdGlvbklkKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpLm5leHQociA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgci5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xyXG4gICAgICAgIC8vIFF1ZXJ5IHRoZSByZW1vdGUgZG9jdW1lbnRzIGFuZCBvdmVybGF5IG11dGF0aW9ucy5cclxuICAgICAgICBsZXQgb3ZlcmxheXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcclxuICAgICAgICAgICAgLmdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbih0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCwgb2Zmc2V0Lmxhcmdlc3RCYXRjaElkKVxyXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBvdmVybGF5cyA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZS5nZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBvdmVybGF5cywgY29udGV4dCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQocmVtb3RlRG9jdW1lbnRzID0+IHtcclxuICAgICAgICAgICAgLy8gQXMgZG9jdW1lbnRzIG1pZ2h0IG1hdGNoIHRoZSBxdWVyeSBiZWNhdXNlIG9mIHRoZWlyIG92ZXJsYXkgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGRvY3VtZW50cyBmb3IgYWxsIG92ZXJsYXlzIGluIHRoZSBpbml0aWFsIGRvY3VtZW50IHNldC5cclxuICAgICAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgb3ZlcmxheSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVEb2N1bWVudHMuZ2V0KGtleSkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVEb2N1bWVudHMgPSByZW1vdGVEb2N1bWVudHMuaW5zZXJ0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvdmVybGF5cyBhbmQgbWF0Y2ggYWdhaW5zdCB0aGUgcXVlcnkuXHJcbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gZG9jdW1lbnRNYXAoKTtcclxuICAgICAgICAgICAgcmVtb3RlRG9jdW1lbnRzLmZvckVhY2goKGtleSwgZG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvdmVybGF5cy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcob3ZlcmxheS5tdXRhdGlvbiwgZG9jdW1lbnQsIEZpZWxkTWFzay5lbXB0eSgpLCBUaW1lc3RhbXAubm93KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgaW5zZXJ0IHRoZSBkb2N1bWVudHMgdGhhdCBzdGlsbCBtYXRjaCB0aGUgcXVlcnlcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeU1hdGNoZXMocXVlcnksIGRvY3VtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE1lbW9yeUJ1bmRsZUNhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm5hbWVkUXVlcmllcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmJ1bmRsZXMuZ2V0KGJ1bmRsZUlkKSk7XHJcbiAgICB9XHJcbiAgICBzYXZlQnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5idW5kbGVzLnNldChidW5kbGVNZXRhZGF0YS5pZCwgZnJvbUJ1bmRsZU1ldGFkYXRhKGJ1bmRsZU1ldGFkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5uYW1lZFF1ZXJpZXMuZ2V0KHF1ZXJ5TmFtZSkpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMuc2V0KHF1ZXJ5Lm5hbWUsIGZyb21Qcm90b05hbWVkUXVlcnkocXVlcnkpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIERvY3VtZW50T3ZlcmxheUNhY2hlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5RG9jdW1lbnRPdmVybGF5Q2FjaGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gQSBtYXAgc29ydGVkIGJ5IERvY3VtZW50S2V5LCB3aG9zZSB2YWx1ZSBpcyBhIHBhaXIgb2YgdGhlIGxhcmdlc3QgYmF0Y2ggaWRcclxuICAgICAgICAvLyBmb3IgdGhlIG92ZXJsYXkgYW5kIHRoZSBvdmVybGF5IGl0c2VsZi5cclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5vdmVybGF5cy5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwga2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpLm5leHQob3ZlcmxheSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcclxuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChfLCBtdXRhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChiYXRjaElkKTtcclxuICAgICAgICBpZiAoa2V5cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gKHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLnJlbW92ZShrZXkpKSk7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5kZWxldGUoYmF0Y2hJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGggKyAxO1xyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uLmNoaWxkKCcnKSk7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XHJcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcclxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEb2N1bWVudHMgZnJvbSBzdWItY29sbGVjdGlvbnNcclxuICAgICAgICAgICAgaWYgKGtleS5wYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZCwgY291bnQpIHtcclxuICAgICAgICBsZXQgYmF0Y2hJZFRvT3ZlcmxheXMgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGVudHJ5LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmdldENvbGxlY3Rpb25Hcm91cCgpICE9PSBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVybGF5Lmxhcmdlc3RCYXRjaElkID4gc2luY2VCYXRjaElkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxheXNGb3JCYXRjaElkID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0KG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlzRm9yQmF0Y2hJZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlzRm9yQmF0Y2hJZCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaElkVG9PdmVybGF5cyA9IGJhdGNoSWRUb092ZXJsYXlzLmluc2VydChvdmVybGF5Lmxhcmdlc3RCYXRjaElkLCBvdmVybGF5c0ZvckJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheXNGb3JCYXRjaElkLnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hJdGVyID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoYmF0Y2hJdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGJhdGNoSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gZW50cnkudmFsdWU7XHJcbiAgICAgICAgICAgIG92ZXJsYXlzLmZvckVhY2goKGtleSwgb3ZlcmxheSkgPT4gcmVzdWx0LnNldChrZXksIG92ZXJsYXkpKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaXplKCkgPj0gY291bnQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbikge1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXNzb2NpYXRpb24gb2YgdGhlIG92ZXJsYXkgdG8gaXRzIGJhdGNoIGlkLlxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5vdmVybGF5cy5nZXQobXV0YXRpb24ua2V5KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2V0ID0gdGhpcy5vdmVybGF5QnlCYXRjaElkXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkKVxyXG4gICAgICAgICAgICAgICAgLmRlbGV0ZShtdXRhdGlvbi5rZXkpO1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkLCBuZXdTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5pbnNlcnQobXV0YXRpb24ua2V5LCBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pKTtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGFzc29jaWF0aW9uIG9mIHRoaXMgb3ZlcmxheSB0byB0aGUgZ2l2ZW4gbGFyZ2VzdEJhdGNoSWQuXHJcbiAgICAgICAgbGV0IGJhdGNoID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChsYXJnZXN0QmF0Y2hJZCk7XHJcbiAgICAgICAgaWYgKGJhdGNoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmF0Y2ggPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGxhcmdlc3RCYXRjaElkLCBiYXRjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQobGFyZ2VzdEJhdGNoSWQsIGJhdGNoLmFkZChtdXRhdGlvbi5rZXkpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBmcm9tIHNvbWUga2luZCBvZiBudW1iZXJlZCBlbnRpdHlcclxuICogKGVpdGhlciBhIHRhcmdldCBJRCBvciBiYXRjaCBJRCkuIEFzIHJlZmVyZW5jZXMgYXJlIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbVxyXG4gKiB0aGUgc2V0IGNvcnJlc3BvbmRpbmcgZXZlbnRzIGFyZSBlbWl0dGVkIHRvIGEgcmVnaXN0ZXJlZCBnYXJiYWdlIGNvbGxlY3Rvci5cclxuICpcclxuICogRWFjaCByZWZlcmVuY2UgaXMgcmVwcmVzZW50ZWQgYnkgYSBEb2N1bWVudFJlZmVyZW5jZSBvYmplY3QuIEVhY2ggb2YgdGhlbVxyXG4gKiBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHJlZmVyZW5jZS4gVGhleSBhcmUgYWxsXHJcbiAqIHN0b3JlZCBwcmltYXJpbHkgaW4gYSBzZXQgc29ydGVkIGJ5IGtleS4gQSBkb2N1bWVudCBpcyBjb25zaWRlcmVkIGdhcmJhZ2UgaWZcclxuICogdGhlcmUncyBubyByZWZlcmVuY2VzIGluIHRoYXQgc2V0ICh0aGlzIGNhbiBiZSBlZmZpY2llbnRseSBjaGVja2VkIHRoYW5rcyB0b1xyXG4gKiBzb3J0aW5nIGJ5IGtleSkuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZVNldCBhbHNvIGtlZXBzIGEgc2Vjb25kYXJ5IHNldCB0aGF0IGNvbnRhaW5zIHJlZmVyZW5jZXMgc29ydGVkIGJ5XHJcbiAqIElEcy4gVGhpcyBvbmUgaXMgdXNlZCB0byBlZmZpY2llbnRseSBpbXBsZW1lbnQgcmVtb3ZhbCBvZiBhbGwgcmVmZXJlbmNlcyBieVxyXG4gKiBzb21lIHRhcmdldCBJRC5cclxuICovXHJcbmNsYXNzIFJlZmVyZW5jZVNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBBIHNldCBvZiBvdXRzdGFuZGluZyByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgc29ydGVkIGJ5IGtleS5cclxuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeUtleSk7XHJcbiAgICAgICAgLy8gQSBzZXQgb2Ygb3V0c3RhbmRpbmcgcmVmZXJlbmNlcyB0byBhIGRvY3VtZW50IHNvcnRlZCBieSB0YXJnZXQgaWQuXHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlUYXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2Ugc2V0IGNvbnRhaW5zIG5vIHJlZmVyZW5jZXMuICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNCeUtleS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQWRkcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5IGZvciB0aGUgZ2l2ZW4gSUQuICovXHJcbiAgICBhZGRSZWZlcmVuY2Uoa2V5LCBpZCkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCBpZCk7XHJcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSB0aGlzLnJlZnNCeUtleS5hZGQocmVmKTtcclxuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IHRoaXMucmVmc0J5VGFyZ2V0LmFkZChyZWYpO1xyXG4gICAgfVxyXG4gICAgLyoqIEFkZCByZWZlcmVuY2VzIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXlzIGZvciB0aGUgZ2l2ZW4gSUQuICovXHJcbiAgICBhZGRSZWZlcmVuY2VzKGtleXMsIGlkKSB7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLmFkZFJlZmVyZW5jZShrZXksIGlkKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleSBmb3IgdGhlIGdpdmVuXHJcbiAgICAgKiBJRC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGtleSwgaWQpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVJlZihuZXcgRG9jUmVmZXJlbmNlKGtleSwgaWQpKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVJlZmVyZW5jZXMoa2V5cywgaWQpIHtcclxuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMucmVtb3ZlUmVmZXJlbmNlKGtleSwgaWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCByZWZlcmVuY2VzIHdpdGggYSBnaXZlbiBJRC4gQ2FsbHMgcmVtb3ZlUmVmKCkgZm9yIGVhY2gga2V5XHJcbiAgICAgKiByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVSZWZlcmVuY2VzRm9ySWQoaWQpIHtcclxuICAgICAgICBjb25zdCBlbXB0eUtleSA9IG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKFtdKSk7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCk7XHJcbiAgICAgICAgY29uc3QgZW5kUmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQgKyAxKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0UmVmLCBlbmRSZWZdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJlZihyZWYpO1xyXG4gICAgICAgICAgICBrZXlzLnB1c2gocmVmLmtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcbiAgICByZW1vdmVBbGxSZWZlcmVuY2VzKCkge1xyXG4gICAgICAgIHRoaXMucmVmc0J5S2V5LmZvckVhY2gocmVmID0+IHRoaXMucmVtb3ZlUmVmKHJlZikpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmKHJlZikge1xyXG4gICAgICAgIHRoaXMucmVmc0J5S2V5ID0gdGhpcy5yZWZzQnlLZXkuZGVsZXRlKHJlZik7XHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSB0aGlzLnJlZnNCeVRhcmdldC5kZWxldGUocmVmKTtcclxuICAgIH1cclxuICAgIHJlZmVyZW5jZXNGb3JJZChpZCkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5S2V5ID0gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoW10pKTtcclxuICAgICAgICBjb25zdCBzdGFydFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkKTtcclxuICAgICAgICBjb25zdCBlbmRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCArIDEpO1xyXG4gICAgICAgIGxldCBrZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldC5mb3JFYWNoSW5SYW5nZShbc3RhcnRSZWYsIGVuZFJlZl0sIHJlZiA9PiB7XHJcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmFkZChyZWYua2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIGNvbnRhaW5zS2V5KGtleSkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCAwKTtcclxuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMucmVmc0J5S2V5LmZpcnN0QWZ0ZXJPckVxdWFsKHJlZik7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0UmVmICE9PSBudWxsICYmIGtleS5pc0VxdWFsKGZpcnN0UmVmLmtleSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRG9jUmVmZXJlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdGFyZ2V0T3JCYXRjaElkKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRPckJhdGNoSWQgPSB0YXJnZXRPckJhdGNoSWQ7XHJcbiAgICB9XHJcbiAgICAvKiogQ29tcGFyZSBieSBrZXkgdGhlbiBieSBJRCAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmVCeUtleShsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmtleSwgcmlnaHQua2V5KSB8fFxyXG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQudGFyZ2V0T3JCYXRjaElkLCByaWdodC50YXJnZXRPckJhdGNoSWQpKTtcclxuICAgIH1cclxuICAgIC8qKiBDb21wYXJlIGJ5IElEIHRoZW4gYnkga2V5ICovXHJcbiAgICBzdGF0aWMgY29tcGFyZUJ5VGFyZ2V0SWQobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC50YXJnZXRPckJhdGNoSWQsIHJpZ2h0LnRhcmdldE9yQmF0Y2hJZCkgfHxcclxuICAgICAgICAgICAgRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmtleSwgcmlnaHQua2V5KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5TXV0YXRpb25RdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzZXQgb2YgYWxsIG11dGF0aW9ucyB0aGF0IGhhdmUgYmVlbiBzZW50IGJ1dCBub3QgeWV0IGJlZW4gYXBwbGllZCB0b1xyXG4gICAgICAgICAqIHRoZSBiYWNrZW5kLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IFtdO1xyXG4gICAgICAgIC8qKiBOZXh0IHZhbHVlIHRvIHVzZSB3aGVuIGFzc2lnbmluZyBzZXF1ZW50aWFsIElEcyB0byBlYWNoIG11dGF0aW9uIGJhdGNoLiAqL1xyXG4gICAgICAgIHRoaXMubmV4dEJhdGNoSWQgPSAxO1xyXG4gICAgICAgIC8qKiBBbiBvcmRlcmVkIG1hcHBpbmcgYmV0d2VlbiBkb2N1bWVudHMgYW5kIHRoZSBtdXRhdGlvbnMgYmF0Y2ggSURzLiAqL1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlLZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwKTtcclxuICAgIH1cclxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBiYXRjaElkID0gdGhpcy5uZXh0QmF0Y2hJZDtcclxuICAgICAgICB0aGlzLm5leHRCYXRjaElkKys7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZVt0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE11dGF0aW9uQmF0Y2goYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgIC8vIFRyYWNrIHJlZmVyZW5jZXMgYnkgZG9jdW1lbnQga2V5IGFuZCBpbmRleCBjb2xsZWN0aW9uIHBhcmVudHMuXHJcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleSA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuYWRkKG5ldyBEb2NSZWZlcmVuY2UobXV0YXRpb24ua2V5LCBiYXRjaElkKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBtdXRhdGlvbi5rZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoYmF0Y2gpO1xyXG4gICAgfVxyXG4gICAgbG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpKTtcclxuICAgIH1cclxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dEJhdGNoSWQgPSBiYXRjaElkICsgMTtcclxuICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIGJhdGNoSWQgbWF5IHN0aWxsIGJlIG91dCBvZiByYW5nZSBzbyBub3JtYWxpemUgaXQgdG8gdGhlXHJcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIHF1ZXVlLlxyXG4gICAgICAgIGNvbnN0IHJhd0luZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChuZXh0QmF0Y2hJZCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSByYXdJbmRleCA8IDAgPyAwIDogcmF3SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiBpbmRleCA/IHRoaXMubXV0YXRpb25RdWV1ZVtpbmRleF0gOiBudWxsKTtcclxuICAgIH1cclxuICAgIGdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDAgPyBCQVRDSElEX1VOS05PV04gOiB0aGlzLm5leHRCYXRjaElkIC0gMSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCAwKTtcclxuICAgICAgICBjb25zdCBlbmQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuZmluZE11dGF0aW9uQmF0Y2gocmVmLnRhcmdldE9yQmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhdGNoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcclxuICAgIH1cclxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgcXVlcnkgcGF0aCBhcyBhIHByZWZpeCBmb3IgdGVzdGluZyBpZiBhIGRvY3VtZW50IG1hdGNoZXMgdGhlXHJcbiAgICAgICAgLy8gcXVlcnkuXHJcbiAgICAgICAgY29uc3QgcHJlZml4ID0gcXVlcnkucGF0aDtcclxuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgMTtcclxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBkb2N1bWVudCByZWZlcmVuY2UgZm9yIGFjdHVhbGx5IHNjYW5uaW5nIHRoZSBpbmRleC4gVW5saWtlXHJcbiAgICAgICAgLy8gdGhlIHByZWZpeCB0aGUgZG9jdW1lbnQga2V5IGluIHRoaXMgcmVmZXJlbmNlIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZlxyXG4gICAgICAgIC8vIHNlZ21lbnRzLiBUaGUgZW1wdHkgc2VnbWVudCBjYW4gYmUgdXNlZCBhIHN1ZmZpeCBvZiB0aGUgcXVlcnkgcGF0aFxyXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgcHJlY2VkZXMgYWxsIG90aGVyIHNlZ21lbnRzIGluIGFuIG9yZGVyZWQgdHJhdmVyc2FsLlxyXG4gICAgICAgIGxldCBzdGFydFBhdGggPSBwcmVmaXg7XHJcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHN0YXJ0UGF0aCkpIHtcclxuICAgICAgICAgICAgc3RhcnRQYXRoID0gc3RhcnRQYXRoLmNoaWxkKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKG5ldyBEb2N1bWVudEtleShzdGFydFBhdGgpLCAwKTtcclxuICAgICAgICAvLyBGaW5kIHVuaXF1ZSBiYXRjaElEcyByZWZlcmVuY2VkIGJ5IGFsbCBkb2N1bWVudHMgcG90ZW50aWFsbHkgbWF0Y2hpbmcgdGhlXHJcbiAgICAgICAgLy8gcXVlcnkuXHJcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hXaGlsZShyZWYgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByb3dLZXlQYXRoID0gcmVmLmtleS5wYXRoO1xyXG4gICAgICAgICAgICBpZiAoIXByZWZpeC5pc1ByZWZpeE9mKHJvd0tleVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSb3dzIHdpdGggZG9jdW1lbnQga2V5cyBtb3JlIHRoYW4gb25lIHNlZ21lbnQgbG9uZ2VyIHRoYW4gdGhlIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGNhbid0IGJlIG1hdGNoZXMuIEZvciBleGFtcGxlLCBhIHF1ZXJ5IG9uICdyb29tcycgY2FuJ3QgbWF0Y2hcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogd2UnbGwgbmVlZCBhIGRpZmZlcmVudCBzY2FubmVyIHdoZW4gd2UgaW1wbGVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBhbmNlc3RvciBxdWVyaWVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHJvd0tleVBhdGgubGVuZ3RoID09PSBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChyZWYudGFyZ2V0T3JCYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcclxuICAgIH1cclxuICAgIGZpbmRNdXRhdGlvbkJhdGNoZXMoYmF0Y2hJRHMpIHtcclxuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgYmF0Y2hlcywgc29ydGVkIGJ5IGJhdGNoSUQgdG8gZW5zdXJlIHRoYXRcclxuICAgICAgICAvLyBtdWx0aXBsZSBtdXRhdGlvbnMgYWZmZWN0aW5nIHRoZSBzYW1lIGRvY3VtZW50IGtleSBhcmUgYXBwbGllZCBpbiBvcmRlci5cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBiYXRjaElEcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIGlmIChiYXRjaCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJhdGNoIGZvciByZW1vdmFsLlxyXG4gICAgICAgIGNvbnN0IGJhdGNoSW5kZXggPSB0aGlzLmluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2guYmF0Y2hJZCwgJ3JlbW92ZWQnKTtcclxuICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoSW5kZXggPT09IDApO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgIGxldCByZWZlcmVuY2VzID0gdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goYmF0Y2gubXV0YXRpb25zLCAobXV0YXRpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShtdXRhdGlvbi5rZXksIGJhdGNoLmJhdGNoSWQpO1xyXG4gICAgICAgICAgICByZWZlcmVuY2VzID0gcmVmZXJlbmNlcy5kZWxldGUocmVmKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUubWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHJhbnNhY3Rpb24sIG11dGF0aW9uLmtleSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSByZWZlcmVuY2VzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcclxuICAgICAgICAvLyBOby1vcCBzaW5jZSB0aGUgbWVtb3J5IG11dGF0aW9uIHF1ZXVlIGRvZXMgbm90IG1haW50YWluIGEgc2VwYXJhdGUgY2FjaGUuXHJcbiAgICB9XHJcbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCAwKTtcclxuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoa2V5LmlzRXF1YWwoZmlyc3RSZWYgJiYgZmlyc3RSZWYua2V5KSk7XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkgO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGJhdGNoSWQgaW4gdGhlIG11dGF0aW9uIHF1ZXVlIGFuZCBhc3NlcnRzIHRoYXRcclxuICAgICAqIHRoZSByZXN1bHRpbmcgaW5kZXggaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBiYXRjaElkIC0gVGhlIGJhdGNoSWQgdG8gc2VhcmNoIGZvclxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgY2FsbGVyIGlzIGRvaW5nLCBwaHJhc2VkIGluIHBhc3NpdmVcclxuICAgICAqIGZvcm0gKGUuZy4gXCJhY2tub3dsZWRnZWRcIiBpbiBhIHJvdXRpbmUgdGhhdCBhY2tub3dsZWRnZXMgYmF0Y2hlcykuXHJcbiAgICAgKi9cclxuICAgIGluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2hJZCwgYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4T2ZCYXRjaElkKGJhdGNoSWQpO1xyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZS4gVGhpcyBvcGVyYXRpb25cclxuICAgICAqIGlzIE8oMSkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXB1dGVkIGluZGV4IG9mIHRoZSBiYXRjaCB3aXRoIHRoZSBnaXZlbiBiYXRjaElkLCBiYXNlZCBvblxyXG4gICAgICogdGhlIHN0YXRlIG9mIHRoZSBxdWV1ZS4gTm90ZSB0aGlzIGluZGV4IGNhbiBiZSBuZWdhdGl2ZSBpZiB0aGUgcmVxdWVzdGVkXHJcbiAgICAgKiBiYXRjaElkIGhhcyBhbHJlYWR5IGJlZW4gcmVtdm9lZCBmcm9tIHRoZSBxdWV1ZSBvciBwYXN0IHRoZSBlbmQgb2YgdGhlXHJcbiAgICAgKiBxdWV1ZSBpZiB0aGUgYmF0Y2hJZCBpcyBsYXJnZXIgdGhhbiB0aGUgbGFzdCBhZGRlZCBiYXRjaC5cclxuICAgICAqL1xyXG4gICAgaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCkge1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIEFzIGFuIGluZGV4IHRoaXMgaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXhhbWluZSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIHRvIGZpZ3VyZSBvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcclxuICAgICAgICAvLyBiYXRjaElkIGFuZCBpbmRleGVzIGluIHRoZSBhcnJheS4gTm90ZSB0aGF0IHNpbmNlIHRoZSBxdWV1ZSBpcyBvcmRlcmVkXHJcbiAgICAgICAgLy8gYnkgYmF0Y2hJZCwgaWYgdGhlIGZpcnN0IGJhdGNoIGhhcyBhIGxhcmdlciBiYXRjaElkIHRoZW4gdGhlIHJlcXVlc3RlZFxyXG4gICAgICAgIC8vIGJhdGNoSWQgZG9lc24ndCBleGlzdCBpbiB0aGUgcXVldWUuXHJcbiAgICAgICAgY29uc3QgZmlyc3RCYXRjaElkID0gdGhpcy5tdXRhdGlvblF1ZXVlWzBdLmJhdGNoSWQ7XHJcbiAgICAgICAgcmV0dXJuIGJhdGNoSWQgLSBmaXJzdEJhdGNoSWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdmVyc2lvbiBvZiBsb29rdXBNdXRhdGlvbkJhdGNoIHRoYXQgZG9lc24ndCByZXR1cm4gYSBwcm9taXNlLCB0aGlzIG1ha2VzXHJcbiAgICAgKiBvdGhlciBmdW5jdGlvbnMgdGhhdCB1c2VzIHRoaXMgY29kZSBlYXNpZXIgdG8gcmVhZCBhbmQgbW9yZSBlZmZpY2VudC5cclxuICAgICAqL1xyXG4gICAgZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5tdXRhdGlvblF1ZXVlW2luZGV4XTtcclxuICAgICAgICByZXR1cm4gYmF0Y2g7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZG9jdW1lbnRFbnRyeU1hcCgpIHtcclxuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgbWVtb3J5LW9ubHkgUmVtb3RlRG9jdW1lbnRDYWNoZSBmb3IgSW5kZXhlZERiLiBUbyBjb25zdHJ1Y3QsIGludm9rZVxyXG4gKiBgbmV3TWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cclxuICovXHJcbmNsYXNzIE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNpemVyIC0gVXNlZCB0byBhc3Nlc3MgdGhlIHNpemUgb2YgYSBkb2N1bWVudC4gRm9yIGVhZ2VyIEdDLCB0aGlzIGlzXHJcbiAgICAgKiBleHBlY3RlZCB0byBqdXN0IHJldHVybiAwIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgZG9pbmcgdGhlIHdvcmsgb2ZcclxuICAgICAqIGNhbGN1bGF0aW5nIHRoZSBzaXplLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzaXplcikge1xyXG4gICAgICAgIHRoaXMuc2l6ZXIgPSBzaXplcjtcclxuICAgICAgICAvKiogVW5kZXJseWluZyBjYWNoZSBvZiBkb2N1bWVudHMgYW5kIHRoZWlyIHJlYWQgdGltZXMuICovXHJcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jdW1lbnRFbnRyeU1hcCgpO1xyXG4gICAgICAgIC8qKiBTaXplIG9mIGFsbCBjYWNoZWQgZG9jdW1lbnRzLiAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBzZXRJbmRleE1hbmFnZXIoaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHN1cHBsaWVkIGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgdXBkYXRlcyB0aGUgY2FjaGUgc2l6ZSBhcyBhcHByb3ByaWF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxyXG4gICAgICovXHJcbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZG9jLmtleTtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoa2V5KTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBlbnRyeSA/IGVudHJ5LnNpemUgOiAwO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplcihkb2MpO1xyXG4gICAgICAgIHRoaXMuZG9jcyA9IHRoaXMuZG9jcy5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2MubXV0YWJsZUNvcHkoKSxcclxuICAgICAgICAgICAgc2l6ZTogY3VycmVudFNpemVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNpemUgKz0gY3VycmVudFNpemUgLSBwcmV2aW91c1NpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBrZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZW50cnkgZnJvbSB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIGNhbGxzIG9mIGByZW1vdmVFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRyeShkb2N1bWVudEtleSkge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jcyA9IHRoaXMuZG9jcy5yZW1vdmUoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgICAgICB0aGlzLnNpemUgLT0gZW50cnkuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShlbnRyeVxyXG4gICAgICAgICAgICA/IGVudHJ5LmRvY3VtZW50Lm11dGFibGVDb3B5KClcclxuICAgICAgICAgICAgOiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50S2V5LCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXHJcbiAgICAgICAgICAgICAgICA6IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBtdXRhdGVkRG9jcykge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgLy8gRG9jdW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGtleSwgc28gd2UgY2FuIHVzZSBhIHByZWZpeCBzY2FuIHRvIG5hcnJvdyBkb3duXHJcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50cyB3ZSBuZWVkIHRvIG1hdGNoIHRoZSBxdWVyeSBhZ2FpbnN0LlxyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gcXVlcnkucGF0aDtcclxuICAgICAgICBjb25zdCBwcmVmaXggPSBuZXcgRG9jdW1lbnRLZXkoY29sbGVjdGlvblBhdGguY2hpbGQoJycpKTtcclxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuZG9jcy5nZXRJdGVyYXRvckZyb20ocHJlZml4KTtcclxuICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZTogeyBkb2N1bWVudCB9IH0gPSBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvblBhdGguaXNQcmVmaXhPZihrZXkucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXkucGF0aC5sZW5ndGggPiBjb2xsZWN0aW9uUGF0aC5sZW5ndGggKyAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIGVudHJpZXMgZnJvbSBzdWJjb2xsZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3SW5kZXhPZmZzZXRGcm9tRG9jdW1lbnQoZG9jdW1lbnQpLCBvZmZzZXQpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgdGhlIG9mZnNldC5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbXV0YXRlZERvY3MuaGFzKGRvY3VtZW50LmtleSkgJiYgIXF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZG9jdW1lbnQgY2Fubm90IHBvc3NpYmx5IG1hdGNoIHRoZSBxdWVyeS5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50Lm11dGFibGVDb3B5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgbGltdGkpIHtcclxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgSW5kZXhCYWNrZmlsbGVyIGlmIHBlcnNpc3RlbmNlXHJcbiAgICAgICAgLy8gaXMgZW5hYmxlZC5cclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGYpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5kb2NzLCAoa2V5KSA9PiBmKGtleSkpO1xyXG4gICAgfVxyXG4gICAgbmV3Q2hhbmdlQnVmZmVyKG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBgdHJhY2tSZW1vdmFsc2AgaXMgaWdub3JlcyBzaW5jZSB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZSBrZWVwc1xyXG4gICAgICAgIC8vIGEgc2VwYXJhdGUgY2hhbmdlbG9nIGFuZCBkb2VzIG5vdCBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHJlbW92YWxzLlxyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXRTaXplKHR4bikge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnNpemUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1lbW9yeS1vbmx5IFJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzaXplciAtIFVzZWQgdG8gYXNzZXNzIHRoZSBzaXplIG9mIGEgZG9jdW1lbnQuIEZvciBlYWdlciBHQywgdGhpcyBpc1xyXG4gKiBleHBlY3RlZCB0byBqdXN0IHJldHVybiAwIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgZG9pbmcgdGhlIHdvcmsgb2ZcclxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKHNpemVyKSB7XHJcbiAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNpemVyKTtcclxufVxyXG4vKipcclxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZS5cclxuICovXHJcbmNsYXNzIE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIGV4dGVuZHMgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlID0gZG9jdW1lbnRDYWNoZTtcclxuICAgIH1cclxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBkb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDYWNoZS5yZW1vdmVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGUuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlUYXJnZXRDYWNoZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXBzIGEgdGFyZ2V0IHRvIHRoZSBkYXRhIGFib3V0IHRoYXQgdGFyZ2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXRzID0gbmV3IE9iamVjdE1hcCh0ID0+IGNhbm9uaWZ5VGFyZ2V0KHQpLCB0YXJnZXRFcXVhbHMpO1xyXG4gICAgICAgIC8qKiBUaGUgbGFzdCByZWNlaXZlZCBzbmFwc2hvdCB2ZXJzaW9uLiAqL1xyXG4gICAgICAgIHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICAvKiogVGhlIGhpZ2hlc3QgbnVtYmVyZWQgdGFyZ2V0IElEIGVuY291bnRlcmVkLiAqL1xyXG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gMDtcclxuICAgICAgICAvKiogVGhlIGhpZ2hlc3Qgc2VxdWVuY2UgbnVtYmVyIGVuY291bnRlcmVkLiAqL1xyXG4gICAgICAgIHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG9yZGVyZWQgYmlkaXJlY3Rpb25hbCBtYXBwaW5nIGJldHdlZW4gZG9jdW1lbnRzIGFuZCB0aGUgcmVtb3RlIHRhcmdldFxyXG4gICAgICAgICAqIElEcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclRhcmdldENhY2hlKCk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKChfLCB0YXJnZXREYXRhKSA9PiBmKHRhcmdldERhdGEpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKTtcclxuICAgIH1cclxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcik7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0aGlzLnRhcmdldElkR2VuZXJhdG9yLm5leHQoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5oaWdoZXN0VGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgc2V0VGFyZ2V0c01ldGFkYXRhKHRyYW5zYWN0aW9uLCBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICBpZiAobGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID4gdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cy5zZXQodGFyZ2V0RGF0YS50YXJnZXQsIHRhcmdldERhdGEpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgICAgICBpZiAodGFyZ2V0SWQgPiB0aGlzLmhpZ2hlc3RUYXJnZXRJZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldElkR2VuZXJhdG9yID0gbmV3IFRhcmdldElkR2VuZXJhdG9yKHRhcmdldElkKTtcclxuICAgICAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPiB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRDb3VudCArPSAxO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXRzLmRlbGV0ZSh0YXJnZXREYXRhLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZXNGb3JJZCh0YXJnZXREYXRhLnRhcmdldElkKTtcclxuICAgICAgICB0aGlzLnRhcmdldENvdW50IC09IDE7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXRzKHRyYW5zYWN0aW9uLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHJlbW92YWxzID0gW107XHJcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKGtleSwgdGFyZ2V0RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHMuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldHMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmFscy5wdXNoKHRoaXMucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIHRhcmdldERhdGEudGFyZ2V0SWQpKTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocmVtb3ZhbHMpLm5leHQoKCkgPT4gY291bnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0Q291bnQodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy50YXJnZXRDb3VudCk7XHJcbiAgICB9XHJcbiAgICBnZXRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXRzLmdldCh0YXJnZXQpIHx8IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xyXG4gICAgfVxyXG4gICAgYWRkTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMuYWRkUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzKGtleXMsIHRhcmdldElkKTtcclxuICAgICAgICBjb25zdCByZWZlcmVuY2VEZWxlZ2F0ZSA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGU7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBpZiAocmVmZXJlbmNlRGVsZWdhdGUpIHtcclxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nS2V5cyA9IHRoaXMucmVmZXJlbmNlcy5yZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtYXRjaGluZ0tleXMpO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5yZWZlcmVuY2VzLmNvbnRhaW5zS2V5KGtleSkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckZCA9ICdNZW1vcnlQZXJzaXN0ZW5jZSc7XHJcbi8qKlxyXG4gKiBBIG1lbW9yeS1iYWNrZWQgaW5zdGFuY2Ugb2YgUGVyc2lzdGVuY2UuIERhdGEgaXMgc3RvcmVkIG9ubHkgaW4gUkFNIGFuZFxyXG4gKiBub3QgcGVyc2lzdGVkIGFjcm9zcyBzZXNzaW9ucy5cclxuICovXHJcbmNsYXNzIE1lbW9yeVBlcnNpc3RlbmNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBkZWxlZ2F0ZS4gVGhpc1xyXG4gICAgICogYWxsb3dzIGJvdGggdGhlIGRlbGVnYXRlIGFuZCB0aGlzIGluc3RhbmNlIHRvIGhhdmUgc3Ryb25nIHJlZmVyZW5jZXMgdG9cclxuICAgICAqIGVhY2ggb3RoZXIgd2l0aG91dCBoYXZpbmcgbnVsbGFibGUgZmllbGRzIHRoYXQgd291bGQgdGhlbiBuZWVkIHRvIGJlXHJcbiAgICAgKiBjaGVja2VkIG9yIGFzc2VydGVkIG9uIGV2ZXJ5IGFjY2Vzcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5LCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSB7fTtcclxuICAgICAgICB0aGlzLmxpc3RlblNlcXVlbmNlID0gbmV3IExpc3RlblNlcXVlbmNlKDApO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q2FjaGUgPSBuZXcgTWVtb3J5VGFyZ2V0Q2FjaGUodGhpcyk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZXIgPSAoZG9jKSA9PiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLmRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gbmV3IE1lbW9yeUluZGV4TWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoc2l6ZXIpO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBMb2NhbFNlcmlhbGl6ZXIoc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBNZW1vcnlCdW5kbGVDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgLy8gTm8gZHVyYWJsZSBzdGF0ZSB0byBlbnN1cmUgaXMgY2xvc2VkIG9uIHNodXRkb3duLlxyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RhcnRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcclxuICAgIH1cclxuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCkge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgc2V0TmV0d29ya0VuYWJsZWQoKSB7XHJcbiAgICAgICAgLy8gTm8gb3AuXHJcbiAgICB9XHJcbiAgICBnZXRJbmRleE1hbmFnZXIodXNlcikge1xyXG4gICAgICAgIC8vIFdlIGRvIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBpbmRpY2VzIGZvciBtZW1vcnkgcGVyc2lzdGVuY2UsIHNvIHdlIGNhblxyXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIG1lbW9yeSBpbmRleCBtYW5hZ2VyLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcclxuICAgICAgICBsZXQgb3ZlcmxheSA9IHRoaXMub3ZlcmxheXNbdXNlci50b0tleSgpXTtcclxuICAgICAgICBpZiAoIW92ZXJsYXkpIHtcclxuICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBNZW1vcnlEb2N1bWVudE92ZXJsYXlDYWNoZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV0gPSBvdmVybGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3ZlcmxheTtcclxuICAgIH1cclxuICAgIGdldE11dGF0aW9uUXVldWUodXNlciwgaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5tdXRhdGlvblF1ZXVlc1t1c2VyLnRvS2V5KCldO1xyXG4gICAgICAgIGlmICghcXVldWUpIHtcclxuICAgICAgICAgICAgcXVldWUgPSBuZXcgTWVtb3J5TXV0YXRpb25RdWV1ZShpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVzW3VzZXIudG9LZXkoKV0gPSBxdWV1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHF1ZXVlO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0Q2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVEb2N1bWVudENhY2hlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRCdW5kbGVDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcclxuICAgIH1cclxuICAgIHJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgbW9kZSwgdHJhbnNhY3Rpb25PcGVyYXRpb24pIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGQsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHR4biA9IG5ldyBNZW1vcnlUcmFuc2FjdGlvbih0aGlzLmxpc3RlblNlcXVlbmNlLm5leHQoKSk7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5vblRyYW5zYWN0aW9uU3RhcnRlZCgpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbih0eG4pXHJcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlXHJcbiAgICAgICAgICAgICAgICAub25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxyXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0eG4ucmFpc2VPbkNvbW1pdHRlZEV2ZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHJhbnNhY3Rpb24sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoT2JqZWN0LnZhbHVlcyh0aGlzLm11dGF0aW9uUXVldWVzKS5tYXAocXVldWUgPT4gKCkgPT4gcXVldWUuY29udGFpbnNLZXkodHJhbnNhY3Rpb24sIGtleSkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWVtb3J5IHBlcnNpc3RlbmNlIGlzIG5vdCBhY3R1YWxseSB0cmFuc2FjdGlvbmFsLCBidXQgZnV0dXJlIGltcGxlbWVudGF0aW9uc1xyXG4gKiBtYXkgaGF2ZSB0cmFuc2FjdGlvbi1zY29wZWQgc3RhdGUuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlUcmFuc2FjdGlvbiBleHRlbmRzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY3VycmVudFNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZU51bWJlciA9IGN1cnJlbnRTZXF1ZW5jZU51bWJlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBNZW1vcnlFYWdlckRlbGVnYXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIC8qKiBUcmFja3MgYWxsIGRvY3VtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gUXVlcnkgdmlld3MuICovXHJcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xyXG4gICAgICAgIC8qKiBUaGUgbGlzdCBvZiBkb2N1bWVudHMgdGhhdCBhcmUgcG90ZW50aWFsbHkgR0NlZCBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLiAqL1xyXG4gICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmYWN0b3J5KHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlFYWdlckRlbGVnYXRlKHBlcnNpc3RlbmNlKTtcclxuICAgIH1cclxuICAgIGdldCBvcnBoYW5lZERvY3VtZW50cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29ycGhhbmVkRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcnBoYW5lZERvY3VtZW50cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLmFkZFJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmRlbGV0ZShrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBtYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0eG4sIGtleSkge1xyXG4gICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpIHtcclxuICAgICAgICBjb25zdCBvcnBoYW5lZCA9IHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XHJcbiAgICAgICAgb3JwaGFuZWQuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKTtcclxuICAgICAgICByZXR1cm4gY2FjaGVcclxuICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcclxuICAgICAgICAgICAgLm5leHQoa2V5cyA9PiB7XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjYWNoZS5yZW1vdmVUYXJnZXREYXRhKHR4biwgdGFyZ2V0RGF0YSkpO1xyXG4gICAgfVxyXG4gICAgb25UcmFuc2FjdGlvblN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBvblRyYW5zYWN0aW9uQ29tbWl0dGVkKHR4bikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBuZXdseSBvcnBoYW5lZCBkb2N1bWVudHMuXHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBjYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5vcnBoYW5lZERvY3VtZW50cywgKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUmVmZXJlbmNlZCh0eG4sIGtleSkubmV4dChpc1JlZmVyZW5jZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZmVyZW5jZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlQnVmZmVyLmFwcGx5KHR4bik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2VkKHR4biwga2V5KS5uZXh0KGlzUmVmZXJlbmNlZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuZGVsZXRlKGtleS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZG9jdW1lbnRTaXplKGRvYykge1xyXG4gICAgICAgIC8vIEZvciBlYWdlciBHQywgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZG9jdW1lbnQgc2l6ZSwgdGhlcmUgYXJlIG5vIHNpemUgdGhyZXNob2xkcy5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGlzUmVmZXJlbmNlZCh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoW1xyXG4gICAgICAgICAgICAoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSksXHJcbiAgICAgICAgICAgICgpID0+IHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS5jb250YWluc0tleSh0eG4sIGtleSksXHJcbiAgICAgICAgICAgICgpID0+IHRoaXMucGVyc2lzdGVuY2UubXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwga2V5KVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE1lbW9yeUxydURlbGVnYXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBscnVQYXJhbXMpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XHJcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycyA9IG5ldyBPYmplY3RNYXAoayA9PiBlbmNvZGVSZXNvdXJjZVBhdGgoay5wYXRoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XHJcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBscnVQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZhY3RvcnkocGVyc2lzdGVuY2UsIGxydVBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5THJ1RGVsZWdhdGUocGVyc2lzdGVuY2UsIGxydVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICAvLyBOby1vcHMsIHByZXNlbnQgc28gbWVtb3J5IHBlcnNpc3RlbmNlIGRvZXNuJ3QgaGF2ZSB0byBjYXJlIHdoaWNoIGRlbGVnYXRlXHJcbiAgICAvLyBpdCBoYXMuXHJcbiAgICBvblRyYW5zYWN0aW9uU3RhcnRlZCgpIHsgfVxyXG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XHJcbiAgICB9XHJcbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xyXG4gICAgICAgIGNvbnN0IGRvY0NvdW50UHJvbWlzZSA9IHRoaXMub3JwaGFuZWREb2N1bWVudENvdW50KHR4bik7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q291bnRQcm9taXNlID0gdGhpcy5wZXJzaXN0ZW5jZVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q291bnQodHhuKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0Q291bnRQcm9taXNlLm5leHQodGFyZ2V0Q291bnQgPT4gZG9jQ291bnRQcm9taXNlLm5leHQoZG9jQ291bnQgPT4gdGFyZ2V0Q291bnQgKyBkb2NDb3VudCkpO1xyXG4gICAgfVxyXG4gICAgb3JwaGFuZWREb2N1bWVudENvdW50KHR4bikge1xyXG4gICAgICAgIGxldCBvcnBoYW5lZENvdW50ID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgXyA9PiB7XHJcbiAgICAgICAgICAgIG9ycGhhbmVkQ291bnQrKztcclxuICAgICAgICB9KS5uZXh0KCgpID0+IG9ycGhhbmVkQ291bnQpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIGYpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycywgKGtleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gUGFzcyBpbiB0aGUgZXhhY3Qgc2VxdWVuY2UgbnVtYmVyIGFzIHRoZSB1cHBlciBib3VuZCBzbyB3ZSBrbm93IGl0IHdvbid0IGJlIHBpbm5lZCBieVxyXG4gICAgICAgICAgICAvLyBiZWluZyB0b28gcmVjZW50LlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Bpbm5lZCh0eG4sIGtleSwgc2VxdWVuY2VOdW1iZXIpLm5leHQoaXNQaW5uZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxyXG4gICAgICAgICAgICAucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gY2FjaGUubmV3Q2hhbmdlQnVmZmVyKCk7XHJcbiAgICAgICAgY29uc3QgcCA9IGNhY2hlLmZvckVhY2hEb2N1bWVudEtleSh0eG4sIGtleSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGlubmVkKHR4biwga2V5LCB1cHBlckJvdW5kKS5uZXh0KGlzUGlubmVkID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNQaW5uZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwLm5leHQoKCkgPT4gY2hhbmdlQnVmZmVyLmFwcGx5KHR4bikpLm5leHQoKCkgPT4gY291bnQpO1xyXG4gICAgfVxyXG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0KHR4biwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpLnVwZGF0ZVRhcmdldERhdGEodHhuLCB1cGRhdGVkKTtcclxuICAgIH1cclxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIHRoaXMub3JwaGFuZWRTZXF1ZW5jZU51bWJlcnMuc2V0KGtleSwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGRvY3VtZW50U2l6ZShkb2N1bWVudCkge1xyXG4gICAgICAgIGxldCBkb2N1bWVudFNpemUgPSBkb2N1bWVudC5rZXkudG9TdHJpbmcoKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50U2l6ZSArPSBlc3RpbWF0ZUJ5dGVTaXplKGRvY3VtZW50LmRhdGEudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRTaXplO1xyXG4gICAgfVxyXG4gICAgaXNQaW5uZWQodHhuLCBrZXksIHVwcGVyQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKFtcclxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpLFxyXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcnBoYW5lZEF0ID0gdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShvcnBoYW5lZEF0ICE9PSB1bmRlZmluZWQgJiYgb3JwaGFuZWRBdCA+IHVwcGVyQm91bmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpLmdldFNpemUodHhuKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogUGVyZm9ybXMgZGF0YWJhc2UgY3JlYXRpb24gYW5kIHNjaGVtYSB1cGdyYWRlcy4gKi9cclxuY2xhc3MgU2NoZW1hQ29udmVydGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmFzZSBjcmVhdGlvbiBhbmQgc2NoZW1hIHVwZ3JhZGVzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBpbiBwcm9kdWN0aW9uLCB0aGlzIG1ldGhvZCBpcyBvbmx5IGV2ZXIgdXNlZCB0byB1cGdyYWRlIHRoZSBzY2hlbWFcclxuICAgICAqIHRvIFNDSEVNQV9WRVJTSU9OLiBEaWZmZXJlbnQgdmFsdWVzIG9mIHRvVmVyc2lvbiBhcmUgb25seSB1c2VkIGZvciB0ZXN0aW5nXHJcbiAgICAgKiBhbmQgbG9jYWwgZmVhdHVyZSBkZXZlbG9wbWVudC5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlT3JVcGdyYWRlKGRiLCB0eG4sIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24pIHtcclxuICAgICAgICBjb25zdCBzaW1wbGVEYlRyYW5zYWN0aW9uID0gbmV3IFNpbXBsZURiVHJhbnNhY3Rpb24oJ2NyZWF0ZU9yVXBncmFkZScsIHR4bik7XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMSAmJiB0b1ZlcnNpb24gPj0gMSkge1xyXG4gICAgICAgICAgICBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpO1xyXG4gICAgICAgICAgICBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKTtcclxuICAgICAgICAgICAgY3JlYXRlUXVlcnlDYWNoZShkYik7XHJcbiAgICAgICAgICAgIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNaWdyYXRpb24gMiB0byBwb3B1bGF0ZSB0aGUgdGFyZ2V0R2xvYmFsIG9iamVjdCBubyBsb25nZXIgbmVlZGVkIHNpbmNlXHJcbiAgICAgICAgLy8gbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cclxuICAgICAgICBsZXQgcCA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMyAmJiB0b1ZlcnNpb24gPj0gMykge1xyXG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgY2xpZW50cyBkb24ndCBuZWVkIHRvIGRyb3AgYW5kIHJlY3JlYXRlLS1vbmx5IGNsaWVudHMgdGhhdFxyXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWxseSBoYXZlIGNvcnJ1cHQgZGF0YS5cclxuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkcm9wUXVlcnlDYWNoZShkYik7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVRdWVyeUNhY2hlKGRiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeShzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDQgJiYgdG9WZXJzaW9uID49IDQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlbWEgdmVyc2lvbiAzIHVzZXMgYXV0by1nZW5lcmF0ZWQga2V5cyB0byBnZW5lcmF0ZSBnbG9iYWxseSB1bmlxdWVcclxuICAgICAgICAgICAgICAgIC8vIG11dGF0aW9uIGJhdGNoIElEcyAodGhpcyB3YXMgcHJldmlvdXNseSBlbnN1cmVkIGludGVybmFsbHkgYnkgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQpLiBUbyBtaWdyYXRlIHRvIHRoZSBuZXcgc2NoZW1hLCB3ZSBoYXZlIHRvIHJlYWQgYWxsIG11dGF0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdyaXRlIHRoZW0gYmFjayBvdXQuIFdlIHByZXNlcnZlIHRoZSBleGlzdGluZyBiYXRjaCBJRHMgdG8gZ3VhcmFudGVlXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIG9iamVjdCBzdG9yZXMuIEFueSBmdXJ0aGVyIG11dGF0aW9uIGJhdGNoIElEcyB3aWxsXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBhdXRvLWdlbmVyYXRlZC5cclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdXBncmFkZU11dGF0aW9uQmF0Y2hTY2hlbWFBbmRNaWdyYXRlRGF0YShkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlQ2xpZW50TWV0YWRhdGFTdG9yZShkYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA1ICYmIHRvVmVyc2lvbiA+PSA1KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZW1vdmVBY2tub3dsZWRnZWRNdXRhdGlvbnMoc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA2ICYmIHRvVmVyc2lvbiA+PSA2KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGREb2N1bWVudEdsb2JhbChzaW1wbGVEYlRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDcgJiYgdG9WZXJzaW9uID49IDcpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLmVuc3VyZVNlcXVlbmNlTnVtYmVycyhzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDggJiYgdG9WZXJzaW9uID49IDgpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLmNyZWF0ZUNvbGxlY3Rpb25QYXJlbnRJbmRleChkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA5ICYmIHRvVmVyc2lvbiA+PSA5KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gTXVsdGktVGFiIHVzZWQgdG8gbWFuYWdlIGl0cyBvd24gY2hhbmdlbG9nLCBidXQgdGhpcyBoYXMgYmVlbiBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIERiUmVtb3RlRG9jdW1lbnQgb2JqZWN0IHN0b3JlIGl0c2VsZi4gU2luY2UgdGhlIHByZXZpb3VzIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgLy8gbG9nIG9ubHkgY29udGFpbmVkIHRyYW5zaWVudCBkYXRhLCB3ZSBjYW4gZHJvcCBpdHMgb2JqZWN0IHN0b3JlLlxyXG4gICAgICAgICAgICAgICAgZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFNjaGVtYSB2ZXJzaW9uIDkgdXNlZCB0byBjcmVhdGUgYSByZWFkIHRpbWUgaW5kZXggZm9yIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3RlRG9jdW1lbnRDYWNoZS4gVGhpcyBpcyBub3cgZG9uZSB3aXRoIHNjaGVtYSB2ZXJzaW9uIDEzLlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTAgJiYgdG9WZXJzaW9uID49IDEwKSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlQ2Fub25pY2FsSWRzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTEgJiYgdG9WZXJzaW9uID49IDExKSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlQnVuZGxlc1N0b3JlKGRiKTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZU5hbWVkUXVlcmllc1N0b3JlKGRiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEyICYmIHRvVmVyc2lvbiA+PSAxMikge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURvY3VtZW50T3ZlcmxheVN0b3JlKGRiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEzICYmIHRvVmVyc2lvbiA+PSAxMykge1xyXG4gICAgICAgICAgICBwID0gcFxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnJld3JpdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE0ICYmIHRvVmVyc2lvbiA+PSAxNCkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMucnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNSAmJiB0b1ZlcnNpb24gPj0gMTUpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiBjcmVhdGVGaWVsZEluZGV4KGRiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE2ICYmIHRvVmVyc2lvbiA+PSAxNikge1xyXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgb2JqZWN0IHN0b3JlcyB0byByZW1vdmUgcG9zc2libHkgY29ycnVwdGVkIGluZGV4IGVudHJpZXNcclxuICAgICAgICAgICAgcCA9IHBcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhdGVTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4U3RhdGVTdG9yZSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleFN0YXRlU3RvcmUuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4RW50cnlTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleEVudHJ5U3RvcmUuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgYWRkRG9jdW1lbnRHbG9iYWwodHhuKSB7XHJcbiAgICAgICAgbGV0IGJ5dGVTaXplID0gMDtcclxuICAgICAgICByZXR1cm4gdHhuXHJcbiAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSlcclxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBieXRlU2l6ZSArPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7IGJ5dGVTaXplIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0eG5cclxuICAgICAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpXHJcbiAgICAgICAgICAgICAgICAucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZUFja25vd2xlZGdlZE11dGF0aW9ucyh0eG4pIHtcclxuICAgICAgICBjb25zdCBxdWV1ZXNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSk7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBxdWV1ZXNTdG9yZS5sb2FkQWxsKCkubmV4dChxdWV1ZXMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocXVldWVzLCAocXVldWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3F1ZXVlLnVzZXJJZCwgQkFUQ0hJRF9VTktOT1dOXSwgW3F1ZXVlLnVzZXJJZCwgcXVldWUubGFzdEFja25vd2xlZGdlZEJhdGNoSWRdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC5sb2FkQWxsKERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoZGJCYXRjaGVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goZGJCYXRjaGVzLCAoZGJCYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2gudXNlcklkID09PSBxdWV1ZS51c2VySWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBxdWV1ZS51c2VySWQsIGJhdGNoKS5uZXh0KCgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCBldmVyeSBkb2N1bWVudCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIGhhcyBhIGNvcnJlc3BvbmRpbmcgc2VudGluZWwgcm93XHJcbiAgICAgKiB3aXRoIGEgc2VxdWVuY2UgbnVtYmVyLiBNaXNzaW5nIHJvd3MgYXJlIGdpdmVuIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgc2VxdWVuY2UgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBlbnN1cmVTZXF1ZW5jZU51bWJlcnModHhuKSB7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50c1N0b3JlID0gdHhuLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKTtcclxuICAgICAgICBjb25zdCBnbG9iYWxUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsVGFyZ2V0U3RvcmUuZ2V0KERiVGFyZ2V0R2xvYmFsS2V5KS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVTZW50aW5lbEtleSA9IChwYXRoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZS5wdXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGVuY29kZVJlc291cmNlUGF0aChwYXRoKSxcclxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50c1N0b3JlXHJcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSgoa2V5LCBkb2MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKGtleSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NTZW50aW5lbEtleSA9IHNlbnRpbmVsS2V5KHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFRhcmdldFN0b3JlLmdldChkb2NTZW50aW5lbEtleSkubmV4dChtYXliZVNlbnRpbmVsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlU2VudGluZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ29sbGVjdGlvblBhcmVudEluZGV4KGRiLCB0eG4pIHtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4LlxyXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQ29sbGVjdGlvblBhcmVudFN0b3JlLCB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IERiQ29sbGVjdGlvblBhcmVudEtleVBhdGhcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGFyZW50c1N0b3JlID0gdHhuLnN0b3JlKERiQ29sbGVjdGlvblBhcmVudFN0b3JlKTtcclxuICAgICAgICAvLyBIZWxwZXIgdG8gYWRkIGFuIGluZGV4IGVudHJ5IGlmZiB3ZSBoYXZlbid0IGFscmVhZHkgd3JpdHRlbiBpdC5cclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgoKTtcclxuICAgICAgICBjb25zdCBhZGRFbnRyeSA9IChjb2xsZWN0aW9uUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUuYWRkKGNvbGxlY3Rpb25QYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZS5wdXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGVuY29kZVJlc291cmNlUGF0aChwYXJlbnRQYXRoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEluZGV4IGV4aXN0aW5nIHJlbW90ZSBkb2N1bWVudHMuXHJcbiAgICAgICAgcmV0dXJuIHR4blxyXG4gICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsga2V5c09ubHk6IHRydWUgfSwgKHBhdGhTZWdtZW50cywgXykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChwYXRoU2VnbWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkRW50cnkocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gSW5kZXggZXhpc3RpbmcgbXV0YXRpb25zLlxyXG4gICAgICAgICAgICByZXR1cm4gdHhuXHJcbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpXHJcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSh7IGtleXNPbmx5OiB0cnVlIH0sIChbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0sIF8pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXdyaXRlQ2Fub25pY2FsSWRzKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0U3RvcmUpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRTdG9yZS5pdGVyYXRlKChrZXksIG9yaWdpbmFsRGJUYXJnZXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KG9yaWdpbmFsRGJUYXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRGJUYXJnZXQgPSB0b0RiVGFyZ2V0KHRoaXMuc2VyaWFsaXplciwgb3JpZ2luYWxUYXJnZXREYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN0b3JlLnB1dCh1cGRhdGVkRGJUYXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV3cml0ZVJlbW90ZURvY3VtZW50Q2FjaGUoZGIsIHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKTtcclxuICAgICAgICBjb25zdCB3cml0ZXMgPSBbXTtcclxuICAgICAgICByZXR1cm4gbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSgoXywgbGVnYWN5RG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3RlRG9jdW1lbnRTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBleHRyYWN0S2V5KGxlZ2FjeURvY3VtZW50KS5wYXRoLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgY29uc3QgZGJSZW1vdGVEb2N1bWVudCA9IHtcclxuICAgICAgICAgICAgICAgIHByZWZpeFBhdGg6IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Hcm91cDogcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgcmVhZFRpbWU6IGxlZ2FjeURvY3VtZW50LnJlYWRUaW1lIHx8IFswLCAwXSxcclxuICAgICAgICAgICAgICAgIHVua25vd25Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQudW5rbm93bkRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgbm9Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQubm9Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50OiBsZWdhY3lEb2N1bWVudC5kb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIGhhc0NvbW1pdHRlZE11dGF0aW9uczogISFsZWdhY3lEb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd3JpdGVzLnB1c2gocmVtb3RlRG9jdW1lbnRTdG9yZS5wdXQoZGJSZW1vdGVEb2N1bWVudCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHdyaXRlcykpO1xyXG4gICAgfVxyXG4gICAgcnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgICAgICBjb25zdCByZW1vdGVEb2N1bWVudENhY2hlID0gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeVBlcnNpc3RlbmNlID0gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKE1lbW9yeUVhZ2VyRGVsZWdhdGUuZmFjdG9yeSwgdGhpcy5zZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZS5sb2FkQWxsKCkubmV4dChkYkJhdGNoZXMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyVG9Eb2N1bWVudFNldCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZGJCYXRjaGVzLmZvckVhY2goZGJCYXRjaCA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBsZXQgZG9jdW1lbnRTZXQgPSAoX2EgPSB1c2VyVG9Eb2N1bWVudFNldC5nZXQoZGJCYXRjaC51c2VySWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5rZXlzKCkuZm9yRWFjaChrZXkgPT4gKGRvY3VtZW50U2V0ID0gZG9jdW1lbnRTZXQuYWRkKGtleSkpKTtcclxuICAgICAgICAgICAgICAgIHVzZXJUb0RvY3VtZW50U2V0LnNldChkYkJhdGNoLnVzZXJJZCwgZG9jdW1lbnRTZXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHVzZXJUb0RvY3VtZW50U2V0LCAoYWxsRG9jdW1lbnRLZXlzRm9yVXNlciwgdXNlcklkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIodXNlcklkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50T3ZlcmxheUNhY2hlID0gSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUuZm9yVXNlcih0aGlzLnNlcmlhbGl6ZXIsIHVzZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogVGhlIGluZGV4IG1hbmFnZXIgYW5kIHRoZSByZWZlcmVuY2UgZGVsZWdhdGUgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBpcnJlbGV2YW50IGZvciB0aGUgcHVycG9zZSBvZiByZWNhbGN1bGF0aW5nIGFuZCBzYXZpbmdcclxuICAgICAgICAgICAgICAgIC8vIG92ZXJsYXlzLiBXZSBjYW4gdGhlcmVmb3JlIHNpbXBseSB1c2UgdGhlIG1lbW9yeVxyXG4gICAgICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBtZW1vcnlQZXJzaXN0ZW5jZS5nZXRJbmRleE1hbmFnZXIodXNlcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvblF1ZXVlID0gSW5kZXhlZERiTXV0YXRpb25RdWV1ZS5mb3JVc2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCBtZW1vcnlQZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbERvY3VtZW50c1ZpZXcgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHJlbW90ZURvY3VtZW50Q2FjaGUsIG11dGF0aW9uUXVldWUsIGRvY3VtZW50T3ZlcmxheUNhY2hlLCBpbmRleE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsRG9jdW1lbnRzVmlld1xyXG4gICAgICAgICAgICAgICAgICAgIC5yZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyhuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIExpc3RlblNlcXVlbmNlLklOVkFMSUQpLCBhbGxEb2N1bWVudEtleXNGb3JVc2VyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlbnRpbmVsS2V5KHBhdGgpIHtcclxuICAgIHJldHVybiBbMCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpIHtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUHJpbWFyeUNsaWVudFN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25RdWV1ZUtleVBhdGhcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbXV0YXRpb25CYXRjaGVzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaEtleVBhdGgsXHJcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBtdXRhdGlvbkJhdGNoZXNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcclxufVxyXG4vKipcclxuICogVXBncmFkZSBmdW5jdGlvbiB0byBtaWdyYXRlIHRoZSAnbXV0YXRpb25zJyBzdG9yZSBmcm9tIFYxIHRvIFYzLiBMb2Fkc1xyXG4gKiBhbmQgcmV3cml0ZXMgYWxsIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGdyYWRlTXV0YXRpb25CYXRjaFNjaGVtYUFuZE1pZ3JhdGVEYXRhKGRiLCB0eG4pIHtcclxuICAgIGNvbnN0IHYxTXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xyXG4gICAgcmV0dXJuIHYxTXV0YXRpb25zU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdNdXRhdGlvbnMgPT4ge1xyXG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlLCB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaEtleVBhdGgsXHJcbiAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBtdXRhdGlvbnNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCB2M011dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgICAgICBjb25zdCB3cml0ZUFsbCA9IGV4aXN0aW5nTXV0YXRpb25zLm1hcChtdXRhdGlvbiA9PiB2M011dGF0aW9uc1N0b3JlLnB1dChtdXRhdGlvbikpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcih3cml0ZUFsbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lSZW1vdGVEb2N1bWVudENhY2hlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikge1xyXG4gICAgY29uc3QgcmVtb3RlRG9jdW1lbnRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiUmVtb3RlRG9jdW1lbnRLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIHJlbW90ZURvY3VtZW50U3RvcmUuY3JlYXRlSW5kZXgoRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsIERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4UGF0aCk7XHJcbiAgICByZW1vdGVEb2N1bWVudFN0b3JlLmNyZWF0ZUluZGV4KERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCwgRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYikge1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVRdWVyeUNhY2hlKGRiKSB7XHJcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudHNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0RG9jdW1lbnRTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiVGFyZ2V0RG9jdW1lbnRLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIHRhcmdldERvY3VtZW50c1N0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCwgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgY29uc3QgdGFyZ2V0U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldFN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXRLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIC8vIE5PVEU6IFRoaXMgaXMgdW5pcXVlIG9ubHkgYmVjYXVzZSB0aGUgVGFyZ2V0SWQgaXMgdGhlIHN1ZmZpeC5cclxuICAgIHRhcmdldFN0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lLCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRHbG9iYWxTdG9yZSk7XHJcbn1cclxuZnVuY3Rpb24gZHJvcFF1ZXJ5Q2FjaGUoZGIpIHtcclxuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0RG9jdW1lbnRTdG9yZSk7XHJcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldFN0b3JlKTtcclxuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGRyb3BSZW1vdGVEb2N1bWVudENoYW5nZXNTdG9yZShkYikge1xyXG4gICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpKSB7XHJcbiAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSB0YXJnZXQgZ2xvYmFsIHNpbmdsZXRvbiByb3cuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eG4gLSBUaGUgdmVyc2lvbiB1cGdyYWRlIHRyYW5zYWN0aW9uIGZvciBpbmRleGVkZGJcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeSh0eG4pIHtcclxuICAgIGNvbnN0IGdsb2JhbFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XHJcbiAgICAgICAgaGlnaGVzdFRhcmdldElkOiAwLFxyXG4gICAgICAgIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjogMCxcclxuICAgICAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uOiBTbmFwc2hvdFZlcnNpb24ubWluKCkudG9UaW1lc3RhbXAoKSxcclxuICAgICAgICB0YXJnZXRDb3VudDogMFxyXG4gICAgfTtcclxuICAgIHJldHVybiBnbG9iYWxTdG9yZS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRhZGF0YVN0b3JlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNsaWVudE1ldGFkYXRhU3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkNsaWVudE1ldGFkYXRhS2V5UGF0aFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlc1N0b3JlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkJ1bmRsZVN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJCdW5kbGVLZXlQYXRoXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVOYW1lZFF1ZXJpZXNTdG9yZShkYikge1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJOYW1lZFF1ZXJ5U3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYk5hbWVkUXVlcnlLZXlQYXRoXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGaWVsZEluZGV4KGRiKSB7XHJcbiAgICBjb25zdCBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4Q29uZmlndXJhdGlvbktleVBhdGgsXHJcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBpbmRleENvbmZpZ3VyYXRpb25TdG9yZS5jcmVhdGVJbmRleChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgY29uc3QgaW5kZXhTdGF0ZVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleFN0YXRlU3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4U3RhdGVLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIGluZGV4U3RhdGVTdG9yZS5jcmVhdGVJbmRleChEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4LCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgY29uc3QgaW5kZXhFbnRyeVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleEVudHJ5U3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4RW50cnlLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIGluZGV4RW50cnlTdG9yZS5jcmVhdGVJbmRleChEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4LCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50T3ZlcmxheVN0b3JlKGRiKSB7XHJcbiAgICBjb25zdCBkb2N1bWVudE92ZXJsYXlTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRPdmVybGF5U3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkRvY3VtZW50T3ZlcmxheUtleVBhdGhcclxuICAgIH0pO1xyXG4gICAgZG9jdW1lbnRPdmVybGF5U3RvcmUuY3JlYXRlSW5kZXgoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxuICAgIGRvY3VtZW50T3ZlcmxheVN0b3JlLmNyZWF0ZUluZGV4KERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0S2V5KHJlbW90ZURvYykge1xyXG4gICAgaWYgKHJlbW90ZURvYy5kb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmVtb3RlRG9jLmRvY3VtZW50Lm5hbWUpLnBvcEZpcnN0KDUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2Mubm9Eb2N1bWVudC5wYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQucGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYyA9ICdJbmRleGVkRGJQZXJzaXN0ZW5jZSc7XHJcbi8qKlxyXG4gKiBPbGRlc3QgYWNjZXB0YWJsZSBhZ2UgaW4gbWlsbGlzZWNvbmRzIGZvciBjbGllbnQgbWV0YWRhdGEgYmVmb3JlIHRoZSBjbGllbnRcclxuICogaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgaXRzIGFzc29jaWF0ZWQgZGF0YSBpcyBnYXJiYWdlIGNvbGxlY3RlZC5cclxuICovXHJcbmNvbnN0IE1BWF9DTElFTlRfQUdFX01TID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcclxuLyoqXHJcbiAqIE9sZGVzdCBhY2NlcHRhYmxlIG1ldGFkYXRhIGFnZSBmb3IgY2xpZW50cyB0aGF0IG1heSBwYXJ0aWNpcGF0ZSBpbiB0aGVcclxuICogcHJpbWFyeSBsZWFzZSBlbGVjdGlvbi4gQ2xpZW50cyB0aGF0IGhhdmUgbm90IHVwZGF0ZWQgdGhlaXIgY2xpZW50IG1ldGFkYXRhXHJcbiAqIHdpdGhpbiA1IHNlY29uZHMgYXJlIG5vdCBlbGlnaWJsZSB0byByZWNlaXZlIGEgcHJpbWFyeSBsZWFzZS5cclxuICovXHJcbmNvbnN0IE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUyA9IDUwMDA7XHJcbi8qKlxyXG4gKiBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggY2xpZW50cyB3aWxsIHVwZGF0ZSB0aGVpciBtZXRhZGF0YSwgaW5jbHVkaW5nXHJcbiAqIHJlZnJlc2hpbmcgdGhlaXIgcHJpbWFyeSBsZWFzZSBpZiBoZWxkIG9yIHBvdGVudGlhbGx5IHRyeWluZyB0byBhY3F1aXJlIGl0IGlmXHJcbiAqIG5vdCBoZWxkLlxyXG4gKlxyXG4gKiBQcmltYXJ5IGNsaWVudHMgbWF5IG9wcG9ydHVuaXN0aWNhbGx5IHJlZnJlc2ggdGhlaXIgbWV0YWRhdGEgZWFybGllclxyXG4gKiBpZiB0aGV5J3JlIGFscmVhZHkgcGVyZm9ybWluZyBhbiBJbmRleGVkREIgb3BlcmF0aW9uLlxyXG4gKi9cclxuY29uc3QgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMgPSA0MDAwO1xyXG4vKiogVXNlci1mYWNpbmcgZXJyb3Igd2hlbiB0aGUgcHJpbWFyeSBsZWFzZSBpcyByZXF1aXJlZCBidXQgbm90IGF2YWlsYWJsZS4gKi9cclxuY29uc3QgUFJJTUFSWV9MRUFTRV9FWENMVVNJVkVfRVJST1JfTVNHID0gJ0ZhaWxlZCB0byBvYnRhaW4gZXhjbHVzaXZlIGFjY2VzcyB0byB0aGUgcGVyc2lzdGVuY2UgbGF5ZXIuIFRvIGFsbG93ICcgK1xyXG4gICAgJ3NoYXJlZCBhY2Nlc3MsIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24gaGFzIHRvIGJlIGVuYWJsZWQgaW4gYWxsIHRhYnMuICcgK1xyXG4gICAgJ0lmIHlvdSBhcmUgdXNpbmcgYGV4cGVyaW1lbnRhbEZvcmNlT3duaW5nVGFiOnRydWVgLCBtYWtlIHN1cmUgdGhhdCBvbmx5ICcgK1xyXG4gICAgJ29uZSB0YWIgaGFzIHBlcnNpc3RlbmNlIGVuYWJsZWQgYXQgYW55IGdpdmVuIHRpbWUuJztcclxuY29uc3QgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHID0gJ1RoaXMgcGxhdGZvcm0gaXMgZWl0aGVyIG1pc3NpbmcgSW5kZXhlZERCIG9yIGlzIGtub3duIHRvIGhhdmUgJyArXHJcbiAgICAnYW4gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvbi4gT2ZmbGluZSBwZXJzaXN0ZW5jZSBoYXMgYmVlbiBkaXNhYmxlZC4nO1xyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHpvbWJpZWQgY2xpZW50IGlzOlxyXG4vLyAgICAgZmlyZXN0b3JlX3pvbWJpZV88cGVyc2lzdGVuY2VfcHJlZml4Pl88aW5zdGFuY2Vfa2V5PlxyXG5jb25zdCBaT01CSUVEX0NMSUVOVFNfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfem9tYmllJztcclxuLyoqXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtYWluIChhbmQgY3VycmVudGx5IG9ubHkpIEluZGV4ZWREQiBkYXRhYmFzZS4gVGhpcyBuYW1lIGlzXHJcbiAqIGFwcGVuZGVkIHRvIHRoZSBwcmVmaXggcHJvdmlkZWQgdG8gdGhlIEluZGV4ZWREYlBlcnNpc3RlbmNlIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuY29uc3QgTUFJTl9EQVRBQkFTRSA9ICdtYWluJztcclxuLyoqXHJcbiAqIEFuIEluZGV4ZWREQi1iYWNrZWQgaW5zdGFuY2Ugb2YgUGVyc2lzdGVuY2UuIERhdGEgaXMgc3RvcmVkIHBlcnNpc3RlbnRseVxyXG4gKiBhY3Jvc3Mgc2Vzc2lvbnMuXHJcbiAqXHJcbiAqIE9uIFdlYiBvbmx5LCB0aGUgRmlyZXN0b3JlIFNES3Mgc3VwcG9ydCBzaGFyZWQgYWNjZXNzIHRvIGl0cyBwZXJzaXN0ZW5jZVxyXG4gKiBsYXllci4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgYnJvd3NlciB0YWJzIHRvIHJlYWQgYW5kIHdyaXRlIHRvIEluZGV4ZWREYiBhbmRcclxuICogdG8gc3luY2hyb25pemUgc3RhdGUgZXZlbiB3aXRob3V0IG5ldHdvcmsgY29ubmVjdGl2aXR5LiBTaGFyZWQgYWNjZXNzIGlzXHJcbiAqIGN1cnJlbnRseSBvcHRpb25hbCBhbmQgbm90IGVuYWJsZWQgdW5sZXNzIGFsbCBjbGllbnRzIGludm9rZVxyXG4gKiBgZW5hYmxlUGVyc2lzdGVuY2UoKWAgd2l0aCBge3N5bmNocm9uaXplVGFiczp0cnVlfWAuXHJcbiAqXHJcbiAqIEluIG11bHRpLXRhYiBtb2RlLCBpZiBtdWx0aXBsZSBjbGllbnRzIGFyZSBhY3RpdmUgYXQgdGhlIHNhbWUgdGltZSwgdGhlIFNES1xyXG4gKiB3aWxsIGRlc2lnbmF0ZSBvbmUgY2xpZW50IGFzIHRoZSDigJxwcmltYXJ5IGNsaWVudOKAnS4gQW4gZWZmb3J0IGlzIG1hZGUgdG8gcGlja1xyXG4gKiBhIHZpc2libGUsIG5ldHdvcmstY29ubmVjdGVkIGFuZCBhY3RpdmUgY2xpZW50LCBhbmQgdGhpcyBjbGllbnQgaXNcclxuICogcmVzcG9uc2libGUgZm9yIGxldHRpbmcgb3RoZXIgY2xpZW50cyBrbm93IGFib3V0IGl0cyBwcmVzZW5jZS4gVGhlIHByaW1hcnlcclxuICogY2xpZW50IHdyaXRlcyBhIHVuaXF1ZSBjbGllbnQtZ2VuZXJhdGVkIGlkZW50aWZpZXIgKHRoZSBjbGllbnQgSUQpIHRvXHJcbiAqIEluZGV4ZWREYuKAmXMg4oCcb3duZXLigJ0gc3RvcmUgZXZlcnkgNCBzZWNvbmRzLiBJZiB0aGUgcHJpbWFyeSBjbGllbnQgZmFpbHMgdG9cclxuICogdXBkYXRlIHRoaXMgZW50cnksIGFub3RoZXIgY2xpZW50IGNhbiBhY3F1aXJlIHRoZSBsZWFzZSBhbmQgdGFrZSBvdmVyIGFzXHJcbiAqIHByaW1hcnkuXHJcbiAqXHJcbiAqIFNvbWUgcGVyc2lzdGVuY2Ugb3BlcmF0aW9ucyBpbiB0aGUgU0RLIGFyZSBkZXNpZ25hdGVkIGFzIHByaW1hcnktY2xpZW50IG9ubHlcclxuICogb3BlcmF0aW9ucy4gVGhpcyBpbmNsdWRlcyB0aGUgYWNrbm93bGVkZ21lbnQgb2YgbXV0YXRpb25zIGFuZCBhbGwgdXBkYXRlcyBvZlxyXG4gKiByZW1vdGUgZG9jdW1lbnRzLiBUaGUgZWZmZWN0cyBvZiB0aGVzZSBvcGVyYXRpb25zIGFyZSB3cml0dGVuIHRvIHBlcnNpc3RlbmNlXHJcbiAqIGFuZCB0aGVuIGJyb2FkY2FzdCB0byBvdGhlciB0YWJzIHZpYSBMb2NhbFN0b3JhZ2UgKHNlZVxyXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCksIHdoaWNoIHRoZW4gcmVmcmVzaCB0aGVpciBzdGF0ZSBmcm9tXHJcbiAqIHBlcnNpc3RlbmNlLlxyXG4gKlxyXG4gKiBTaW1pbGFybHksIHRoZSBwcmltYXJ5IGNsaWVudCBsaXN0ZW5zIHRvIG5vdGlmaWNhdGlvbnMgc2VudCBieSBzZWNvbmRhcnlcclxuICogY2xpZW50cyB0byBkaXNjb3ZlciBwZXJzaXN0ZW5jZSBjaGFuZ2VzIHdyaXR0ZW4gYnkgc2Vjb25kYXJ5IGNsaWVudHMsIHN1Y2ggYXNcclxuICogdGhlIGFkZGl0aW9uIG9mIG5ldyBtdXRhdGlvbnMgYW5kIHF1ZXJ5IHRhcmdldHMuXHJcbiAqXHJcbiAqIElmIG11bHRpLXRhYiBpcyBub3QgZW5hYmxlZCBhbmQgYW5vdGhlciB0YWIgYWxyZWFkeSBvYnRhaW5lZCB0aGUgcHJpbWFyeVxyXG4gKiBsZWFzZSwgSW5kZXhlZERiUGVyc2lzdGVuY2UgZW50ZXJzIGEgZmFpbGVkIHN0YXRlIGFuZCBhbGwgc3Vic2VxdWVudFxyXG4gKiBvcGVyYXRpb25zIHdpbGwgYXV0b21hdGljYWxseSBmYWlsLlxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHksIHRoZXJlIGlzIGFuIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gYSB0YWIgaXMgY2xvc2VkLCB0aGVcclxuICogcHJpbWFyeSBsZWFzZSBpcyByZWxlYXNlZCBpbW1lZGlhdGVseSAodGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCB0byBtYWtlXHJcbiAqIHN1cmUgdGhhdCBhIHJlZnJlc2hlZCB0YWIgaXMgYWJsZSB0byBpbW1lZGlhdGVseSByZS1hY3F1aXJlIHRoZSBwcmltYXJ5XHJcbiAqIGxlYXNlKS4gVW5mb3J0dW5hdGVseSwgSW5kZXhlZERCIGNhbm5vdCBiZSByZWxpYWJseSB1c2VkIGluIHdpbmRvdy51bmxvYWRcclxuICogc2luY2UgaXQgaXMgYW4gYXN5bmNocm9ub3VzIEFQSS4gU28gaW4gYWRkaXRpb24gdG8gYXR0ZW1wdGluZyB0byBnaXZlIHVwIHRoZVxyXG4gKiBsZWFzZSwgdGhlIGxlYXNlaG9sZGVyIHdyaXRlcyBpdHMgY2xpZW50IElEIHRvIGEgXCJ6b21iaWVkQ2xpZW50XCIgZW50cnkgaW5cclxuICogTG9jYWxTdG9yYWdlIHdoaWNoIGFjdHMgYXMgYW4gaW5kaWNhdG9yIHRoYXQgYW5vdGhlciB0YWIgc2hvdWxkIGdvIGFoZWFkIGFuZFxyXG4gKiB0YWtlIHRoZSBwcmltYXJ5IGxlYXNlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbGVhc2UgdGltZXN0YW1wLlxyXG4gKlxyXG4gKiBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIGBzeW5jaHJvbml6ZVRhYnNgIHNlY3Rpb24gd2hlbiBtdWx0aS10YWIgaXMgbm9cclxuICogbG9uZ2VyIG9wdGlvbmFsLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiUGVyc2lzdGVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc3luY2hyb25pemUgdGhlIGluLW1lbW9yeSBzdGF0ZSBvZiBtdWx0aXBsZSB0YWJzIGFuZCBzaGFyZVxyXG4gICAgICogYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxyXG4gICAgICovXHJcbiAgICBhbGxvd1RhYlN5bmNocm9uaXphdGlvbiwgcGVyc2lzdGVuY2VLZXksIGNsaWVudElkLCBscnVQYXJhbXMsIHF1ZXVlLCB3aW5kb3csIGRvY3VtZW50LCBzZXJpYWxpemVyLCBzZXF1ZW5jZU51bWJlclN5bmNlciwgXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCBmb3JjZWZ1bGx5IG9idGFpbnMgZGF0YWJhc2UgYWNjZXNzLiBFeGlzdGluZyB0YWJzIHdpbGxcclxuICAgICAqIG5vIGxvbmdlciBiZSBhYmxlIHRvIGFjY2VzcyBJbmRleGVkREIuXHJcbiAgICAgKi9cclxuICAgIGZvcmNlT3duaW5nVGFiLCBzY2hlbWFWZXJzaW9uID0gU0NIRU1BX1ZFUlNJT04pIHtcclxuICAgICAgICB0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uID0gYWxsb3dUYWJTeW5jaHJvbml6YXRpb247XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJTeW5jZXIgPSBzZXF1ZW5jZU51bWJlclN5bmNlcjtcclxuICAgICAgICB0aGlzLmZvcmNlT3duaW5nVGFiID0gZm9yY2VPd25pbmdUYWI7XHJcbiAgICAgICAgdGhpcy5zY2hlbWFWZXJzaW9uID0gc2NoZW1hVmVyc2lvbjtcclxuICAgICAgICB0aGlzLmxpc3RlblNlcXVlbmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm5ldHdvcmtFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAvKiogT3VyIHdpbmRvdy51bmxvYWQgaGFuZGxlciwgaWYgcmVnaXN0ZXJlZC4gKi9cclxuICAgICAgICB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5Gb3JlZ3JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIE91ciAndmlzaWJpbGl0eWNoYW5nZScgbGlzdGVuZXIgaWYgcmVnaXN0ZXJlZC4gKi9cclxuICAgICAgICB0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKiBUaGUgY2xpZW50IG1ldGFkYXRhIHJlZnJlc2ggdGFzay4gKi9cclxuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcclxuICAgICAgICAvKiogVGhlIGxhc3QgdGltZSB3ZSBnYXJiYWdlIGNvbGxlY3RlZCB0aGUgY2xpZW50IG1ldGFkYXRhIG9iamVjdCBzdG9yZS4gKi9cclxuICAgICAgICB0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgLyoqIEEgbGlzdGVuZXIgdG8gbm90aWZ5IG9uIHByaW1hcnkgc3RhdGUgY2hhbmdlcy4gKi9cclxuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gXyA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICBpZiAoIUluZGV4ZWREYlBlcnNpc3RlbmNlLmlzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IG5ldyBJbmRleGVkRGJMcnVEZWxlZ2F0ZUltcGwodGhpcywgbHJ1UGFyYW1zKTtcclxuICAgICAgICB0aGlzLmRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgTG9jYWxTZXJpYWxpemVyKHNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlRGIgPSBuZXcgU2ltcGxlRGIodGhpcy5kYk5hbWUsIHRoaXMuc2NoZW1hVmVyc2lvbiwgbmV3IFNjaGVtYUNvbnZlcnRlcih0aGlzLnNlcmlhbGl6ZXIpKTtcclxuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IEluZGV4ZWREYlRhcmdldENhY2hlKHRoaXMucmVmZXJlbmNlRGVsZWdhdGUsIHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlID0gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBuZXcgSW5kZXhlZERiQnVuZGxlQ2FjaGUoKTtcclxuICAgICAgICBpZiAodGhpcy53aW5kb3cgJiYgdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZSA9IHRoaXMud2luZG93LmxvY2FsU3RvcmFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZU93bmluZ1RhYiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYywgJ0xvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZS4gQXMgYSByZXN1bHQsIHBlcnNpc3RlbmNlIG1heSBub3Qgd29yayAnICtcclxuICAgICAgICAgICAgICAgICAgICAncmVsaWFibHkuIEluIHBhcnRpY3VsYXIgZW5hYmxlUGVyc2lzdGVuY2UoKSBjb3VsZCBmYWlsIGltbWVkaWF0ZWx5ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciByZWZyZXNoaW5nIHRoZSBwYWdlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0IHRvIHN0YXJ0IEluZGV4ZWREYiBwZXJzaXN0ZW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHBlcnNpc3RlbmNlIHdhcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGV4cGVjdGVkIHRvIGZhaWwgc29tZXRpbWVzIChpbiB0aGUgY2FzZSBvZiBhbm90aGVyIHRhYlxyXG4gICAgICAgIC8vIGFscmVhZHkgaGF2aW5nIHRoZSBwZXJzaXN0ZW5jZSBsb2NrKSwgc28gaXQncyB0aGUgZmlyc3QgdGhpbmcgd2Ugc2hvdWxkXHJcbiAgICAgICAgLy8gZG8uXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmltYXJ5ICYmICF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGYWlsIGBzdGFydCgpYCBpZiBgc3luY2hyb25pemVUYWJzYCBpcyBkaXNhYmxlZCBhbmQgd2UgY2Fubm90XHJcbiAgICAgICAgICAgICAgICAvLyBvYnRhaW4gdGhlIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRhY2hXaW5kb3dVbmxvYWRIb29rKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDbGllbnRNZXRhZGF0YUFuZFByaW1hcnlMZWFzZVJlZnJlc2hlcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbignZ2V0SGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyJywgJ3JlYWRvbmx5JywgdHhuID0+IHRoaXMudGFyZ2V0Q2FjaGUuZ2V0SGlnaGVzdFNlcXVlbmNlTnVtYmVyKHR4bikpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBuZXcgTGlzdGVuU2VxdWVuY2UoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCB0aGlzLnNlcXVlbmNlTnVtYmVyU3luY2VyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNpbXBsZURiICYmIHRoaXMuc2ltcGxlRGIuY2xvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgcHJpbWFyeSBzdGF0ZSBvZiB0aGVcclxuICAgICAqIGluc3RhbmNlIGNoYW5nZXMuIFVwb24gcmVnaXN0ZXJpbmcsIHRoaXMgbGlzdGVuZXIgaXMgaW52b2tlZCBpbW1lZGlhdGVseVxyXG4gICAgICogd2l0aCB0aGUgY3VycmVudCBwcmltYXJ5IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXHJcbiAgICAgKi9cclxuICAgIHNldFByaW1hcnlTdGF0ZUxpc3RlbmVyKHByaW1hcnlTdGF0ZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lciA9IGFzeW5jIChwcmltYXJ5U3RhdGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW1hcnlTdGF0ZUxpc3RlbmVyKHByaW1hcnlTdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwcmltYXJ5U3RhdGVMaXN0ZW5lcih0aGlzLmlzUHJpbWFyeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgcmVjZWl2ZXMgYVxyXG4gICAgICogdmVyc2lvbiBjaGFuZ2UgZXZlbnQgaW5kaWNhdGluZyB0aGF0IGl0IGhhcyBkZWxldGVkLlxyXG4gICAgICpcclxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXHJcbiAgICAgKi9cclxuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVEYi5zZXRWZXJzaW9uQ2hhbmdlTGlzdGVuZXIoYXN5bmMgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBkZWxldGUgSW5kZXhlZERCLlxyXG4gICAgICAgICAgICBpZiAoZXZlbnQubmV3VmVyc2lvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUgaW4gdGhlIGNsaWVudCdzIG1ldGFkYXRhLCBwb3RlbnRpYWxseVxyXG4gICAgICogYWZmZWN0aW5nIHRoZSBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICpcclxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXHJcbiAgICAgKi9cclxuICAgIHNldE5ldHdvcmtFbmFibGVkKG5ldHdvcmtFbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgIT09IG5ldHdvcmtFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSBuZXR3b3JrRW5hYmxlZDtcclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBwcmltYXJ5IGxlYXNlIHJlZnJlc2ggZm9yIGltbWVkaWF0ZSBleGVjdXRpb24uIFRoZSBldmVudHVhbFxyXG4gICAgICAgICAgICAvLyBsZWFzZSB1cGRhdGUgd2lsbCBiZSBwcm9wYWdhdGVkIHZpYSBgcHJpbWFyeVN0YXRlTGlzdGVuZXJgLlxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgY2xpZW50IG1ldGFkYXRhIGluIEluZGV4ZWREYiBhbmQgYXR0ZW1wdHMgdG8gZWl0aGVyIG9idGFpbiBvclxyXG4gICAgICogZXh0ZW5kIHRoZSBwcmltYXJ5IGxlYXNlIGZvciB0aGUgbG9jYWwgY2xpZW50LiBBc3luY2hyb25vdXNseSBub3RpZmllcyB0aGVcclxuICAgICAqIHByaW1hcnkgc3RhdGUgbGlzdGVuZXIgaWYgdGhlIGNsaWVudCBlaXRoZXIgbmV3bHkgb2J0YWluZWQgb3IgcmVsZWFzZWQgaXRzXHJcbiAgICAgKiBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJhbnNhY3Rpb24oJ3VwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeScsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFTdG9yZVxyXG4gICAgICAgICAgICAgICAgLnB1dCh7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWVNczogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgIG5ldHdvcmtFbmFibGVkOiB0aGlzLm5ldHdvcmtFbmFibGVkLFxyXG4gICAgICAgICAgICAgICAgaW5Gb3JlZ3JvdW5kOiB0aGlzLmluRm9yZWdyb3VuZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5UHJpbWFyeUxlYXNlKHR4bikubmV4dChzdWNjZXNzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5jYW5BY3RBc1ByaW1hcnkodHhuKSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KGNhbkFjdEFzUHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgJiYgIWNhbkFjdEFzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKS5uZXh0KCgpID0+IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbkFjdEFzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pLm5leHQoKCkgPT4gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyogY2FuQWN0QXNQcmltYXJ5PSAqLyBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdGYWlsZWQgdG8gZXh0ZW5kIG93bmVyIGxlYXNlOiAnLCBlKTtcclxuICAgICAgICAgICAgICAgIC8vIFByb2NlZWQgd2l0aCB0aGUgZXhpc3Rpbmcgc3RhdGUuIEFueSBzdWJzZXF1ZW50IGFjY2VzcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlZERCIHdpbGwgdmVyaWZ5IHRoZSBsZWFzZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUHJpbWFyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnUmVsZWFzaW5nIG93bmVyIGxlYXNlIGFmdGVyIGVycm9yIGR1cmluZyBsZWFzZSByZWZyZXNoJywgZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAvKiBpc1ByaW1hcnk9ICovIGZhbHNlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGlzUHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAhPT0gaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihpc1ByaW1hcnkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGlzUHJpbWFyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZlcmlmeVByaW1hcnlMZWFzZSh0eG4pIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xyXG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5pc0xvY2FsQ2xpZW50KHByaW1hcnlDbGllbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNsaWVudE1ldGFkYXRhKHR4bikge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhU3RvcmUgPSBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUuZGVsZXRlKHRoaXMuY2xpZW50SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRocmVzaG9sZCBoYXMgcGFzc2VkLCBwcnVuZXMgdGhlXHJcbiAgICAgKiBSZW1vdGVEb2N1bWVudENoYW5nZXMgYW5kIHRoZSBDbGllbnRNZXRhZGF0YSBzdG9yZSBiYXNlZCBvbiB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAqIHRpbWUgb2YgYWxsIGNsaWVudHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIG1heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5pc1dpdGhpbkFnZSh0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUsIE1BWF9DTElFTlRfQUdFX01TKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmFjdGl2ZUNsaWVudHMgPSBhd2FpdCB0aGlzLnJ1blRyYW5zYWN0aW9uKCdtYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZScsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gZ2V0U3RvcmUodHhuLCBEYkNsaWVudE1ldGFkYXRhU3RvcmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdDbGllbnRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfQ0xJRU5UX0FHRV9NUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBleGlzdGluZ0NsaWVudHMuZmlsdGVyKGNsaWVudCA9PiBhY3RpdmUuaW5kZXhPZihjbGllbnQpID09PSAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG1ldGFkYXRhIGZvciBjbGllbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBjb25zaWRlcmVkIGFjdGl2ZS5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5hY3RpdmUsIChpbmFjdGl2ZUNsaWVudCkgPT4gbWV0YWRhdGFTdG9yZS5kZWxldGUoaW5hY3RpdmVDbGllbnQuY2xpZW50SWQpKS5uZXh0KCgpID0+IGluYWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcHJpbWFyeSBsZWFzZSB2aW9sYXRpb25zIG9yIGFueSBvdGhlciB0eXBlIG9mIGVycm9yLiBUaGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSB3aWxsIHJ1biBgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKWAgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgYGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcygpYCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGRlcGVuZFxyXG4gICAgICAgICAgICAgICAgLy8gb24gTG9jYWxTdG9yZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwb3RlbnRpYWwgbGVmdG92ZXIgZW50cmllcyB0aGF0IG1heSBjb250aW51ZSB0byBtYXJrIHRoZVxyXG4gICAgICAgICAgICAvLyBpbmFjdGl2ZSBjbGllbnRzIGFzIHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlLlxyXG4gICAgICAgICAgICAvLyBJZGVhbGx5IHdlJ2QgZGVsZXRlIHRoZSBJbmRleGVkRGIgYW5kIExvY2FsU3RvcmFnZSB6b21iaWUgZW50cmllcyBmb3JcclxuICAgICAgICAgICAgLy8gdGhlIGNsaWVudCBhdG9taWNhbGx5LCBidXQgd2UgY2FuJ3QuIFNvIHdlIG9wdCB0byBkZWxldGUgdGhlIEluZGV4ZWREYlxyXG4gICAgICAgICAgICAvLyBlbnRyaWVzIGZpcnN0IHRvIGF2b2lkIHBvdGVudGlhbGx5IHJldml2aW5nIGEgem9tYmllZCBjbGllbnQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLndlYlN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5hY3RpdmVDbGllbnQgb2YgaW5hY3RpdmVDbGllbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhIHJlY3VycmluZyB0aW1lciB0byB1cGRhdGUgdGhlIGNsaWVudCBtZXRhZGF0YSBhbmQgdG8gZWl0aGVyXHJcbiAgICAgKiBleHRlbmQgb3IgYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSBpZiB0aGUgY2xpZW50IGlzIGVsaWdpYmxlLlxyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCkge1xyXG4gICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwiY2xpZW50X21ldGFkYXRhX3JlZnJlc2hcIiAvKiBUaW1lcklkLkNsaWVudE1ldGFkYXRhUmVmcmVzaCAqLywgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMsICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMubWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVDbGllbnRNZXRhZGF0YUFuZFByaW1hcnlMZWFzZVJlZnJlc2hlcygpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBDaGVja3Mgd2hldGhlciBgY2xpZW50YCBpcyB0aGUgbG9jYWwgY2xpZW50LiAqL1xyXG4gICAgaXNMb2NhbENsaWVudChjbGllbnQpIHtcclxuICAgICAgICByZXR1cm4gY2xpZW50ID8gY2xpZW50Lm93bmVySWQgPT09IHRoaXMuY2xpZW50SWQgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXZhbHVhdGUgdGhlIHN0YXRlIG9mIGFsbCBhY3RpdmUgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGxvY2FsXHJcbiAgICAgKiBjbGllbnQgaXMgb3IgY2FuIGFjdCBhcyB0aGUgaG9sZGVyIG9mIHRoZSBwcmltYXJ5IGxlYXNlLiBSZXR1cm5zIHdoZXRoZXJcclxuICAgICAqIHRoZSBjbGllbnQgaXMgZWxpZ2libGUgZm9yIHRoZSBsZWFzZSwgYnV0IGRvZXMgbm90IGFjdHVhbGx5IGFjcXVpcmUgaXQuXHJcbiAgICAgKiBNYXkgcmV0dXJuICdmYWxzZScgZXZlbiBpZiB0aGVyZSBpcyBubyBhY3RpdmUgbGVhc2Vob2xkZXIgYW5kIGFub3RoZXJcclxuICAgICAqIChmb3JlZ3JvdW5kKSBjbGllbnQgc2hvdWxkIGJlY29tZSBsZWFzZWhvbGRlciBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBjYW5BY3RBc1ByaW1hcnkodHhuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VPd25pbmdUYWIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xyXG4gICAgICAgIHJldHVybiBzdG9yZVxyXG4gICAgICAgICAgICAuZ2V0KERiUHJpbWFyeUNsaWVudEtleSlcclxuICAgICAgICAgICAgLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGVhc2VJc1ZhbGlkID0gY3VycmVudFByaW1hcnkgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xyXG4gICAgICAgICAgICAvLyBBIGNsaWVudCBpcyBlbGlnaWJsZSBmb3IgdGhlIHByaW1hcnkgbGVhc2UgaWY6XHJcbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGUgZm9yZWdyb3VuZC5cclxuICAgICAgICAgICAgLy8gLSBpdHMgbmV0d29yayBpcyBlbmFibGVkIGFuZCBubyBvdGhlciBjbGllbnQncyB0YWIgaXMgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vICAgZm9yZWdyb3VuZC5cclxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIHRoZSBjbGllbnQncyB0YWIgaXMgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vICAgZm9yZWdyb3VuZC5cclxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIG5vIG90aGVyIGNsaWVudCdzIHRhYiBpcyBpblxyXG4gICAgICAgICAgICAvLyAgIHRoZSBmb3JlZ3JvdW5kLlxyXG4gICAgICAgICAgICAvLyAtIHRoZSBgZm9yY2VPd25pbmdUYWJgIHNldHRpbmcgd2FzIHBhc3NlZCBpbi5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFzZUlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpICYmIHRoaXMubmV0d29ya0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByaW1hcnkuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFpbCB0aGUgYGNhbkFjdEFzUHJpbWFyeWAgY2hlY2sgaWYgdGhlIGN1cnJlbnQgbGVhc2Vob2xkZXIgaGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvcHRlZCBpbnRvIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uIElmIHRoaXMgaGFwcGVucyBhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQgc3RhcnR1cCwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBlbmFibGVQZXJzaXN0ZW5jZSgpYCBhbmQgdGhlIHVzZXIgY2FuIGNvbnRpbnVlIHRvIHVzZSBGaXJlc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbHMgZHVyaW5nIGEgbGVhc2UgcmVmcmVzaCwgd2Ugd2lsbCBpbnN0ZWFkIGJsb2NrIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3luY1F1ZXVlIGZyb20gZXhlY3V0aW5nIGZ1cnRoZXIgb3BlcmF0aW9ucy4gTm90ZSB0aGF0IHRoaXMgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSBzaW5jZSBtaXhpbmcgJiBtYXRjaGluZyBkaWZmZXJlbnQgYHN5bmNocm9uaXplVGFic2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZ3MgaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciBiZSB0dXJuZWQgb2ZmLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgJiYgdGhpcy5pbkZvcmVncm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bilcclxuICAgICAgICAgICAgICAgIC5sb2FkQWxsKClcclxuICAgICAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFsbCBleGlzdGluZyBjbGllbnRzIGFuZCBkZXRlcm1pbmUgd2hldGhlciBhdCBsZWFzdCBvbmUgb2ZcclxuICAgICAgICAgICAgICAgIC8vIHRoZW0gaXMgYmV0dGVyIHN1aXRlZCB0byBvYnRhaW4gdGhlIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRDYW5kaWRhdGUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpLmZpbmQob3RoZXJDbGllbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudElkICE9PSBvdGhlckNsaWVudC5jbGllbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlck5ldHdvcmtTdGF0ZSA9ICF0aGlzLm5ldHdvcmtFbmFibGVkICYmIG90aGVyQ2xpZW50Lm5ldHdvcmtFbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgPSAhdGhpcy5pbkZvcmVncm91bmQgJiYgb3RoZXJDbGllbnQuaW5Gb3JlZ3JvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc1NhbWVOZXR3b3JrU3RhdGUgPSB0aGlzLm5ldHdvcmtFbmFibGVkID09PSBvdGhlckNsaWVudC5uZXR3b3JrRW5hYmxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ2xpZW50SGFzQmV0dGVyTmV0d29ya1N0YXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3RoZXJDbGllbnRIYXNCZXR0ZXJWaXNpYmlsaXR5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDbGllbnRIYXNTYW1lTmV0d29ya1N0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZmVycmVkQ2FuZGlkYXRlID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KGNhbkFjdEFzUHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAhPT0gY2FuQWN0QXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJHtjYW5BY3RBc1ByaW1hcnkgPyAnaXMnIDogJ2lzIG5vdCd9IGVsaWdpYmxlIGZvciBhIHByaW1hcnkgbGVhc2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbkFjdEFzUHJpbWFyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNodXRkb3duKCkge1xyXG4gICAgICAgIC8vIFRoZSBzaHV0ZG93bigpIG9wZXJhdGlvbnMgYXJlIGlkZW1wb3RlbnQgYW5kIGNhbiBiZSBjYWxsZWQgZXZlbiB3aGVuXHJcbiAgICAgICAgLy8gc3RhcnQoKSBhYm9ydGVkIChlLmcuIGJlY2F1c2UgaXQgY291bGRuJ3QgYWNxdWlyZSB0aGUgcGVyc2lzdGVuY2UgbGVhc2UpLlxyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGV0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKTtcclxuICAgICAgICB0aGlzLmRldGFjaFdpbmRvd1VubG9hZEhvb2soKTtcclxuICAgICAgICAvLyBVc2UgYFNpbXBsZURiLnJ1blRyYW5zYWN0aW9uYCBkaXJlY3RseSB0byBhdm9pZCBmYWlsaW5nIGlmIGFub3RoZXIgdGFiXHJcbiAgICAgICAgLy8gaGFzIG9idGFpbmVkIHRoZSBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICAgIGF3YWl0IHRoaXMuc2ltcGxlRGIucnVuVHJhbnNhY3Rpb24oJ3NodXRkb3duJywgJ3JlYWR3cml0ZScsIFtEYlByaW1hcnlDbGllbnRTdG9yZSwgRGJDbGllbnRNZXRhZGF0YVN0b3JlXSwgc2ltcGxlRGJUeG4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uID0gbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uKHNpbXBsZURiVHhuLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsZWFzZVByaW1hcnlMZWFzZUlmSGVsZChwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHRoaXMucmVtb3ZlQ2xpZW50TWV0YWRhdGEocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlRGIuY2xvc2UoKTtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGVudHJ5IG1hcmtpbmcgdGhlIGNsaWVudCBhcyB6b21iaWVkIGZyb20gTG9jYWxTdG9yYWdlIHNpbmNlXHJcbiAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgaXRzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLlxyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xpZW50Wm9tYmllZEVudHJ5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY2xpZW50cyB0aGF0IGFyZSBub3Qgem9tYmllZCBhbmQgaGF2ZSBhbiB1cGRhdGVUaW1lIHdpdGhpbiB0aGVcclxuICAgICAqIHByb3ZpZGVkIHRocmVzaG9sZC5cclxuICAgICAqL1xyXG4gICAgZmlsdGVyQWN0aXZlQ2xpZW50cyhjbGllbnRzLCBhY3Rpdml0eVRocmVzaG9sZE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsaWVudHMuZmlsdGVyKGNsaWVudCA9PiB0aGlzLmlzV2l0aGluQWdlKGNsaWVudC51cGRhdGVUaW1lTXMsIGFjdGl2aXR5VGhyZXNob2xkTXMpICYmXHJcbiAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjbGllbnQuY2xpZW50SWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuIElmIG11bHRpLXRhYlxyXG4gICAgICogaXMgbm90IHN1cHBvcnRlZCwgcmV0dXJucyBhbiBhcnJheSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGxvY2FsIGNsaWVudCdzXHJcbiAgICAgKiBJRC5cclxuICAgICAqXHJcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxyXG4gICAgICovXHJcbiAgICBnZXRBY3RpdmVDbGllbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRBY3RpdmVDbGllbnRzJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKVxyXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoY2xpZW50cyA9PiB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgTUFYX0NMSUVOVF9BR0VfTVMpLm1hcChjbGllbnRNZXRhZGF0YSA9PiBjbGllbnRNZXRhZGF0YS5jbGllbnRJZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRNdXRhdGlvblF1ZXVlKHVzZXIsIGluZGV4TWFuYWdlcikge1xyXG4gICAgICAgIHJldHVybiBJbmRleGVkRGJNdXRhdGlvblF1ZXVlLmZvclVzZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0Q2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVEb2N1bWVudENhY2hlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleE1hbmFnZXIodXNlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiSW5kZXhNYW5hZ2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLmRhdGFiYXNlSWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRPdmVybGF5Q2FjaGUodXNlcikge1xyXG4gICAgICAgIHJldHVybiBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZS5mb3JVc2VyKHRoaXMuc2VyaWFsaXplciwgdXNlcik7XHJcbiAgICB9XHJcbiAgICBnZXRCdW5kbGVDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcclxuICAgIH1cclxuICAgIHJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgbW9kZSwgdHJhbnNhY3Rpb25PcGVyYXRpb24pIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHNpbXBsZURiTW9kZSA9IG1vZGUgPT09ICdyZWFkb25seScgPyAncmVhZG9ubHknIDogJ3JlYWR3cml0ZSc7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmVzID0gZ2V0T2JqZWN0U3RvcmVzKHRoaXMuc2NoZW1hVmVyc2lvbik7XHJcbiAgICAgICAgbGV0IHBlcnNpc3RlbmNlVHJhbnNhY3Rpb247XHJcbiAgICAgICAgLy8gRG8gYWxsIHRyYW5zYWN0aW9ucyBhcyByZWFkd3JpdGUgYWdhaW5zdCBhbGwgb2JqZWN0IHN0b3Jlcywgc2luY2Ugd2VcclxuICAgICAgICAvLyBhcmUgdGhlIG9ubHkgcmVhZGVyL3dyaXRlci5cclxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVEYlxyXG4gICAgICAgICAgICAucnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBzaW1wbGVEYk1vZGUsIG9iamVjdFN0b3Jlcywgc2ltcGxlRGJUeG4gPT4ge1xyXG4gICAgICAgICAgICBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uID0gbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uKHNpbXBsZURiVHhuLCB0aGlzLmxpc3RlblNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMubGlzdGVuU2VxdWVuY2UubmV4dCgpXHJcbiAgICAgICAgICAgICAgICA6IExpc3RlblNlcXVlbmNlLklOVkFMSUQpO1xyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZS1wcmltYXJ5Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgbWVyZWx5IHZlcmlmeSB0aGF0IHdlIGhhdmUgKG9yIGNhbiBhY3F1aXJlKSB0aGUgbGVhc2VcclxuICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5LCB3ZSB3YWl0IHRvIGV4dGVuZCB0aGUgcHJpbWFyeSBsZWFzZSB1bnRpbCBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0aW5nIHRyYW5zYWN0aW9uT3BlcmF0aW9uKCkuIFRoaXMgZW5zdXJlcyB0aGF0IGV2ZW4gaWYgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbk9wZXJhdGlvbiB0YWtlcyBhIGxvbmcgdGltZSwgd2UnbGwgdXNlIGEgcmVjZW50XHJcbiAgICAgICAgICAgICAgICAvLyBsZWFzZVRpbWVzdGFtcE1zIGluIHRoZSBleHRlbmRlZCAob3IgbmV3bHkgYWNxdWlyZWQpIGxlYXNlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5UHJpbWFyeUxlYXNlKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkc1ByaW1hcnlMZWFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyogaG9sZHNQcmltYXJ5TGVhc2U9ICovIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbkFjdEFzUHJpbWFyeShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9sZHNQcmltYXJ5TGVhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXJyb3IoYEZhaWxlZCB0byBvYnRhaW4gcHJpbWFyeSBsZWFzZSBmb3IgYWN0aW9uICcke2FjdGlvbn0nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0xPU1RfRVJST1JfTVNHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uT3BlcmF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUFsbG93VGFiU3luY2hyb25pemF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pLm5leHQoKCkgPT4gdHJhbnNhY3Rpb25PcGVyYXRpb24ocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCB0YWIgaXMgdGhlIHByaW1hcnkgbGVhc2Vob2xkZXIgb3IgYWx0ZXJuYXRpdmVseVxyXG4gICAgICogdGhhdCB0aGUgbGVhc2Vob2xkZXIgaGFzIG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuIG5vIGxvbmdlclxyXG4gICAgLy8gYmUgdHVybmVkIG9mZi5cclxuICAgIHZlcmlmeUFsbG93VGFiU3luY2hyb25pemF0aW9uKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGVhc2VJc1ZhbGlkID0gY3VycmVudFByaW1hcnkgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCAmJiAhdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlT3duaW5nVGFiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50UHJpbWFyeS5hbGxvd1RhYlN5bmNocm9uaXphdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgb3IgZXh0ZW5kcyB0aGUgbmV3IHByaW1hcnkgbGVhc2UgZm9yIHRoZSBsb2NhbCBjbGllbnQuIFRoaXNcclxuICAgICAqIG1ldGhvZCBkb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGlzIGxlYXNlLlxyXG4gICAgICovXHJcbiAgICBhY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UodHhuKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UHJpbWFyeSA9IHtcclxuICAgICAgICAgICAgb3duZXJJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgYWxsb3dUYWJTeW5jaHJvbml6YXRpb246IHRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24sXHJcbiAgICAgICAgICAgIGxlYXNlVGltZXN0YW1wTXM6IERhdGUubm93KClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKS5wdXQoRGJQcmltYXJ5Q2xpZW50S2V5LCBuZXdQcmltYXJ5KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gU2ltcGxlRGIuaXNBdmFpbGFibGUoKTtcclxuICAgIH1cclxuICAgIC8qKiBDaGVja3MgdGhlIHByaW1hcnkgbGVhc2UgYW5kIHJlbW92ZXMgaXQgaWYgd2UgYXJlIHRoZSBjdXJyZW50IHByaW1hcnkuICovXHJcbiAgICByZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQocHJpbWFyeUNsaWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQocHJpbWFyeUNsaWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgJ1JlbGVhc2luZyBwcmltYXJ5IGxlYXNlLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShEYlByaW1hcnlDbGllbnRLZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBWZXJpZmllcyB0aGF0IGB1cGRhdGVUaW1lTXNgIGlzIHdpdGhpbiBgbWF4QWdlTXNgLiAqL1xyXG4gICAgaXNXaXRoaW5BZ2UodXBkYXRlVGltZU1zLCBtYXhBZ2VNcykge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgbWluQWNjZXB0YWJsZSA9IG5vdyAtIG1heEFnZU1zO1xyXG4gICAgICAgIGNvbnN0IG1heEFjY2VwdGFibGUgPSBub3c7XHJcbiAgICAgICAgaWYgKHVwZGF0ZVRpbWVNcyA8IG1pbkFjY2VwdGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh1cGRhdGVUaW1lTXMgPiBtYXhBY2NlcHRhYmxlKSB7XHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKGBEZXRlY3RlZCBhbiB1cGRhdGUgdGltZSB0aGF0IGlzIGluIHRoZSBmdXR1cmU6ICR7dXBkYXRlVGltZU1zfSA+ICR7bWF4QWNjZXB0YWJsZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGF0dGFjaFZpc2liaWxpdHlIYW5kbGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50ICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSB0aGlzLmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRldGFjaFZpc2liaWxpdHlIYW5kbGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgd2luZG93LnVubG9hZCBoYW5kbGVyIHRoYXQgd2lsbCBzeW5jaHJvbm91c2x5IHdyaXRlIG91clxyXG4gICAgICogY2xpZW50SWQgdG8gYSBcInpvbWJpZSBjbGllbnQgaWRcIiBsb2NhdGlvbiBpbiBMb2NhbFN0b3JhZ2UuIFRoaXMgY2FuIGJlIHVzZWRcclxuICAgICAqIGJ5IHRhYnMgdHJ5aW5nIHRvIGFjcXVpcmUgdGhlIHByaW1hcnkgbGVhc2UgdG8gZGV0ZXJtaW5lIHRoYXQgdGhlIGxlYXNlXHJcbiAgICAgKiBpcyBubyBsb25nZXIgdmFsaWQgZXZlbiBpZiB0aGUgdGltZXN0YW1wIGlzIHJlY2VudC4gVGhpcyBpcyBwYXJ0aWN1bGFybHlcclxuICAgICAqIGltcG9ydGFudCBmb3IgdGhlIHJlZnJlc2ggY2FzZSAoc28gdGhlIHRhYiBjb3JyZWN0bHkgcmUtYWNxdWlyZXMgdGhlXHJcbiAgICAgKiBwcmltYXJ5IGxlYXNlKS4gTG9jYWxTdG9yYWdlIGlzIHVzZWQgZm9yIHRoaXMgcmF0aGVyIHRoYW4gSW5kZXhlZERiIGJlY2F1c2VcclxuICAgICAqIGl0IGlzIGEgc3luY2hyb25vdXMgQVBJIGFuZCBzbyBjYW4gYmUgdXNlZCByZWxpYWJseSBmcm9tICBhbiB1bmxvYWRcclxuICAgICAqIGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKChfYSA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogSW4gdGhlb3J5LCB0aGlzIHNob3VsZCBiZSBzY2hlZHVsZWQgb24gdGhlIEFzeW5jUXVldWUgc2luY2UgaXRcclxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzc2VzIGludGVybmFsIHN0YXRlLiBXZSBleGVjdXRlIHRoaXMgY29kZSBkaXJlY3RseSBkdXJpbmcgc2h1dGRvd25cclxuICAgICAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdCBnZXRzIGEgY2hhbmNlIHRvIHJ1bi5cclxuICAgICAgICAgICAgICAgIHRoaXMubWFya0NsaWVudFpvbWJpZWQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXggPSAvKD86VmVyc2lvbnxNb2JpbGUpXFwvMVs0NTZdLztcclxuICAgICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goc2FmYXJpSW5kZXhkYkJ1Z1ZlcnNpb25SZWdleCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gU2FmYXJpIDE0LCAxNSwgYW5kIDE2LCB3ZSBkbyBub3QgcnVuIGFueSBjbGVhbnVwIGFjdGlvbnMgYXMgaXQgbWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgYnVnIHRoYXQgcHJldmVudHMgU2FmYXJpIGZyb20gcmUtb3BlbmluZyBJbmRleGVkREIgZHVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgcGFnZSBsb2FkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2NTQ3XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKC8qIHB1cmdlRXhpc3RpbmdUYXNrcz0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgZ3JhY2VmdWwgc2h1dGRvd24gKGluY2x1ZGluZyByZWxlYXNpbmcgb3VyIHByaW1hcnkgbGVhc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGVyZSdzIG5vIGd1YXJhbnRlZSBpdCB3aWxsIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRldGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2luZG93VW5sb2FkSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMud2luZG93VW5sb2FkSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBjbGllbnQgaXMgXCJ6b21iaWVkXCIgYmFzZWQgb24gaXRzIExvY2FsU3RvcmFnZSBlbnRyeS5cclxuICAgICAqIENsaWVudHMgYmVjb21lIHpvbWJpZWQgd2hlbiB0aGVpciB0YWIgY2xvc2VzIHdpdGhvdXQgcnVubmluZyBhbGwgb2YgdGhlXHJcbiAgICAgKiBjbGVhbnVwIGxvZ2ljIGluIGBzaHV0ZG93bigpYC5cclxuICAgICAqL1xyXG4gICAgaXNDbGllbnRab21iaWVkKGNsaWVudElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzWm9tYmllZCA9ICgoX2EgPSB0aGlzLndlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleShjbGllbnRJZCkpKSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCBgQ2xpZW50ICcke2NsaWVudElkfScgJHtpc1pvbWJpZWQgPyAnaXMnIDogJ2lzIG5vdCd9IHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1pvbWJpZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGlmIExvY2FsU3RvcmFnZSBpc24ndCB3b3JraW5nLlxyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGMsICdGYWlsZWQgdG8gZ2V0IHpvbWJpZWQgY2xpZW50IGlkLicsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvcmQgY2xpZW50IGFzIHpvbWJpZWQgKGEgY2xpZW50IHRoYXQgaGFkIGl0cyB0YWIgY2xvc2VkKS4gWm9tYmllZFxyXG4gICAgICogY2xpZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgcHJpbWFyeSB0YWIgc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBtYXJrQ2xpZW50Wm9tYmllZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5zZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSwgU3RyaW5nKERhdGUubm93KCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgaWYgTG9jYWxTdG9yYWdlIGlzbid0IGF2YWlsYWJsZSAvIHdvcmtpbmcuXHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2V0IHpvbWJpZSBjbGllbnQgaWQuJywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFJlbW92ZXMgdGhlIHpvbWJpZWQgY2xpZW50IGVudHJ5IGlmIGl0IGV4aXN0cy4gKi9cclxuICAgIHJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIElnbm9yZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoY2xpZW50SWQpIHtcclxuICAgICAgICByZXR1cm4gYCR7Wk9NQklFRF9DTElFTlRTX0tFWV9QUkVGSVh9XyR7dGhpcy5wZXJzaXN0ZW5jZUtleX1fJHtjbGllbnRJZH1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHByaW1hcnkgY2xpZW50IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIHByaW1hcnlDbGllbnRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUHJpbWFyeUNsaWVudFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBjbGllbnQgbWV0YWRhdGEgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQ2xpZW50TWV0YWRhdGFTdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB1c2VkIGFzIGEgcHJlZml4IHdoZW4gc3RvcmluZyBkYXRhIGluIEluZGV4ZWREQiBhbmRcclxuICogTG9jYWxTdG9yYWdlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXhlZERiU3RvcmFnZVByZWZpeChkYXRhYmFzZUlkLCBwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgLy8gVXNlIHR3byBkaWZmZXJlbnQgcHJlZml4IGZvcm1hdHM6XHJcbiAgICAvL1xyXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC4gZGF0YWJhc2VJRCAvIC4uLlxyXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC8gLi4uXHJcbiAgICAvL1xyXG4gICAgLy8gcHJvamVjdElEcyBhcmUgRE5TLWNvbXBhdGlibGUgbmFtZXMgYW5kIGNhbm5vdCBjb250YWluIGRvdHNcclxuICAgIC8vIHNvIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGNvbGxpc2lvbnMuXHJcbiAgICBsZXQgZGF0YWJhc2UgPSBkYXRhYmFzZUlkLnByb2plY3RJZDtcclxuICAgIGlmICghZGF0YWJhc2VJZC5pc0RlZmF1bHREYXRhYmFzZSkge1xyXG4gICAgICAgIGRhdGFiYXNlICs9ICcuJyArIGRhdGFiYXNlSWQuZGF0YWJhc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ2ZpcmVzdG9yZS8nICsgcGVyc2lzdGVuY2VLZXkgKyAnLycgKyBkYXRhYmFzZSArICcvJztcclxufVxyXG5hc3luYyBmdW5jdGlvbiBpbmRleGVkRGJDbGVhclBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICBpZiAoIVNpbXBsZURiLmlzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYk5hbWUgPSBwZXJzaXN0ZW5jZUtleSArIE1BSU5fREFUQUJBU0U7XHJcbiAgICBhd2FpdCBTaW1wbGVEYi5kZWxldGUoZGJOYW1lKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIGFycmF5IGZvciBlcXVhbGl0eSB1c2luZyBjb21wYXJhdG9yLiBUaGUgbWV0aG9kIGNvbXB1dGVzIHRoZVxyXG4gKiBpbnRlcnNlY3Rpb24gYW5kIGludm9rZXMgYG9uQWRkYCBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIGluIGBhZnRlcmAgYnV0IG5vdFxyXG4gKiBgYmVmb3JlYC4gYG9uUmVtb3ZlYCBpcyBpbnZva2VkIGZvciBldmVyeSBlbGVtZW50IGluIGBiZWZvcmVgIGJ1dCBtaXNzaW5nXHJcbiAqIGZyb20gYGFmdGVyYC5cclxuICpcclxuICogVGhlIG1ldGhvZCBjcmVhdGVzIGEgY29weSBvZiBib3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFuZCBydW5zIGluIE8obiBsb2dcclxuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cclxuICpcclxuICogQHBhcmFtIGJlZm9yZSAtIFRoZSBlbGVtZW50cyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBhcnJheS5cclxuICogQHBhcmFtIGFmdGVyIC0gVGhlIGVsZW1lbnRzIHRvIGRpZmYgYWdhaW5zdCB0aGUgb3JpZ2luYWwgYXJyYXkuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIC0gVGhlIGNvbXBhcmF0b3IgZm9yIHRoZSBlbGVtZW50cyBpbiBiZWZvcmUgYW5kIGFmdGVyLlxyXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxyXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cclxuICogQHBhcmFtIG9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mXHJcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cclxuICovXHJcbmZ1bmN0aW9uIGRpZmZBcnJheXMoYmVmb3JlLCBhZnRlciwgY29tcGFyYXRvciwgb25BZGQsIG9uUmVtb3ZlKSB7XHJcbiAgICBiZWZvcmUgPSBbLi4uYmVmb3JlXTtcclxuICAgIGFmdGVyID0gWy4uLmFmdGVyXTtcclxuICAgIGJlZm9yZS5zb3J0KGNvbXBhcmF0b3IpO1xyXG4gICAgYWZ0ZXIuc29ydChjb21wYXJhdG9yKTtcclxuICAgIGNvbnN0IGJMZW4gPSBiZWZvcmUubGVuZ3RoO1xyXG4gICAgY29uc3QgYUxlbiA9IGFmdGVyLmxlbmd0aDtcclxuICAgIGxldCBhID0gMDtcclxuICAgIGxldCBiID0gMDtcclxuICAgIHdoaWxlIChhIDwgYUxlbiAmJiBiIDwgYkxlbikge1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlW2JdLCBhZnRlclthXSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgaWYgdGhlIG5leHQgZWxlbWVudCBpbiBvdXIgb3JkZXJlZFxyXG4gICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxyXG4gICAgICAgICAgICBvblJlbW92ZShiZWZvcmVbYisrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWQgd2Fsa3Rocm91Z2hcclxuICAgICAgICAgICAgLy8gaXMgb25seSBpbiBgYWZ0ZXJgLlxyXG4gICAgICAgICAgICBvbkFkZChhZnRlclthKytdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGErKztcclxuICAgICAgICAgICAgYisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdoaWxlIChhIDwgYUxlbikge1xyXG4gICAgICAgIG9uQWRkKGFmdGVyW2ErK10pO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGIgPCBiTGVuKSB7XHJcbiAgICAgICAgb25SZW1vdmUoYmVmb3JlW2IrK10pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYiA9ICdMb2NhbFN0b3JlJztcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gbGVhdmUgYSByZXN1bWUgdG9rZW4gYnVmZmVyZWQgd2l0aG91dCB3cml0aW5nIGl0IG91dC5cclxuICogVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnk6IGl0J3MgbG9uZyBlbm91Z2ggdG8gYXZvaWQgc2V2ZXJhbCB3cml0ZXNcclxuICogKHBvc3NpYmx5IGluZGVmaW5pdGVseSBpZiB1cGRhdGVzIGNvbWUgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcykgYnV0XHJcbiAqIHNob3J0IGVub3VnaCB0aGF0IHJlc3RhcnRpbmcgYWZ0ZXIgY3Jhc2hpbmcgd2lsbCBzdGlsbCBoYXZlIGEgcHJldHR5XHJcbiAqIHJlY2VudCByZXN1bWUgdG9rZW4uXHJcbiAqL1xyXG5jb25zdCBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MgPSA1ICogNjAgKiAxZTY7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBMb2NhbFN0b3JlYCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIE5vdGU6IHNvbWUgZmllbGQgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIG1pZ2h0IGhhdmUgcHVibGljIGFjY2VzcyBsZXZlbCwgYnV0XHJcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXHJcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGltcGxlbWVudCBvcHRpb25hbCBmZWF0dXJlcyAobGlrZSBidW5kbGVzKSBpbiBmcmVlXHJcbiAqIGZ1bmN0aW9ucywgc3VjaCB0aGF0IHRoZXkgYXJlIHRyZWUtc2hha2VhYmxlLlxyXG4gKi9cclxuY2xhc3MgTG9jYWxTdG9yZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogTWFuYWdlcyBvdXIgaW4tbWVtb3J5IG9yIGR1cmFibGUgcGVyc2lzdGVuY2UuICovXHJcbiAgICBwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUgPSBxdWVyeUVuZ2luZTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcHMgYSB0YXJnZXRJRCB0byBkYXRhIGFib3V0IGl0cyB0YXJnZXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQT1JUSU5HIE5PVEU6IFdlIGFyZSB1c2luZyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgb24gV2ViIHRvIG1ha2UgcmUtcnVuc1xyXG4gICAgICAgICAqIG9mIGBhcHBseVJlbW90ZUV2ZW50KClgIGlkZW1wb3RlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIC8qKiBNYXBzIGEgdGFyZ2V0IHRvIGl0cyB0YXJnZXRJRC4gKi9cclxuICAgICAgICAvLyBUT0RPKHd1YW5keSk6IEV2YWx1YXRlIGlmIFRhcmdldElkIGNhbiBiZSBwYXJ0IG9mIFRhcmdldC5cclxuICAgICAgICB0aGlzLnRhcmdldElkQnlUYXJnZXQgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBwZXIgY29sbGVjdGlvbiBncm91cCBpbmRleCBvZiB0aGUgbGFzdCByZWFkIHRpbWUgcHJvY2Vzc2VkIGJ5XHJcbiAgICAgICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cyA9IHBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcclxuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gcGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKTtcclxuICAgICAgICB0aGlzLmJ1bmRsZUNhY2hlID0gcGVyc2lzdGVuY2UuZ2V0QnVuZGxlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyhpbml0aWFsVXNlcik7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplVXNlckNvbXBvbmVudHModXNlcikge1xyXG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBBZGQgc3BlYyB0ZXN0cyB0aGF0IHRlc3QgdGhlc2UgY29tcG9uZW50cyBjaGFuZ2UgYWZ0ZXIgYVxyXG4gICAgICAgIC8vIHVzZXIgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0RG9jdW1lbnRPdmVybGF5Q2FjaGUodXNlcik7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSB0aGlzLnBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldE11dGF0aW9uUXVldWUodXNlciwgdGhpcy5pbmRleE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMubG9jYWxEb2N1bWVudHMgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHRoaXMucmVtb3RlRG9jdW1lbnRzLCB0aGlzLm11dGF0aW9uUXVldWUsIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cy5zZXRJbmRleE1hbmFnZXIodGhpcy5pbmRleE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUuaW5pdGlhbGl6ZSh0aGlzLmxvY2FsRG9jdW1lbnRzLCB0aGlzLmluZGV4TWFuYWdlcik7XHJcbiAgICB9XHJcbiAgICBjb2xsZWN0R2FyYmFnZShnYXJiYWdlQ29sbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0NvbGxlY3QgZ2FyYmFnZScsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiBnYXJiYWdlQ29sbGVjdG9yLmNvbGxlY3QodHhuLCB0aGlzLnRhcmdldERhdGFCeVRhcmdldCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0xvY2FsU3RvcmUoXHJcbi8qKiBNYW5hZ2VzIG91ciBpbi1tZW1vcnkgb3IgZHVyYWJsZSBwZXJzaXN0ZW5jZS4gKi9cclxucGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JlSW1wbChwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKTtcclxufVxyXG4vKipcclxuICogVGVsbHMgdGhlIExvY2FsU3RvcmUgdGhhdCB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciBoYXMgY2hhbmdlZC5cclxuICpcclxuICogSW4gcmVzcG9uc2UgdGhlIGxvY2FsIHN0b3JlIHN3aXRjaGVzIHRoZSBtdXRhdGlvbiBxdWV1ZSB0byB0aGUgbmV3IHVzZXIgYW5kXHJcbiAqIHJldHVybnMgYW55IHJlc3VsdGluZyBkb2N1bWVudCBjaGFuZ2VzLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBBbmRyb2lkIGFuZCBpT1Mgb25seSByZXR1cm4gdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSB0aGVcclxuLy8gY2hhbmdlLlxyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShsb2NhbFN0b3JlLCB1c2VyKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdIYW5kbGUgdXNlciBjaGFuZ2UnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xyXG4gICAgICAgIC8vIFN3YXAgb3V0IHRoZSBtdXRhdGlvbiBxdWV1ZSwgZ3JhYmJpbmcgdGhlIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlc1xyXG4gICAgICAgIC8vIGJlZm9yZSBhbmQgYWZ0ZXIuXHJcbiAgICAgICAgbGV0IG9sZEJhdGNoZXM7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWVcclxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pXHJcbiAgICAgICAgICAgIC5uZXh0KHByb21pc2VkT2xkQmF0Y2hlcyA9PiB7XHJcbiAgICAgICAgICAgIG9sZEJhdGNoZXMgPSBwcm9taXNlZE9sZEJhdGNoZXM7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyh1c2VyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHR4bik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQobmV3QmF0Y2hlcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRCYXRjaElkcyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZEJhdGNoSWRzID0gW107XHJcbiAgICAgICAgICAgIC8vIFVuaW9uIHRoZSBvbGQvbmV3IGNoYW5nZWQga2V5cy5cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBvbGRCYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMgPSBjaGFuZ2VkS2V5cy5hZGQobXV0YXRpb24ua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIG5ld0JhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMgPSBjaGFuZ2VkS2V5cy5hZGQobXV0YXRpb24ua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNldCBvZiBhbGwgKHBvdGVudGlhbGx5KSBjaGFuZ2VkIGRvY3VtZW50cyBhbmQgdGhlIGxpc3RcclxuICAgICAgICAgICAgLy8gb2YgbXV0YXRpb24gYmF0Y2ggSURzIHRoYXQgd2VyZSBhZmZlY3RlZCBieSBjaGFuZ2UuXHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50c1xyXG4gICAgICAgICAgICAgICAgLmdldERvY3VtZW50cyh0eG4sIGNoYW5nZWRLZXlzKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoYWZmZWN0ZWREb2N1bWVudHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZERvY3VtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRCYXRjaElkc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyogQWNjZXB0cyBsb2NhbGx5IGdlbmVyYXRlZCBNdXRhdGlvbnMgYW5kIGNvbW1pdCB0aGVtIHRvIHN0b3JhZ2UuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkobG9jYWxTdG9yZSwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gVGltZXN0YW1wLm5vdygpO1xyXG4gICAgY29uc3Qga2V5cyA9IG11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICBsZXQgb3ZlcmxheWVkRG9jdW1lbnRzO1xyXG4gICAgbGV0IG11dGF0aW9uQmF0Y2g7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcclxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0xvY2FsbHkgd3JpdGUgbXV0YXRpb25zJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XHJcbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBrZXlzIGRvIG5vdCBoYXZlIGEgcmVtb3RlIHZlcnNpb24gaW4gdGhlIGNhY2hlLCB0aGlzXHJcbiAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgcmlnaHQgb3ZlcmxheSBtdXRhdGlvbjogaWYgbm8gcmVtb3RlIHZlcnNpb25cclxuICAgICAgICAvLyBwcmVzZW50cywgd2UgZG8gbm90IG5lZWQgdG8gY3JlYXRlIG92ZXJsYXlzIGFzIHBhdGNoIG11dGF0aW9ucy5cclxuICAgICAgICAvLyBUT0RPKE92ZXJsYXkpOiBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZGV0ZXJtaW5lIHRoaXM/IFVzaW5nIHRoZVxyXG4gICAgICAgIC8vICBkb2N1bWVudCB2ZXJzaW9uIGRvZXMgbm90IHdvcmsgYmVjYXVzZSBsb2NhbCBtdXRhdGlvbnMgc2V0IHRoZW0gYmFja1xyXG4gICAgICAgIC8vICB0byAwLlxyXG4gICAgICAgIGxldCByZW1vdGVEb2NzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgbGV0IGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbiA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50c1xyXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0eG4sIGtleXMpXHJcbiAgICAgICAgICAgIC5uZXh0KGRvY3MgPT4ge1xyXG4gICAgICAgICAgICByZW1vdGVEb2NzID0gZG9jcztcclxuICAgICAgICAgICAgcmVtb3RlRG9jcy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24gPSBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24uYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gTG9hZCBhbmQgYXBwbHkgYWxsIGV4aXN0aW5nIG11dGF0aW9ucy4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgdGhlXHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYmFzZSBzdGF0ZSBmb3IgYWxsIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYmVmb3JlIGFwcGx5aW5nXHJcbiAgICAgICAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHVzZXItcHJvdmlkZWQgd3JpdGVzLlxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0T3ZlcmxheWVkRG9jdW1lbnRzKHR4biwgcmVtb3RlRG9jcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKGRvY3MpID0+IHtcclxuICAgICAgICAgICAgb3ZlcmxheWVkRG9jdW1lbnRzID0gZG9jcztcclxuICAgICAgICAgICAgLy8gRm9yIG5vbi1pZGVtcG90ZW50IG11dGF0aW9ucyAoc3VjaCBhcyBgRmllbGRWYWx1ZS5pbmNyZW1lbnQoKWApLFxyXG4gICAgICAgICAgICAvLyB3ZSByZWNvcmQgdGhlIGJhc2Ugc3RhdGUgaW4gYSBzZXBhcmF0ZSBwYXRjaCBtdXRhdGlvbi4gVGhpcyBpc1xyXG4gICAgICAgICAgICAvLyBsYXRlciB1c2VkIHRvIGd1YXJhbnRlZSBjb25zaXN0ZW50IHZhbHVlcyBhbmQgcHJldmVudHMgZmxpY2tlclxyXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBiYWNrZW5kIHNlbmRzIHVzIGFuIHVwZGF0ZSB0aGF0IGFscmVhZHkgaW5jbHVkZXMgb3VyXHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVZhbHVlID0gbXV0YXRpb25FeHRyYWN0QmFzZVZhbHVlKG11dGF0aW9uLCBvdmVybGF5ZWREb2N1bWVudHMuZ2V0KG11dGF0aW9uLmtleSkub3ZlcmxheWVkRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhlIGJhc2Ugc3RhdGUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCBpZiB0aGVyZSdzIHNvbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBkb2N1bWVudCB0byBvdmVycmlkZSwgc28gdXNlIGEgUHJlY29uZGl0aW9uIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RzPXRydWVcclxuICAgICAgICAgICAgICAgICAgICBiYXNlTXV0YXRpb25zLnB1c2gobmV3IFBhdGNoTXV0YXRpb24obXV0YXRpb24ua2V5LCBiYXNlVmFsdWUsIGV4dHJhY3RGaWVsZE1hc2soYmFzZVZhbHVlLnZhbHVlLm1hcFZhbHVlKSwgUHJlY29uZGl0aW9uLmV4aXN0cyh0cnVlKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmFkZE11dGF0aW9uQmF0Y2godHhuLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dChiYXRjaCA9PiB7XHJcbiAgICAgICAgICAgIG11dGF0aW9uQmF0Y2ggPSBiYXRjaDtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBiYXRjaC5hcHBseVRvTG9jYWxEb2N1bWVudFNldChvdmVybGF5ZWREb2N1bWVudHMsIGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHhuLCBiYXRjaC5iYXRjaElkLCBvdmVybGF5cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKCgpID0+ICh7XHJcbiAgICAgICAgYmF0Y2hJZDogbXV0YXRpb25CYXRjaC5iYXRjaElkLFxyXG4gICAgICAgIGNoYW5nZXM6IGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAob3ZlcmxheWVkRG9jdW1lbnRzKVxyXG4gICAgfSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBY2tub3dsZWRnZXMgdGhlIGdpdmVuIGJhdGNoLlxyXG4gKlxyXG4gKiBPbiB0aGUgaGFwcHkgcGF0aCB3aGVuIGEgYmF0Y2ggaXMgYWNrbm93bGVkZ2VkLCB0aGUgbG9jYWwgc3RvcmUgd2lsbFxyXG4gKlxyXG4gKiAgKyByZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlO1xyXG4gKiAgKyBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlO1xyXG4gKiAgKyByZWNhbGN1bGF0ZSB0aGUgbGF0ZW5jeSBjb21wZW5zYXRlZCB2aWV3IGltcGxpZWQgYnkgdGhvc2UgY2hhbmdlcyAodGhlcmVcclxuICogICAgbWF5IGJlIG11dGF0aW9ucyBpbiB0aGUgcXVldWUgdGhhdCBhZmZlY3QgdGhlIGRvY3VtZW50cyBidXQgaGF2ZW4ndCBiZWVuXHJcbiAqICAgIGFja25vd2xlZGdlZCB5ZXQpOyBhbmRcclxuICogICsgZ2l2ZSB0aGUgY2hhbmdlZCBkb2N1bWVudHMgYmFjayB0aGUgc3luYyBlbmdpbmVcclxuICpcclxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyAobW9kaWZpZWQpIGRvY3VtZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVBY2tub3dsZWRnZUJhdGNoKGxvY2FsU3RvcmUsIGJhdGNoUmVzdWx0KSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQWNrbm93bGVkZ2UgYmF0Y2gnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xyXG4gICAgICAgIGNvbnN0IGFmZmVjdGVkID0gYmF0Y2hSZXN1bHQuYmF0Y2gua2V5cygpO1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhcHBseVdyaXRlVG9SZW1vdGVEb2N1bWVudHMobG9jYWxTdG9yZUltcGwsIHR4biwgYmF0Y2hSZXN1bHQsIGRvY3VtZW50QnVmZmVyKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmRvY3VtZW50T3ZlcmxheUNhY2hlLnJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0eG4sIGFmZmVjdGVkLCBiYXRjaFJlc3VsdC5iYXRjaC5iYXRjaElkKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBnZXRLZXlzV2l0aFRyYW5zZm9ybVJlc3VsdHMoYmF0Y2hSZXN1bHQpKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWQpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEtleXNXaXRoVHJhbnNmb3JtUmVzdWx0cyhiYXRjaFJlc3VsdCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0ID0gYmF0Y2hSZXN1bHQubXV0YXRpb25SZXN1bHRzW2ldO1xyXG4gICAgICAgIGlmIChtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChiYXRjaFJlc3VsdC5iYXRjaC5tdXRhdGlvbnNbaV0ua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIG11dGF0aW9ucyBmcm9tIHRoZSBNdXRhdGlvblF1ZXVlIGZvciB0aGUgc3BlY2lmaWVkIGJhdGNoO1xyXG4gKiBMb2NhbERvY3VtZW50cyB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cclxuICpcclxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBtb2RpZmllZCBkb2N1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVqZWN0QmF0Y2gobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1JlamVjdCBiYXRjaCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkS2V5cztcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxyXG4gICAgICAgICAgICAubG9va3VwTXV0YXRpb25CYXRjaCh0eG4sIGJhdGNoSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KChiYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoICE9PSBudWxsKTtcclxuICAgICAgICAgICAgYWZmZWN0ZWRLZXlzID0gYmF0Y2gua2V5cygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5yZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgYmF0Y2gpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuZG9jdW1lbnRPdmVybGF5Q2FjaGUucmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHR4biwgYWZmZWN0ZWRLZXlzLCBiYXRjaElkKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBhZmZlY3RlZEtleXMpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudHModHhuLCBhZmZlY3RlZEtleXMpKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsYXJnZXN0IChsYXRlc3QpIGJhdGNoIGlkIGluIG11dGF0aW9uIHF1ZXVlIHRoYXQgaXMgcGVuZGluZ1xyXG4gKiBzZXJ2ZXIgcmVzcG9uc2UuXHJcbiAqXHJcbiAqIFJldHVybnMgYEJBVENISURfVU5LTk9XTmAgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQobG9jYWxTdG9yZSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBoaWdoZXN0IHVuYWNrbm93bGVkZ2VkIGJhdGNoIGlkJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCh0eG4pKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGFzdCBjb25zaXN0ZW50IHNuYXBzaG90IHByb2Nlc3NlZCAodXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG9cclxuICogZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYnVmZmVyIGluY29taW5nIHNuYXBzaG90cyBmcm9tIHRoZSBiYWNrZW5kKS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKGxvY2FsU3RvcmUpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbGFzdCByZW1vdGUgc25hcHNob3QgdmVyc2lvbicsICdyZWFkb25seScsIHR4biA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bikpO1xyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBcImdyb3VuZC1zdGF0ZVwiIChyZW1vdGUpIGRvY3VtZW50cy4gV2UgYXNzdW1lIHRoYXQgdGhlIHJlbW90ZVxyXG4gKiBldmVudCByZWZsZWN0cyBhbnkgd3JpdGUgYmF0Y2hlcyB0aGF0IGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgb3IgcmVqZWN0ZWRcclxuICogKGkuZS4gd2UgZG8gbm90IHJlLWFwcGx5IGxvY2FsIG11dGF0aW9ucyB0byB1cGRhdGVzIGZyb20gdGhpcyBldmVudCkuXHJcbiAqXHJcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxyXG4gKiBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKGxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHJlbW90ZVZlcnNpb24gPSByZW1vdGVFdmVudC5zbmFwc2hvdFZlcnNpb247XHJcbiAgICBsZXQgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXHJcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdBcHBseSByZW1vdGUgZXZlbnQnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFJlc2V0IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCBpbiBjYXNlIHRoaXMgdHJhbnNhY3Rpb24gZ2V0cyByZS1ydW4uXHJcbiAgICAgICAgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFRhcmdldERhdGEgPSBuZXdUYXJnZXREYXRhQnlUYXJnZXRNYXAuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgaWYgKCFvbGRUYXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHJlbW90ZSBrZXlzIGlmIHRoZSB0YXJnZXQgaXMgc3RpbGwgYWN0aXZlLiBUaGlzXHJcbiAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhhdCB3ZSBjYW4gcGVyc2lzdCB0aGUgdXBkYXRlZCB0YXJnZXQgZGF0YSBhbG9uZyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHRoZSB1cGRhdGVkIGFzc2lnbm1lbnQuXHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UucmVtb3ZlZERvY3VtZW50cywgdGFyZ2V0SWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuYWRkTWF0Y2hpbmdLZXlzKHR4biwgY2hhbmdlLmFkZGVkRG9jdW1lbnRzLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldERhdGEgPSBvbGRUYXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgaWYgKHJlbW90ZUV2ZW50LnRhcmdldE1pc21hdGNoZXMuZ2V0KHRhcmdldElkKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGFcclxuICAgICAgICAgICAgICAgICAgICAud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFNuYXBzaG90VmVyc2lvbi5taW4oKSlcclxuICAgICAgICAgICAgICAgICAgICAud2l0aExhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24oU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgcmVtb3RlVmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmluc2VydCh0YXJnZXRJZCwgbmV3VGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGFyZ2V0IGRhdGEgaWYgdGhlcmUgYXJlIHRhcmdldCBjaGFuZ2VzIChvciBpZlxyXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLlxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUGVyc2lzdFRhcmdldERhdGEob2xkVGFyZ2V0RGF0YSwgbmV3VGFyZ2V0RGF0YSwgY2hhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS51cGRhdGVUYXJnZXREYXRhKHR4biwgbmV3VGFyZ2V0RGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGNoYW5nZWREb2NzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICByZW1vdGVFdmVudC5kb2N1bWVudFVwZGF0ZXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVtb3RlRXZlbnQucmVzb2x2ZWRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS51cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBFYWNoIGxvb3AgaXRlcmF0aW9uIG9ubHkgYWZmZWN0cyBpdHMgXCJvd25cIiBkb2MsIHNvIGl0J3Mgc2FmZSB0byBnZXQgYWxsXHJcbiAgICAgICAgLy8gdGhlIHJlbW90ZSBkb2N1bWVudHMgaW4gYWR2YW5jZSBpbiBhIHNpbmdsZSBjYWxsLlxyXG4gICAgICAgIHByb21pc2VzLnB1c2gocG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCByZW1vdGVFdmVudC5kb2N1bWVudFVwZGF0ZXMpLm5leHQocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlZERvY3MgPSByZXN1bHQuY2hhbmdlZERvY3VtZW50cztcclxuICAgICAgICAgICAgZXhpc3RlbmNlQ2hhbmdlZEtleXMgPSByZXN1bHQuZXhpc3RlbmNlQ2hhbmdlZEtleXM7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8vIEhBQ0s6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBhIG51bGwgc25hcHNob3QgdmVyc2lvbiBpcyBzbyB0aGF0IHdlXHJcbiAgICAgICAgLy8gY2FuIHN5bnRoZXNpemUgcmVtb3RlIGV2ZW50cyB3aGVuIHdlIGdldCBwZXJtaXNzaW9uIGRlbmllZCBlcnJvcnMgd2hpbGVcclxuICAgICAgICAvLyB0cnlpbmcgdG8gcmVzb2x2ZSB0aGUgc3RhdGUgb2YgYSBsb2NhbGx5IGNhY2hlZCBkb2N1bWVudCB0aGF0IGlzIGluXHJcbiAgICAgICAgLy8gbGltYm8uXHJcbiAgICAgICAgaWYgKCFyZW1vdGVWZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVSZW1vdGVWZXJzaW9uID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgICAgIC5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bilcclxuICAgICAgICAgICAgICAgIC5uZXh0KGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnNldFRhcmdldHNNZXRhZGF0YSh0eG4sIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIsIHJlbW90ZVZlcnNpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh1cGRhdGVSZW1vdGVWZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXRMb2NhbFZpZXdPZkRvY3VtZW50cyh0eG4sIGNoYW5nZWREb2NzLCBleGlzdGVuY2VDaGFuZ2VkS2V5cykpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZWREb2NzKTtcclxuICAgIH0pXHJcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcDtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUG9wdWxhdGVzIGRvY3VtZW50IGNoYW5nZSBidWZmZXIgd2l0aCBkb2N1bWVudHMgZnJvbSBiYWNrZW5kIG9yIGEgYnVuZGxlLlxyXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGFwcGx5aW5nIHRob3NlIGRvY3VtZW50cywgYW5kXHJcbiAqIGFsc28gYSBzZXQgb2YgZG9jdW1lbnRzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZSBhcmUgY2hhbmdlZCBhcyBhIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHR4biAtIFRyYW5zYWN0aW9uIHRvIHVzZSB0byByZWFkIGV4aXN0aW5nIGRvY3VtZW50cyBmcm9tIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSBkb2N1bWVudEJ1ZmZlciAtIERvY3VtZW50IGJ1ZmZlciB0byBjb2xsZWN0IHRoZSByZXN1bHRlZCBjaGFuZ2VzIHRvIGJlXHJcbiAqICAgICAgICBhcHBsaWVkIHRvIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSBkb2N1bWVudHMgLSBEb2N1bWVudHMgdG8gYmUgYXBwbGllZC5cclxuICovXHJcbmZ1bmN0aW9uIHBvcHVsYXRlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodHhuLCBkb2N1bWVudEJ1ZmZlciwgZG9jdW1lbnRzKSB7XHJcbiAgICBsZXQgdXBkYXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgIGRvY3VtZW50cy5mb3JFYWNoKGsgPT4gKHVwZGF0ZWRLZXlzID0gdXBkYXRlZEtleXMuYWRkKGspKSk7XHJcbiAgICByZXR1cm4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cmllcyh0eG4sIHVwZGF0ZWRLZXlzKS5uZXh0KGV4aXN0aW5nRG9jcyA9PiB7XHJcbiAgICAgICAgbGV0IGNoYW5nZWREb2N1bWVudHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBkb2N1bWVudHMuZm9yRWFjaCgoa2V5LCBkb2MpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdEb2MgPSBleGlzdGluZ0RvY3MuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNlZSBpZiB0aGVyZSBpcyBhIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2UgZm9yIHRoaXMgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChkb2MuaXNGb3VuZERvY3VtZW50KCkgIT09IGV4aXN0aW5nRG9jLmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGV4aXN0ZW5jZUNoYW5nZWRLZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBvcmRlciBvZiB0aGUgc3RlcHMgYmVsb3cgaXMgaW1wb3J0YW50LCBzaW5jZSB3ZSB3YW50XHJcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHJlamVjdGVkIGxpbWJvIHJlc29sdXRpb25zICh3aGljaCBmYWJyaWNhdGVcclxuICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkpIG5ldmVyIGFkZCBkb2N1bWVudHMgdG9cclxuICAgICAgICAgICAgLy8gY2FjaGUuXHJcbiAgICAgICAgICAgIGlmIChkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb0RvY3VtZW50cyB3aXRoIFNuYXBzaG90VmVyc2lvbi5taW4oKSBhcmUgdXNlZCBpbiBtYW51ZmFjdHVyZWRcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cy4gV2UgcmVtb3ZlIHRoZXNlIGRvY3VtZW50cyBmcm9tIGNhY2hlIHNpbmNlIHdlIGxvc3RcclxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzcy5cclxuICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLnJlbW92ZUVudHJ5KGtleSwgZG9jLnJlYWRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWREb2N1bWVudHMgPSBjaGFuZ2VkRG9jdW1lbnRzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nRG9jLmlzVmFsaWREb2N1bWVudCgpIHx8XHJcbiAgICAgICAgICAgICAgICBkb2MudmVyc2lvbi5jb21wYXJlVG8oZXhpc3RpbmdEb2MudmVyc2lvbikgPiAwIHx8XHJcbiAgICAgICAgICAgICAgICAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEb2MuaGFzUGVuZGluZ1dyaXRlcykpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFkZEVudHJ5KGRvYyk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jdW1lbnRzID0gY2hhbmdlZERvY3VtZW50cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCAnSWdub3Jpbmcgb3V0ZGF0ZWQgd2F0Y2ggdXBkYXRlIGZvciAnLCBrZXksICcuIEN1cnJlbnQgdmVyc2lvbjonLCBleGlzdGluZ0RvYy52ZXJzaW9uLCAnIFdhdGNoIHZlcnNpb246JywgZG9jLnZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZERvY3VtZW50cywgZXhpc3RlbmNlQ2hhbmdlZEtleXMgfTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG5ld1RhcmdldERhdGEgc2hvdWxkIGJlIHBlcnNpc3RlZCBkdXJpbmcgYW4gdXBkYXRlIG9mXHJcbiAqIGFuIGFjdGl2ZSB0YXJnZXQuIFRhcmdldERhdGEgc2hvdWxkIGFsd2F5cyBiZSBwZXJzaXN0ZWQgd2hlbiBhIHRhcmdldCBpc1xyXG4gKiBiZWluZyByZWxlYXNlZCBhbmQgc2hvdWxkIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFdoaWxlIHRoZSB0YXJnZXQgaXMgYWN0aXZlLCBUYXJnZXREYXRhIHVwZGF0ZXMgY2FuIGJlIG9taXR0ZWQgd2hlbiBub3RoaW5nXHJcbiAqIGFib3V0IHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgZXhjZXB0IG1ldGFkYXRhIGxpa2UgdGhlIHJlc3VtZSB0b2tlbiBvclxyXG4gKiBzbmFwc2hvdCB2ZXJzaW9uLiBPY2Nhc2lvbmFsbHkgaXQncyB3b3J0aCB0aGUgZXh0cmEgd3JpdGUgdG8gcHJldmVudCB0aGVzZVxyXG4gKiB2YWx1ZXMgZnJvbSBnZXR0aW5nIHRvbyBzdGFsZSBhZnRlciBhIGNyYXNoLCBidXQgdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmVcclxuICogdG9vIGZyZXF1ZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkUGVyc2lzdFRhcmdldERhdGEob2xkVGFyZ2V0RGF0YSwgbmV3VGFyZ2V0RGF0YSwgY2hhbmdlKSB7XHJcbiAgICAvLyBBbHdheXMgcGVyc2lzdCB0YXJnZXQgZGF0YSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZXN1bWUgdG9rZW4uXHJcbiAgICBpZiAob2xkVGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIERvbid0IGFsbG93IHJlc3VtZSB0b2tlbiBjaGFuZ2VzIHRvIGJlIGJ1ZmZlcmVkIGluZGVmaW5pdGVseS4gVGhpc1xyXG4gICAgLy8gYWxsb3dzIHVzIHRvIGJlIHJlYXNvbmFibHkgdXAtdG8tZGF0ZSBhZnRlciBhIGNyYXNoIGFuZCBhdm9pZHMgbmVlZGluZ1xyXG4gICAgLy8gdG8gbG9vcCBvdmVyIGFsbCBhY3RpdmUgcXVlcmllcyBvbiBzaHV0ZG93bi4gRXNwZWNpYWxseSBpbiB0aGUgYnJvd3NlclxyXG4gICAgLy8gd2UgbWF5IG5vdCBnZXQgdGltZSB0byBkbyBhbnl0aGluZyBpbnRlcmVzdGluZyB3aGlsZSB0aGUgY3VycmVudCB0YWIgaXNcclxuICAgIC8vIGNsb3NpbmcuXHJcbiAgICBjb25zdCB0aW1lRGVsdGEgPSBuZXdUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpIC1cclxuICAgICAgICBvbGRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpO1xyXG4gICAgaWYgKHRpbWVEZWx0YSA+PSBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIE90aGVyd2lzZSBpZiB0aGUgb25seSB0aGluZyB0aGF0IGhhcyBjaGFuZ2VkIGFib3V0IGEgdGFyZ2V0IGlzIGl0cyByZXN1bWVcclxuICAgIC8vIHRva2VuIGl0J3Mgbm90IHdvcnRoIHBlcnNpc3RpbmcuIE5vdGUgdGhhdCB0aGUgUmVtb3RlU3RvcmUga2VlcHMgYW5cclxuICAgIC8vIGluLW1lbW9yeSB2aWV3IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhcmdldHMgd2hpY2ggaW5jbHVkZXMgdGhlIGN1cnJlbnRcclxuICAgIC8vIHJlc3VtZSB0b2tlbiwgc28gc3RyZWFtIGZhaWx1cmUgb3IgdXNlciBjaGFuZ2VzIHdpbGwgc3RpbGwgdXNlIGFuXHJcbiAgICAvLyB1cC10by1kYXRlIHJlc3VtZSB0b2tlbiByZWdhcmRsZXNzIG9mIHdoYXQgd2UgZG8gaGVyZS5cclxuICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSArXHJcbiAgICAgICAgY2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xyXG4gICAgICAgIGNoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemU7XHJcbiAgICByZXR1cm4gY2hhbmdlcyA+IDA7XHJcbn1cclxuLyoqXHJcbiAqIE5vdGlmaWVzIGxvY2FsIHN0b3JlIG9mIHRoZSBjaGFuZ2VkIHZpZXdzIHRvIGxvY2FsbHkgcGluIGRvY3VtZW50cy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKGxvY2FsU3RvcmUsIHZpZXdDaGFuZ2VzKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ25vdGlmeUxvY2FsVmlld0NoYW5nZXMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2VzLCAodmlld0NoYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2UuYWRkZWRLZXlzLCAoa2V5KSA9PiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5hZGRSZWZlcmVuY2UodHhuLCB2aWV3Q2hhbmdlLnRhcmdldElkLCBrZXkpKS5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2UucmVtb3ZlZEtleXMsIChrZXkpID0+IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVJlZmVyZW5jZSh0eG4sIHZpZXdDaGFuZ2UudGFyZ2V0SWQsIGtleSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICAgICAgLy8gSWYgYG5vdGlmeUxvY2FsVmlld0NoYW5nZXNgIGZhaWxzLCB3ZSBkaWQgbm90IGFkdmFuY2UgdGhlIHNlcXVlbmNlXHJcbiAgICAgICAgICAgIC8vIG51bWJlciBmb3IgdGhlIGRvY3VtZW50cyB0aGF0IHdlcmUgaW5jbHVkZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgICAgLy8gVGhpcyBtaWdodCB0cmlnZ2VyIHRoZW0gdG8gYmUgZGVsZXRlZCBlYXJsaWVyIHRoYW4gdGhleSBvdGhlcndpc2VcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSwgYnV0IGl0IHNob3VsZCBub3QgaW52YWxpZGF0ZSB0aGUgaW50ZWdyaXR5IG9mIHRoZSBkYXRhLlxyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsICdGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnM6ICcgKyBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCB2aWV3Q2hhbmdlIG9mIHZpZXdDaGFuZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB2aWV3Q2hhbmdlLnRhcmdldElkO1xyXG4gICAgICAgIGlmICghdmlld0NoYW5nZS5mcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBsYXN0IGxpbWJvIGZyZWUgc25hcHNob3QgdmVyc2lvblxyXG4gICAgICAgICAgICBjb25zdCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYXJnZXREYXRhID0gdGFyZ2V0RGF0YS53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5pbnNlcnQodGFyZ2V0SWQsIHVwZGF0ZWRUYXJnZXREYXRhKTtcclxuICAgICAgICAgICAgLy8gVE9ETyhiLzI3MjU2NDMxNik6IEFwcGx5IHRoZSBvcHRpbWl6YXRpb24gZG9uZSBvbiBvdGhlciBwbGF0Zm9ybXMuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcm9ibGVtIGZvciB3ZWIgYmVjYXVzZSBzYXZpbmcgdGhlIHVwZGF0ZWQgdGFyZ2V0RGF0YSBmcm9tXHJcbiAgICAgICAgICAgIC8vIG5vbi1wcmltYXJ5IGNsaWVudCBjb25mbGljdHMgd2l0aCB3aGF0IHByaW1hcnkgY2xpZW50IHNhdmVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgbXV0YXRpb24gYmF0Y2ggYWZ0ZXIgdGhlIHBhc3NlZCBpbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZVxyXG4gKiBvciBudWxsIGlmIGVtcHR5LlxyXG4gKiBAcGFyYW0gYWZ0ZXJCYXRjaElkIC0gSWYgcHJvdmlkZWQsIHRoZSBiYXRjaCB0byBzZWFyY2ggYWZ0ZXIuXHJcbiAqIEByZXR1cm5zIFRoZSBuZXh0IG11dGF0aW9uIG9yIG51bGwgaWYgdGhlcmUgd2Fzbid0IG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXh0TXV0YXRpb25CYXRjaChsb2NhbFN0b3JlLCBhZnRlckJhdGNoSWQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmV4dCBtdXRhdGlvbiBiYXRjaCcsICdyZWFkb25seScsIHR4biA9PiB7XHJcbiAgICAgICAgaWYgKGFmdGVyQmF0Y2hJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFmdGVyQmF0Y2hJZCA9IEJBVENISURfVU5LTk9XTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHhuLCBhZnRlckJhdGNoSWQpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgRG9jdW1lbnQgd2l0aCBhIGdpdmVuIGtleSBvciBudWxsIGlmIG5vdFxyXG4gKiBmb3VuZCAtIHVzZWQgZm9yIHRlc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVhZERvY3VtZW50KGxvY2FsU3RvcmUsIGtleSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ3JlYWQgZG9jdW1lbnQnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnQodHhuLCBrZXkpKTtcclxufVxyXG4vKipcclxuICogQXNzaWducyB0aGUgZ2l2ZW4gdGFyZ2V0IGFuIGludGVybmFsIElEIHNvIHRoYXQgaXRzIHJlc3VsdHMgY2FuIGJlIHBpbm5lZCBzb1xyXG4gKiB0aGV5IGRvbid0IGdldCBHQydkLiBBIHRhcmdldCBtdXN0IGJlIGFsbG9jYXRlZCBpbiB0aGUgbG9jYWwgc3RvcmUgYmVmb3JlXHJcbiAqIHRoZSBzdG9yZSBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgaXRzIHZpZXcuXHJcbiAqXHJcbiAqIEFsbG9jYXRpbmcgYW4gYWxyZWFkeSBhbGxvY2F0ZWQgYFRhcmdldGAgd2lsbCByZXR1cm4gdGhlIGV4aXN0aW5nIGBUYXJnZXREYXRhYFxyXG4gKiBmb3IgdGhhdCBgVGFyZ2V0YC5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXHJcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdBbGxvY2F0ZSB0YXJnZXQnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0RGF0YTtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgLmdldFRhcmdldERhdGEodHhuLCB0YXJnZXQpXHJcbiAgICAgICAgICAgIC5uZXh0KChjYWNoZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0YXJnZXQgaGFzIGJlZW4gbGlzdGVuZWQgdG8gcHJldmlvdXNseSwgc28gcmV1c2UgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB0YXJnZXRJRC5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogZnJlc2hlbiBsYXN0IGFjY2Vzc2VkIGRhdGU/XHJcbiAgICAgICAgICAgICAgICB0YXJnZXREYXRhID0gY2FjaGVkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgLmFsbG9jYXRlVGFyZ2V0SWQodHhuKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHRhcmdldElkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhID0gbmV3IFRhcmdldERhdGEodGFyZ2V0LCB0YXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi8sIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVGFyZ2V0RGF0YSh0eG4sIHRhcmdldERhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRhcmdldERhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pXHJcbiAgICAgICAgLnRoZW4odGFyZ2V0RGF0YSA9PiB7XHJcbiAgICAgICAgLy8gSWYgTXVsdGktVGFiIGlzIGVuYWJsZWQsIHRoZSBleGlzdGluZyB0YXJnZXQgZGF0YSBtYXkgYmUgbmV3ZXIgdGhhblxyXG4gICAgICAgIC8vIHRoZSBpbi1tZW1vcnkgZGF0YVxyXG4gICAgICAgIGNvbnN0IGNhY2hlZFRhcmdldERhdGEgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmIChjYWNoZWRUYXJnZXREYXRhID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhjYWNoZWRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikgPlxyXG4gICAgICAgICAgICAgICAgMCkge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQgPVxyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5zZXQodGFyZ2V0LCB0YXJnZXREYXRhLnRhcmdldElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldERhdGE7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgVGFyZ2V0RGF0YSBhcyBzZWVuIGJ5IHRoZSBMb2NhbFN0b3JlLCBpbmNsdWRpbmcgdXBkYXRlcyB0aGF0IG1heVxyXG4gKiBoYXZlIG5vdCB5ZXQgYmVlbiBwZXJzaXN0ZWQgdG8gdGhlIFRhcmdldENhY2hlLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZSwgdHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCB0YXJnZXRJZCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0SWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVW5waW5zIGFsbCB0aGUgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0LiBJZlxyXG4gKiBga2VlcFBlcnNpc3RlZFRhcmdldERhdGFgIGlzIHNldCB0byBmYWxzZSBhbmQgRWFnZXIgR0MgZW5hYmxlZCwgdGhlIG1ldGhvZFxyXG4gKiBkaXJlY3RseSByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIHRhcmdldCBkYXRhIGZyb20gdGhlIHRhcmdldCBjYWNoZS5cclxuICpcclxuICogUmVsZWFzaW5nIGEgbm9uLWV4aXN0aW5nIGBUYXJnZXRgIGlzIGEgbm8tb3AuXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgbXVsdGktdGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KGxvY2FsU3RvcmUsIHRhcmdldElkLCBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCB0YXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICBjb25zdCBtb2RlID0ga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgPyAncmVhZHdyaXRlJyA6ICdyZWFkd3JpdGUtcHJpbWFyeSc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICgha2VlcFBlcnNpc3RlZFRhcmdldERhdGEpIHtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1JlbGVhc2UgdGFyZ2V0JywgbW9kZSwgdHhuID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgIC8vIEFsbCBgcmVsZWFzZVRhcmdldGAgZG9lcyBpcyByZWNvcmQgdGhlIGZpbmFsIG1ldGFkYXRhIHN0YXRlIGZvciB0aGVcclxuICAgICAgICAgICAgLy8gdGFyZ2V0LCBidXQgd2UndmUgYmVlbiByZWNvcmRpbmcgdGhpcyBwZXJpb2RpY2FsbHkgZHVyaW5nIHRhcmdldFxyXG4gICAgICAgICAgICAvLyBhY3Rpdml0eS4gSWYgd2UgbG9zZSB0aGlzIHdyaXRlIHRoaXMgY291bGQgY2F1c2UgYSB2ZXJ5IHNsaWdodFxyXG4gICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSBvcmRlciBvZiB0YXJnZXQgZGVsZXRpb24gZHVyaW5nIEdDLCBidXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZGVmaW5lIGV4YWN0IExSVSBzZW1hbnRpY3Mgc28gdGhpcyBpcyBhY2NlcHRhYmxlLlxyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsIGBGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnMgZm9yIHRhcmdldCAke3RhcmdldElkfTogJHtlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQgPVxyXG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5yZW1vdmUodGFyZ2V0SWQpO1xyXG4gICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBSdW5zIHRoZSBzcGVjaWZpZWQgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgc3RvcmUgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMsXHJcbiAqIHBvdGVudGlhbGx5IHRha2luZyBhZHZhbnRhZ2Ugb2YgcXVlcnkgZGF0YSBmcm9tIHByZXZpb3VzIGV4ZWN1dGlvbnMgKHN1Y2hcclxuICogYXMgdGhlIHNldCBvZiByZW1vdGUga2V5cykuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VQcmV2aW91c1Jlc3VsdHMgLSBXaGV0aGVyIHJlc3VsdHMgZnJvbSBwcmV2aW91cyBleGVjdXRpb25zIGNhblxyXG4gKiBiZSB1c2VkIHRvIG9wdGltaXplIHRoaXMgcXVlcnkgZXhlY3V0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGxldCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgbGV0IHJlbW90ZUtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdFeGVjdXRlIHF1ZXJ5JywgJ3JlYWR3cml0ZScsIC8vIFVzZSByZWFkd3JpdGUgaW5zdGVhZCBvZiByZWFkb25seSBzbyBpbmRleGVzIGNhbiBiZSBjcmVhdGVkXHJcbiAgICAvLyBVc2UgcmVhZHdyaXRlIGluc3RlYWQgb2YgcmVhZG9ubHkgc28gaW5kZXhlcyBjYW4gYmUgY3JlYXRlZFxyXG4gICAgdHhuID0+IHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZUltcGwsIHR4biwgcXVlcnlUb1RhcmdldChxdWVyeSkpXHJcbiAgICAgICAgICAgIC5uZXh0KHRhcmdldERhdGEgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YS5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUtleXMgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnF1ZXJ5RW5naW5lLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHhuLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzXHJcbiAgICAgICAgICAgID8gbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvblxyXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKSwgdXNlUHJldmlvdXNSZXN1bHRzID8gcmVtb3RlS2V5cyA6IGRvY3VtZW50S2V5U2V0KCkpKVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHMgPT4ge1xyXG4gICAgICAgICAgICBzZXRNYXhSZWFkVGltZShsb2NhbFN0b3JlSW1wbCwgcXVlcnlDb2xsZWN0aW9uR3JvdXAocXVlcnkpLCBkb2N1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb2N1bWVudHMsIHJlbW90ZUtleXMgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpIHtcclxuICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hSZXN1bHQuYmF0Y2g7XHJcbiAgICBjb25zdCBkb2NLZXlzID0gYmF0Y2gua2V5cygpO1xyXG4gICAgbGV0IHByb21pc2VDaGFpbiA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICBkb2NLZXlzLmZvckVhY2goZG9jS2V5ID0+IHtcclxuICAgICAgICBwcm9taXNlQ2hhaW4gPSBwcm9taXNlQ2hhaW5cclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpKVxyXG4gICAgICAgICAgICAubmV4dChkb2MgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhY2tWZXJzaW9uID0gYmF0Y2hSZXN1bHQuZG9jVmVyc2lvbnMuZ2V0KGRvY0tleSk7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoYWNrVmVyc2lvbiAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGlmIChkb2MudmVyc2lvbi5jb21wYXJlVG8oYWNrVmVyc2lvbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5hcHBseVRvUmVtb3RlRG9jdW1lbnQoZG9jLCBiYXRjaFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBjb21taXRWZXJzaW9uIGFzIHRoZSByZWFkVGltZSByYXRoZXIgdGhhbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudCdzIHVwZGF0ZVRpbWUgc2luY2UgdGhlIHVwZGF0ZVRpbWUgaXMgbm90IGFkdmFuY2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVwZGF0ZXMgdGhhdCBkbyBub3QgbW9kaWZ5IHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zZXRSZWFkVGltZShiYXRjaFJlc3VsdC5jb21taXRWZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5hZGRFbnRyeShkb2MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwcm9taXNlQ2hhaW4ubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCkpO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudHMgYWZmZWN0ZWQgYnkgYSBtdXRhdGlvbiBiYXRjaC4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUxvb2t1cE11dGF0aW9uRG9jdW1lbnRzKGxvY2FsU3RvcmUsIGJhdGNoSWQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0xvb2t1cCBtdXRhdGlvbiBkb2N1bWVudHMnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlSW1wbC5sb29rdXBNdXRhdGlvbktleXModHhuLCBiYXRjaElkKS5uZXh0KGtleXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldERvY3VtZW50cyh0eG4sIGtleXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVtb3ZlQ2FjaGVkTXV0YXRpb25CYXRjaE1ldGFkYXRhKGxvY2FsU3RvcmUsIGJhdGNoSWQpIHtcclxuICAgIGNvbnN0IG11dGF0aW9uUXVldWVJbXBsID0gZGVidWdDYXN0KGRlYnVnQ2FzdChsb2NhbFN0b3JlLCBMb2NhbFN0b3JlSW1wbCkubXV0YXRpb25RdWV1ZSk7XHJcbiAgICBtdXRhdGlvblF1ZXVlSW1wbC5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2hJZCk7XHJcbn1cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEFjdGl2ZUNsaWVudHMobG9jYWxTdG9yZSkge1xyXG4gICAgY29uc3QgcGVyc2lzdGVuY2VJbXBsID0gZGVidWdDYXN0KGRlYnVnQ2FzdChsb2NhbFN0b3JlLCBMb2NhbFN0b3JlSW1wbCkucGVyc2lzdGVuY2UpO1xyXG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlSW1wbC5nZXRBY3RpdmVDbGllbnRzKCk7XHJcbn1cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXRJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCB0YXJnZXRDYWNoZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUpO1xyXG4gICAgY29uc3QgY2FjaGVkVGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgaWYgKGNhY2hlZFRhcmdldERhdGEpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFRhcmdldERhdGEudGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignR2V0IHRhcmdldCBkYXRhJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhY2hlSW1wbFxyXG4gICAgICAgICAgICAgICAgLmdldFRhcmdldERhdGFGb3JUYXJnZXQodHhuLCB0YXJnZXRJZClcclxuICAgICAgICAgICAgICAgIC5uZXh0KHRhcmdldERhdGEgPT4gKHRhcmdldERhdGEgPyB0YXJnZXREYXRhLnRhcmdldCA6IG51bGwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwuXHJcbiAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIHJldHVybnMgdGhlIHNldCBvZiBjaGFuZ2VzIHNpbmNlIGNsaWVudFxyXG4gKiBpbml0aWFsaXphdGlvbi4gRnVydGhlciBpbnZvY2F0aW9ucyB3aWxsIHJldHVybiBkb2N1bWVudCB0aGF0IGhhdmUgY2hhbmdlZFxyXG4gKiBzaW5jZSB0aGUgcHJpb3IgY2FsbC5cclxuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMobG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXhpbXVtIHJlYWQgdGltZSBmb3IgdGhlIGNvbGxlY3Rpb24uIFRoaXMgc2hvdWxkIGFsd2F5c1xyXG4gICAgLy8gZXhpc3QsIGJ1dCB0byByZWR1Y2UgdGhlIGNoYW5jZSBmb3IgcmVncmVzc2lvbnMgd2UgZGVmYXVsdCB0b1xyXG4gICAgLy8gU25hcHNob3RWZXJzaW9uLk1pbigpXHJcbiAgICAvLyBUT0RPKGluZGV4aW5nKTogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIGRlZmF1bHQgdmFsdWUuXHJcbiAgICBjb25zdCByZWFkVGltZSA9IGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLmdldChjb2xsZWN0aW9uR3JvdXApIHx8XHJcbiAgICAgICAgU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXHJcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmV3IGRvY3VtZW50IGNoYW5nZXMnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLmdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHhuLCBjb2xsZWN0aW9uR3JvdXAsIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKHJlYWRUaW1lLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpLCBcclxuICAgIC8qIGxpbWl0PSAqLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpXHJcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xyXG4gICAgICAgIHNldE1heFJlYWRUaW1lKGxvY2FsU3RvcmVJbXBsLCBjb2xsZWN0aW9uR3JvdXAsIGNoYW5nZWREb2NzKTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XHJcbiAgICB9KTtcclxufVxyXG4vKiogU2V0cyB0aGUgY29sbGVjdGlvbiBncm91cCdzIG1heGltdW0gcmVhZCB0aW1lIGZyb20gdGhlIGdpdmVuIGRvY3VtZW50cy4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIGNvbGxlY3Rpb25Hcm91cCwgY2hhbmdlZERvY3MpIHtcclxuICAgIGxldCByZWFkVGltZSA9IGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLmdldChjb2xsZWN0aW9uR3JvdXApIHx8XHJcbiAgICAgICAgU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgY2hhbmdlZERvY3MuZm9yRWFjaCgoXywgZG9jKSA9PiB7XHJcbiAgICAgICAgaWYgKGRvYy5yZWFkVGltZS5jb21wYXJlVG8ocmVhZFRpbWUpID4gMCkge1xyXG4gICAgICAgICAgICByZWFkVGltZSA9IGRvYy5yZWFkVGltZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLnNldChjb2xsZWN0aW9uR3JvdXAsIHJlYWRUaW1lKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgdXNpbmcgdGhlIGdpdmVuIGJ1bmRsZSBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZWQgdG9cclxuICogaG9sZCB0aGUga2V5cyBvZiBhbGwgZG9jdW1lbnRzIGZyb20gdGhlIGJ1bmRsZSBpbiBxdWVyeS1kb2N1bWVudCBtYXBwaW5ncy5cclxuICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGxvYWRlZCBkb2N1bWVudHMgZG8gbm90IGdldCBnYXJiYWdlIGNvbGxlY3RlZFxyXG4gKiByaWdodCBhd2F5LlxyXG4gKi9cclxuZnVuY3Rpb24gdW1icmVsbGFUYXJnZXQoYnVuZGxlTmFtZSkge1xyXG4gICAgLy8gSXQgaXMgT0sgdGhhdCB0aGUgcGF0aCB1c2VkIGZvciB0aGUgcXVlcnkgaXMgbm90IHZhbGlkLCBiZWNhdXNlIHRoaXMgd2lsbFxyXG4gICAgLy8gbm90IGJlIHJlYWQgYW5kIHF1ZXJpZWQuXHJcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoYF9fYnVuZGxlX18vZG9jcy8ke2J1bmRsZU5hbWV9YCkpKTtcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGUgZG9jdW1lbnRzIGZyb20gYSBidW5kbGUgdG8gdGhlIFwiZ3JvdW5kLXN0YXRlXCIgKHJlbW90ZSlcclxuICogZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBMb2NhbERvY3VtZW50cyBhcmUgcmUtY2FsY3VsYXRlZCBpZiB0aGVyZSBhcmUgcmVtYWluaW5nIG11dGF0aW9ucyBpbiB0aGVcclxuICogcXVldWUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlQXBwbHlCdW5kbGVkRG9jdW1lbnRzKGxvY2FsU3RvcmUsIGJ1bmRsZUNvbnZlcnRlciwgZG9jdW1lbnRzLCBidW5kbGVOYW1lKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGxldCBkb2N1bWVudEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgbGV0IGRvY3VtZW50TWFwID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICBmb3IgKGNvbnN0IGJ1bmRsZURvYyBvZiBkb2N1bWVudHMpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcclxuICAgICAgICBpZiAoYnVuZGxlRG9jLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50S2V5cyA9IGRvY3VtZW50S2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkb2MgPSBidW5kbGVDb252ZXJ0ZXIudG9NdXRhYmxlRG9jdW1lbnQoYnVuZGxlRG9jKTtcclxuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoYnVuZGxlQ29udmVydGVyLnRvU25hcHNob3RWZXJzaW9uKGJ1bmRsZURvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xyXG4gICAgICAgIGRvY3VtZW50TWFwID0gZG9jdW1lbnRNYXAuaW5zZXJ0KGRvY3VtZW50S2V5LCBkb2MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcclxuICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcclxuICAgIH0pO1xyXG4gICAgLy8gQWxsb2NhdGVzIGEgdGFyZ2V0IHRvIGhvbGQgYWxsIGRvY3VtZW50IGtleXMgZnJvbSB0aGUgYnVuZGxlLCBzdWNoIHRoYXRcclxuICAgIC8vIHRoZXkgd2lsbCBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkIHJpZ2h0IGF3YXkuXHJcbiAgICBjb25zdCB1bWJyZWxsYVRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZUltcGwsIHVtYnJlbGxhVGFyZ2V0KGJ1bmRsZU5hbWUpKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQXBwbHkgYnVuZGxlIGRvY3VtZW50cycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xyXG4gICAgICAgIHJldHVybiBwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIGRvY3VtZW50TWFwKVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudENoYW5nZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bik7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudENoYW5nZVJlc3VsdDtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudENoYW5nZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdW1icmVsbGFUYXJnZXREYXRhLnRhcmdldElkKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuYWRkTWF0Y2hpbmdLZXlzKHR4biwgZG9jdW1lbnRLZXlzLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHhuLCBkb2N1bWVudENoYW5nZVJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzLCBkb2N1bWVudENoYW5nZVJlc3VsdC5leGlzdGVuY2VDaGFuZ2VkS2V5cykpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudENoYW5nZVJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGdpdmVuIGJ1bmRsZSBoYXMgYWxyZWFkeVxyXG4gKiBiZWVuIGxvYWRlZCBhbmQgdGhlIGNyZWF0ZSB0aW1lIGlzIG5ld2VyIHRoYW4gdGhlIGN1cnJlbnQgbG9hZGluZyBidW5kbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlSGFzTmV3ZXJCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgY29uc3QgY3VycmVudFJlYWRUaW1lID0gZnJvbVZlcnNpb24oYnVuZGxlTWV0YWRhdGEuY3JlYXRlVGltZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcclxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ2hhc05ld2VyQnVuZGxlJywgJ3JlYWRvbmx5JywgdHJhbnNhY3Rpb24gPT4ge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEuaWQpO1xyXG4gICAgfSlcclxuICAgICAgICAudGhlbihjYWNoZWQgPT4ge1xyXG4gICAgICAgIHJldHVybiAhIWNhY2hlZCAmJiBjYWNoZWQuY3JlYXRlVGltZS5jb21wYXJlVG8oY3VycmVudFJlYWRUaW1lKSA+PSAwO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFNhdmVzIHRoZSBnaXZlbiBgQnVuZGxlTWV0YWRhdGFgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdTYXZlIGJ1bmRsZScsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLnNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIG9mIGEgYE5hbWVkUXVlcnlgIGFzc29jaWF0ZWQgd2l0aCBnaXZlbiBxdWVyeSBuYW1lLiBQcm9taXNlXHJcbiAqIHJlc29sdmVzIHRvIHVuZGVmaW5lZCBpZiBubyBwZXJzaXN0ZWQgZGF0YSBjYW4gYmUgZm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TmFtZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeU5hbWUpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmFtZWQgcXVlcnknLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpKTtcclxufVxyXG4vKipcclxuICogU2F2ZXMgdGhlIGdpdmVuIGBOYW1lZFF1ZXJ5YCB0byBsb2NhbCBwZXJzaXN0ZW5jZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVTYXZlTmFtZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgZG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKSkge1xyXG4gICAgLy8gQWxsb2NhdGUgYSB0YXJnZXQgZm9yIHRoZSBuYW1lZCBxdWVyeSBzdWNoIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWRcclxuICAgIC8vIGZyb20gYXNzb2NpYXRlZCByZWFkIHRpbWUgaWYgdXNlcnMgdXNlIGl0IHRvIGxpc3Rlbi5cclxuICAgIC8vIE5PVEU6IHRoaXMgYWxzbyBtZWFucyBpZiBubyBjb3JyZXNwb25kaW5nIHRhcmdldCBleGlzdHMsIHRoZSBuZXcgdGFyZ2V0XHJcbiAgICAvLyB3aWxsIHJlbWFpbiBhY3RpdmUgYW5kIHdpbGwgbm90IGdldCBjb2xsZWN0ZWQsIHVubGVzcyB1c2VycyBoYXBwZW4gdG9cclxuICAgIC8vIHVubGlzdGVuIHRoZSBxdWVyeSBzb21laG93LlxyXG4gICAgY29uc3QgYWxsb2NhdGVkID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KGxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQoZnJvbUJ1bmRsZWRRdWVyeShxdWVyeS5idW5kbGVkUXVlcnkpKSk7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignU2F2ZSBuYW1lZCBxdWVyeScsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVhZFRpbWUgPSBmcm9tVmVyc2lvbihxdWVyeS5yZWFkVGltZSk7XHJcbiAgICAgICAgLy8gU2ltcGx5IHNhdmUgdGhlIHF1ZXJ5IGl0c2VsZiBpZiBpdCBpcyBvbGRlciB0aGFuIHdoYXQgdGhlIFNESyBhbHJlYWR5XHJcbiAgICAgICAgLy8gaGFzLlxyXG4gICAgICAgIGlmIChhbGxvY2F0ZWQuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhyZWFkVGltZSkgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIHRhcmdldCBkYXRhIGJlY2F1c2UgdGhlIHF1ZXJ5IGZyb20gdGhlIGJ1bmRsZSBpcyBuZXdlci5cclxuICAgICAgICBjb25zdCBuZXdUYXJnZXREYXRhID0gYWxsb2NhdGVkLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCByZWFkVGltZSk7XHJcbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cclxuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydChuZXdUYXJnZXREYXRhLnRhcmdldElkLCBuZXdUYXJnZXREYXRhKTtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgLnVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIG5ld1RhcmdldERhdGEpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHRyYW5zYWN0aW9uLCBhbGxvY2F0ZWQudGFyZ2V0SWQpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHJhbnNhY3Rpb24sIGRvY3VtZW50cywgYWxsb2NhdGVkLnRhcmdldElkKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSk7XHJcbiAgICB9KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGxvY2FsU3RvcmUsIG5ld0ZpZWxkSW5kZXhlcykge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBsb2NhbFN0b3JlSW1wbC5pbmRleE1hbmFnZXI7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdDb25maWd1cmUgaW5kZXhlcycsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiBpbmRleE1hbmFnZXJcclxuICAgICAgICAuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgIC5uZXh0KG9sZEZpZWxkSW5kZXhlcyA9PiBkaWZmQXJyYXlzKG9sZEZpZWxkSW5kZXhlcywgbmV3RmllbGRJbmRleGVzLCBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yLCBmaWVsZEluZGV4ID0+IHtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4TWFuYWdlci5hZGRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KSk7XHJcbiAgICB9LCBmaWVsZEluZGV4ID0+IHtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4TWFuYWdlci5kZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KSk7XHJcbiAgICB9KSlcclxuICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpKTtcclxufVxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlU2V0SW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGxvY2FsU3RvcmUsIGlzRW5hYmxlZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBsb2NhbFN0b3JlSW1wbC5xdWVyeUVuZ2luZS5pbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQgPSBpc0VuYWJsZWQ7XHJcbn1cclxuZnVuY3Rpb24gbG9jYWxTdG9yZURlbGV0ZUFsbEZpZWxkSW5kZXhlcyhsb2NhbFN0b3JlKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IGluZGV4TWFuYWdlciA9IGxvY2FsU3RvcmVJbXBsLmluZGV4TWFuYWdlcjtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignRGVsZXRlIEFsbCBJbmRleGVzJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IGluZGV4TWFuYWdlci5kZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB0cmFja2VyIHRvIGtlZXAgYSByZWNvcmQgb2YgaW1wb3J0YW50IGRldGFpbHMgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5XHJcbiAqIGV4ZWN1dGlvbi5cclxuICovXHJcbmNsYXNzIFF1ZXJ5Q29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcGFzc2VkIHRocm91Z2ggZHVyaW5nIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kb2N1bWVudFJlYWRDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgZG9jdW1lbnRSZWFkQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50UmVhZENvdW50O1xyXG4gICAgfVxyXG4gICAgaW5jcmVtZW50RG9jdW1lbnRSZWFkQ291bnQoYW1vdW50KSB7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWFkQ291bnQgKz0gYW1vdW50O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfSU5ERVhfQVVUT19DUkVBVElPTl9NSU5fQ09MTEVDVElPTl9TSVpFID0gMTAwO1xyXG4vKipcclxuICogVGhpcyBjb3N0IHJlcHJlc2VudHMgdGhlIGV2YWx1YXRpb24gcmVzdWx0IG9mXHJcbiAqICgoW2luZGV4LCBkb2NLZXldICsgW2RvY0tleSwgZG9jQ29udGVudF0pIHBlciBkb2N1bWVudCBpbiB0aGUgcmVzdWx0IHNldClcclxuICogLyAoW2RvY0tleSwgZG9jQ29udGVudF0gcGVyIGRvY3VtZW50cyBpbiBmdWxsIGNvbGxlY3Rpb24gc2NhbikgY29taW5nIGZyb21cclxuICogZXhwZXJpbWVudCBbZW50ZXIgUFIgZXhwZXJpbWVudCBVUkwgaGVyZV0uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKSB7XHJcbiAgICAvLyBUaGVzZSB2YWx1ZXMgd2VyZSBkZXJpdmVkIGZyb20gYW4gZXhwZXJpbWVudCB3aGVyZSBzZXZlcmFsIG1lbWJlcnMgb2YgdGhlXHJcbiAgICAvLyBGaXJlc3RvcmUgU0RLIHRlYW0gcmFuIGEgcGVyZm9ybWFuY2UgdGVzdCBpbiB2YXJpb3VzIGVudmlyb25tZW50cy5cclxuICAgIC8vIEdvb2dsZXJzIGNhbiBzZWUgYi8yOTkyODQyODcgZm9yIGRldGFpbHMuXHJcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xyXG4gICAgICAgIHJldHVybiA4O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZ2V0QW5kcm9pZFZlcnNpb24oZ2V0VUEoKSkgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDY7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gNDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIEZpcmVzdG9yZSBxdWVyeSBlbmdpbmUuXHJcbiAqXHJcbiAqIEZpcmVzdG9yZSBxdWVyaWVzIGNhbiBiZSBleGVjdXRlZCBpbiB0aHJlZSBtb2Rlcy4gVGhlIFF1ZXJ5IEVuZ2luZSBkZXRlcm1pbmVzXHJcbiAqIHdoYXQgbW9kZSB0byB1c2UgYmFzZWQgb24gd2hhdCBkYXRhIGlzIHBlcnNpc3RlZC4gVGhlIG1vZGUgb25seSBkZXRlcm1pbmVzXHJcbiAqIHRoZSBydW50aW1lIGNvbXBsZXhpdHkgb2YgdGhlIHF1ZXJ5IC0gdGhlIHJlc3VsdCBzZXQgaXMgZXF1aXZhbGVudCBhY3Jvc3MgYWxsXHJcbiAqIGltcGxlbWVudGF0aW9ucy5cclxuICpcclxuICogVGhlIFF1ZXJ5IGVuZ2luZSB3aWxsIHVzZSBpbmRleGVkLWJhc2VkIGV4ZWN1dGlvbiBpZiBhIHVzZXIgaGFzIGNvbmZpZ3VyZWRcclxuICogYW55IGluZGV4IHRoYXQgY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBxdWVyeSAodmlhIGBzZXRJbmRleENvbmZpZ3VyYXRpb24oKWApLlxyXG4gKiBPdGhlcndpc2UsIHRoZSBlbmdpbmUgd2lsbCB0cnkgdG8gb3B0aW1pemUgdGhlIHF1ZXJ5IGJ5IHJlLXVzaW5nIGEgcHJldmlvdXNseVxyXG4gKiBwZXJzaXN0ZWQgcXVlcnkgcmVzdWx0LiBJZiB0aGF0IGlzIG5vdCBwb3NzaWJsZSwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWRcclxuICogdmlhIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4uXHJcbiAqXHJcbiAqIEluZGV4LWJhc2VkIGV4ZWN1dGlvbiBpcyB0aGUgZGVmYXVsdCB3aGVuIGF2YWlsYWJsZS4gVGhlIHF1ZXJ5IGVuZ2luZVxyXG4gKiBzdXBwb3J0cyBwYXJ0aWFsIGluZGV4ZWQgZXhlY3V0aW9uIGFuZCBtZXJnZXMgdGhlIHJlc3VsdCBmcm9tIHRoZSBpbmRleFxyXG4gKiBsb29rdXAgd2l0aCBkb2N1bWVudHMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLiBUaGUgaW5kZXggZXZhbHVhdGlvblxyXG4gKiBtYXRjaGVzIHRoZSBiYWNrZW5kJ3MgZm9ybWF0IGFuZCBhcyBzdWNoLCB0aGUgU0RLIGNhbiB1c2UgaW5kZXhpbmcgZm9yIGFsbFxyXG4gKiBxdWVyaWVzIHRoYXQgdGhlIGJhY2tlbmQgc3VwcG9ydHMuXHJcbiAqXHJcbiAqIElmIG5vIGluZGV4IGV4aXN0cywgdGhlIHF1ZXJ5IGVuZ2luZSB0cmllcyB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGUgdGFyZ2V0XHJcbiAqIGRvY3VtZW50IG1hcHBpbmcgaW4gdGhlIFRhcmdldENhY2hlLiBUaGVzZSBtYXBwaW5ncyBleGlzdHMgZm9yIGFsbCBxdWVyaWVzXHJcbiAqIHRoYXQgaGF2ZSBiZWVuIHN5bmNlZCB3aXRoIHRoZSBiYWNrZW5kIGF0IGxlYXN0IG9uY2UgYW5kIGFsbG93IHRoZSBxdWVyeVxyXG4gKiBlbmdpbmUgdG8gb25seSByZWFkIGRvY3VtZW50cyB0aGF0IHByZXZpb3VzbHkgbWF0Y2hlZCBhIHF1ZXJ5IHBsdXMgYW55XHJcbiAqIGRvY3VtZW50cyB0aGF0IHdlcmUgZWRpdGVkIGFmdGVyIHRoZSBxdWVyeSB3YXMgbGFzdCBsaXN0ZW5lZCB0by5cclxuICpcclxuICogVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlbiB0aGlzIG9wdGltaXphdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBwcm9kdWNlXHJcbiAqIHRoZSBzYW1lIHJlc3VsdHMgYXMgZnVsbCBjb2xsZWN0aW9uIHNjYW5zLiBJbiB0aGVzZSBjYXNlcywgcXVlcnlcclxuICogcHJvY2Vzc2luZyBmYWxscyBiYWNrIHRvIGZ1bGwgc2NhbnMuIFRoZXNlIGNhc2VzIGFyZTpcclxuICpcclxuICogLSBMaW1pdCBxdWVyaWVzIHdoZXJlIGEgZG9jdW1lbnQgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSBwcmV2aW91c2x5IG5vIGxvbmdlclxyXG4gKiAgIG1hdGNoZXMgdGhlIHF1ZXJ5LlxyXG4gKlxyXG4gKiAtIExpbWl0IHF1ZXJpZXMgd2hlcmUgYSBkb2N1bWVudCBlZGl0IG1heSBjYXVzZSB0aGUgZG9jdW1lbnQgdG8gc29ydCBiZWxvd1xyXG4gKiAgIGFub3RoZXIgZG9jdW1lbnQgdGhhdCBpcyBpbiB0aGUgbG9jYWwgY2FjaGUuXHJcbiAqXHJcbiAqIC0gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgYmVlbiBDVVJSRU5UIG9yIGZyZWUgb2YgbGltYm8gZG9jdW1lbnRzLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlFbmdpbmUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU0RLIG9ubHkgZGVjaWRlcyB3aGV0aGVyIGl0IHNob3VsZCBjcmVhdGUgaW5kZXggd2hlbiBjb2xsZWN0aW9uIHNpemUgaXNcclxuICAgICAgICAgKiBsYXJnZXIgdGhhbiB0aGlzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25NaW5Db2xsZWN0aW9uU2l6ZSA9IERFRkFVTFRfSU5ERVhfQVVUT19DUkVBVElPTl9NSU5fQ09MTEVDVElPTl9TSVpFO1xyXG4gICAgICAgIHRoaXMucmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQgPSBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKTtcclxuICAgIH1cclxuICAgIC8qKiBTZXRzIHRoZSBkb2N1bWVudCB2aWV3IHRvIHF1ZXJ5IGFnYWluc3QuICovXHJcbiAgICBpbml0aWFsaXplKGxvY2FsRG9jdW1lbnRzLCBpbmRleE1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLmxvY2FsRG9jdW1lbnRzVmlldyA9IGxvY2FsRG9jdW1lbnRzO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYWxsIGxvY2FsIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHF1ZXJ5LiAqL1xyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHJlbW90ZUtleXMpIHtcclxuICAgICAgICAvLyBTdG9yZXMgdGhlIHJlc3VsdCBmcm9tIGV4ZWN1dGluZyB0aGUgcXVlcnk7IHVzaW5nIHRoaXMgb2JqZWN0IGlzIG1vcmVcclxuICAgICAgICAvLyBjb252ZW5pZW50IHRoYW4gcGFzc2luZyB0aGUgcmVzdWx0IGJldHdlZW4gc3RlcHMgb2YgdGhlIHBlcnNpc3RlbmNlXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gYW5kIGltcHJvdmVzIHJlYWRhYmlsaXR5IGNvbXBhcmF0aXZlbHkuXHJcbiAgICAgICAgY29uc3QgcXVlcnlSZXN1bHQgPSB7IHJlc3VsdDogbnVsbCB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVVzaW5nSW5kZXgodHJhbnNhY3Rpb24sIHF1ZXJ5KVxyXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBxdWVyeVJlc3VsdC5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlSZXN1bHQucmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdSZW1vdGVLZXlzKHRyYW5zYWN0aW9uLCBxdWVyeSwgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdC5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IFF1ZXJ5Q29udGV4dCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlRnVsbENvbGxlY3Rpb25TY2FuKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCkubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2FjaGVJbmRleGVzKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCwgcmVzdWx0LnNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBxdWVyeVJlc3VsdC5yZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FjaGVJbmRleGVzKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCwgcmVzdWx0U2l6ZSkge1xyXG4gICAgICAgIGlmIChjb250ZXh0LmRvY3VtZW50UmVhZENvdW50IDwgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUXVlcnlFbmdpbmUnLCAnU0RLIHdpbGwgbm90IGNyZWF0ZSBjYWNoZSBpbmRleGVzIGZvciBxdWVyeTonLCBzdHJpbmdpZnlRdWVyeShxdWVyeSksICdzaW5jZSBpdCBvbmx5IGNyZWF0ZXMgY2FjaGUgaW5kZXhlcyBmb3IgY29sbGVjdGlvbiBjb250YWlucycsICdtb3JlIHRoYW4gb3IgZXF1YWwgdG8nLCB0aGlzLmluZGV4QXV0b0NyZWF0aW9uTWluQ29sbGVjdGlvblNpemUsICdkb2N1bWVudHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1F1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSwgJ3NjYW5zJywgY29udGV4dC5kb2N1bWVudFJlYWRDb3VudCwgJ2xvY2FsIGRvY3VtZW50cyBhbmQgcmV0dXJucycsIHJlc3VsdFNpemUsICdkb2N1bWVudHMgYXMgcmVzdWx0cy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQgPlxyXG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50ICogcmVzdWx0U2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1RoZSBTREsgZGVjaWRlcyB0byBjcmVhdGUgY2FjaGUgaW5kZXhlcyBmb3IgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpLCAnYXMgdXNpbmcgY2FjaGUgaW5kZXhlcyBtYXkgaGVscCBpbXByb3ZlIHBlcmZvcm1hbmNlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5jcmVhdGVUYXJnZXRJbmRleGVzKHRyYW5zYWN0aW9uLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhbiBpbmRleGVkIHF1ZXJ5IHRoYXQgZXZhbHVhdGVzIHRoZSBxdWVyeSBiYXNlZCBvbiBhIGNvbGxlY3Rpb24nc1xyXG4gICAgICogcGVyc2lzdGVkIGluZGV4IHZhbHVlcy4gUmV0dXJucyBgbnVsbGAgaWYgYW4gaW5kZXggaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAqL1xyXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnlNYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICAvLyBRdWVyaWVzIHRoYXQgbWF0Y2ggYWxsIGRvY3VtZW50cyBkb24ndCBiZW5lZml0IGZyb20gdXNpbmdcclxuICAgICAgICAgICAgLy8ga2V5LWJhc2VkIGxvb2t1cHMuIEl0IGlzIG1vcmUgZWZmaWNpZW50IHRvIHNjYW4gYWxsIGRvY3VtZW50cyBpbiBhXHJcbiAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24sIHJhdGhlciB0aGFuIHRvIHBlcmZvcm0gaW5kaXZpZHVhbCBsb29rdXBzLlxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0YXJnZXQgPSBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KVxyXG4gICAgICAgICAgICAubmV4dChpbmRleFR5cGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhUeXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhbm5vdCBiZSBzZXJ2ZWQgZnJvbSBhbnkgaW5kZXguXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkubGltaXQgIT09IG51bGwgJiYgaW5kZXhUeXBlID09PSAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgYXBwbHkgYSBsaW1pdCBmb3IgdGFyZ2V0cyB0aGF0IGFyZSBzZXJ2ZWQgdXNpbmcgYSBwYXJ0aWFsXHJcbiAgICAgICAgICAgICAgICAvLyBpbmRleC4gSWYgYSBwYXJ0aWFsIGluZGV4IHdpbGwgYmUgdXNlZCB0byBzZXJ2ZSB0aGUgdGFyZ2V0LCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IG1heSByZXR1cm4gYSBzdXBlcnNldCBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBpZiB0aGUgaW5kZXggZG9lc24ndCBpbmNsdWRlIGFsbCB0aGUgdGFyZ2V0J3MgZmlsdGVycyksIG9yXHJcbiAgICAgICAgICAgICAgICAvLyBtYXkgcmV0dXJuIHRoZSBjb3JyZWN0IHNldCBvZiBkb2N1bWVudHMgaW4gdGhlIHdyb25nIG9yZGVyIChlLmcuIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggZG9lc24ndCBpbmNsdWRlIGEgc2VnbWVudCBmb3Igb25lIG9mIHRoZSBvcmRlckJ5cykuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIGEgbGltaXQgc2hvdWxkIG5vdCBiZSBhcHBsaWVkIGluIHN1Y2ggY2FzZXMuXHJcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBudWxsLCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlUb1RhcmdldChxdWVyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXHJcbiAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldClcclxuICAgICAgICAgICAgICAgIC5uZXh0KGtleXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KC4uLmtleXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3XHJcbiAgICAgICAgICAgICAgICAgICAgLmdldERvY3VtZW50cyh0cmFuc2FjdGlvbiwgc29ydGVkS2V5cylcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleGVkRG9jdW1lbnRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dChvZmZzZXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSB0aGlzLmFwcGx5UXVlcnkocXVlcnksIGluZGV4ZWREb2N1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkc1JlZmlsbChxdWVyeSwgcHJldmlvdXNSZXN1bHRzLCBzb3J0ZWRLZXlzLCBvZmZzZXQucmVhZFRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGxpbWl0IHF1ZXJ5IHdob3NlIGJvdW5kYXJpZXMgY2hhbmdlIGR1ZSB0byBsb2NhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWRpdHMgY2FuIGJlIHJlLXJ1biBhZ2FpbnN0IHRoZSBjYWNoZSBieSBleGNsdWRpbmcgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaW1pdC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkncyBmaWx0ZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gVGhlIFNES1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHRoZW4gYXBwbHkgdGhlIGxpbWl0IG9uY2UgYWxsIGxvY2FsIGVkaXRzIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jb3Jwb3JhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnlXaXRoTGltaXQocXVlcnksIG51bGwsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIHByZXZpb3VzUmVzdWx0cywgcXVlcnksIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYmFzZWQgb24gdGhlIHRhcmdldCdzIHBlcnNpc3RlZCBxdWVyeSBtYXBwaW5nLiBSZXR1cm5zXHJcbiAgICAgKiBgbnVsbGAgaWYgdGhlIG1hcHBpbmcgaXMgbm90IGF2YWlsYWJsZSBvciBjYW5ub3QgYmUgdXNlZC5cclxuICAgICAqL1xyXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdSZW1vdGVLZXlzKHRyYW5zYWN0aW9uLCBxdWVyeSwgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgdGhhdCBtYXRjaCBhbGwgZG9jdW1lbnRzIGRvbid0IGJlbmVmaXQgZnJvbSB1c2luZ1xyXG4gICAgICAgICAgICAvLyBrZXktYmFzZWQgbG9va3Vwcy4gSXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gc2NhbiBhbGwgZG9jdW1lbnRzIGluIGFcclxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgc2VlbiBhIHNuYXBzaG90IHdpdGhvdXQgbGltYm8gZnJlZSBkb2N1bWVudHNcclxuICAgICAgICAvLyBzaG91bGQgYWxzbyBiZSBydW4gYXMgYSBmdWxsIGNvbGxlY3Rpb24gc2Nhbi5cclxuICAgICAgICBpZiAobGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCByZW1vdGVLZXlzKS5uZXh0KGRvY3VtZW50cyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IHRoaXMuYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZWZpbGwocXVlcnksIHByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1JlLXVzaW5nIHByZXZpb3VzIHJlc3VsdCBmcm9tICVzIHRvIGV4ZWN1dGUgcXVlcnk6ICVzJywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi50b1N0cmluZygpLCBzdHJpbmdpZnlRdWVyeShxdWVyeSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGFsbCByZXN1bHRzIGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwZGF0ZWQgc2luY2UgdGhlIGxhc3RcclxuICAgICAgICAgICAgLy8gbGltYm8tZG9jdW1lbnQgZnJlZSByZW1vdGUgc25hcHNob3QuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIHByZXZpb3VzUmVzdWx0cywgcXVlcnksIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCkpLm5leHQocmVzdWx0cyA9PiByZXN1bHRzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBBcHBsaWVzIHRoZSBxdWVyeSBmaWx0ZXIgYW5kIHNvcnRpbmcgdG8gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gICovXHJcbiAgICBhcHBseVF1ZXJ5KHF1ZXJ5LCBkb2N1bWVudHMpIHtcclxuICAgICAgICAvLyBTb3J0IHRoZSBkb2N1bWVudHMgYW5kIHJlLWFwcGx5IHRoZSBxdWVyeSBmaWx0ZXIgc2luY2UgcHJldmlvdXNseVxyXG4gICAgICAgIC8vIG1hdGNoaW5nIGRvY3VtZW50cyBkbyBub3QgbmVjZXNzYXJpbHkgc3RpbGwgbWF0Y2ggdGhlIHF1ZXJ5LlxyXG4gICAgICAgIGxldCBxdWVyeVJlc3VsdHMgPSBuZXcgU29ydGVkU2V0KG5ld1F1ZXJ5Q29tcGFyYXRvcihxdWVyeSkpO1xyXG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChfLCBtYXliZURvYykgPT4ge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlNYXRjaGVzKHF1ZXJ5LCBtYXliZURvYykpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cyA9IHF1ZXJ5UmVzdWx0cy5hZGQobWF5YmVEb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGxpbWl0IHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGZyb20gY2FjaGUsIG1ha2luZyBpdFxyXG4gICAgICogaW5lbGlnaWJsZSBmb3IgaW5kZXgtZnJlZSBleGVjdXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHNvcnRlZFByZXZpb3VzUmVzdWx0cyAtIFRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSB3aGVuIGl0XHJcbiAgICAgKiB3YXMgbGFzdCBzeW5jaHJvbml6ZWQsIHNvcnRlZCBieSB0aGUgcXVlcnkncyBjb21wYXJhdG9yLlxyXG4gICAgICogQHBhcmFtIHJlbW90ZUtleXMgLSBUaGUgZG9jdW1lbnQga2V5cyB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IGF0IHRoZSBsYXN0XHJcbiAgICAgKiBzbmFwc2hvdC5cclxuICAgICAqIEBwYXJhbSBsaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgc25hcHNob3Qgd2hlbiB0aGVcclxuICAgICAqIHF1ZXJ5IHdhcyBsYXN0IHN5bmNocm9uaXplZC5cclxuICAgICAqL1xyXG4gICAgbmVlZHNSZWZpbGwocXVlcnksIHNvcnRlZFByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5LmxpbWl0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgd2l0aG91dCBsaW1pdHMgZG8gbm90IG5lZWQgdG8gYmUgcmVmaWxsZWQuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW90ZUtleXMuc2l6ZSAhPT0gc29ydGVkUHJldmlvdXNSZXN1bHRzLnNpemUpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGlmIGEgcHJldmlvdXNseSBtYXRjaGluZyBkb2N1bWVudCBub1xyXG4gICAgICAgICAgICAvLyBsb25nZXIgbWF0Y2hlcy5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExpbWl0IHF1ZXJpZXMgYXJlIG5vdCBlbGlnaWJsZSBmb3IgaW5kZXgtZnJlZSBxdWVyeSBleGVjdXRpb24gaWYgdGhlcmUgaXNcclxuICAgICAgICAvLyBhIHBvdGVudGlhbCB0aGF0IGFuIG9sZGVyIGRvY3VtZW50IGZyb20gY2FjaGUgbm93IHNvcnRzIGJlZm9yZSBhIGRvY3VtZW50XHJcbiAgICAgICAgLy8gdGhhdCB3YXMgcHJldmlvdXNseSBwYXJ0IG9mIHRoZSBsaW1pdC4gVGhpcywgaG93ZXZlciwgY2FuIG9ubHkgaGFwcGVuIGlmXHJcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50IGF0IHRoZSBlZGdlIG9mIHRoZSBsaW1pdCBnb2VzIG91dCBvZiBsaW1pdC5cclxuICAgICAgICAvLyBJZiBhIGRvY3VtZW50IHRoYXQgaXMgbm90IHRoZSBsaW1pdCBib3VuZGFyeSBzb3J0cyBkaWZmZXJlbnRseSxcclxuICAgICAgICAvLyB0aGUgYm91bmRhcnkgb2YgdGhlIGxpbWl0IGl0c2VsZiBkaWQgbm90IGNoYW5nZSBhbmQgZG9jdW1lbnRzIGZyb20gY2FjaGVcclxuICAgICAgICAvLyB3aWxsIGNvbnRpbnVlIHRvIGJlIFwicmVqZWN0ZWRcIiBieSB0aGlzIGJvdW5kYXJ5LiBUaGVyZWZvcmUsIHdlIGNhbiBpZ25vcmVcclxuICAgICAgICAvLyBhbnkgbW9kaWZpY2F0aW9ucyB0aGF0IGRvbid0IGFmZmVjdCB0aGUgbGFzdCBkb2N1bWVudC5cclxuICAgICAgICBjb25zdCBkb2NBdExpbWl0RWRnZSA9IHF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXHJcbiAgICAgICAgICAgID8gc29ydGVkUHJldmlvdXNSZXN1bHRzLmxhc3QoKVxyXG4gICAgICAgICAgICA6IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5maXJzdCgpO1xyXG4gICAgICAgIGlmICghZG9jQXRMaW1pdEVkZ2UpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWZpbGwgdGhlIHF1ZXJ5IGlmIHRoZXJlIHdlcmUgYWxyZWFkeSBubyBkb2N1bWVudHMuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkb2NBdExpbWl0RWRnZS5oYXNQZW5kaW5nV3JpdGVzIHx8XHJcbiAgICAgICAgICAgIGRvY0F0TGltaXRFZGdlLnZlcnNpb24uY29tcGFyZVRvKGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikgPiAwKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGVGdWxsQ29sbGVjdGlvblNjYW4odHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1VzaW5nIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHRvIGV4ZWN1dGUgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3LmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBJbmRleE9mZnNldC5taW4oKSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSByZXN1bHRzIGZyb20gYW4gaW5kZXhlZCBleGVjdXRpb24gd2l0aCB0aGUgcmVtYWluaW5nIGRvY3VtZW50c1xyXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLlxyXG4gICAgICovXHJcbiAgICBhcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBpbmRleGVkUmVzdWx0cywgcXVlcnksIG9mZnNldCkge1xyXG4gICAgICAgIC8vIFJldHJpZXZlIGFsbCByZXN1bHRzIGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwZGF0ZWQgc2luY2UgdGhlIG9mZnNldC5cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXdcclxuICAgICAgICAgICAgLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQpXHJcbiAgICAgICAgICAgIC5uZXh0KHJlbWFpbmluZ1Jlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHJlc3VsdHNcclxuICAgICAgICAgICAgaW5kZXhlZFJlc3VsdHMuZm9yRWFjaChkID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1Jlc3VsdHMgPSByZW1haW5pbmdSZXN1bHRzLmluc2VydChkLmtleSwgZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nUmVzdWx0cztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBjbGllbnQgc3RhdGUgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfY2xpZW50c188cGVyc2lzdGVuY2VfcHJlZml4Pl88aW5zdGFuY2Vfa2V5PlxyXG5jb25zdCBDTElFTlRfU1RBVEVfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfY2xpZW50cyc7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBjbGllbnQgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkocGVyc2lzdGVuY2VLZXksIGNsaWVudElkKSB7XHJcbiAgICByZXR1cm4gYCR7Q0xJRU5UX1NUQVRFX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7Y2xpZW50SWR9YDtcclxufVxyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBXZWJTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyB0aGUgbXV0YXRpb24gc3RhdGUgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5cclxuLy8gICAgIChmb3IgdW5hdXRoZW50aWNhdGVkIHVzZXJzKVxyXG4vLyBvcjogZmlyZXN0b3JlX211dGF0aW9uc188cGVyc2lzdGVuY2VfcHJlZml4Pl88YmF0Y2hfaWQ+Xzx1c2VyX3VpZD5cclxuLy9cclxuLy8gJ3VzZXJfdWlkJyBpcyBsYXN0IHRvIGF2b2lkIG5lZWRpbmcgdG8gZXNjYXBlICdfJyBjaGFyYWN0ZXJzIHRoYXQgaXQgbWlnaHRcclxuLy8gY29udGFpbi5cclxuY29uc3QgTVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfbXV0YXRpb25zJztcclxuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciBhIG11dGF0aW9uIGJhdGNoIGluIFdlYlN0b3JhZ2UgKi9cclxuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkocGVyc2lzdGVuY2VLZXksIHVzZXIsIGJhdGNoSWQpIHtcclxuICAgIGxldCBtdXRhdGlvbktleSA9IGAke01VVEFUSU9OX0JBVENIX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7YmF0Y2hJZH1gO1xyXG4gICAgaWYgKHVzZXIuaXNBdXRoZW50aWNhdGVkKCkpIHtcclxuICAgICAgICBtdXRhdGlvbktleSArPSBgXyR7dXNlci51aWR9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBtdXRhdGlvbktleTtcclxufVxyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBXZWJTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyBhIHF1ZXJ5IHRhcmdldCdzIG1ldGFkYXRhIGlzOlxyXG4vLyAgICAgZmlyZXN0b3JlX3RhcmdldHNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPHRhcmdldF9pZD5cclxuY29uc3QgUVVFUllfVEFSR0VUX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX3RhcmdldHMnO1xyXG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgcXVlcnkgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleShwZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpIHtcclxuICAgIHJldHVybiBgJHtRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHt0YXJnZXRJZH1gO1xyXG59XHJcbi8vIFRoZSBXZWJTdG9yYWdlIHByZWZpeCB0aGF0IHN0b3JlcyB0aGUgcHJpbWFyeSB0YWIncyBvbmxpbmUgc3RhdGUuIFRoZVxyXG4vLyBmb3JtYXQgb2YgdGhlIGtleSBpczpcclxuLy8gICAgIGZpcmVzdG9yZV9vbmxpbmVfc3RhdGVfPHBlcnNpc3RlbmNlX3ByZWZpeD5cclxuY29uc3QgT05MSU5FX1NUQVRFX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX29ubGluZV9zdGF0ZSc7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgdGhlIG9ubGluZSBzdGF0ZSBvZiB0aGUgcHJpbWFyeSB0YWIuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgcmV0dXJuIGAke09OTElORV9TVEFURV9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XHJcbn1cclxuLy8gVGhlIFdlYlN0b3JhZ2UgcHJlZml4IHRoYXQgcGxheXMgYXMgYSBldmVudCB0byBpbmRpY2F0ZSB0aGUgcmVtb3RlIGRvY3VtZW50c1xyXG4vLyBtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIHNvbWUgc2Vjb25kYXJ5IHRhYnMgbG9hZGluZyBhIGJ1bmRsZS5cclxuLy8gZm9ybWF0IG9mIHRoZSBrZXkgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfYnVuZGxlX2xvYWRlZF92Ml88cGVyc2lzdGVuY2VLZXk+XHJcbi8vIFRoZSB2ZXJzaW9uIGVuZGluZyB3aXRoIFwidjJcIiBzdG9yZXMgdGhlIGxpc3Qgb2YgbW9kaWZpZWQgY29sbGVjdGlvbiBncm91cHMuXHJcbmNvbnN0IEJVTkRMRV9MT0FERURfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfYnVuZGxlX2xvYWRlZF92Mic7XHJcbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZUxvYWRlZEtleShwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgcmV0dXJuIGAke0JVTkRMRV9MT0FERURfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xyXG59XHJcbi8vIFRoZSBXZWJTdG9yYWdlIGtleSBwcmVmaXggZm9yIHRoZSBrZXkgdGhhdCBzdG9yZXMgdGhlIGxhc3Qgc2VxdWVuY2UgbnVtYmVyIGFsbG9jYXRlZC4gVGhlIGtleVxyXG4vLyBsb29rcyBsaWtlICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyXzxwZXJzaXN0ZW5jZV9wcmVmaXg+Jy5cclxuY29uc3QgU0VRVUVOQ0VfTlVNQkVSX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX3NlcXVlbmNlX251bWJlcic7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgdGhlIGN1cnJlbnQgc2VxdWVuY2UgbnVtYmVyLiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXJLZXkocGVyc2lzdGVuY2VLZXkpIHtcclxuICAgIHJldHVybiBgJHtTRVFVRU5DRV9OVU1CRVJfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYSA9ICdTaGFyZWRDbGllbnRTdGF0ZSc7XHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBtdXRhdGlvbiBiYXRjaCwgaW5jbHVkaW5nIGl0cyB1c2VyIElELCBiYXRjaCBJRCBhbmRcclxuICogd2hldGhlciB0aGUgYmF0Y2ggaXMgJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJyBvciAncmVqZWN0ZWQnLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5jbGFzcyBNdXRhdGlvbk1ldGFkYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKHVzZXIsIGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy5iYXRjaElkID0gYmF0Y2hJZDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBNdXRhdGlvbk1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cclxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHVzZXIsIGJhdGNoSWQsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25CYXRjaCA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgbXV0YXRpb25CYXRjaCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgWydwZW5kaW5nJywgJ2Fja25vd2xlZGdlZCcsICdyZWplY3RlZCddLmluZGV4T2YobXV0YXRpb25CYXRjaC5zdGF0ZSkgIT09XHJcbiAgICAgICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICAobXV0YXRpb25CYXRjaC5lcnJvciA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvciA9PT0gJ29iamVjdCcpO1xyXG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodmFsaWREYXRhICYmIG11dGF0aW9uQmF0Y2guZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFsaWREYXRhID1cclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG11dGF0aW9uQmF0Y2guZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKG11dGF0aW9uQmF0Y2guZXJyb3IuY29kZSwgbXV0YXRpb25CYXRjaC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsaWREYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXV0YXRpb25NZXRhZGF0YSh1c2VyLCBiYXRjaElkLCBtdXRhdGlvbkJhdGNoLnN0YXRlLCBmaXJlc3RvcmVFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsIGBGYWlsZWQgdG8gcGFyc2UgbXV0YXRpb24gc3RhdGUgZm9yIElEICcke2JhdGNoSWR9JzogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcclxuICAgICAgICBjb25zdCBiYXRjaE1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcclxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICBiYXRjaE1ldGFkYXRhLmVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgY29kZTogdGhpcy5lcnJvci5jb2RlLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5lcnJvci5tZXNzYWdlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShiYXRjaE1ldGFkYXRhKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSG9sZHMgdGhlIHN0YXRlIG9mIGEgcXVlcnkgdGFyZ2V0LCBpbmNsdWRpbmcgaXRzIHRhcmdldCBJRCBhbmQgd2hldGhlciB0aGVcclxuICogdGFyZ2V0IGlzICdub3QtY3VycmVudCcsICdjdXJyZW50JyBvciAncmVqZWN0ZWQnLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5jbGFzcyBRdWVyeVRhcmdldE1ldGFkYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgUXVlcnlUYXJnZXRNZXRhZGF0YSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIGluIFdlYlN0b3JhZ2UuXHJcbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVdlYlN0b3JhZ2VFbnRyeSh0YXJnZXRJZCwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgdGFyZ2V0U3RhdGUgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgIFsnbm90LWN1cnJlbnQnLCAnY3VycmVudCcsICdyZWplY3RlZCddLmluZGV4T2YodGFyZ2V0U3RhdGUuc3RhdGUpICE9PVxyXG4gICAgICAgICAgICAgICAgLTEgJiZcclxuICAgICAgICAgICAgKHRhcmdldFN0YXRlLmVycm9yID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRTdGF0ZS5lcnJvciA9PT0gJ29iamVjdCcpO1xyXG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodmFsaWREYXRhICYmIHRhcmdldFN0YXRlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhbGlkRGF0YSA9XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKHRhcmdldFN0YXRlLmVycm9yLmNvZGUsIHRhcmdldFN0YXRlLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCB0YXJnZXRTdGF0ZS5zdGF0ZSwgZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIHRhcmdldCBzdGF0ZSBmb3IgSUQgJyR7dGFyZ2V0SWR9JzogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHtcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWVNczogRGF0ZS5ub3coKSAvLyBNb2RpZnkgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIHRyaWdnZXIgdXBkYXRlLlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgdGFyZ2V0U3RhdGUuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmVycm9yLmNvZGUsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRhcmdldFN0YXRlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBpbW11dGFibGUgQ2xpZW50U3RhdGUgZm9yIGEgY2xpZW50IHJlYWQgZnJvbVxyXG4gKiBXZWJTdG9yYWdlLCBjb250YWluaW5nIHRoZSBsaXN0IG9mIGFjdGl2ZSBxdWVyeSB0YXJnZXRzLlxyXG4gKi9cclxuY2xhc3MgUmVtb3RlQ2xpZW50U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IGFjdGl2ZVRhcmdldElkcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgUmVtb3RlQ2xpZW50U3RhdGUgZnJvbSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxyXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkoY2xpZW50SWQsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBKU09OLnBhcnNlKHZhbHVlKTtcclxuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIGNsaWVudFN0YXRlID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMgaW5zdGFuY2VvZiBBcnJheTtcclxuICAgICAgICBsZXQgYWN0aXZlVGFyZ2V0SWRzU2V0ID0gdGFyZ2V0SWRTZXQoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgdmFsaWREYXRhICYmIGkgPCBjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFsaWREYXRhID0gaXNTYWZlSW50ZWdlcihjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHNbaV0pO1xyXG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHNTZXQgPSBhY3RpdmVUYXJnZXRJZHNTZXQuYWRkKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVDbGllbnRTdGF0ZShjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgZGF0YSBmb3IgaW5zdGFuY2UgJyR7Y2xpZW50SWR9JzogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIG9ubGluZSBzdGF0ZSBmb3IgYWxsIGNsaWVudHMgcGFydGljaXBhdGluZyBpblxyXG4gKiBtdWx0aS10YWIuIFRoZSBvbmxpbmUgc3RhdGUgaXMgb25seSB3cml0dGVuIHRvIGJ5IHRoZSBwcmltYXJ5IGNsaWVudCwgYW5kXHJcbiAqIHVzZWQgaW4gc2Vjb25kYXJ5IGNsaWVudHMgdG8gdXBkYXRlIHRoZWlyIHF1ZXJ5IHZpZXdzLlxyXG4gKi9cclxuY2xhc3MgU2hhcmVkT25saW5lU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgU2hhcmVkT25saW5lU3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxyXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IHR5cGVvZiBvbmxpbmVTdGF0ZSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgWydVbmtub3duJywgJ09ubGluZScsICdPZmZsaW5lJ10uaW5kZXhPZihvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSkgIT09XHJcbiAgICAgICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICB0eXBlb2Ygb25saW5lU3RhdGUuY2xpZW50SWQgPT09ICdzdHJpbmcnO1xyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZWRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZS5jbGllbnRJZCwgb25saW5lU3RhdGUub25saW5lU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIG9ubGluZSBzdGF0ZTogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXRhZGF0YSBzdGF0ZSBvZiB0aGUgbG9jYWwgY2xpZW50LiBVbmxpa2UgYFJlbW90ZUNsaWVudFN0YXRlYCwgdGhpcyBjbGFzcyBpc1xyXG4gKiBtdXRhYmxlIGFuZCBrZWVwcyB0cmFjayBvZiBhbGwgcGVuZGluZyBtdXRhdGlvbnMsIHdoaWNoIGFsbG93cyB1cyB0b1xyXG4gKiB1cGRhdGUgdGhlIHJhbmdlIG9mIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2ggSURzIGFzIG5ldyBtdXRhdGlvbnMgYXJlIGFkZGVkIG9yXHJcbiAqIHJlbW92ZWQuXHJcbiAqXHJcbiAqIFRoZSBkYXRhIGluIGBMb2NhbENsaWVudFN0YXRlYCBpcyBub3QgcmVhZCBmcm9tIFdlYlN0b3JhZ2UgYW5kIGluc3RlYWRcclxuICogdXBkYXRlZCB2aWEgaXRzIGluc3RhbmNlIG1ldGhvZHMuIFRoZSB1cGRhdGVkIHN0YXRlIGNhbiBiZSBzZXJpYWxpemVkIHZpYVxyXG4gKiBgdG9XZWJTdG9yYWdlSlNPTigpYC5cclxuICovXHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbmNsYXNzIExvY2FsQ2xpZW50U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0YXJnZXRJZFNldCgpO1xyXG4gICAgfVxyXG4gICAgYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRoaXMuYWN0aXZlVGFyZ2V0SWRzLmFkZCh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGhpcy5hY3RpdmVUYXJnZXRJZHMuZGVsZXRlKHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBlbnRyeSBpbnRvIGEgSlNPTi1lbmNvZGVkIGZvcm1hdCB3ZSBjYW4gdXNlIGZvciBXZWJTdG9yYWdlLlxyXG4gICAgICogRG9lcyBub3QgZW5jb2RlIGBjbGllbnRJZGAgYXMgaXQgaXMgcGFydCBvZiB0aGUga2V5IGluIFdlYlN0b3JhZ2UuXHJcbiAgICAgKi9cclxuICAgIHRvV2ViU3RvcmFnZUpTT04oKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzOiB0aGlzLmFjdGl2ZVRhcmdldElkcy50b0FycmF5KCksXHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWVNczogRGF0ZS5ub3coKSAvLyBNb2RpZnkgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIHRyaWdnZXIgdXBkYXRlLlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCB1c2VzIFdlYlN0b3JhZ2UgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIGFzIHRoZVxyXG4gKiBiYWNraW5nIHN0b3JlIGZvciB0aGUgU2hhcmVkQ2xpZW50U3RhdGUuIEl0IGtlZXBzIHRyYWNrIG9mIGFsbCBhY3RpdmVcclxuICogY2xpZW50cyBhbmQgc3VwcG9ydHMgbW9kaWZpY2F0aW9ucyBvZiB0aGUgbG9jYWwgY2xpZW50J3MgZGF0YS5cclxuICovXHJcbmNsYXNzIFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aW5kb3csIHF1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgbG9jYWxDbGllbnRJZCwgaW5pdGlhbFVzZXIpIHtcclxuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRJZCA9IGxvY2FsQ2xpZW50SWQ7XHJcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlckhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVXZWJTdG9yYWdlRXZlbnQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhcHR1cmVzIFdlYlN0b3JhZ2UgZXZlbnRzIHRoYXQgb2NjdXIgYmVmb3JlIGBzdGFydCgpYCBpcyBjYWxsZWQuIFRoZXNlXHJcbiAgICAgICAgICogZXZlbnRzIGFyZSByZXBsYXllZCBvbmNlIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgIGlzIHN0YXJ0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIEVzY2FwZSB0aGUgc3BlY2lhbCBjaGFyYWN0ZXJzIG1lbnRpb25lZCBoZXJlOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9uc1xyXG4gICAgICAgIGNvbnN0IGVzY2FwZWRQZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5LnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBpbml0aWFsVXNlcjtcclxuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmxvY2FsQ2xpZW50SWQpO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJLZXkgPSBjcmVhdGVXZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXJLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gdGhpcy5hY3RpdmVDbGllbnRzLmluc2VydCh0aGlzLmxvY2FsQ2xpZW50SWQsIG5ldyBMb2NhbENsaWVudFN0YXRlKCkpO1xyXG4gICAgICAgIHRoaXMuY2xpZW50U3RhdGVLZXlSZSA9IG5ldyBSZWdFeHAoYF4ke0NMSUVOVF9TVEFURV9LRVlfUFJFRklYfV8ke2VzY2FwZWRQZXJzaXN0ZW5jZUtleX1fKFteX10qKSRgKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZSA9IG5ldyBSZWdFeHAoYF4ke01VVEFUSU9OX0JBVENIX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oXFxcXGQrKSg/Ol8oLiopKT8kYCk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVRhcmdldEtleVJlID0gbmV3IFJlZ0V4cChgXiR7UVVFUllfVEFSR0VUX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oXFxcXGQrKSRgKTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlTG9hZGVkS2V5ID0gY3JlYXRlQnVuZGxlTG9hZGVkS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xyXG4gICAgICAgIC8vIFJhdGhlciB0aGFuIGFkZGluZyB0aGUgc3RvcmFnZSBvYnNlcnZlciBkdXJpbmcgc3RhcnQoKSwgd2UgYWRkIHRoZVxyXG4gICAgICAgIC8vIHN0b3JhZ2Ugb2JzZXJ2ZXIgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBjb2xsZWN0XHJcbiAgICAgICAgLy8gZXZlbnRzIGJlZm9yZSBvdGhlciBjb21wb25lbnRzIHBvcHVsYXRlIHRoZWlyIGluaXRpYWwgc3RhdGUgKGR1cmluZyB0aGVpclxyXG4gICAgICAgIC8vIHJlc3BlY3RpdmUgc3RhcnQoKSBjYWxscykuIE90aGVyd2lzZSwgd2UgbWlnaHQgZm9yIGV4YW1wbGUgbWlzcyBhXHJcbiAgICAgICAgLy8gbXV0YXRpb24gdGhhdCBpcyBhZGRlZCBhZnRlciBMb2NhbFN0b3JlJ3Mgc3RhcnQoKSBwcm9jZXNzZWQgdGhlIGV4aXN0aW5nXHJcbiAgICAgICAgLy8gbXV0YXRpb25zIGJ1dCBiZWZvcmUgd2Ugb2JzZXJ2ZSBXZWJTdG9yYWdlIGV2ZW50cy5cclxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5zdG9yYWdlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgJ3RydWUnIGlmIFdlYlN0b3JhZ2UgaXMgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiAqL1xyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKHdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93LmxvY2FsU3RvcmFnZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzdGFydCgpIHtcclxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjbGllbnRzIHRvIGJhY2tmaWxsIHRoZSBkYXRhIGluXHJcbiAgICAgICAgLy8gU2hhcmVkQ2xpZW50U3RhdGUuXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbGllbnRzID0gYXdhaXQgdGhpcy5zeW5jRW5naW5lLmdldEFjdGl2ZUNsaWVudHMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElkIG9mIGV4aXN0aW5nQ2xpZW50cykge1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50SWQgPT09IHRoaXMubG9jYWxDbGllbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSB0aGlzLmdldEl0ZW0oY3JlYXRlV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIGNsaWVudElkKSk7XHJcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBSZW1vdGVDbGllbnRTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCBzdG9yYWdlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudFN0YXRlLmNsaWVudElkLCBjbGllbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0Q2xpZW50U3RhdGUoKTtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBvbmxpbmUgc3RhdGUgYW5kIGNhbGwgdGhlIGNhbGxiYWNrIGhhbmRsZXJcclxuICAgICAgICAvLyBpZiBhcHBsaWNhYmxlLlxyXG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlSlNPTiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXkpO1xyXG4gICAgICAgIGlmIChvbmxpbmVTdGF0ZUpTT04pIHtcclxuICAgICAgICAgICAgY29uc3Qgb25saW5lU3RhdGUgPSB0aGlzLmZyb21XZWJTdG9yYWdlT25saW5lU3RhdGUob25saW5lU3RhdGVKU09OKTtcclxuICAgICAgICAgICAgaWYgKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9ubGluZVN0YXRlRXZlbnQob25saW5lU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5lYXJseUV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWFybHlFdmVudHMgPSBbXTtcclxuICAgICAgICAvLyBSZWdpc3RlciBhIHdpbmRvdyB1bmxvYWQgaG9vayB0byByZW1vdmUgdGhlIGNsaWVudCBtZXRhZGF0YSBlbnRyeSBmcm9tXHJcbiAgICAgICAgLy8gV2ViU3RvcmFnZSBldmVuIGlmIGBzaHV0ZG93bigpYCB3YXMgbm90IGNhbGxlZC5cclxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsICgpID0+IHRoaXMuc2h1dGRvd24oKSk7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHdyaXRlU2VxdWVuY2VOdW1iZXIoc2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5zZXF1ZW5jZU51bWJlcktleSwgSlNPTi5zdHJpbmdpZnkoc2VxdWVuY2VOdW1iZXIpKTtcclxuICAgIH1cclxuICAgIGdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHRoaXMuYWN0aXZlQ2xpZW50cyk7XHJcbiAgICB9XHJcbiAgICBpc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzLmZvckVhY2goKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcbiAgICBhZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdE11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ3BlbmRpbmcnKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xyXG4gICAgICAgIC8vIE9uY2UgYSBmaW5hbCBtdXRhdGlvbiByZXN1bHQgaXMgb2JzZXJ2ZWQgYnkgb3RoZXIgY2xpZW50cywgdGhleSBubyBsb25nZXJcclxuICAgICAgICAvLyBhY2Nlc3MgdGhlIG11dGF0aW9uJ3MgbWV0YWRhdGEgZW50cnkuIFNpbmNlIFdlYlN0b3JhZ2UgcmVwbGF5cyBldmVudHNcclxuICAgICAgICAvLyBpbiBvcmRlciwgaXQgaXMgc2FmZSB0byBkZWxldGUgdGhlIGVudHJ5IHJpZ2h0IGFmdGVyIHVwZGF0aW5nIGl0LlxyXG4gICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcclxuICAgIH1cclxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICBsZXQgcXVlcnlTdGF0ZSA9ICdub3QtY3VycmVudCc7XHJcbiAgICAgICAgLy8gTG9va3VwIGFuIGV4aXN0aW5nIHF1ZXJ5IHN0YXRlIGlmIHRoZSB0YXJnZXQgSUQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFxyXG4gICAgICAgIC8vIGJ5IGFub3RoZXIgdGFiXHJcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gUXVlcnlUYXJnZXRNZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCBzdG9yYWdlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gbWV0YWRhdGEuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0YXRlLmFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiBxdWVyeVN0YXRlO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5yZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0Q2xpZW50U3RhdGUoKTtcclxuICAgIH1cclxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsQ2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdFF1ZXJ5VGFyZ2V0U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xyXG4gICAgICAgIHJlbW92ZWRCYXRjaElkcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHVzZXI7XHJcbiAgICAgICAgYWRkZWRCYXRjaElkcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0T25saW5lU3RhdGUob25saW5lU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgbm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RCdW5kbGVMb2FkZWRTdGF0ZShjb2xsZWN0aW9uR3JvdXBzKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHRoaXMuc3RvcmFnZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5KTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnUkVBRCcsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1NFVCcsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdSRU1PVkUnLCBrZXkpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVXZWJTdG9yYWdlRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICAvLyBOb3RlOiBUaGUgZnVuY3Rpb24gaXMgdHlwZWQgdG8gdGFrZSBFdmVudCB0byBiZSBpbnRlcmZhY2UtY29tcGF0aWJsZSB3aXRoXHJcbiAgICAgICAgLy8gYFdpbmRvdy5hZGRFdmVudExpc3RlbmVyYC5cclxuICAgICAgICBjb25zdCBzdG9yYWdlRXZlbnQgPSBldmVudDtcclxuICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LnN0b3JhZ2VBcmVhID09PSB0aGlzLnN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnRVZFTlQnLCBzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdSZWNlaXZlZCBXZWJTdG9yYWdlIG5vdGlmaWNhdGlvbiBmb3IgbG9jYWwgY2hhbmdlLiBBbm90aGVyIGNsaWVudCBtaWdodCBoYXZlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdnYXJiYWdlLWNvbGxlY3RlZCBvdXIgc3RhdGUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RXZlbnRzLnB1c2goc3RvcmFnZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFN0YXRlS2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50U3RhdGUuY2xpZW50SWQsIGNsaWVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoc3RvcmFnZUV2ZW50LmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50SWQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubXV0YXRpb25CYXRjaEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uTWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5xdWVyeVRhcmdldEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0TWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlUYXJnZXRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUXVlcnlUYXJnZXRFdmVudChxdWVyeVRhcmdldE1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0b3JhZ2VFdmVudC5rZXkgPT09IHRoaXMub25saW5lU3RhdGVLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBmcm9tV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmJ1bmRsZUxvYWRlZEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cHMgPSB0aGlzLmZyb21XZWJTdG9yZUJ1bmRsZUxvYWRlZFN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29sbGVjdGlvbkdyb3Vwcy5tYXAoY2cgPT4gdGhpcy5zeW5jRW5naW5lLnN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoY2cpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBsb2NhbENsaWVudFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUNsaWVudHMuZ2V0KHRoaXMubG9jYWxDbGllbnRJZCk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0Q2xpZW50U3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5LCB0aGlzLmxvY2FsQ2xpZW50U3RhdGUudG9XZWJTdG9yYWdlSlNPTigpKTtcclxuICAgIH1cclxuICAgIHBlcnNpc3RNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RhdGUgPSBuZXcgTXV0YXRpb25NZXRhZGF0YSh0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCk7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKG11dGF0aW9uS2V5LCBtdXRhdGlvblN0YXRlLnRvV2ViU3RvcmFnZUpTT04oKSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNdXRhdGlvblN0YXRlKGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShtdXRhdGlvbktleSk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHtcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMubG9jYWxDbGllbnRJZCxcclxuICAgICAgICAgICAgb25saW5lU3RhdGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXksIEpTT04uc3RyaW5naWZ5KGVudHJ5KSk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE1ldGFkYXRhID0gbmV3IFF1ZXJ5VGFyZ2V0TWV0YWRhdGEodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcik7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRhcmdldEtleSwgdGFyZ2V0TWV0YWRhdGEudG9XZWJTdG9yYWdlSlNPTigpKTtcclxuICAgIH1cclxuICAgIHBlcnNpc3RCdW5kbGVMb2FkZWRTdGF0ZShjb2xsZWN0aW9uR3JvdXBzKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY29sbGVjdGlvbkdyb3VwcykpO1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLmJ1bmRsZUxvYWRlZEtleSwganNvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBrZXkgaW4gV2ViU3RvcmFnZS4gUmV0dXJucyBudWxsIGlmIHRoZSBrZXkgZG9lcyBub3RcclxuICAgICAqIG1hdGNoIHRoZSBleHBlY3RlZCBrZXkgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBmcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jbGllbnRTdGF0ZUtleVJlLmV4ZWMoa2V5KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWUgY291bGQgbm90XHJcbiAgICAgKiBiZSBwYXJzZWQuXHJcbiAgICAgKi9cclxuICAgIGZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5mcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIFJlbW90ZUNsaWVudFN0YXRlLmZyb21XZWJTdG9yYWdlRW50cnkoY2xpZW50SWQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgbXV0YXRpb24gYmF0Y2ggc3RhdGUgaW4gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXHJcbiAgICAgKiBjb3VsZCBub3QgYmUgcGFyc2VkLlxyXG4gICAgICovXHJcbiAgICBmcm9tV2ViU3RvcmFnZU11dGF0aW9uTWV0YWRhdGEoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tdXRhdGlvbkJhdGNoS2V5UmUuZXhlYyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGJhdGNoSWQgPSBOdW1iZXIobWF0Y2hbMV0pO1xyXG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IG1hdGNoWzJdICE9PSB1bmRlZmluZWQgPyBtYXRjaFsyXSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIE11dGF0aW9uTWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeShuZXcgVXNlcih1c2VySWQpLCBiYXRjaElkLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIHF1ZXJ5IHRhcmdldCBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxyXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cclxuICAgICAqL1xyXG4gICAgZnJvbVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMucXVlcnlUYXJnZXRLZXlSZS5leGVjKGtleSk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBOdW1iZXIobWF0Y2hbMV0pO1xyXG4gICAgICAgIHJldHVybiBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGFuIG9ubGluZSBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxyXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cclxuICAgICAqL1xyXG4gICAgZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBTaGFyZWRPbmxpbmVTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGZyb21XZWJTdG9yZUJ1bmRsZUxvYWRlZFN0YXRlKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uQmF0Y2gpIHtcclxuICAgICAgICBpZiAobXV0YXRpb25CYXRjaC51c2VyLnVpZCAhPT0gdGhpcy5jdXJyZW50VXNlci51aWQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCBgSWdub3JpbmcgbXV0YXRpb24gZm9yIG5vbi1hY3RpdmUgdXNlciAke211dGF0aW9uQmF0Y2gudXNlci51aWR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUJhdGNoU3RhdGUobXV0YXRpb25CYXRjaC5iYXRjaElkLCBtdXRhdGlvbkJhdGNoLnN0YXRlLCBtdXRhdGlvbkJhdGNoLmVycm9yKTtcclxuICAgIH1cclxuICAgIGhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQodGFyZ2V0TWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jRW5naW5lLmFwcGx5VGFyZ2V0U3RhdGUodGFyZ2V0TWV0YWRhdGEudGFyZ2V0SWQsIHRhcmdldE1ldGFkYXRhLnN0YXRlLCB0YXJnZXRNZXRhZGF0YS5lcnJvcik7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBjbGllbnRTdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDbGllbnRzID0gY2xpZW50U3RhdGVcclxuICAgICAgICAgICAgPyB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudElkLCBjbGllbnRTdGF0ZSlcclxuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsaWVudHMucmVtb3ZlKGNsaWVudElkKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ1RhcmdldHMgPSB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModGhpcy5hY3RpdmVDbGllbnRzKTtcclxuICAgICAgICBjb25zdCBuZXdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHVwZGF0ZWRDbGllbnRzKTtcclxuICAgICAgICBjb25zdCBhZGRlZFRhcmdldHMgPSBbXTtcclxuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIG5ld1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV4aXN0aW5nVGFyZ2V0cy5mb3JFYWNoKHRhcmdldElkID0+IHtcclxuICAgICAgICAgICAgaWYgKCFuZXdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UoYWRkZWRUYXJnZXRzLCByZW1vdmVkVGFyZ2V0cykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IHVwZGF0ZWRDbGllbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgIC8vIFdlIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWVudCB0aGF0IHdyb3RlIHRoaXMgb25saW5lIHN0YXRlIGlzIHN0aWxsIGFjdGl2ZVxyXG4gICAgICAgIC8vIGJ5IGNvbXBhcmluZyBpdHMgY2xpZW50IElEIHRvIHRoZSBsaXN0IG9mIGNsaWVudHMga2VwdCBhY3RpdmUgaW5cclxuICAgICAgICAvLyBJbmRleGVkRGIuIElmIGEgY2xpZW50IGRvZXMgbm90IHVwZGF0ZSB0aGVpciBJbmRleGVkRGIgY2xpZW50IHN0YXRlXHJcbiAgICAgICAgLy8gd2l0aGluIDUgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgd2UgZG9uJ3QgZW1pdCBhbiBvbmxpbmVcclxuICAgICAgICAvLyBzdGF0ZSBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVDbGllbnRzLmdldChvbmxpbmVTdGF0ZS5jbGllbnRJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIob25saW5lU3RhdGUub25saW5lU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHMoY2xpZW50cykge1xyXG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRzID0gdGFyZ2V0SWRTZXQoKTtcclxuICAgICAgICBjbGllbnRzLmZvckVhY2goKGtldiwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cyA9IGFjdGl2ZVRhcmdldHMudW5pb25XaXRoKHZhbHVlLmFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVRhcmdldHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcihzZXFTdHJpbmcpIHtcclxuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IExpc3RlblNlcXVlbmNlLklOVkFMSUQ7XHJcbiAgICBpZiAoc2VxU3RyaW5nICE9IG51bGwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcVN0cmluZyk7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHBhcnNlZCA9PT0gJ251bWJlcicpO1xyXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlciA9IHBhcnNlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCAnRmFpbGVkIHRvIHJlYWQgc2VxdWVuY2UgbnVtYmVyIGZyb20gV2ViU3RvcmFnZScsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzZXF1ZW5jZU51bWJlcjtcclxufVxyXG4vKipcclxuICogYE1lbW9yeVNoYXJlZENsaWVudFN0YXRlYCBpcyBhIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBTaGFyZWRDbGllbnRTdGF0ZSBmb3JcclxuICogY2xpZW50cyB1c2luZyBtZW1vcnkgcGVyc2lzdGVuY2UuIFRoZSBzdGF0ZSBpbiB0aGlzIGNsYXNzIHJlbWFpbnMgZnVsbHlcclxuICogaXNvbGF0ZWQgYW5kIG5vIHN5bmNocm9uaXphdGlvbiBpcyBwZXJmb3JtZWQuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBuZXcgTG9jYWxDbGllbnRTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMucXVlcnlTdGF0ZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCkge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdIHx8ICdub3QtY3VycmVudCc7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdID0gc3RhdGU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXTtcclxuICAgIH1cclxuICAgIGdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcztcclxuICAgIH1cclxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsQ2xpZW50U3RhdGUoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgc2V0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbiAgICB3cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7IH1cclxuICAgIG5vdGlmeUJ1bmRsZUxvYWRlZChjb2xsZWN0aW9uR3JvdXBzKSB7XHJcbiAgICAgICAgLy8gTm8gb3AuXHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTm9vcENvbm5lY3Rpdml0eU1vbml0b3Ige1xyXG4gICAgYWRkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBOby1vcC5cclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIC8vIE5vLW9wLlxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHNpbXBsZSBoZWxwZXIgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBTdHJlYW0gaW50ZXJmYWNlIHRvXHJcbiAqIGJyaWRnZSB0byBvdGhlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBhcmUgc3RyZWFtcyBidXQgZG8gbm90IGltcGxlbWVudCB0aGVcclxuICogaW50ZXJmYWNlLiBUaGUgc3RyZWFtIGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBjYWxsT24uLi4gbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIFN0cmVhbUJyaWRnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kRm4gPSBhcmdzLnNlbmRGbjtcclxuICAgICAgICB0aGlzLmNsb3NlRm4gPSBhcmdzLmNsb3NlRm47XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3RlZChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ29ubmVjdGVkID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBvbk9wZW4oY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk9wZW4gPSBjYWxsYmFjaztcclxuICAgIH1cclxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbkNsb3NlID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UgPSBjYWxsYmFjaztcclxuICAgIH1cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMuY2xvc2VGbigpO1xyXG4gICAgfVxyXG4gICAgc2VuZChtc2cpIHtcclxuICAgICAgICB0aGlzLnNlbmRGbihtc2cpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uQ29ubmVjdGVkKCkge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ29ubmVjdGVkKCk7XHJcbiAgICB9XHJcbiAgICBjYWxsT25PcGVuKCkge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uT3BlbigpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uQ2xvc2UoZXJyKSB7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkT25DbG9zZShlcnIpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uTWVzc2FnZShtc2cpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UobXNnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIG1vc3QgcmVjZW50IGludm9jYXRpb24gb2ZcclxuICogYGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpYCwgb3IgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBpbnZva2VkLlxyXG4gKi9cclxubGV0IGxhc3RVbmlxdWVEZWJ1Z0lkID0gbnVsbDtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhbiBpbml0aWFsIHZhbHVlIGZvciBgbGFzdFVuaXF1ZURlYnVnSWRgLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWQgZnJvbSBhIHJhbmdlIG9mIGludGVnZXJzIHRoYXQgYXJlXHJcbiAqIHJlcHJlc2VudGVkIGFzIDggaGV4YWRlY2ltYWwgZGlnaXRzLiBUaGlzIG1lYW5zIHRoYXQgKHdpdGhpbiByZWFzb24pIGFueVxyXG4gKiBudW1iZXJzIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgdGhlIHJldHVybmVkIG51bWJlciBieSAxIHdpbGwgYWxzbyBiZVxyXG4gKiByZXByZXNlbnRlZCBieSA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBsZWFkcyB0byBhbGwgXCJJRHNcIiBoYXZpbmcgdGhlIHNhbWVcclxuICogbGVuZ3RoIHdoZW4gY29udmVydGVkIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBtYWtpbmcgcmVhZGluZyBsb2dzIGNvbnRhaW5pbmdcclxuICogdGhlc2UgSURzIGVhc2llciB0byBmb2xsb3cuIEFuZCBzaW5jZSB0aGUgcmV0dXJuIHZhbHVlIGlzIHJhbmRvbWx5IHNlbGVjdGVkXHJcbiAqIGl0IHdpbGwgaGVscCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbG9ncyBmcm9tIGRpZmZlcmVudCBleGVjdXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVJbml0aWFsVW5pcXVlRGVidWdJZCgpIHtcclxuICAgIGNvbnN0IG1pblJlc3VsdCA9IDB4MTAwMDAwMDA7XHJcbiAgICBjb25zdCBtYXhSZXN1bHQgPSAweDkwMDAwMDAwO1xyXG4gICAgY29uc3QgcmVzdWx0UmFuZ2UgPSBtYXhSZXN1bHQgLSBtaW5SZXN1bHQ7XHJcbiAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBNYXRoLnJvdW5kKHJlc3VsdFJhbmdlICogTWF0aC5yYW5kb20oKSk7XHJcbiAgICByZXR1cm4gbWluUmVzdWx0ICsgcmVzdWx0T2Zmc2V0O1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYSB1bmlxdWUgSUQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBJRCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlYnVnIGxvZ2dpbmcgbWVzc2FnZXMgdG8gaGVscFxyXG4gKiBjb3JyZWxhdGUgbG9nIG1lc3NhZ2VzIHRoYXQgbWF5IGJlIHNwYXRpYWxseSBzZXBhcmF0ZWQgaW4gdGhlIGxvZ3MsIGJ1dFxyXG4gKiBsb2dpY2FsbHkgcmVsYXRlZC4gRm9yIGV4YW1wbGUsIGEgbmV0d29yayBjb25uZWN0aW9uIGNvdWxkIGluY2x1ZGUgdGhlIHNhbWVcclxuICogXCJkZWJ1ZyBJRFwiIHN0cmluZyBpbiBhbGwgb2YgaXRzIGxvZyBtZXNzYWdlcyB0byBoZWxwIHRyYWNlIGEgc3BlY2lmaWNcclxuICogY29ubmVjdGlvbiBvdmVyIHRpbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdGhlIDEwLWNoYXJhY3RlciBnZW5lcmF0ZWQgSUQgKGUuZy4gXCIweGExYjJjM2Q0XCIpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCkge1xyXG4gICAgaWYgKGxhc3RVbmlxdWVEZWJ1Z0lkID09PSBudWxsKSB7XHJcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQgPSBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXN0VW5pcXVlRGVidWdJZCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcweCcgKyBsYXN0VW5pcXVlRGVidWdJZC50b1N0cmluZygxNik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLypcclxuICogVXRpbGl0aWVzIGZvciBkZWFsaW5nIHdpdGggbm9kZS5qcy1zdHlsZSBBUElzLiBTZWUgbm9kZVByb21pc2UgZm9yIG1vcmVcclxuICogZGV0YWlscy5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYSBuZXcgUHJvbWlzZS4gVGhlXHJcbiAqIGNhbGxiYWNrIGlzIHBhc3NlZCB0byB0aGUgZ2l2ZW4gYWN0aW9uIHdoaWNoIGNhbiB0aGVuIHVzZSB0aGUgY2FsbGJhY2sgYXNcclxuICogYSBwYXJhbWV0ZXIgdG8gYSBub2RlLXN0eWxlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgaW50ZW50IGlzIHRvIGRpcmVjdGx5IGJyaWRnZSBhIG5vZGUtc3R5bGUgZnVuY3Rpb24gKHdoaWNoIHRha2VzIGFcclxuICogY2FsbGJhY2spIGludG8gYSBQcm9taXNlIHdpdGhvdXQgbWFudWFsbHkgY29udmVydGluZyBiZXR3ZWVuIHRoZSBub2RlLXN0eWxlXHJcbiAqIGNhbGxiYWNrIGFuZCB0aGUgcHJvbWlzZSBhdCBlYWNoIGNhbGwuXHJcbiAqXHJcbiAqIEluIGVmZmVjdCBpdCBhbGxvd3MgeW91IHRvIGNvbnZlcnQ6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5ldyBQcm9taXNlKChyZXNvbHZlOiAodmFsdWU/OiBmcy5TdGF0cykgPT4gdm9pZCxcclxuICogICAgICAgICAgICAgIHJlamVjdDogKGVycm9yPzogYW55KSA9PiB2b2lkKSA9PiB7XHJcbiAqICAgZnMuc3RhdChwYXRoLCAoZXJyb3I/OiBhbnksIHN0YXQ/OiBmcy5TdGF0cykgPT4ge1xyXG4gKiAgICAgaWYgKGVycm9yKSB7XHJcbiAqICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICByZXNvbHZlKHN0YXQpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH0pO1xyXG4gKiB9KTtcclxuICpcclxuICogSW50b1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBub2RlUHJvbWlzZSgoY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxmcy5TdGF0cz4pID0+IHtcclxuICogICBmcy5zdGF0KHBhdGgsIGNhbGxiYWNrKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIGFzIGFuIGFyZ3VtZW50XHJcbiAqICAgICBhbmQgdGhlbiB1c2VzIHRoYXQgY2FsbGJhY2sgdG8gaW52b2tlIHNvbWUgbm9kZS1zdHlsZSBBUEkuXHJcbiAqIEByZXR1cm5zIGEgbmV3IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZWplY3RlZCBpZiB0aGUgY2FsbGJhY2sgaXMgZ2l2ZW4gdGhlXHJcbiAqICAgICBmaXJzdCBFcnJvciBwYXJhbWV0ZXIgb3Igd2lsbCByZXNvbHZlIHRvIHRoZSB2YWx1ZSBnaXZlbiBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlUHJvbWlzZShhY3Rpb24pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgYWN0aW9uKChlcnJvciwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFRPRE86IEZldGNoIHJ1bnRpbWUgdmVyc2lvbiBmcm9tIGdycGMtanMvcGFja2FnZS5qc29uIGluc3RlYWRcclxuLy8gd2hlbiB0aGVyZSdzIGEgY2xlYW5lciB3YXkgdG8gZHluYW1pYyByZXF1aXJlIEpTT04gaW4gYm90aCBOb2RlIEVTTSBhbmQgQ0pTXHJcbmNvbnN0IGdycGNWZXJzaW9uID0gJzEuOS4xJztcclxuY29uc3QgTE9HX1RBRyQ5ID0gJ0dycGNDb25uZWN0aW9uJztcclxuY29uc3QgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUgPSBgZ2wtbm9kZS8ke3Byb2Nlc3MudmVyc2lvbnMubm9kZX0gZmlyZS8ke1NES19WRVJTSU9OfSBncnBjLyR7Z3JwY1ZlcnNpb259YDtcclxuZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGEoZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGFwcElkKSB7XHJcbiAgICBoYXJkQXNzZXJ0KGF1dGhUb2tlbiA9PT0gbnVsbCB8fCBhdXRoVG9rZW4udHlwZSA9PT0gJ09BdXRoJyk7XHJcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBncnBjLk1ldGFkYXRhKCk7XHJcbiAgICBpZiAoYXV0aFRva2VuKSB7XHJcbiAgICAgICAgYXV0aFRva2VuLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gbWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpKTtcclxuICAgIH1cclxuICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgYXBwQ2hlY2tUb2tlbi5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IG1ldGFkYXRhLnNldChrZXksIHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXBwSWQpIHtcclxuICAgICAgICBtZXRhZGF0YS5zZXQoJ1gtRmlyZWJhc2UtR01QSUQnLCBhcHBJZCk7XHJcbiAgICB9XHJcbiAgICBtZXRhZGF0YS5zZXQoJ1gtR29vZy1BcGktQ2xpZW50JywgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUpO1xyXG4gICAgLy8gVGhlc2UgaGVhZGVycyBhcmUgdXNlZCB0byBpbXByb3ZlIHJvdXRpbmcgYW5kIHByb2plY3QgaXNvbGF0aW9uIGJ5IHRoZVxyXG4gICAgLy8gYmFja2VuZC5cclxuICAgIC8vIFRPRE8oYi8xOTk3Njc3MTIpOiBXZSBhcmUga2VlcGluZyAnR29vZ2xlLUNsb3VkLVJlc291cmNlLVByZWZpeCcgdW50aWwgRW11bGF0b3JzIGNhbiBiZVxyXG4gICAgLy8gcmVsZWFzZWQgd2l0aCBjbC80Mjg4MjAwNDYuIEN1cnJlbnRseSBibG9ja2VkIGJlY2F1c2UgRW11bGF0b3JzIGFyZSBub3cgYnVpbHQgd2l0aCBKYXZhXHJcbiAgICAvLyAxMSBmcm9tIEdvb2dsZTMuXHJcbiAgICBtZXRhZGF0YS5zZXQoJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnLCBkYXRhYmFzZVBhdGgpO1xyXG4gICAgbWV0YWRhdGEuc2V0KCd4LWdvb2ctcmVxdWVzdC1wYXJhbXMnLCBkYXRhYmFzZVBhdGgpO1xyXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xyXG59XHJcbi8qKlxyXG4gKiBBIENvbm5lY3Rpb24gaW1wbGVtZW50ZWQgYnkgR1JQQy1Ob2RlLlxyXG4gKi9cclxuY2xhc3MgR3JwY0Nvbm5lY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IocHJvdG9zLCBkYXRhYmFzZUluZm8pIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSW5mbyA9IGRhdGFiYXNlSW5mbztcclxuICAgICAgICAvLyBXZSBjYWNoZSBzdHVicyBmb3IgdGhlIG1vc3QtcmVjZW50bHktdXNlZCB0b2tlbi5cclxuICAgICAgICB0aGlzLmNhY2hlZFN0dWIgPSBudWxsO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBwcm90b3NbJ2dvb2dsZSddWydmaXJlc3RvcmUnXVsndjEnXTtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlUGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSW5mby5kYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQuZGF0YWJhc2V9YDtcclxuICAgIH1cclxuICAgIGdldCBzaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KCkge1xyXG4gICAgICAgIC8vIEJvdGggYGludm9rZVJQQygpYCBhbmQgYGludm9rZVN0cmVhbWluZ1JQQygpYCBpZ25vcmUgdGhlaXIgYHBhdGhgIGFyZ3VtZW50cywgYW5kIGV4cGVjdFxyXG4gICAgICAgIC8vIHRoZSBcInBhdGhcIiB0byBiZSBwYXJ0IG9mIHRoZSBnaXZlbiBgcmVxdWVzdGAuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVBY3RpdmVTdHViKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRTdHViKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgJ0NyZWF0aW5nIEZpcmVzdG9yZSBzdHViLicpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuZGF0YWJhc2VJbmZvLnNzbFxyXG4gICAgICAgICAgICAgICAgPyBncnBjLmNyZWRlbnRpYWxzLmNyZWF0ZVNzbCgpXHJcbiAgICAgICAgICAgICAgICA6IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUoKTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gbmV3IHRoaXMuZmlyZXN0b3JlLkZpcmVzdG9yZSh0aGlzLmRhdGFiYXNlSW5mby5ob3N0LCBjcmVkZW50aWFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFN0dWI7XHJcbiAgICB9XHJcbiAgICBpbnZva2VSUEMocnBjTmFtZSwgcGF0aCwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKTtcclxuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVNZXRhZGF0YSh0aGlzLmRhdGFiYXNlUGF0aCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCB0aGlzLmRhdGFiYXNlSW5mby5hcHBJZCk7XHJcbiAgICAgICAgY29uc3QganNvblJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0sIHJlcXVlc3QpO1xyXG4gICAgICAgIHJldHVybiBub2RlUHJvbWlzZSgoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBpbnZva2VkIHdpdGggcmVxdWVzdDpgLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0dWJbcnBjTmFtZV0oanNvblJlcXVlc3QsIG1ldGFkYXRhLCAoZ3JwY0Vycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdycGNFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gZmFpbGVkIHdpdGggZXJyb3I6YCwgZ3JwY0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRmlyZXN0b3JlRXJyb3IobWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gY29tcGxldGVkIHdpdGggcmVzcG9uc2U6YCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGV4cGVjdGVkUmVzcG9uc2VDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGludm9rZWQgKHN0cmVhbWluZykgd2l0aCByZXF1ZXN0OmAsIHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IHN0dWIgPSB0aGlzLmVuc3VyZUFjdGl2ZVN0dWIoKTtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkKTtcclxuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0pO1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHN0dWJbcnBjTmFtZV0oanNvblJlcXVlc3QsIG1ldGFkYXRhKTtcclxuICAgICAgICBsZXQgY2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJHtycGNOYW1lfSAke3N0cmVhbUlkfSByZWNlaXZlZCByZXN1bHQ6YCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMubGVuZ3RoID09PSBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gY29tcGxldGVkLmApO1xyXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrRmlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChncnBjRXJyb3IpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBmYWlsZWQgd2l0aCBlcnJvcjpgLCBncnBjRXJyb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gbWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKTtcclxuICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKGNvZGUsIGdycGNFcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8obWlrZWxlaGVuKTogVGhpcyBcIm1ldGhvZFwiIGlzIGEgbW9uc3Rlci4gU2hvdWxkIGJlIHJlZmFjdG9yZWQuXHJcbiAgICBvcGVuU3RyZWFtKHJwY05hbWUsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xyXG4gICAgICAgIGNvbnN0IGdycGNTdHJlYW0gPSBzdHViW3JwY05hbWVdKG1ldGFkYXRhKTtcclxuICAgICAgICBsZXQgY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbkNsb3NlKGVycik7XHJcbiAgICAgICAgICAgICAgICBncnBjU3RyZWFtLmVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtQnJpZGdlKHtcclxuICAgICAgICAgICAgc2VuZEZuOiAobXNnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IHNlbmRpbmc6YCwgbXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncnBjU3RyZWFtLndyaXRlKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvYmFibHkgbWVhbnMgd2UgZGlkbid0IGNvbmZvcm0gdG8gdGhlIHByb3RvLiAgTWFrZSBzdXJlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZyB0aGUgbWVzc2FnZSB3ZSBzZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcignRmFpbHVyZSBzZW5kaW5nOicsIG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdFcnJvcjonLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzZW5kaW5nIGJlY2F1c2UgZ1JQQyBzdHJlYW0gaXMgY2xvc2VkOicsIG1zZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlRm46ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGNsb3NlZCBsb2NhbGx5IHZpYSBjbG9zZSgpLmApO1xyXG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBvbkNvbm5lY3RlZFNlbnQgPSBmYWxzZTtcclxuICAgICAgICBncnBjU3RyZWFtLm9uKCdkYXRhJywgKG1zZykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gcmVjZWl2ZWQ6YCwgbXNnKTtcclxuICAgICAgICAgICAgICAgIC8vIEVtdWxhdGUgdGhlIFwib25Db25uZWN0ZWRcIiBldmVudCB0aGF0IFdlYkNoYW5uZWxDb25uZWN0aW9uIHNlbmRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFvbkNvbm5lY3RlZFNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uY2FsbE9uQ29ubmVjdGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db25uZWN0ZWRTZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25NZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBncnBjU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVuZGVkLmApO1xyXG4gICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgbG9nV2FybihMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBlcnJvci4gQ29kZTpgLCBncnBjRXJyb3IuY29kZSwgJ01lc3NhZ2U6JywgZ3JwY0Vycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XHJcbiAgICAgICAgICAgICAgICBjbG9zZShuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYE9wZW5pbmcgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gYCArXHJcbiAgICAgICAgICAgIGB0byAke3RoaXMuZGF0YWJhc2VJbmZvLmhvc3R9YCk7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTaW5jZSBncnBjIGhhcyBubyBleHBsaWNpdCBvcGVuIHN0YXR1cyAob3IgZG9lcyBpdD8pIHdlXHJcbiAgICAgICAgLy8gc2ltdWxhdGUgYW4gb25PcGVuIGluIHRoZSBuZXh0IGxvb3AgYWZ0ZXIgdGhlIHN0cmVhbSBoYWQgaXQncyBsaXN0ZW5lcnNcclxuICAgICAgICAvLyByZWdpc3RlcmVkXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHN0cmVhbS5jYWxsT25PcGVuKCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIGFuZCBjbGVhbnMgdXAgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEdycGNDb25uZWN0aW9uLlxyXG4gICAgICogSWYgYSBnUlBDIGNsaWVudCBoYXMgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoaXMgY29ubmVjdGlvbiwgdGhlIGdSUEMgY2xpZW50XHJcbiAgICAgKiBpcyBjbG9zZWQuIEZhaWx1cmUgdG8gY2FsbCB0ZXJtaW5hdGUgb24gYSBHcnBjQ29ubmVjdGlvbiBjYW4gcmVzdWx0XHJcbiAgICAgKiBpbiBsZWFrZWQgcmVzb3VyY2VzIG9mIHRoZSBnUlBDIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFN0dWIpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmVzdGVkID0ge1xuXHRnb29nbGU6IHtcblx0XHRuZXN0ZWQ6IHtcblx0XHRcdHByb3RvYnVmOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5Qcm90b2J1Zi5XZWxsS25vd25UeXBlc1wiLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ2l0aHViLmNvbS9nb2xhbmcvcHJvdG9idWYvcHR5cGVzL3dyYXBwZXJzXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucHJvdG9idWZcIixcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJXcmFwcGVyc1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHUEJcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdG9wdGltaXplX2ZvcjogXCJTUEVFRFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFRpbWVzdGFtcDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHNlY29uZHM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmFub3M6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JTZXQ6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpbGVEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcInBhY2thZ2VcIjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHB1YmxpY0RlcGVuZGVuY3k6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYWNrZWQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmljZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbGVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNvdXJjZUNvZGVJbmZvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDlcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3ludGF4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVzdGVkVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVudW1UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRW51bURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkRlY2w6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzZXJ2ZWRSYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlc2VydmVkUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZE5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRFeHRlbnNpb25SYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSZXNlcnZlZFJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhYmVsOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR0eXBlTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kZWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b25lb2ZJbmRleDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqc29uTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9ET1VCTEU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0ZMT0FUOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQ2NDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDY0OiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQzMjogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQ2NDogNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQzMjogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfQk9PTDogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU1RSSU5HOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9HUk9VUDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX01FU1NBR0U6IDExLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CWVRFUzogMTIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1VJTlQzMjogMTMsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0VOVU06IDE0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TRklYRUQzMjogMTUsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDY0OiAxNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDMyOiAxNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDY0OiAxOFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX09QVElPTkFMOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfUkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVBFQVRFRDogM1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0T25lb2ZEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFbnVtRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG51bWJlcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U2VydmljZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0TWV0aG9kRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0aW5wdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvdXRwdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJNZXRob2RPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2xpZW50U3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmVyU3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRqYXZhUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YU91dGVyQ2xhc3NuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhTXVsdGlwbGVGaWxlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDIwLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFTdHJpbmdDaGVja1V0Zjg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW1pemVGb3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wdGltaXplTW9kZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5LFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIlNQRUVEXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGdvUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNjR2VuZXJpY1NlcnZpY2VzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDE2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHlHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjY0VuYWJsZUFyZW5hczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvYmpjQ2xhc3NQcmVmaXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjc2hhcnBOYW1lc3BhY2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MzgsXG5cdFx0XHRcdFx0XHRcdFx0Mzhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRPcHRpbWl6ZU1vZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNQRUVEOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0Q09ERV9TSVpFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0TElURV9SVU5USU1FOiAzXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXNzYWdlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VTZXRXaXJlRm9ybWF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bm9TdGFuZGFyZERlc2NyaXB0b3JBY2Nlc3Nvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtYXBFbnRyeToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ4LFxuXHRcdFx0XHRcdFx0XHRcdDhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y3R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1RSSU5HXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhY2tlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSlNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDYsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiSlNfTk9STUFMXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhenk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0d2Vhazoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0NCxcblx0XHRcdFx0XHRcdFx0XHQ0XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0Q1R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklORzogMCxcblx0XHRcdFx0XHRcdFx0XHRcdENPUkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRTVFJJTkdfUElFQ0U6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEpTVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTk9STUFMOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfU1RSSU5HOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTlVNQkVSOiAyXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZk9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0YWxsb3dBbGlhczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMzNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2RPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTmFtZVBhcnRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpZGVudGlmaWVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG5lZ2F0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lUGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNFeHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXF1aXJlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNvdXJjZUNvZGVJbmZvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMb2NhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Bhbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFpbGluZ0NvbW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVhZGluZ0RldGFjaGVkQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0R2VuZXJhdGVkQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQW5ub3RhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QW5ub3RhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzb3VyY2VGaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YmVnaW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTdHJ1Y3Q6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibnVtYmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RyaW5nVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiYm9vbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImxpc3RWYWx1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib29sVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdHJ1Y3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGlzdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMaXN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHROdWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHROVUxMX1ZBTFVFOiAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRMaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVtcHR5OiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdERvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZsb2F0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZmxvYXRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRJbnQ2NFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VUludDY0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SW50MzJWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVJbnQzMlZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEJvb2xWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Qnl0ZXNWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEFueToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHR5cGVVcmw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJlc3RvcmU6IHtcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0djE6IHtcblx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0Y3NoYXJwX25hbWVzcGFjZTogXCJHb29nbGUuQ2xvdWQuRmlyZXN0b3JlLlYxXCIsXG5cdFx0XHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9maXJlc3RvcmUvdjE7ZmlyZXN0b3JlXCIsXG5cdFx0XHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIldyaXRlUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUuZmlyZXN0b3JlLnYxXCIsXG5cdFx0XHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdDRlNcIixcblx0XHRcdFx0XHRcdFx0cGhwX25hbWVzcGFjZTogXCJHb29nbGVcXFxcQ2xvdWRcXFxcRmlyZXN0b3JlXFxcXFYxXCIsXG5cdFx0XHRcdFx0XHRcdHJ1YnlfcGFja2FnZTogXCJHb29nbGU6OkNsb3VkOjpGaXJlc3RvcmU6OlYxXCJcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb25SZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZUZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCaXRTZXF1ZW5jZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Yml0bWFwOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJsb29tRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRiaXRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQml0U2VxdWVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNoQ291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFBhdGhzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFByZWNvbmRpdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uZGl0aW9uVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZXhpc3RzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleGlzdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRyYW5zYWN0aW9uT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZE9ubHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRXcml0ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE9ubHk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJSZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0cnlUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJib29sZWFuVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImludGVnZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG91YmxlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRpbWVzdGFtcFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYnl0ZXNWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVmZXJlbmNlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImdlb1BvaW50VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1hcFZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJvb2xlYW5WYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGltZXN0YW1wVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGdlb1BvaW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUudHlwZS5MYXRMbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhcnJheVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWFwVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEFycmF5VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdE1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RmlyZXN0b3JlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5kZWZhdWx0X2hvc3QpXCI6IFwiZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm9hdXRoX3Njb3BlcylcIjogXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlXCJcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG1ldGhvZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEdldERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkdldERvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3REb2N1bWVudHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJVcGRhdGVEb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBhdGNoXCI6IFwiL3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiZG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZG9jdW1lbnQsdXBkYXRlX21hc2tcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdGNoOiBcIi92MS97ZG9jdW1lbnQubmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkb2N1bWVudCx1cGRhdGVfbWFza1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiRGVsZXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJuYW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaEdldERvY3VtZW50c1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaEdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hHZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJCZWdpblRyYW5zYWN0aW9uUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNvbW1pdFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkNvbW1pdFJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHdyaXRlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx3cml0ZXNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJvbGxiYWNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJvbGxiYWNrUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkVtcHR5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2UsdHJhbnNhY3Rpb25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6cm9sbGJhY2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx0cmFuc2FjdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UnVuUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUnVuUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUGFydGl0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIldyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0U3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czp3cml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdExpc3Rlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0ZW5SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0ZW5SZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmxpc3RlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiTGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmF0Y2hXcml0ZVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNyZWF0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qKn0ve2NvbGxlY3Rpb25faWR9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiZG9jdW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0R2V0RG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yZGVyQnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzaG93TWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDcmVhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VXBkYXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcmVjb25kaXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmb3VuZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWlzc2luZ1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm91bmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1pc3Npbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Q29tbWl0UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSb2xsYmFja1JlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c2tpcHBlZFJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHJhbnNhY3Rpb25PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkFnZ3JlZ2F0aW9uUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnlSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25Db3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFydGl0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV4dFBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0ZW5SZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFkZFRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlVGFyZ2V0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmlsdGVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnREZWxldGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudERlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50UmVtb3ZlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRSZW1vdmVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFeGlzdGVuY2VGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50c1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZXN1bWVUb2tlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUXVlcnlUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudHNUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGV4cGVjdGVkQ291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0RG9jdW1lbnRzVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UXVlcnlUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Q2hhbmdlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2F1c2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucnBjLlN0YXR1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VGFyZ2V0Q2hhbmdlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT19DSEFOR0U6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0QUREOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFTU9WRTogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRDVVJSRU5UOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFU0VUOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RDb2xsZWN0aW9uSWRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaFdyaXRlUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGVSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnJwYy5TdGF0dXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJvamVjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZyb206IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvbGxlY3Rpb25TZWxlY3RvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdoZXJlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JkZXJCeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3JkZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydEF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kQXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxpbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Q29sbGVjdGlvblNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhbGxEZXNjZW5kYW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImNvbXBvc2l0ZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidW5hcnlGaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9zaXRlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvbXBvc2l0ZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5hcnlGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5hcnlGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tcG9zaXRlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBTkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9SOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0TEVTU19USEFOOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRMRVNTX1RIQU5fT1JfRVFVQUw6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEdSRUFURVJfVEhBTjogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0R1JFQVRFUl9USEFOX09SX0VRVUFMOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRFUVVBTDogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0VRVUFMOiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBUlJBWV9DT05UQUlOUzogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SU46IDgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFSUkFZX0NPTlRBSU5TX0FOWTogOSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0lOOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFVuYXJ5RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhbmRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OQU46IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05VTEw6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OQU46IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OVUxMOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0T3JkZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGlyZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkUmVmZXJlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UHJvamVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGlyZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERJUkVDVElPTl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBU0NFTkRJTkc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0REVTQ0VORElORzogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRTdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQWdncmVnYXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiY291bnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJhdmdcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ291bnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3VtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXZnOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkF2Z1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFsaWFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdENvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXBUbzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBdmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDdXJzb3I6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWZvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidmVyaWZ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2Zvcm1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHZlcmlmeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlTWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtLkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkVHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic2V0VG9TZXJ2ZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImluY3JlbWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1heGltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaW5pbXVtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXBwZW5kTWlzc2luZ0VsZW1lbnRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlQWxsRnJvbUFycmF5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUb1NlcnZlclZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4aW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbmltdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZUFsbEZyb21BcnJheToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTRVJWRVJfVkFMVUVfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFUVVFU1RfVElNRTogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEV4aXN0ZW5jZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1bmNoYW5nZWROYW1lczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkJsb29tRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YXBpOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvYXBpL2Fubm90YXRpb25zO2Fubm90YXRpb25zXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJIdHRwUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5hcGlcIixcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHQVBJXCIsXG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRodHRwOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIkh0dHBSdWxlXCIsXG5cdFx0XHRcdFx0XHRpZDogNzIyOTU3MjgsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SHR0cDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHJ1bGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwUnVsZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicHV0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBvc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBhdGNoXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGdldDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHV0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwb3N0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwYXRjaDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y3VzdG9tOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXN0b21IdHRwUGF0dGVyblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsQmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRDdXN0b21IdHRwUGF0dGVybjoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1ldGhvZFNpZ25hdHVyZToge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUxLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5NZXRob2RPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRlZmF1bHRIb3N0OiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNDksXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG9hdXRoU2NvcGVzOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTAsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLmFwaS5GaWVsZEJlaGF2aW9yXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1Mixcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRGSUVMRF9CRUhBVklPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0T1BUSU9OQUw6IDEsXG5cdFx0XHRcdFx0XHRcdFJFUVVJUkVEOiAyLFxuXHRcdFx0XHRcdFx0XHRPVVRQVVRfT05MWTogMyxcblx0XHRcdFx0XHRcdFx0SU5QVVRfT05MWTogNCxcblx0XHRcdFx0XHRcdFx0SU1NVVRBQkxFOiA1LFxuXHRcdFx0XHRcdFx0XHRVTk9SREVSRURfTElTVDogNixcblx0XHRcdFx0XHRcdFx0Tk9OX0VNUFRZX0RFRkFVTFQ6IDdcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0eXBlOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy90eXBlL2xhdGxuZztsYXRsbmdcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkxhdExuZ1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUudHlwZVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdUUFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdExhdExuZzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGxhdGl0dWRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRsb25naXR1ZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRycGM6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3JwYy9zdGF0dXM7c3RhdHVzXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJTdGF0dXNQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLnJwY1wiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIlJQQ1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFN0YXR1czoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGNvZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5BbnlcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIHByb3RvcyA9IHtcblx0bmVzdGVkOiBuZXN0ZWRcbn07XG5cbnZhciBwcm90b3MkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBuZXN0ZWQ6IG5lc3RlZCxcbiAgJ2RlZmF1bHQnOiBwcm90b3Ncbn0pO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVXNlZCBieSB0ZXN0cyBzbyB3ZSBjYW4gbWF0Y2ggQGdycGMvcHJvdG8tbG9hZGVyIGJlaGF2aW9yLiAqL1xyXG5jb25zdCBwcm90b0xvYWRlck9wdGlvbnMgPSB7XHJcbiAgICBsb25nczogU3RyaW5nLFxyXG4gICAgZW51bXM6IFN0cmluZyxcclxuICAgIGRlZmF1bHRzOiB0cnVlLFxyXG4gICAgb25lb2ZzOiBmYWxzZVxyXG59O1xyXG4vKipcclxuICogTG9hZHMgdGhlIHByb3RvY29sIGJ1ZmZlciBkZWZpbml0aW9ucyBmb3IgRmlyZXN0b3JlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgR3JwY09iamVjdCByZXByZXNlbnRpbmcgb3VyIHByb3Rvcy5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRQcm90b3MoKSB7XHJcbiAgICBjb25zdCBwYWNrYWdlRGVmaW5pdGlvbiA9IHByb3RvTG9hZGVyLmZyb21KU09OKHByb3RvcyQxLCBwcm90b0xvYWRlck9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGdycGMubG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWZpbml0aW9uKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogTG9hZHMgdGhlIEdSUEMgc3RhY2sgKi9cclxuZnVuY3Rpb24gbmV3Q29ubmVjdGlvbihkYXRhYmFzZUluZm8pIHtcclxuICAgIGNvbnN0IHByb3RvcyA9IGxvYWRQcm90b3MoKTtcclxuICAgIHJldHVybiBuZXcgR3JwY0Nvbm5lY3Rpb24ocHJvdG9zLCBkYXRhYmFzZUluZm8pO1xyXG59XHJcbi8qKiBSZXR1cm4gdGhlIFBsYXRmb3JtLXNwZWNpZmljIGNvbm5lY3Rpdml0eSBtb25pdG9yLiAqL1xyXG5mdW5jdGlvbiBuZXdDb25uZWN0aXZpdHlNb25pdG9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBOb29wQ29ubmVjdGl2aXR5TW9uaXRvcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBUaGUgUGxhdGZvcm0ncyAnd2luZG93JyBpbXBsZW1lbnRhdGlvbiBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuICovXHJcbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5VU0VfTU9DS19QRVJTSVNURU5DRSA9PT0gJ1lFUycpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKiBUaGUgUGxhdGZvcm0ncyAnZG9jdW1lbnQnIGltcGxlbWVudGF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpIHtcclxuICAgIHJldHVybiBuZXcgSnNvblByb3RvU2VyaWFsaXplcihkYXRhYmFzZUlkLCAvKiB1c2VQcm90bzNKc29uPSAqLyBmYWxzZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ4ID0gJ0V4cG9uZW50aWFsQmFja29mZic7XHJcbi8qKlxyXG4gKiBJbml0aWFsIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgYW4gZXJyb3IuXHJcbiAqIFNldCB0byAxcyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwaXMvZGVzaWduL2Vycm9ycy5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TID0gMTAwMDtcclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDEuNTtcclxuLyoqIE1heGltdW0gYmFja29mZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TID0gNjAgKiAxMDAwO1xyXG4vKipcclxuICogQSBoZWxwZXIgZm9yIHJ1bm5pbmcgZGVsYXllZCB0YXNrcyBmb2xsb3dpbmcgYW4gZXhwb25lbnRpYWwgYmFja29mZiBjdXJ2ZVxyXG4gKiBiZXR3ZWVuIGF0dGVtcHRzLlxyXG4gKlxyXG4gKiBFYWNoIGRlbGF5IGlzIG1hZGUgdXAgb2YgYSBcImJhc2VcIiBkZWxheSB3aGljaCBmb2xsb3dzIHRoZSBleHBvbmVudGlhbFxyXG4gKiBiYWNrb2ZmIGN1cnZlLCBhbmQgYSArLy0gNTAlIFwiaml0dGVyXCIgdGhhdCBpcyBjYWxjdWxhdGVkIGFuZCBhZGRlZCB0byB0aGVcclxuICogYmFzZSBkZWxheS4gVGhpcyBwcmV2ZW50cyBjbGllbnRzIGZyb20gYWNjaWRlbnRhbGx5IHN5bmNocm9uaXppbmcgdGhlaXJcclxuICogZGVsYXlzIGNhdXNpbmcgc3Bpa2VzIG9mIGxvYWQgdG8gdGhlIGJhY2tlbmQuXHJcbiAqL1xyXG5jbGFzcyBFeHBvbmVudGlhbEJhY2tvZmYge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBBc3luY1F1ZXVlIHRvIHJ1biBiYWNrb2ZmIG9wZXJhdGlvbnMgb24uXHJcbiAgICAgKi9cclxuICAgIHF1ZXVlLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIElEIHRvIHVzZSB3aGVuIHNjaGVkdWxpbmcgYmFja29mZiBvcGVyYXRpb25zIG9uIHRoZSBBc3luY1F1ZXVlLlxyXG4gICAgICovXHJcbiAgICB0aW1lcklkLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluaXRpYWwgZGVsYXkgKHVzZWQgYXMgdGhlIGJhc2UgZGVsYXkgb24gdGhlIGZpcnN0IHJldHJ5IGF0dGVtcHQpLlxyXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcclxuICAgICAqIGxpdHRsZSBhcyAwLjUqaW5pdGlhbERlbGF5TXMuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxEZWxheU1zID0gREVGQVVMVF9CQUNLT0ZGX0lOSVRJQUxfREVMQVlfTVMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbXVsdGlwbGllciB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBleHRlbmRlZCBiYXNlIGRlbGF5IGFmdGVyIGVhY2hcclxuICAgICAqIGF0dGVtcHQuXHJcbiAgICAgKi9cclxuICAgIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYmFzZSBkZWxheSBhZnRlciB3aGljaCBubyBmdXJ0aGVyIGJhY2tvZmYgaXMgcGVyZm9ybWVkLlxyXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcclxuICAgICAqIG11Y2ggYXMgMS41Km1heERlbGF5TXMuXHJcbiAgICAgKi9cclxuICAgIG1heERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TKSB7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xyXG4gICAgICAgIHRoaXMudGltZXJJZCA9IHRpbWVySWQ7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNcyA9IGluaXRpYWxEZWxheU1zO1xyXG4gICAgICAgIHRoaXMuYmFja29mZkZhY3RvciA9IGJhY2tvZmZGYWN0b3I7XHJcbiAgICAgICAgdGhpcy5tYXhEZWxheU1zID0gbWF4RGVsYXlNcztcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xyXG4gICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvKiogVGhlIGxhc3QgYmFja29mZiBhdHRlbXB0LCBhcyBlcG9jaCBtaWxsaXNlY29uZHMuICovXHJcbiAgICAgICAgdGhpcy5sYXN0QXR0ZW1wdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSB2ZXJ5IG5leHQgYmFja29mZkFuZFdhaXQoKSB3aWxsIGhhdmUgbm8gZGVsYXkuIElmIGl0IGlzIGNhbGxlZCBhZ2FpblxyXG4gICAgICogKGkuZS4gZHVlIHRvIGFuIGVycm9yKSwgaW5pdGlhbERlbGF5TXMgKHBsdXMgaml0dGVyKSB3aWxsIGJlIHVzZWQsIGFuZFxyXG4gICAgICogc3Vic2VxdWVudCBvbmVzIHdpbGwgaW5jcmVhc2UgYWNjb3JkaW5nIHRvIHRoZSBiYWNrb2ZmRmFjdG9yLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gdGhlIG1heGltdW0gZGVsYXkgKGUuZy4gZm9yIHVzZSBhZnRlciBhXHJcbiAgICAgKiBSRVNPVVJDRV9FWEhBVVNURUQgZXJyb3IpLlxyXG4gICAgICovXHJcbiAgICByZXNldFRvTWF4KCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMubWF4RGVsYXlNcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBjdXJyZW50RGVsYXlNcywgYW5kIGluY3JlYXNlcyB0aGVcclxuICAgICAqIGRlbGF5IGZvciBhbnkgc3Vic2VxdWVudCBhdHRlbXB0cy4gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvblxyXG4gICAgICogYWxyZWFkeSwgaXQgd2lsbCBiZSBjYW5jZWxlZC5cclxuICAgICAqL1xyXG4gICAgYmFja29mZkFuZFJ1bihvcCkge1xyXG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvbi5cclxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xyXG4gICAgICAgIC8vIEZpcnN0IHNjaGVkdWxlIHVzaW5nIHRoZSBjdXJyZW50IGJhc2UgKHdoaWNoIG1heSBiZSAwIGFuZCBzaG91bGQgYmVcclxuICAgICAgICAvLyBob25vcmVkIGFzIHN1Y2gpLlxyXG4gICAgICAgIGNvbnN0IGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyA9IE1hdGguZmxvb3IodGhpcy5jdXJyZW50QmFzZU1zICsgdGhpcy5qaXR0ZXJEZWxheU1zKCkpO1xyXG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgbGFzdEF0dGVtcHRUaW1lIGJlaW5nIGluIHRoZSBmdXR1cmUgZHVlIHRvIGEgY2xvY2sgY2hhbmdlLlxyXG4gICAgICAgIGNvbnN0IGRlbGF5U29GYXJNcyA9IE1hdGgubWF4KDAsIERhdGUubm93KCkgLSB0aGlzLmxhc3RBdHRlbXB0VGltZSk7XHJcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgYmFja29mZiBkZWxheSBhbHJlYWR5IGJlaW5nIHBhc3QuXHJcbiAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXlNcyA9IE1hdGgubWF4KDAsIGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyAtIGRlbGF5U29GYXJNcyk7XHJcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlbGF5TXMgPiAwKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOCwgYEJhY2tpbmcgb2ZmIGZvciAke3JlbWFpbmluZ0RlbGF5TXN9IG1zIGAgK1xyXG4gICAgICAgICAgICAgICAgYChiYXNlIGRlbGF5OiAke3RoaXMuY3VycmVudEJhc2VNc30gbXMsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlbGF5IHdpdGggaml0dGVyOiAke2Rlc2lyZWREZWxheVdpdGhKaXR0ZXJNc30gbXMsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGxhc3QgYXR0ZW1wdDogJHtkZWxheVNvRmFyTXN9IG1zIGFnbylgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMudGltZXJJZCwgcmVtYWluaW5nRGVsYXlNcywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RBdHRlbXB0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvcCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFwcGx5IGJhY2tvZmYgZmFjdG9yIHRvIGRldGVybWluZSBuZXh0IGRlbGF5IGFuZCBlbnN1cmUgaXQgaXMgd2l0aGluXHJcbiAgICAgICAgLy8gYm91bmRzLlxyXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyAqPSB0aGlzLmJhY2tvZmZGYWN0b3I7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA8IHRoaXMuaW5pdGlhbERlbGF5TXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5pbml0aWFsRGVsYXlNcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA+IHRoaXMubWF4RGVsYXlNcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLm1heERlbGF5TXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcEJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXJQcm9taXNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlLnNraXBEZWxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVyUHJvbWlzZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGluIHRoZSByYW5nZSBbLWN1cnJlbnRCYXNlTXMvMiwgY3VycmVudEJhc2VNcy8yXSAqL1xyXG4gICAgaml0dGVyRGVsYXlNcygpIHtcclxuICAgICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5jdXJyZW50QmFzZU1zO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckNyA9ICdQZXJzaXN0ZW50U3RyZWFtJztcclxuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gYWZ0ZXIgaXQgaXMgbWFya2VkIGlkbGUuICovXHJcbmNvbnN0IElETEVfVElNRU9VVF9NUyA9IDYwICogMTAwMDtcclxuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gdW50aWwgd2UgY29uc2lkZXIgaXQgaGVhbHRoeS4gKi9cclxuY29uc3QgSEVBTFRIWV9USU1FT1VUX01TID0gMTAgKiAxMDAwO1xyXG4vKipcclxuICogQSBQZXJzaXN0ZW50U3RyZWFtIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc3RyZWFtaW5nIFJQQ1xyXG4gKiB0byB0aGUgRmlyZXN0b3JlIGJhY2tlbmQuIEl0J3MgYnVpbHQgb24gdG9wIG9mIHRoZSBjb25uZWN0aW9ucyBvd24gc3VwcG9ydFxyXG4gKiBmb3Igc3RyZWFtaW5nIFJQQ3MsIGFuZCBhZGRzIHNldmVyYWwgY3JpdGljYWwgZmVhdHVyZXMgZm9yIG91ciBjbGllbnRzOlxyXG4gKlxyXG4gKiAgIC0gRXhwb25lbnRpYWwgYmFja29mZiBvbiBmYWlsdXJlXHJcbiAqICAgLSBBdXRoZW50aWNhdGlvbiB2aWEgQ3JlZGVudGlhbHNQcm92aWRlclxyXG4gKiAgIC0gRGlzcGF0Y2hpbmcgYWxsIGNhbGxiYWNrcyBpbnRvIHRoZSBzaGFyZWQgd29ya2VyIHF1ZXVlXHJcbiAqICAgLSBDbG9zaW5nIGlkbGUgc3RyZWFtcyBhZnRlciA2MCBzZWNvbmRzIG9mIGluYWN0aXZpdHlcclxuICpcclxuICogU3ViY2xhc3NlcyBvZiBQZXJzaXN0ZW50U3RyZWFtIGltcGxlbWVudCBzZXJpYWxpemF0aW9uIG9mIG1vZGVscyB0byBhbmRcclxuICogZnJvbSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdG9jb2wgYnVmZmVycyBmb3IgYSBzcGVjaWZpY1xyXG4gKiBzdHJlYW1pbmcgUlBDLlxyXG4gKlxyXG4gKiAjIyBTdGFydGluZyBhbmQgU3RvcHBpbmdcclxuICpcclxuICogU3RyZWFtaW5nIFJQQ3MgYXJlIHN0YXRlZnVsIGFuZCBuZWVkIHRvIGJlIHN0YXJ0KCllZCBiZWZvcmUgbWVzc2FnZXMgY2FuXHJcbiAqIGJlIHNlbnQgYW5kIHJlY2VpdmVkLiBUaGUgUGVyc2lzdGVudFN0cmVhbSB3aWxsIGNhbGwgdGhlIG9uT3BlbigpIGZ1bmN0aW9uXHJcbiAqIG9mIHRoZSBsaXN0ZW5lciBvbmNlIHRoZSBzdHJlYW0gaXMgcmVhZHkgdG8gYWNjZXB0IHJlcXVlc3RzLlxyXG4gKlxyXG4gKiBTaG91bGQgYSBzdGFydCgpIGZhaWwsIFBlcnNpc3RlbnRTdHJlYW0gd2lsbCBjYWxsIHRoZSByZWdpc3RlcmVkIG9uQ2xvc2UoKVxyXG4gKiBsaXN0ZW5lciB3aXRoIGEgRmlyZXN0b3JlRXJyb3IgaW5kaWNhdGluZyB3aGF0IHdlbnQgd3JvbmcuXHJcbiAqXHJcbiAqIEEgUGVyc2lzdGVudFN0cmVhbSBjYW4gYmUgc3RhcnRlZCBhbmQgc3RvcHBlZCByZXBlYXRlZGx5LlxyXG4gKlxyXG4gKiBHZW5lcmljIHR5cGVzOlxyXG4gKiAgU2VuZFR5cGU6IFRoZSB0eXBlIG9mIHRoZSBvdXRnb2luZyBtZXNzYWdlIG9mIHRoZSB1bmRlcmx5aW5nXHJcbiAqICAgIGNvbm5lY3Rpb24gc3RyZWFtXHJcbiAqICBSZWNlaXZlVHlwZTogVGhlIHR5cGUgb2YgdGhlIGluY29taW5nIG1lc3NhZ2Ugb2YgdGhlIHVuZGVybHlpbmdcclxuICogICAgY29ubmVjdGlvbiBzdHJlYW1cclxuICogIExpc3RlbmVyVHlwZTogVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjYWxsYmFja3NcclxuICovXHJcbmNsYXNzIFBlcnNpc3RlbnRTdHJlYW0ge1xyXG4gICAgY29uc3RydWN0b3IocXVldWUsIGNvbm5lY3Rpb25UaW1lcklkLCBpZGxlVGltZXJJZCwgaGVhbHRoVGltZXJJZCwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciwgbGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZXJJZCA9IGlkbGVUaW1lcklkO1xyXG4gICAgICAgIHRoaXMuaGVhbHRoVGltZXJJZCA9IGhlYWx0aFRpbWVySWQ7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyID0gYXV0aENyZWRlbnRpYWxzUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIgPSBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xvc2UgY291bnQgdGhhdCdzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgdGhlIHN0cmVhbSBpcyBjbG9zZWQ7IHVzZWQgYnlcclxuICAgICAgICAgKiBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKCkgdG8gaW52YWxpZGF0ZSBjYWxsYmFja3MgdGhhdCBoYXBwZW4gYWZ0ZXJcclxuICAgICAgICAgKiBjbG9zZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsb3NlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZihxdWV1ZSwgY29ubmVjdGlvblRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3RhcnQoKSBoYXMgYmVlbiBjYWxsZWQgYW5kIG5vIGVycm9yIGhhcyBvY2N1cnJlZC4gVHJ1ZVxyXG4gICAgICogaW5kaWNhdGVzIHRoZSBzdHJlYW0gaXMgb3BlbiBvciBpbiB0aGUgcHJvY2VzcyBvZiBvcGVuaW5nICh3aGljaFxyXG4gICAgICogZW5jb21wYXNzZXMgcmVzcGVjdGluZyBiYWNrb2ZmLCBnZXR0aW5nIGF1dGggdG9rZW5zLCBhbmQgc3RhcnRpbmcgdGhlXHJcbiAgICAgKiBhY3R1YWwgUlBDKS4gVXNlIGlzT3BlbigpIHRvIGRldGVybWluZSBpZiB0aGUgc3RyZWFtIGlzIG9wZW4gYW5kIHJlYWR5IGZvclxyXG4gICAgICogb3V0Ym91bmQgcmVxdWVzdHMuXHJcbiAgICAgKi9cclxuICAgIGlzU3RhcnRlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IDUgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkJhY2tvZmYgKi8gfHxcclxuICAgICAgICAgICAgdGhpcy5pc09wZW4oKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBSUEMgaXMgb3BlbiAodGhlIG9uT3BlbigpIGxpc3RlbmVyIGhhcyBiZWVuXHJcbiAgICAgKiBjYWxsZWQpIGFuZCB0aGUgc3RyZWFtIGlzIHJlYWR5IGZvciBvdXRib3VuZCByZXF1ZXN0cy5cclxuICAgICAqL1xyXG4gICAgaXNPcGVuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLyB8fFxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBSUEMuIE9ubHkgYWxsb3dlZCBpZiBpc1N0YXJ0ZWQoKSByZXR1cm5zIGZhbHNlLiBUaGUgc3RyZWFtIGlzXHJcbiAgICAgKiBub3QgaW1tZWRpYXRlbHkgcmVhZHkgZm9yIHVzZTogb25PcGVuKCkgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIFJQQyBpc1xyXG4gICAgICogcmVhZHkgZm9yIG91dGJvdW5kIHJlcXVlc3RzLCBhdCB3aGljaCBwb2ludCBpc09wZW4oKSB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gc3RhcnQgcmV0dXJucywgaXNTdGFydGVkKCkgd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybUJhY2tvZmYoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmF1dGgoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIFJQQy4gVGhpcyBjYWxsIGlzIGlkZW1wb3RlbnQgYW5kIGFsbG93ZWQgcmVnYXJkbGVzcyBvZiB0aGVcclxuICAgICAqIGN1cnJlbnQgaXNTdGFydGVkKCkgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBzdG9wIHJldHVybnMsIGlzU3RhcnRlZCgpIGFuZCBpc09wZW4oKSB3aWxsIGJvdGggcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnRlZCgpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZnRlciBhbiBlcnJvciB0aGUgc3RyZWFtIHdpbGwgdXN1YWxseSBiYWNrIG9mZiBvbiB0aGUgbmV4dCBhdHRlbXB0IHRvXHJcbiAgICAgKiBzdGFydCBpdC4gSWYgdGhlIGVycm9yIHdhcnJhbnRzIGFuIGltbWVkaWF0ZSByZXN0YXJ0IG9mIHRoZSBzdHJlYW0sIHRoZVxyXG4gICAgICogc2VuZGVyIGNhbiB1c2UgdGhpcyB0byBpbmRpY2F0ZSB0aGF0IHRoZSByZWNlaXZlciBzaG91bGQgbm90IGJhY2sgb2ZmLlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggZXJyb3Igd2lsbCBjYWxsIHRoZSBvbkNsb3NlKCkgbGlzdGVuZXIuIFRoYXQgZnVuY3Rpb24gY2FuIGRlY2lkZSB0b1xyXG4gICAgICogaW5oaWJpdCBiYWNrb2ZmIGlmIHJlcXVpcmVkLlxyXG4gICAgICovXHJcbiAgICBpbmhpYml0QmFja29mZigpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLztcclxuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgdGhpcyBzdHJlYW0gYXMgaWRsZS4gSWYgbm8gZnVydGhlciBhY3Rpb25zIGFyZSBwZXJmb3JtZWQgb24gdGhlXHJcbiAgICAgKiBzdHJlYW0gZm9yIG9uZSBtaW51dGUsIHRoZSBzdHJlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGNsb3NlIGl0c2VsZiBhbmRcclxuICAgICAqIG5vdGlmeSB0aGUgc3RyZWFtJ3Mgb25DbG9zZSgpIGhhbmRsZXIgd2l0aCBTdGF0dXMuT0suIFRoZSBzdHJlYW0gd2lsbCB0aGVuXHJcbiAgICAgKiBiZSBpbiBhICFpc1N0YXJ0ZWQoKSBzdGF0ZSwgcmVxdWlyaW5nIHRoZSBjYWxsZXIgdG8gc3RhcnQgdGhlIHN0cmVhbSBhZ2FpblxyXG4gICAgICogYmVmb3JlIGZ1cnRoZXIgdXNlLlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgc3RyZWFtcyB0aGF0IGFyZSBpbiBzdGF0ZSAnT3BlbicgY2FuIGJlIG1hcmtlZCBpZGxlLCBhcyBhbGwgb3RoZXJcclxuICAgICAqIHN0YXRlcyBpbXBseSBwZW5kaW5nIG5ldHdvcmsgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgbWFya0lkbGUoKSB7XHJcbiAgICAgICAgLy8gU3RhcnRzIHRoZSBpZGxlIHRpbWUgaWYgd2UgYXJlIGluIHN0YXRlICdPcGVuJyBhbmQgYXJlIG5vdCB5ZXQgYWxyZWFkeVxyXG4gICAgICAgIC8vIHJ1bm5pbmcgYSB0aW1lciAoaW4gd2hpY2ggY2FzZSB0aGUgcHJldmlvdXMgaWRsZSB0aW1lb3V0IHN0aWxsIGFwcGxpZXMpLlxyXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpICYmIHRoaXMuaWRsZVRpbWVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLmlkbGVUaW1lcklkLCBJRExFX1RJTUVPVVRfTVMsICgpID0+IHRoaXMuaGFuZGxlSWRsZUNsb3NlVGltZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgdW5kZXJseWluZyBzdHJlYW0uICovXHJcbiAgICBzZW5kUmVxdWVzdChtc2cpIHtcclxuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLnNlbmQobXNnKTtcclxuICAgIH1cclxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIGlkbGUgdGltZXIgd2hlbiB0aGUgc3RyZWFtIHNob3VsZCBjbG9zZSBkdWUgdG8gaW5hY3Rpdml0eS4gKi9cclxuICAgIGFzeW5jIGhhbmRsZUlkbGVDbG9zZVRpbWVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGltaW5nIG91dCBhbiBpZGxlIHN0cmVhbSB0aGVyZSdzIG5vIHJlYXNvbiB0byBmb3JjZSB0aGUgc3RyZWFtIGludG8gYmFja29mZiB3aGVuXHJcbiAgICAgICAgICAgIC8vIGl0IHJlc3RhcnRzIHNvIHNldCB0aGUgc3RyZWFtIHN0YXRlIHRvIEluaXRpYWwgaW5zdGVhZCBvZiBFcnJvci5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIE1hcmtzIHRoZSBzdHJlYW0gYXMgYWN0aXZlIGFnYWluLiAqL1xyXG4gICAgY2FuY2VsSWRsZUNoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xyXG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBDYW5jZWxzIHRoZSBoZWFsdGggY2hlY2sgZGVsYXllZCBvcGVyYXRpb24uICovXHJcbiAgICBjYW5jZWxIZWFsdGhDaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFsdGhDaGVjaykge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgc3RyZWFtIGFuZCBjbGVhbnMgdXAgYXMgbmVjZXNzYXJ5OlxyXG4gICAgICpcclxuICAgICAqICogY2xvc2VzIHRoZSB1bmRlcmx5aW5nIEdSUEMgc3RyZWFtO1xyXG4gICAgICogKiBjYWxscyB0aGUgb25DbG9zZSBoYW5kbGVyIHdpdGggdGhlIGdpdmVuICdlcnJvcic7XHJcbiAgICAgKiAqIHNldHMgaW50ZXJuYWwgc3RyZWFtIHN0YXRlIHRvICdmaW5hbFN0YXRlJztcclxuICAgICAqICogYWRqdXN0cyB0aGUgYmFja29mZiB0aW1lciBiYXNlZCBvbiB0aGUgZXJyb3JcclxuICAgICAqXHJcbiAgICAgKiBBIG5ldyBzdHJlYW0gY2FuIGJlIG9wZW5lZCBieSBjYWxsaW5nIHN0YXJ0KCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbmFsU3RhdGUgLSB0aGUgaW50ZW5kZWQgc3RhdGUgb2YgdGhlIHN0cmVhbSBhZnRlciBjbG9zaW5nLlxyXG4gICAgICogQHBhcmFtIGVycm9yIC0gdGhlIGVycm9yIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgd2l0aC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY2xvc2UoZmluYWxTdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICAvLyBDYW5jZWwgYW55IG91dHN0YW5kaW5nIHRpbWVycyAodGhleSdyZSBndWFyYW50ZWVkIG5vdCB0byBleGVjdXRlKS5cclxuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsSGVhbHRoQ2hlY2soKTtcclxuICAgICAgICB0aGlzLmJhY2tvZmYuY2FuY2VsKCk7XHJcbiAgICAgICAgLy8gSW52YWxpZGF0ZXMgYW55IHN0cmVhbS1yZWxhdGVkIGNhbGxiYWNrcyAoZS5nLiBmcm9tIGF1dGggb3IgdGhlXHJcbiAgICAgICAgLy8gdW5kZXJseWluZyBzdHJlYW0pLCBndWFyYW50ZWVpbmcgdGhleSB3b24ndCBleGVjdXRlLlxyXG4gICAgICAgIHRoaXMuY2xvc2VDb3VudCsrO1xyXG4gICAgICAgIGlmIChmaW5hbFN0YXRlICE9PSA0IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5FcnJvciAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGludGVudGlvbmFsIGNsb3NlIGVuc3VyZSB3ZSBkb24ndCBkZWxheSBvdXIgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRCkge1xyXG4gICAgICAgICAgICAvLyBMb2cgdGhlIGVycm9yLiAoUHJvYmFibHkgZWl0aGVyICdxdW90YSBleGNlZWRlZCcgb3IgJ21heCBxdWV1ZSBsZW5ndGggcmVhY2hlZCcuKVxyXG4gICAgICAgICAgICBsb2dFcnJvcihlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgbG9nRXJyb3IoJ1VzaW5nIG1heGltdW0gYmFja29mZiBkZWxheSB0byBwcmV2ZW50IG92ZXJsb2FkaW5nIHRoZSBiYWNrZW5kLicpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXRUb01heCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJlxyXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKSB7XHJcbiAgICAgICAgICAgIC8vIFwidW5hdXRoZW50aWNhdGVkXCIgZXJyb3IgbWVhbnMgdGhlIHRva2VuIHdhcyByZWplY3RlZC4gVGhpcyBzaG91bGQgcmFyZWx5XHJcbiAgICAgICAgICAgIC8vIGhhcHBlbiBzaW5jZSBib3RoIEF1dGggYW5kIEFwcENoZWNrIGVuc3VyZSBhIHN1ZmZpY2llbnQgVFRMIHdoZW4gd2VcclxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhIHRva2VuLiBJZiBhIHVzZXIgbWFudWFsbHkgcmVzZXRzIHRoZWlyIHN5c3RlbSBjbG9jayB0aGlzIGNhblxyXG4gICAgICAgICAgICAvLyBmYWlsLCBob3dldmVyLiBJbiB0aGlzIGNhc2UsIHdlIHNob3VsZCBnZXQgYSBDb2RlLlVOQVVUSEVOVElDQVRFRCBlcnJvclxyXG4gICAgICAgICAgICAvLyBiZWZvcmUgd2UgcmVjZWl2ZWQgdGhlIGZpcnN0IG1lc3NhZ2UgYW5kIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSB0aGUgdG9rZW5cclxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgd2UgZmV0Y2ggYSBuZXcgdG9rZW4uXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdW5kZXJseWluZyBzdHJlYW0gYmVjYXVzZSB3ZSBhcmUgbm8gbG9uZ2VyIGludGVyZXN0ZWQgaW4gZXZlbnRzLlxyXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRlYXJEb3duKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyBzdGF0ZSBtdXN0IGJlIGFzc2lnbmVkIGJlZm9yZSBjYWxsaW5nIG9uQ2xvc2UoKSB0byBhbGxvdyB0aGUgY2FsbGJhY2sgdG9cclxuICAgICAgICAvLyBpbmhpYml0IGJhY2tvZmYgb3Igb3RoZXJ3aXNlIG1hbmlwdWxhdGUgdGhlIHN0YXRlIGluIGl0cyBub24tc3RhcnRlZCBzdGF0ZS5cclxuICAgICAgICB0aGlzLnN0YXRlID0gZmluYWxTdGF0ZTtcclxuICAgICAgICAvLyBOb3RpZnkgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIHN0cmVhbSBjbG9zZWQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5saXN0ZW5lci5vbkNsb3NlKGVycm9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIG92ZXJyaWRkZW4gdG8gcGVyZm9ybSBhZGRpdGlvbmFsIGNsZWFudXAgYmVmb3JlIHRoZSBzdHJlYW0gaXMgY2xvc2VkLlxyXG4gICAgICogQ2FsbGluZyBzdXBlci50ZWFyRG93bigpIGlzIG5vdCByZXF1aXJlZC5cclxuICAgICAqL1xyXG4gICAgdGVhckRvd24oKSB7IH1cclxuICAgIGF1dGgoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovO1xyXG4gICAgICAgIGNvbnN0IGRpc3BhdGNoSWZOb3RDbG9zZWQgPSB0aGlzLmdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIodGhpcy5jbG9zZUNvdW50KTtcclxuICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWQsIGJ1dCBzZWUgVE9ETyBiZWxvdy5cclxuICAgICAgICBjb25zdCBjbG9zZUNvdW50ID0gdGhpcy5jbG9zZUNvdW50O1xyXG4gICAgICAgIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpXHJcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgLy8gU3RyZWFtIGNhbiBiZSBzdG9wcGVkIHdoaWxlIHdhaXRpbmcgZm9yIGF1dGhlbnRpY2F0aW9uLlxyXG4gICAgICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IFdlIHJlYWxseSBzaG91bGQganVzdCB1c2UgZGlzcGF0Y2hJZk5vdENsb3NlZFxyXG4gICAgICAgICAgICAvLyBhbmQgbGV0IHRoaXMgZGlzcGF0Y2ggb250byB0aGUgcXVldWUsIGJ1dCB0aGF0IG9wZW5lZCBhIHNwZWMgdGVzdCBjYW5cclxuICAgICAgICAgICAgLy8gb2Ygd29ybXMgdGhhdCBJIGRvbid0IHdhbnQgdG8gZGVhbCB3aXRoIGluIHRoaXMgUFIuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlQ291bnQgPT09IGNsb3NlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaGF2ZSB0byBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgb24gdGhlIEFzeW5jUXVldWUuXHJcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgZm9sbG93aW5nIGNhbGxzIGFyZSBzYWZlIHRvIGJlIGNhbGxlZCBvdXRzaWRlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gQXN5bmNRdWV1ZSBzaW5jZSB0aGV5IGRvbid0IGNoYWluIGFzeW5jaHJvbm91cyBjYWxsc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN0cmVhbShhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcnBjRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCAnRmV0Y2hpbmcgYXV0aCB0b2tlbiBmYWlsZWQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUNsb3NlKHJwY0Vycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFN0cmVhbShhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBkaXNwYXRjaElmTm90Q2xvc2VkID0gdGhpcy5nZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHRoaXMuY2xvc2VDb3VudCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLnN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ub25Db25uZWN0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHRoaXMubGlzdGVuZXIub25Db25uZWN0ZWQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ub25PcGVuKCgpID0+IHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMuaGVhbHRoVGltZXJJZCwgSEVBTFRIWV9USU1FT1VUX01TLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkhlYWx0aHkgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25PcGVuKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uQ2xvc2UoKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RyZWFtQ2xvc2UoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0cmVhbS5vbk1lc3NhZ2UoKG1zZykgPT4ge1xyXG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZShtc2cpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBlcmZvcm1CYWNrb2ZmKCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5CYWNrb2ZmICovO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFZpc2libGUgZm9yIHRlc3RzXHJcbiAgICBoYW5kbGVTdHJlYW1DbG9zZShlcnJvcikge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgYGNsb3NlIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xyXG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGUgc3RyZWFtIGNvdWxkIGNsb3NlIGNsZWFubHksIGhvd2V2ZXIsIGluIG91ciBjdXJyZW50IG1vZGVsXHJcbiAgICAgICAgLy8gd2UgbmV2ZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlY2F1c2UgaWYgd2Ugc3RvcCBhIHN0cmVhbSBvdXJzZWx2ZXMsXHJcbiAgICAgICAgLy8gdGhpcyBjYWxsYmFjayB3aWxsIG5ldmVyIGJlIGNhbGxlZC4gVG8gcHJldmVudCBjYXNlcyB3aGVyZSB3ZSByZXRyeVxyXG4gICAgICAgIC8vIHdpdGhvdXQgYSBiYWNrb2ZmIGFjY2lkZW50YWxseSwgd2Ugc2V0IHRoZSBzdHJlYW0gdG8gZXJyb3IgaW4gYWxsIGNhc2VzLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBcImRpc3BhdGNoZXJcIiBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgb3BlcmF0aW9ucyBvbnRvIHRoZVxyXG4gICAgICogQXN5bmNRdWV1ZSBidXQgb25seSBydW5zIHRoZW0gaWYgY2xvc2VDb3VudCByZW1haW5zIHVuY2hhbmdlZC4gVGhpcyBhbGxvd3NcclxuICAgICAqIHVzIHRvIHR1cm4gYXV0aCAvIHN0cmVhbSBjYWxsYmFja3MgaW50byBuby1vcHMgaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQgL1xyXG4gICAgICogcmUtb3BlbmVkLCBldGMuXHJcbiAgICAgKi9cclxuICAgIGdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIoc3RhcnRDbG9zZUNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIChmbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VDb3VudCA9PT0gc3RhcnRDbG9zZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDcsICdzdHJlYW0gY2FsbGJhY2sgc2tpcHBlZCBieSBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBQZXJzaXN0ZW50U3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgTGlzdGVuIFJQQy5cclxuICpcclxuICogT25jZSB0aGUgTGlzdGVuIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBvbk9wZW4oKSBsaXN0ZW5lciwgYW55IG51bWJlciBvZlxyXG4gKiBsaXN0ZW4oKSBhbmQgdW5saXN0ZW4oKSBjYWxscyBjYW4gYmUgbWFkZSB0byBjb250cm9sIHdoYXQgY2hhbmdlcyB3aWxsIGJlXHJcbiAqIHNlbnQgZnJvbSB0aGUgc2VydmVyIGZvciBMaXN0ZW5SZXNwb25zZXMuXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW50TGlzdGVuU3RyZWFtIGV4dGVuZHMgUGVyc2lzdGVudFN0cmVhbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcImxpc3Rlbl9zdHJlYW1fY29ubmVjdGlvbl9iYWNrb2ZmXCIgLyogVGltZXJJZC5MaXN0ZW5TdHJlYW1Db25uZWN0aW9uQmFja29mZiAqLywgXCJsaXN0ZW5fc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLkxpc3RlblN0cmVhbUlkbGUgKi8sIFwiaGVhbHRoX2NoZWNrX3RpbWVvdXRcIiAvKiBUaW1lcklkLkhlYWx0aENoZWNrVGltZW91dCAqLywgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnTGlzdGVuJywgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgIH1cclxuICAgIG9uTWVzc2FnZSh3YXRjaENoYW5nZVByb3RvKSB7XHJcbiAgICAgICAgLy8gQSBzdWNjZXNzZnVsIHJlc3BvbnNlIG1lYW5zIHRoZSBzdHJlYW0gaXMgaGVhbHRoeVxyXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIGNvbnN0IHdhdGNoQ2hhbmdlID0gZnJvbVdhdGNoQ2hhbmdlKHRoaXMuc2VyaWFsaXplciwgd2F0Y2hDaGFuZ2VQcm90byk7XHJcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSB2ZXJzaW9uRnJvbUxpc3RlblJlc3BvbnNlKHdhdGNoQ2hhbmdlUHJvdG8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2Uod2F0Y2hDaGFuZ2UsIHNuYXBzaG90KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGludGVyZXN0IGluIHRoZSByZXN1bHRzIG9mIHRoZSBnaXZlbiB0YXJnZXQuIElmIHRoZSB0YXJnZXRcclxuICAgICAqIGluY2x1ZGVzIGEgcmVzdW1lVG9rZW4gaXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC4gUmVzdWx0cyB0aGF0XHJcbiAgICAgKiBhZmZlY3QgdGhlIHRhcmdldCB3aWxsIGJlIHN0cmVhbWVkIGJhY2sgYXMgV2F0Y2hDaGFuZ2UgbWVzc2FnZXMgdGhhdFxyXG4gICAgICogcmVmZXJlbmNlIHRoZSB0YXJnZXRJZC5cclxuICAgICAqL1xyXG4gICAgd2F0Y2godGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcclxuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcclxuICAgICAgICByZXF1ZXN0LmFkZFRhcmdldCA9IHRvVGFyZ2V0KHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gdG9MaXN0ZW5SZXF1ZXN0TGFiZWxzKHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICByZXF1ZXN0LmxhYmVscyA9IGxhYmVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5yZWdpc3RlcnMgaW50ZXJlc3QgaW4gdGhlIHJlc3VsdHMgb2YgdGhlIHRhcmdldCBhc3NvY2lhdGVkIHdpdGggdGhlXHJcbiAgICAgKiBnaXZlbiB0YXJnZXRJZC5cclxuICAgICAqL1xyXG4gICAgdW53YXRjaCh0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcclxuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcclxuICAgICAgICByZXF1ZXN0LnJlbW92ZVRhcmdldCA9IHRhcmdldElkO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgU3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgV3JpdGUgUlBDLlxyXG4gKlxyXG4gKiBUaGUgV3JpdGUgUlBDIHJlcXVpcmVzIHRoZSBjYWxsZXIgdG8gbWFpbnRhaW4gc3BlY2lhbCBzdHJlYW1Ub2tlblxyXG4gKiBzdGF0ZSBpbiBiZXR3ZWVuIGNhbGxzLCB0byBoZWxwIHRoZSBzZXJ2ZXIgdW5kZXJzdGFuZCB3aGljaCByZXNwb25zZXMgdGhlXHJcbiAqIGNsaWVudCBoYXMgcHJvY2Vzc2VkIGJ5IHRoZSB0aW1lIHRoZSBuZXh0IHJlcXVlc3QgaXMgbWFkZS4gRXZlcnkgcmVzcG9uc2VcclxuICogd2lsbCBjb250YWluIGEgc3RyZWFtVG9rZW47IHRoaXMgdmFsdWUgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIG5leHRcclxuICogcmVxdWVzdC5cclxuICpcclxuICogQWZ0ZXIgY2FsbGluZyBzdGFydCgpIG9uIHRoaXMgc3RyZWFtLCB0aGUgbmV4dCByZXF1ZXN0IG11c3QgYmUgYSBoYW5kc2hha2UsXHJcbiAqIGNvbnRhaW5pbmcgd2hhdGV2ZXIgc3RyZWFtVG9rZW4gaXMgb24gaGFuZC4gT25jZSBhIHJlc3BvbnNlIHRvIHRoaXNcclxuICogcmVxdWVzdCBpcyByZWNlaXZlZCwgYWxsIHBlbmRpbmcgbXV0YXRpb25zIG1heSBiZSBzdWJtaXR0ZWQuIFdoZW5cclxuICogc3VibWl0dGluZyBtdWx0aXBsZSBiYXRjaGVzIG9mIG11dGF0aW9ucyBhdCB0aGUgc2FtZSB0aW1lLCBpdCdzXHJcbiAqIG9rYXkgdG8gdXNlIHRoZSBzYW1lIHN0cmVhbVRva2VuIGZvciB0aGUgY2FsbHMgdG8gd3JpdGVNdXRhdGlvbnMuXHJcbiAqXHJcbiAqIFRPRE8oYi8zMzI3MTIzNSk6IFVzZSBwcm90byB0eXBlc1xyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudFdyaXRlU3RyZWFtIGV4dGVuZHMgUGVyc2lzdGVudFN0cmVhbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcIndyaXRlX3N0cmVhbV9jb25uZWN0aW9uX2JhY2tvZmZcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwid3JpdGVfc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtSWRsZSAqLywgXCJoZWFsdGhfY2hlY2tfdGltZW91dFwiIC8qIFRpbWVySWQuSGVhbHRoQ2hlY2tUaW1lb3V0ICovLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrcyB3aGV0aGVyIG9yIG5vdCBhIGhhbmRzaGFrZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhjaGFuZ2VkIGFuZFxyXG4gICAgICogdGhlIHN0cmVhbSBpcyByZWFkeSB0byBhY2NlcHQgbXV0YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFuZHNoYWtlQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfO1xyXG4gICAgfVxyXG4gICAgLy8gT3ZlcnJpZGUgb2YgUGVyc2lzdGVudFN0cmVhbS5zdGFydFxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kc2hha2VDb21wbGV0ZV8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhc3RTdHJlYW1Ub2tlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdXBlci5zdGFydCgpO1xyXG4gICAgfVxyXG4gICAgdGVhckRvd24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVNdXRhdGlvbnMoW10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnV3JpdGUnLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgb25NZXNzYWdlKHJlc3BvbnNlUHJvdG8pIHtcclxuICAgICAgICAvLyBBbHdheXMgY2FwdHVyZSB0aGUgbGFzdCBzdHJlYW0gdG9rZW4uXHJcbiAgICAgICAgaGFyZEFzc2VydCghIXJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW4pO1xyXG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbjtcclxuICAgICAgICBpZiAoIXRoaXMuaGFuZHNoYWtlQ29tcGxldGVfKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCByZXNwb25zZSBpcyBhbHdheXMgdGhlIGhhbmRzaGFrZSByZXNwb25zZVxyXG4gICAgICAgICAgICBoYXJkQXNzZXJ0KCFyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cyB8fCByZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cy5sZW5ndGggPT09IDApO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZUNvbXBsZXRlXyA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uSGFuZHNoYWtlQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEEgc3VjY2Vzc2Z1bCBmaXJzdCB3cml0ZSByZXNwb25zZSBtZWFucyB0aGUgc3RyZWFtIGlzIGhlYWx0aHksXHJcbiAgICAgICAgICAgIC8vIE5vdGUsIHRoYXQgd2UgY291bGQgY29uc2lkZXIgYSBzdWNjZXNzZnVsIGhhbmRzaGFrZSBoZWFsdGh5LCBob3dldmVyLFxyXG4gICAgICAgICAgICAvLyB0aGUgd3JpdGUgaXRzZWxmIG1pZ2h0IGJlIGNhdXNpbmcgYW4gZXJyb3Igd2Ugd2FudCB0byBiYWNrIG9mZiBmcm9tLlxyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGZyb21Xcml0ZVJlc3VsdHMocmVzcG9uc2VQcm90by53cml0ZVJlc3VsdHMsIHJlc3BvbnNlUHJvdG8uY29tbWl0VGltZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbW1pdFZlcnNpb24gPSBmcm9tVmVyc2lvbihyZXNwb25zZVByb3RvLmNvbW1pdFRpbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbk11dGF0aW9uUmVzdWx0KGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYW4gaW5pdGlhbCBzdHJlYW1Ub2tlbiB0byB0aGUgc2VydmVyLCBwZXJmb3JtaW5nIHRoZSBoYW5kc2hha2VcclxuICAgICAqIHJlcXVpcmVkIHRvIG1ha2UgdGhlIFN0cmVhbWluZ1dyaXRlIFJQQyB3b3JrLiBTdWJzZXF1ZW50XHJcbiAgICAgKiBjYWxscyBzaG91bGQgd2FpdCB1bnRpbCBvbkhhbmRzaGFrZUNvbXBsZXRlIHdhcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSGFuZHNoYWtlKCkge1xyXG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogU3VwcG9ydCBzdHJlYW0gcmVzdW1wdGlvbi4gV2UgaW50ZW50aW9uYWxseSBkbyBub3Qgc2V0IHRoZVxyXG4gICAgICAgIC8vIHN0cmVhbSB0b2tlbiBvbiB0aGUgaGFuZHNoYWtlLCBpZ25vcmluZyBhbnkgc3RyZWFtIHRva2VuIHdlIG1pZ2h0IGhhdmUuXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xyXG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogU2VuZHMgYSBncm91cCBvZiBtdXRhdGlvbnMgdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kIHRvIGFwcGx5LiAqL1xyXG4gICAgd3JpdGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgc3RyZWFtVG9rZW46IHRoaXMubGFzdFN0cmVhbVRva2VuLFxyXG4gICAgICAgICAgICB3cml0ZXM6IG11dGF0aW9ucy5tYXAobXV0YXRpb24gPT4gdG9NdXRhdGlvbih0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERhdGFzdG9yZSBhbmQgaXRzIHJlbGF0ZWQgbWV0aG9kcyBhcmUgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgR29vZ2xlXHJcbiAqIENsb3VkIERhdGFzdG9yZSBncnBjIEFQSSwgd2hpY2ggcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgaXMgbW9yZSBjb252ZW5pZW50XHJcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUgdG8gY29uc3VtZS5cclxuICovXHJcbmNsYXNzIERhdGFzdG9yZSB7XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERhdGFzdG9yZSB0aGF0IGV4cG9zZXMgYWRkaXRpb25hbCBzdGF0ZSBmb3IgaW50ZXJuYWxcclxuICogY29uc3VtcHRpb24uXHJcbiAqL1xyXG5jbGFzcyBEYXRhc3RvcmVJbXBsIGV4dGVuZHMgRGF0YXN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlJbml0aWFsaXplZCgpIHtcclxuICAgICAgICBpZiAodGhpcy50ZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogSW52b2tlcyB0aGUgcHJvdmlkZWQgUlBDIHdpdGggYXV0aCBhbmQgQXBwQ2hlY2sgdG9rZW5zLiAqL1xyXG4gICAgaW52b2tlUlBDKHJwY05hbWUsIGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVJQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIHN0cmVhbWVkIHJlc3VsdHMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXHJcbiAgICBpbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0LCBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcclxuICAgICAgICB0aGlzLnZlcmlmeUluaXRpYWxpemVkKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSxcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmdldFRva2VuKClcclxuICAgICAgICBdKVxyXG4gICAgICAgICAgICAudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoKSwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8oZmlyZXN0b3JleHApOiBNYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgRGF0YXN0b3JlIGluc3RhbmNlIHBlclxyXG4vLyBmaXJlc3RvcmUtZXhwIGNsaWVudC5cclxuZnVuY3Rpb24gbmV3RGF0YXN0b3JlKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRhc3RvcmVJbXBsKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24oZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBtKSlcclxuICAgIH07XHJcbiAgICBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVJQQygnQ29tbWl0JywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGMoZGF0YXN0b3JlLCBrZXlzKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIGRvY3VtZW50czoga2V5cy5tYXAoayA9PiB0b05hbWUoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBrKSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdCYXRjaEdldERvY3VtZW50cycsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIHJlcXVlc3QsIGtleXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGRvY3MgPSBuZXcgTWFwKCk7XHJcbiAgICByZXNwb25zZS5mb3JFYWNoKHByb3RvID0+IHtcclxuICAgICAgICBjb25zdCBkb2MgPSBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvKTtcclxuICAgICAgICBkb2NzLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvYyk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gZG9jcy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoISFkb2MpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGRvYyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCB7IHJlcXVlc3QsIGFsaWFzTWFwLCBwYXJlbnQgfSA9IHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBxdWVyeVRvQWdncmVnYXRlVGFyZ2V0KHF1ZXJ5KSwgYWdncmVnYXRlcyk7XHJcbiAgICBpZiAoIWRhdGFzdG9yZUltcGwuY29ubmVjdGlvbi5zaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KSB7XHJcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QucGFyZW50O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnUnVuQWdncmVnYXRpb25RdWVyeScsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBwYXJlbnQsIHJlcXVlc3QsIFxyXG4gICAgLypleHBlY3RlZFJlc3BvbnNlQ291bnQ9Ki8gMSk7XHJcbiAgICAvLyBPbWl0IFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZSB0aGF0IG9ubHkgY29udGFpbiByZWFkVGltZXMuXHJcbiAgICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IHJlc3BvbnNlLmZpbHRlcihwcm90byA9PiAhIXByb3RvLnJlc3VsdCk7XHJcbiAgICBoYXJkQXNzZXJ0KGZpbHRlcmVkUmVzdWx0Lmxlbmd0aCA9PT0gMSk7XHJcbiAgICAvLyBSZW1hcCB0aGUgc2hvcnQtZm9ybSBhbGlhc2VzIHRoYXQgd2VyZSBzZW50IHRvIHRoZSBzZXJ2ZXJcclxuICAgIC8vIHRvIHRoZSBjbGllbnQtc2lkZSBhbGlhc2VzLiBVc2VycyB3aWxsIGFjY2VzcyB0aGUgcmVzdWx0c1xyXG4gICAgLy8gdXNpbmcgdGhlIGNsaWVudC1zaWRlIGFsaWFzLlxyXG4gICAgY29uc3QgdW5tYXBwZWRBZ2dyZWdhdGVGaWVsZHMgPSAoX2EgPSBmaWx0ZXJlZFJlc3VsdFswXS5yZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2dyZWdhdGVGaWVsZHM7XHJcbiAgICBjb25zdCByZW1hcHBlZEZpZWxkcyA9IE9iamVjdC5rZXlzKHVubWFwcGVkQWdncmVnYXRlRmllbGRzKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcclxuICAgICAgICBhY2N1bXVsYXRvclthbGlhc01hcFtrZXldXSA9IHVubWFwcGVkQWdncmVnYXRlRmllbGRzW2tleV07XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIHJlbWFwcGVkRmllbGRzO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShkYXRhc3RvcmUsIHF1ZXVlLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xyXG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xyXG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XHJcbn1cclxuZnVuY3Rpb24gbmV3UGVyc2lzdGVudFdhdGNoU3RyZWFtKGRhdGFzdG9yZSwgcXVldWUsIGxpc3RlbmVyKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBkYXRhc3RvcmVJbXBsLnZlcmlmeUluaXRpYWxpemVkKCk7XHJcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMaXN0ZW5TdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ2ID0gJ09ubGluZVN0YXRlVHJhY2tlcic7XHJcbi8vIFRvIGRlYWwgd2l0aCB0cmFuc2llbnQgZmFpbHVyZXMsIHdlIGFsbG93IG11bHRpcGxlIHN0cmVhbSBhdHRlbXB0cyBiZWZvcmVcclxuLy8gZ2l2aW5nIHVwIGFuZCB0cmFuc2l0aW9uaW5nIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPZmZsaW5lLlxyXG4vLyBUT0RPKG1pa2VsZWhlbik6IFRoaXMgdXNlZCB0byBiZSBzZXQgdG8gMiBhcyBhIG1pdGlnYXRpb24gZm9yIGIvNjYyMjgzOTQuXHJcbi8vIEBqZGltb25kIHRoaW5rcyB0aGF0IGJ1ZyBpcyBzdWZmaWNpZW50bHkgZml4ZWQgc28gdGhhdCB3ZSBjYW4gc2V0IHRoaXMgYmFja1xyXG4vLyB0byAxLiBJZiB0aGF0IHdvcmtzIG9rYXksIHdlIGNvdWxkIHBvdGVudGlhbGx5IHJlbW92ZSB0aGlzIGxvZ2ljIGVudGlyZWx5LlxyXG5jb25zdCBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTID0gMTtcclxuLy8gVG8gZGVhbCB3aXRoIHN0cmVhbSBhdHRlbXB0cyB0aGF0IGRvbid0IHN1Y2NlZWQgb3IgZmFpbCBpbiBhIHRpbWVseSBtYW5uZXIsXHJcbi8vIHdlIGhhdmUgYSB0aW1lb3V0IGZvciBPbmxpbmVTdGF0ZSB0byByZWFjaCBPbmxpbmUgb3IgT2ZmbGluZS5cclxuLy8gSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgd2UgdHJhbnNpdGlvbiB0byBPZmZsaW5lIHJhdGhlciB0aGFuIHdhaXRpbmdcclxuLy8gaW5kZWZpbml0ZWx5LlxyXG5jb25zdCBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcclxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHVzZWQgYnkgdGhlIFJlbW90ZVN0b3JlIHRvIHRyYWNrIHRoZSBPbmxpbmVTdGF0ZSAodGhhdCBpcyxcclxuICogd2hldGhlciBvciBub3QgdGhlIGNsaWVudCBhcyBhIHdob2xlIHNob3VsZCBiZSBjb25zaWRlcmVkIHRvIGJlIG9ubGluZSBvclxyXG4gKiBvZmZsaW5lKSwgaW1wbGVtZW50aW5nIHRoZSBhcHByb3ByaWF0ZSBoZXVyaXN0aWNzLlxyXG4gKlxyXG4gKiBJbiBwYXJ0aWN1bGFyLCB3aGVuIHRoZSBjbGllbnQgaXMgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQsIHdlXHJcbiAqIGFsbG93IHVwIHRvIE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgd2l0aGluIE9OTElORV9TVEFURV9USU1FT1VUX01TIGZvclxyXG4gKiBhIGNvbm5lY3Rpb24gdG8gc3VjY2VlZC4gSWYgd2UgaGF2ZSB0b28gbWFueSBmYWlsdXJlcyBvciB0aGUgdGltZW91dCBlbGFwc2VzLFxyXG4gKiB0aGVuIHdlIHNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSwgYW5kIHRoZSBjbGllbnQgd2lsbCBiZWhhdmUgYXMgaWZcclxuICogaXQgaXMgb2ZmbGluZSAoZ2V0KClzIHdpbGwgcmV0dXJuIGNhY2hlZCBkYXRhLCBldGMuKS5cclxuICovXHJcbmNsYXNzIE9ubGluZVN0YXRlVHJhY2tlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGVIYW5kbGVyO1xyXG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBPbmxpbmVTdGF0ZS4gKi9cclxuICAgICAgICB0aGlzLnN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNvdW50IG9mIGNvbnNlY3V0aXZlIGZhaWx1cmVzIHRvIG9wZW4gdGhlIHN0cmVhbS4gSWYgaXQgcmVhY2hlcyB0aGVcclxuICAgICAgICAgKiBtYXhpbXVtIGRlZmluZWQgYnkgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUywgd2UnbGwgc2V0IHRoZSBPbmxpbmVTdGF0ZSB0b1xyXG4gICAgICAgICAqIE9mZmxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRpbWVyIHRoYXQgZWxhcHNlcyBhZnRlciBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUywgYXQgd2hpY2ggcG9pbnQgd2VcclxuICAgICAgICAgKiB0cmFuc2l0aW9uIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPbmxpbmVTdGF0ZS5PZmZsaW5lIHdpdGhvdXQgd2FpdGluZ1xyXG4gICAgICAgICAqIGZvciB0aGUgc3RyZWFtIHRvIGFjdHVhbGx5IGZhaWwgKE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgdGltZXMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGUgY2xpZW50IHNob3VsZCBsb2cgYSB3YXJuaW5nIG1lc3NhZ2UgaWYgaXQgZmFpbHMgdG8gY29ubmVjdCB0b1xyXG4gICAgICAgICAqIHRoZSBiYWNrZW5kIChpbml0aWFsbHkgdHJ1ZSwgY2xlYXJlZCBhZnRlciBhIHN1Y2Nlc3NmdWwgc3RyZWFtLCBvciBpZiB3ZSd2ZVxyXG4gICAgICAgICAqIGxvZ2dlZCB0aGUgbWVzc2FnZSBhbHJlYWR5KS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNob3VsZFdhcm5DbGllbnRJc09mZmxpbmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgUmVtb3RlU3RvcmUgd2hlbiBhIHdhdGNoIHN0cmVhbSBpcyBzdGFydGVkIChpbmNsdWRpbmcgb24gZWFjaFxyXG4gICAgICogYmFja29mZiBhdHRlbXB0KS5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBhdHRlbXB0LCBpdCBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byBVbmtub3duIGFuZCBzdGFydHNcclxuICAgICAqIHRoZSBvbmxpbmVTdGF0ZVRpbWVyLlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcIm9ubGluZV9zdGF0ZV90aW1lb3V0XCIgLyogVGltZXJJZC5PbmxpbmVTdGF0ZVRpbWVvdXQgKi8sIE9OTElORV9TVEFURV9USU1FT1VUX01TLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dDbGllbnRPZmZsaW5lV2FybmluZ0lmTmVjZXNzYXJ5KGBCYWNrZW5kIGRpZG4ndCByZXNwb25kIHdpdGhpbiAke09OTElORV9TVEFURV9USU1FT1VUX01TIC8gMTAwMH0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHNlY29uZHMuYCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcclxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGhhbmRsZVdhdGNoU3RyZWFtRmFpbHVyZSgpIHdpbGwgY29udGludWUgdG8gaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyB3YXRjaFN0cmVhbUZhaWx1cmVzIGV2ZW4gdGhvdWdoIHdlIGFyZSBhbHJlYWR5IG1hcmtlZCBPZmZsaW5lLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm9uLWhhcm1mdWwuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBvdXIgT25saW5lU3RhdGUgYXMgYXBwcm9wcmlhdGUgYWZ0ZXIgdGhlIHdhdGNoIHN0cmVhbSByZXBvcnRzIGFcclxuICAgICAqIGZhaWx1cmUuIFRoZSBmaXJzdCBmYWlsdXJlIG1vdmVzIHVzIHRvIHRoZSAnVW5rbm93bicgc3RhdGUuIFdlIHRoZW4gbWF5XHJcbiAgICAgKiBhbGxvdyBtdWx0aXBsZSBmYWlsdXJlcyAoYmFzZWQgb24gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykgYmVmb3JlIHdlXHJcbiAgICAgKiBhY3R1YWxseSB0cmFuc2l0aW9uIHRvIHRoZSAnT2ZmbGluZScgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVdhdGNoU3RyZWFtRmFpbHVyZShlcnJvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xyXG4gICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2F0Y2hTdHJlYW1GYWlsdXJlcysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID49IE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0NsaWVudE9mZmxpbmVXYXJuaW5nSWZOZWNlc3NhcnkoYENvbm5lY3Rpb24gZmFpbGVkICR7TUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFU30gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRpbWVzLiBNb3N0IHJlY2VudCBlcnJvcjogJHtlcnJvci50b1N0cmluZygpfWApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4cGxpY2l0bHkgc2V0cyB0aGUgT25saW5lU3RhdGUgdG8gdGhlIHNwZWNpZmllZCBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyByZXNldHMgb3VyIHRpbWVycyAvIGZhaWx1cmUgY291bnRlcnMsIGV0Yy4gdXNlZCBieSBvdXJcclxuICAgICAqIE9mZmxpbmUgaGV1cmlzdGljcywgc28gbXVzdCBub3QgYmUgdXNlZCBpbiBwbGFjZSBvZlxyXG4gICAgICogaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpIGFuZCBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKS5cclxuICAgICAqL1xyXG4gICAgc2V0KG5ld1N0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhck9ubGluZVN0YXRlVGltZXIoKTtcclxuICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPSAwO1xyXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pIHtcclxuICAgICAgICAgICAgLy8gV2UndmUgY29ubmVjdGVkIHRvIHdhdGNoIGF0IGxlYXN0IG9uY2UuIERvbid0IHdhcm4gdGhlIGRldmVsb3BlclxyXG4gICAgICAgICAgICAvLyBhYm91dCBiZWluZyBvZmZsaW5lIGdvaW5nIGZvcndhcmQuXHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChuZXdTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBzZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpIHtcclxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihuZXdTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShkZXRhaWxzKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDb3VsZCBub3QgcmVhY2ggQ2xvdWQgRmlyZXN0b3JlIGJhY2tlbmQuICR7ZGV0YWlsc31cXG5gICtcclxuICAgICAgICAgICAgYFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyB0aGF0IHlvdXIgZGV2aWNlIGRvZXMgbm90IGhhdmUgYSBoZWFsdGh5IGAgK1xyXG4gICAgICAgICAgICBgSW50ZXJuZXQgY29ubmVjdGlvbiBhdCB0aGUgbW9tZW50LiBUaGUgY2xpZW50IHdpbGwgb3BlcmF0ZSBpbiBvZmZsaW5lIGAgK1xyXG4gICAgICAgICAgICBgbW9kZSB1bnRpbCBpdCBpcyBhYmxlIHRvIHN1Y2Nlc3NmdWxseSBjb25uZWN0IHRvIHRoZSBiYWNrZW5kLmA7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSkge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDYsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyT25saW5lU3RhdGVUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy5vbmxpbmVTdGF0ZVRpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ1ID0gJ1JlbW90ZVN0b3JlJztcclxuLy8gVE9ETyhiLzM1ODUzNDAyKTogTmVnb3RpYXRlIHRoaXMgd2l0aCB0aGUgc3RyZWFtLlxyXG5jb25zdCBNQVhfUEVORElOR19XUklURVMgPSAxMDtcclxuY2xhc3MgUmVtb3RlU3RvcmVJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9jYWwgc3RvcmUsIHVzZWQgdG8gZmlsbCB0aGUgd3JpdGUgcGlwZWxpbmUgd2l0aCBvdXRib3VuZCBtdXRhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGxvY2FsU3RvcmUsIFxyXG4gICAgLyoqIFRoZSBjbGllbnQtc2lkZSBwcm94eSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZC4gKi9cclxuICAgIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMucmVtb3RlU3luY2VyID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIHVwIHRvIE1BWF9QRU5ESU5HX1dSSVRFUyB3cml0ZXMgdGhhdCB3ZSBoYXZlIGZldGNoZWQgZnJvbSB0aGVcclxuICAgICAgICAgKiBMb2NhbFN0b3JlIHZpYSBmaWxsV3JpdGVQaXBlbGluZSgpIGFuZCBoYXZlIG9yIHdpbGwgc2VuZCB0byB0aGUgd3JpdGVcclxuICAgICAgICAgKiBzdHJlYW0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuZXZlciB3cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDAgdGhlIFJlbW90ZVN0b3JlIHdpbGwgYXR0ZW1wdCB0byBzdGFydCBvclxyXG4gICAgICAgICAqIHJlc3RhcnQgdGhlIHdyaXRlIHN0cmVhbS4gV2hlbiB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkIHRoZSB3cml0ZXMgaW4gdGhlXHJcbiAgICAgICAgICogcGlwZWxpbmUgd2lsbCBiZSBzZW50IGluIG9yZGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV3JpdGVzIHJlbWFpbiBpbiB3cml0ZVBpcGVsaW5lIHVudGlsIHRoZXkgYXJlIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZFxyXG4gICAgICAgICAqIGFuZCB0aHVzIHdpbGwgYXV0b21hdGljYWxseSBiZSByZS1zZW50IGlmIHRoZSBzdHJlYW0gaXMgaW50ZXJydXB0ZWQgL1xyXG4gICAgICAgICAqIHJlc3RhcnRlZCBiZWZvcmUgdGhleSdyZSBhY2tub3dsZWRnZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXcml0ZSByZXNwb25zZXMgZnJvbSB0aGUgYmFja2VuZCBhcmUgbGlua2VkIHRvIHRoZWlyIG9yaWdpbmF0aW5nIHJlcXVlc3RcclxuICAgICAgICAgKiBwdXJlbHkgYmFzZWQgb24gb3JkZXIsIGFuZCBzbyB3ZSBjYW4ganVzdCBzaGlmdCgpIHdyaXRlcyBmcm9tIHRoZSBmcm9udCBvZlxyXG4gICAgICAgICAqIHRoZSB3cml0ZVBpcGVsaW5lIGFzIHdlIHJlY2VpdmUgcmVzcG9uc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud3JpdGVQaXBlbGluZSA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiB3YXRjaGVkIHRhcmdldHMgdGhhdCB0aGUgY2xpZW50IGNhcmVzIGFib3V0IHRyYWNraW5nIGFuZCB0aGVcclxuICAgICAgICAgKiB1c2VyIGhhcyBleHBsaWNpdGx5IGNhbGxlZCBhICdsaXN0ZW4nIGZvciB0aGlzIHRhcmdldC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZXNlIHRhcmdldHMgbWF5IG9yIG1heSBub3QgaGF2ZSBiZWVuIHNlbnQgdG8gb3IgYWNrbm93bGVkZ2VkIGJ5IHRoZVxyXG4gICAgICAgICAqIHNlcnZlci4gT24gcmUtZXN0YWJsaXNoaW5nIHRoZSBsaXN0ZW4gc3RyZWFtLCB0aGVzZSB0YXJnZXRzIHNob3VsZCBiZSBzZW50XHJcbiAgICAgICAgICogdG8gdGhlIHNlcnZlci4gVGhlIHRhcmdldHMgcmVtb3ZlZCB3aXRoIHVubGlzdGVucyBhcmUgcmVtb3ZlZCBlYWdlcmx5XHJcbiAgICAgICAgICogd2l0aG91dCB3YWl0aW5nIGZvciBjb25maXJtYXRpb24gZnJvbSB0aGUgbGlzdGVuIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpc3RlblRhcmdldHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzZXQgb2YgcmVhc29ucyBmb3Igd2h5IHRoZSBSZW1vdGVTdG9yZSBtYXkgYmUgb2ZmbGluZS4gSWYgZW1wdHksIHRoZVxyXG4gICAgICAgICAqIFJlbW90ZVN0b3JlIG1heSBzdGFydCBpdHMgbmV0d29yayBjb25uZWN0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9mZmxpbmVDYXVzZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgaGFuZGxlcnMgdGhhdCBnZXQgY2FsbGVkIHdoZW4gdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIG9uIHRoZSBXZWIgY2xpZW50IHRvIGNyZWF0ZSB0aGVcclxuICAgICAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbXMgKHRvIHN1cHBvcnQgdHJlZS1zaGFrZWFibGUgc3RyZWFtcykuIE9uIEFuZHJvaWQgYW5kIGlPUyxcclxuICAgICAgICAgKiB0aGUgc3RyZWFtcyBhcmUgY3JlYXRlZCBkdXJpbmcgY29uc3RydWN0aW9uIG9mIFJlbW90ZVN0b3JlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlNb25pdG9yID0gY29ubmVjdGl2aXR5TW9uaXRvcjtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eU1vbml0b3IuYWRkQ2FsbGJhY2soKF8pID0+IHtcclxuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFBvcnRpbmcgTm90ZTogVW5saWtlIGlPUywgYHJlc3RhcnROZXR3b3JrKClgIGlzIGNhbGxlZCBldmVuIHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIGJlY29tZXMgdW5yZWFjaGFibGUgYXMgd2UgZG9uJ3QgaGF2ZSBhbnkgb3RoZXIgd2F5IHRvIHRlYXJcclxuICAgICAgICAgICAgICAgIC8vIGRvd24gb3VyIHN0cmVhbXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuVXNlTmV0d29yayh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1Jlc3RhcnRpbmcgc3RyZWFtcyBmb3IgbmV0d29yayByZWFjaGFiaWxpdHkgY2hhbmdlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3RhcnROZXR3b3JrKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlVHJhY2tlciA9IG5ldyBPbmxpbmVTdGF0ZVRyYWNrZXIoYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdSZW1vdGVTdG9yZShsb2NhbFN0b3JlLCBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyBSZW1vdGVTdG9yZUltcGwobG9jYWxTdG9yZSwgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpO1xyXG59XHJcbi8qKiBSZS1lbmFibGVzIHRoZSBuZXR3b3JrLiBJZGVtcG90ZW50LiAqL1xyXG5mdW5jdGlvbiByZW1vdGVTdG9yZUVuYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5kZWxldGUoMCAvKiBPZmZsaW5lQ2F1c2UuVXNlckRpc2FibGVkICovKTtcclxuICAgIHJldHVybiBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrU3RhdHVzSGFuZGxlciBvZiByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldHdvcmtTdGF0dXNIYW5kbGVyKC8qIGVuYWJsZWQ9ICovIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGVtcG9yYXJpbHkgZGlzYWJsZXMgdGhlIG5ldHdvcmsuIFRoZSBuZXR3b3JrIGNhbiBiZSByZS1lbmFibGVkIHVzaW5nXHJcbiAqIGVuYWJsZU5ldHdvcmsoKS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMCAvKiBPZmZsaW5lQ2F1c2UuVXNlckRpc2FibGVkICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSBzbyBnZXQoKXMgcmV0dXJuIGZyb20gY2FjaGUsIGV0Yy5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBmb3IgKGNvbnN0IG5ldHdvcmtTdGF0dXNIYW5kbGVyIG9mIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UpIHtcclxuICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVTaHV0ZG93bihyZW1vdGVTdG9yZSkge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1JlbW90ZVN0b3JlIHNodXR0aW5nIGRvd24uJyk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNSAvKiBPZmZsaW5lQ2F1c2UuU2h1dGRvd24gKi8pO1xyXG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmNvbm5lY3Rpdml0eU1vbml0b3Iuc2h1dGRvd24oKTtcclxuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gVW5rbm93biAocmF0aGVyIHRoYW4gT2ZmbGluZSkgdG8gYXZvaWQgcG90ZW50aWFsbHlcclxuICAgIC8vIHRyaWdnZXJpbmcgc3B1cmlvdXMgbGlzdGVuZXIgZXZlbnRzIHdpdGggY2FjaGVkIGRhdGEsIGV0Yy5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG59XHJcbi8qKlxyXG4gKiBTdGFydHMgbmV3IGxpc3RlbiBmb3IgdGhlIGdpdmVuIHRhcmdldC4gVXNlcyByZXN1bWUgdG9rZW4gaWYgcHJvdmlkZWQuIEl0XHJcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIHRhcmdldCBvZiBnaXZlbiBgVGFyZ2V0RGF0YWAgaXMgYWxyZWFkeSBiZWluZyBsaXN0ZW5lZCB0by5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW90ZVN0b3JlTGlzdGVuKHJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmhhcyh0YXJnZXREYXRhLnRhcmdldElkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIE1hcmsgdGhpcyBhcyBzb21ldGhpbmcgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgbGlzdGVuaW5nIGZvci5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNldCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcclxuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcclxuICAgICAgICAvLyBUaGUgbGlzdGVuIHdpbGwgYmUgc2VudCBpbiBvbldhdGNoU3RyZWFtT3BlblxyXG4gICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNPcGVuKCkpIHtcclxuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbiBmcm9tIHNlcnZlci4gSXQgaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gdGFyZ2V0IGlkIGlzXHJcbiAqIG5vdCBiZWluZyBsaXN0ZW5lZCB0by5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW90ZVN0b3JlVW5saXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldElkKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgY29uc3Qgd2F0Y2hTdHJlYW0gPSBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcclxuICAgIGlmICh3YXRjaFN0cmVhbS5pc09wZW4oKSkge1xyXG4gICAgICAgIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgaWYgKHdhdGNoU3RyZWFtLmlzT3BlbigpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoU3RyZWFtLm1hcmtJZGxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgICAgICAvLyBSZXZlcnQgdG8gT25saW5lU3RhdGUuVW5rbm93biBpZiB0aGUgd2F0Y2ggc3RyZWFtIGlzIG5vdCBvcGVuIGFuZCB3ZVxyXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGxpc3RlbmVycywgc2luY2Ugd2l0aG91dCBhbnkgbGlzdGVucyB0byBzZW5kIHdlIGNhbm5vdFxyXG4gICAgICAgICAgICAvLyBjb25maXJtIGlmIHRoZSBzdHJlYW0gaXMgaGVhbHRoeSBhbmQgdXBncmFkZSB0byBPbmxpbmVTdGF0ZS5PbmxpbmUuXHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogV2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcGVuZGluZyByZXNwb25zZXMgd2UncmUgZHVlXHJcbiAqIGZyb20gd2F0Y2ggc28gd2Ugd2FpdCBmb3IgdGhlIGFjayB0byBwcm9jZXNzIGFueSBtZXNzYWdlcyBmcm9tIHRoaXMgdGFyZ2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2VuZFdhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldERhdGEpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QodGFyZ2V0RGF0YS50YXJnZXRJZCk7XHJcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwIHx8XHJcbiAgICAgICAgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXREYXRhLnRhcmdldElkKS5zaXplO1xyXG4gICAgICAgIHRhcmdldERhdGEgPSB0YXJnZXREYXRhLndpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS53YXRjaCh0YXJnZXREYXRhKTtcclxufVxyXG4vKipcclxuICogV2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwZW5kaW5nIHJlc3BvbnNlcyB3ZSdyZSBkdWVcclxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgcmVtb3ZhbCBvbiB0aGUgc2VydmVyIGJlZm9yZSB3ZSBwcm9jZXNzIGFueVxyXG4gKiBtZXNzYWdlcyBmcm9tIHRoaXMgdGFyZ2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QodGFyZ2V0SWQpO1xyXG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS51bndhdGNoKHRhcmdldElkKTtcclxufVxyXG5mdW5jdGlvbiBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvciA9IG5ldyBXYXRjaENoYW5nZUFnZ3JlZ2F0b3Ioe1xyXG4gICAgICAgIGdldFJlbW90ZUtleXNGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCksXHJcbiAgICAgICAgZ2V0VGFyZ2V0RGF0YUZvclRhcmdldDogdGFyZ2V0SWQgPT4gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKSB8fCBudWxsLFxyXG4gICAgICAgIGdldERhdGFiYXNlSWQ6ICgpID0+IHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUuc2VyaWFsaXplci5kYXRhYmFzZUlkXHJcbiAgICB9KTtcclxuICAgIGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuc3RhcnQoKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHdhdGNoIHN0cmVhbSBzaG91bGQgYmUgc3RhcnRlZCBiZWNhdXNlIGl0J3MgbmVjZXNzYXJ5XHJcbiAqIGFuZCBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcclxuICAgICAgICAhZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc1N0YXJ0ZWQoKSAmJlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNpemUgPiAwKTtcclxufVxyXG5mdW5jdGlvbiBjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLnNpemUgPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gdW5kZWZpbmVkO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIFwiY29ubmVjdGVkXCIgbm90aWZpY2F0aW9uLlxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1PcGVuKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZm9yRWFjaCgodGFyZ2V0RGF0YSwgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2xvc2UocmVtb3RlU3RvcmVJbXBsLCBlcnJvcikge1xyXG4gICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIC8vIElmIHdlIHN0aWxsIG5lZWQgdGhlIHdhdGNoIHN0cmVhbSwgcmV0cnkgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoZXJyb3IpO1xyXG4gICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcmVzdGFydCB3YXRjaCBzdHJlYW0gYmVjYXVzZSB0aGVyZSBhcmUgbm8gYWN0aXZlIHRhcmdldHMuXHJcbiAgICAgICAgLy8gVGhlIG9ubGluZSBzdGF0ZSBpcyBzZXQgdG8gdW5rbm93biBiZWNhdXNlIHRoZXJlIGlzIG5vIGFjdGl2ZSBhdHRlbXB0XHJcbiAgICAgICAgLy8gYXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvblxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1DaGFuZ2UocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSwgc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXHJcbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLyk7XHJcbiAgICBpZiAod2F0Y2hDaGFuZ2UgaW5zdGFuY2VvZiBXYXRjaFRhcmdldENoYW5nZSAmJlxyXG4gICAgICAgIHdhdGNoQ2hhbmdlLnN0YXRlID09PSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgIHdhdGNoQ2hhbmdlLmNhdXNlKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yIG9uIGEgdGFyZ2V0LCBkb24ndCB3YWl0IGZvciBhIGNvbnNpc3RlbnQgc25hcHNob3RcclxuICAgICAgICAvLyB0byByYWlzZSBldmVudHNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVUYXJnZXRFcnJvcihyZW1vdGVTdG9yZUltcGwsIHdhdGNoQ2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnRmFpbGVkIHRvIHJlbW92ZSB0YXJnZXRzICVzOiAlcyAnLCB3YXRjaENoYW5nZS50YXJnZXRJZHMuam9pbignLCcpLCBlKTtcclxuICAgICAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIERvY3VtZW50V2F0Y2hDaGFuZ2UpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmhhbmRsZURvY3VtZW50Q2hhbmdlKHdhdGNoQ2hhbmdlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlKSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVFeGlzdGVuY2VGaWx0ZXIod2F0Y2hDaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVUYXJnZXRDaGFuZ2Uod2F0Y2hDaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzbmFwc2hvdFZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IGF3YWl0IGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlKTtcclxuICAgICAgICAgICAgaWYgKHNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8obGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWNlaXZlZCBhIHRhcmdldCBjaGFuZ2Ugd2l0aCBhIGdsb2JhbCBzbmFwc2hvdCBpZiB0aGUgc25hcHNob3RcclxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gaXMgbm90IGVxdWFsIHRvIFNuYXBzaG90VmVyc2lvbi5taW4oKS5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnRmFpbGVkIHRvIHJhaXNlIHNuYXBzaG90OicsIGUpO1xyXG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY292ZXJ5IGxvZ2ljIGZvciBJbmRleGVkREIgZXJyb3JzIHRoYXQgdGFrZXMgdGhlIG5ldHdvcmsgb2ZmbGluZSB1bnRpbFxyXG4gKiBgb3BgIHN1Y2NlZWRzLiBSZXRyaWVzIGFyZSBzY2hlZHVsZWQgd2l0aCBiYWNrb2ZmIHVzaW5nXHJcbiAqIGBlbnF1ZXVlUmV0cnlhYmxlKClgLiBJZiBgb3AoKWAgaXMgbm90IHByb3ZpZGVkLCBJbmRleGVkREIgYWNjZXNzIGlzXHJcbiAqIHZhbGlkYXRlZCB2aWEgYSBnZW5lcmljIG9wZXJhdGlvbi5cclxuICpcclxuICogVGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgYmVmb3JlXHJcbiAqIGFueSByZXRyeSBhdHRlbXB0LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApIHtcclxuICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMSAvKiBPZmZsaW5lQ2F1c2UuSW5kZXhlZERiRmFpbGVkICovKTtcclxuICAgICAgICAvLyBEaXNhYmxlIG5ldHdvcmsgYW5kIHJhaXNlIG9mZmxpbmUgc25hcHNob3RzXHJcbiAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xyXG4gICAgICAgIGlmICghb3ApIHtcclxuICAgICAgICAgICAgLy8gVXNlIGEgc2ltcGxlIHJlYWQgb3BlcmF0aW9uIHRvIGRldGVybWluZSBpZiBJbmRleGVkREIgcmVjb3ZlcmVkLlxyXG4gICAgICAgICAgICAvLyBJZGVhbGx5LCB3ZSB3b3VsZCBleHBvc2UgYSBoZWFsdGggY2hlY2sgZGlyZWN0bHkgb24gU2ltcGxlRGIsIGJ1dFxyXG4gICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBvbmx5IGhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVuY2UgdGhyb3VnaCBMb2NhbFN0b3JlLlxyXG4gICAgICAgICAgICBvcCA9ICgpID0+IGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvYmUgSW5kZXhlZERCIHBlcmlvZGljYWxseSBhbmQgcmUtZW5hYmxlIG5ldHdvcmtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmV0cnlpbmcgSW5kZXhlZERCIGFjY2VzcycpO1xyXG4gICAgICAgICAgICBhd2FpdCBvcCgpO1xyXG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5kZWxldGUoMSAvKiBPZmZsaW5lQ2F1c2UuSW5kZXhlZERiRmFpbGVkICovKTtcclxuICAgICAgICAgICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBgb3BgLiBJZiBgb3BgIGZhaWxzLCB0YWtlcyB0aGUgbmV0d29yayBvZmZsaW5lIHVudGlsIGBvcGBcclxuICogc3VjY2VlZHMuIFJldHVybnMgYWZ0ZXIgdGhlIGZpcnN0IGF0dGVtcHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgb3ApIHtcclxuICAgIHJldHVybiBvcCgpLmNhdGNoKGUgPT4gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApKTtcclxufVxyXG4vKipcclxuICogVGFrZXMgYSBiYXRjaCBvZiBjaGFuZ2VzIGZyb20gdGhlIERhdGFzdG9yZSwgcmVwYWNrYWdlcyB0aGVtIGFzIGFcclxuICogUmVtb3RlRXZlbnQsIGFuZCBwYXNzZXMgdGhhdCBvbiB0byB0aGUgbGlzdGVuZXIsIHdoaWNoIGlzIHR5cGljYWxseSB0aGVcclxuICogU3luY0VuZ2luZS5cclxuICovXHJcbmZ1bmN0aW9uIHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgY29uc3QgcmVtb3RlRXZlbnQgPSByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmNyZWF0ZVJlbW90ZUV2ZW50KHNuYXBzaG90VmVyc2lvbik7XHJcbiAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHJlc3VtZSB0b2tlbnMuIExvY2FsU3RvcmUgd2lsbCB1cGRhdGUgdGhlXHJcbiAgICAvLyBwZXJzaXN0ZW50IHZpZXcgb2YgdGhlc2Ugd2hlbiBhcHBseWluZyB0aGUgY29tcGxldGVkIFJlbW90ZUV2ZW50LlxyXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYW5nZS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIFJlLWVzdGFibGlzaCBsaXN0ZW5zIGZvciB0aGUgdGFyZ2V0cyB0aGF0IGhhdmUgYmVlbiBpbnZhbGlkYXRlZCBieVxyXG4gICAgLy8gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaGVzLlxyXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5mb3JFYWNoKCh0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlc3VtZSB0b2tlbiBmb3IgdGhlIHRhcmdldCwgc2luY2Ugd2UncmUgaW4gYSBrbm93biBtaXNtYXRjaFxyXG4gICAgICAgIC8vIHN0YXRlLlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNldCh0YXJnZXRJZCwgdGFyZ2V0RGF0YS53aXRoUmVzdW1lVG9rZW4oQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORywgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24pKTtcclxuICAgICAgICAvLyBDYXVzZSBhIGhhcmQgcmVzZXQgYnkgdW53YXRjaGluZyBhbmQgcmV3YXRjaGluZyBpbW1lZGlhdGVseSwgYnV0XHJcbiAgICAgICAgLy8gZGVsaWJlcmF0ZWx5IGRvbid0IHNlbmQgYSByZXN1bWUgdG9rZW4gc28gdGhhdCB3ZSBnZXQgYSBmdWxsIHVwZGF0ZS5cclxuICAgICAgICBzZW5kVW53YXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdlIHNlbmQgYXMgYmVpbmcgb24gYmVoYWxmIG9mIGFuIGV4aXN0ZW5jZSBmaWx0ZXJcclxuICAgICAgICAvLyBtaXNtYXRjaCwgYnV0IGRvbid0IGFjdHVhbGx5IHJldGFpbiB0aGF0IGluIGxpc3RlblRhcmdldHMuIFRoaXMgZW5zdXJlc1xyXG4gICAgICAgIC8vIHRoYXQgd2UgZmxhZyB0aGUgZmlyc3QgcmUtbGlzdGVuIHRoaXMgd2F5IHdpdGhvdXQgaW1wYWN0aW5nIGZ1dHVyZVxyXG4gICAgICAgIC8vIGxpc3RlbnMgb2YgdGhpcyB0YXJnZXQgKHRoYXQgbWlnaHQgaGFwcGVuIGUuZy4gb24gcmVjb25uZWN0KS5cclxuICAgICAgICBjb25zdCByZXF1ZXN0VGFyZ2V0RGF0YSA9IG5ldyBUYXJnZXREYXRhKHRhcmdldERhdGEudGFyZ2V0LCB0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSwgdGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgc2VuZFdhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHJlcXVlc3RUYXJnZXREYXRhKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuYXBwbHlSZW1vdGVFdmVudChyZW1vdGVFdmVudCk7XHJcbn1cclxuLyoqIEhhbmRsZXMgYW4gZXJyb3Igb24gYSB0YXJnZXQgKi9cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVGFyZ2V0RXJyb3IocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSkge1xyXG4gICAgY29uc3QgZXJyb3IgPSB3YXRjaENoYW5nZS5jYXVzZTtcclxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2Ygd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxyXG4gICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5oYXModGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0TGlzdGVuKHRhcmdldElkLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmRlbGV0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVtb3ZlVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGZpbGwgb3VyIHdyaXRlIHBpcGVsaW5lIHdpdGggd3JpdGVzIGZyb20gdGhlIExvY2FsU3RvcmUuXHJcbiAqXHJcbiAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGJvb3RzdHJhcCBvciByZWZpbGwgdGhlIHdyaXRlIHBpcGVsaW5lIGFuZCBieVxyXG4gKiBTeW5jRW5naW5lIHdoZW5ldmVyIHRoZXJlIGFyZSBuZXcgbXV0YXRpb25zIHRvIHByb2Nlc3MuXHJcbiAqXHJcbiAqIFN0YXJ0cyB0aGUgd3JpdGUgc3RyZWFtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgbGV0IGxhc3RCYXRjaElkUmV0cmlldmVkID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMFxyXG4gICAgICAgID8gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmVbcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgLmJhdGNoSWRcclxuICAgICAgICA6IEJBVENISURfVU5LTk9XTjtcclxuICAgIHdoaWxlIChjYW5BZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgbG9jYWxTdG9yZUdldE5leHRNdXRhdGlvbkJhdGNoKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlLCBsYXN0QmF0Y2hJZFJldHJpZXZlZCk7XHJcbiAgICAgICAgICAgIGlmIChiYXRjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3RyZWFtLm1hcmtJZGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhc3RCYXRjaElkUmV0cmlldmVkID0gYmF0Y2guYmF0Y2hJZDtcclxuICAgICAgICAgICAgICAgIGFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwsIGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgc3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgd2UgY2FuIGFkZCB0byB0aGUgd3JpdGUgcGlwZWxpbmUgKGkuZS4gdGhlIG5ldHdvcmsgaXNcclxuICogZW5hYmxlZCBhbmQgdGhlIHdyaXRlIHBpcGVsaW5lIGlzIG5vdCBmdWxsKS5cclxuICovXHJcbmZ1bmN0aW9uIGNhbkFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIDwgTUFYX1BFTkRJTkdfV1JJVEVTKTtcclxufVxyXG4vKipcclxuICogUXVldWVzIGFkZGl0aW9uYWwgd3JpdGVzIHRvIGJlIHNlbnQgdG8gdGhlIHdyaXRlIHN0cmVhbSwgc2VuZGluZyB0aGVtXHJcbiAqIGltbWVkaWF0ZWx5IGlmIHRoZSB3cml0ZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsLCBiYXRjaCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUucHVzaChiYXRjaCk7XHJcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICBpZiAod3JpdGVTdHJlYW0uaXNPcGVuKCkgJiYgd3JpdGVTdHJlYW0uaGFuZHNoYWtlQ29tcGxldGUpIHtcclxuICAgICAgICB3cml0ZVN0cmVhbS53cml0ZU11dGF0aW9ucyhiYXRjaC5tdXRhdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNob3VsZFN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxyXG4gICAgICAgICFlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmlzU3RhcnRlZCgpICYmXHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCk7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuc3RhcnQoKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldyaXRlU3RyZWFtT3BlbihyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkud3JpdGVIYW5kc2hha2UoKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldyaXRlSGFuZHNoYWtlQ29tcGxldGUocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAvLyBTZW5kIHRoZSB3cml0ZSBwaXBlbGluZSBub3cgdGhhdCB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkLlxyXG4gICAgZm9yIChjb25zdCBiYXRjaCBvZiByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZSkge1xyXG4gICAgICAgIHdyaXRlU3RyZWFtLndyaXRlTXV0YXRpb25zKGJhdGNoLm11dGF0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25NdXRhdGlvblJlc3VsdChyZW1vdGVTdG9yZUltcGwsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpIHtcclxuICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBNdXRhdGlvbkJhdGNoUmVzdWx0LmZyb20oYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpO1xyXG4gICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuYXBwbHlTdWNjZXNzZnVsV3JpdGUoc3VjY2VzcykpO1xyXG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvbiBhbm90aGVyXHJcbiAgICAvLyBzbG90IGhhcyBmcmVlZCB1cC5cclxuICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZVN0cmVhbUNsb3NlKHJlbW90ZVN0b3JlSW1wbCwgZXJyb3IpIHtcclxuICAgIC8vIElmIHRoZSB3cml0ZSBzdHJlYW0gY2xvc2VkIGFmdGVyIHRoZSB3cml0ZSBoYW5kc2hha2UgY29tcGxldGVzLCBhIHdyaXRlXHJcbiAgICAvLyBvcGVyYXRpb24gZmFpbGVkIGFuZCB3ZSBmYWlsIHRoZSBwZW5kaW5nIG9wZXJhdGlvbi5cclxuICAgIGlmIChlcnJvciAmJiBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmhhbmRzaGFrZUNvbXBsZXRlKSB7XHJcbiAgICAgICAgLy8gVGhpcyBlcnJvciBhZmZlY3RzIHRoZSBhY3R1YWwgd3JpdGUuXHJcbiAgICAgICAgYXdhaXQgaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8vIFRoZSB3cml0ZSBzdHJlYW0gbWlnaHQgaGF2ZSBiZWVuIHN0YXJ0ZWQgYnkgcmVmaWxsaW5nIHRoZSB3cml0ZVxyXG4gICAgLy8gcGlwZWxpbmUgZm9yIGZhaWxlZCB3cml0ZXNcclxuICAgIGlmIChzaG91bGRTdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcclxuICAgICAgICBzdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XHJcbiAgICAvLyBPbmx5IGhhbmRsZSBwZXJtYW5lbnQgZXJyb3JzIGhlcmUuIElmIGl0J3MgdHJhbnNpZW50LCBqdXN0IGxldCB0aGUgcmV0cnlcclxuICAgIC8vIGxvZ2ljIGtpY2sgaW4uXHJcbiAgICBpZiAoaXNQZXJtYW5lbnRXcml0ZUVycm9yKGVycm9yLmNvZGUpKSB7XHJcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBwZXJtYW5lbnQgZXJyb3IsIHRoZSByZXF1ZXN0IGl0c2VsZiB3YXMgdGhlIHByb2JsZW1cclxuICAgICAgICAvLyBzbyBpdCdzIG5vdCBnb2luZyB0byBzdWNjZWVkIGlmIHdlIHJlc2VuZCBpdC5cclxuICAgICAgICBjb25zdCBiYXRjaCA9IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLnNoaWZ0KCk7XHJcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGl0J3MgYWxzbyB1bmxpa2VseSB0aGF0IHRoZSBzZXJ2ZXIgaXRzZWxmIGlzIG1lbHRpbmdcclxuICAgICAgICAvLyBkb3duIC0tIHRoaXMgd2FzIGp1c3QgYSBiYWQgcmVxdWVzdCBzbyBpbmhpYml0IGJhY2tvZmYgb24gdGhlIG5leHRcclxuICAgICAgICAvLyByZXN0YXJ0LlxyXG4gICAgICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaW5oaWJpdEJhY2tvZmYoKTtcclxuICAgICAgICBhd2FpdCBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgKCkgPT4gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5yZWplY3RGYWlsZWRXcml0ZShiYXRjaC5iYXRjaElkLCBlcnJvcikpO1xyXG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3aXRoIHRoZSBjb21wbGV0aW9uIG9mIHRoaXMgbXV0YXRpb25cclxuICAgICAgICAvLyBhbm90aGVyIHNsb3QgaGFzIGZyZWVkIHVwLlxyXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVzdGFydE5ldHdvcmsocmVtb3RlU3RvcmUpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNCAvKiBPZmZsaW5lQ2F1c2UuQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDQgLyogT2ZmbGluZUNhdXNlLkNvbm5lY3Rpdml0eUNoYW5nZSAqLyk7XHJcbiAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UocmVtb3RlU3RvcmUsIHVzZXIpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XHJcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZW1vdGVTdG9yZSByZWNlaXZlZCBuZXcgY3JlZGVudGlhbHMnKTtcclxuICAgIGNvbnN0IHVzZXNOZXR3b3JrID0gY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgLy8gVGVhciBkb3duIGFuZCByZS1jcmVhdGUgb3VyIG5ldHdvcmsgc3RyZWFtcy4gVGhpcyB3aWxsIGVuc3VyZSB3ZSBnZXQgYVxyXG4gICAgLy8gZnJlc2ggYXV0aCB0b2tlbiBmb3IgdGhlIG5ldyB1c2VyIGFuZCByZS1maWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoXHJcbiAgICAvLyBuZXcgbXV0YXRpb25zIGZyb20gdGhlIExvY2FsU3RvcmUgKHNpbmNlIG11dGF0aW9ucyBhcmUgcGVyLXVzZXIpLlxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xyXG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgaWYgKHVzZXNOZXR3b3JrKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IHRoZSBuZXR3b3JrIHN0YXR1cyB0byBVbmtub3duIGlmIHdlIGFyZSBvZmZsaW5lLlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5oYW5kbGVDcmVkZW50aWFsQ2hhbmdlKHVzZXIpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xyXG4gICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbn1cclxuLyoqXHJcbiAqIFRvZ2dsZXMgdGhlIG5ldHdvcmsgc3RhdGUgd2hlbiB0aGUgY2xpZW50IGdhaW5zIG9yIGxvc2VzIGl0cyBwcmltYXJ5IGxlYXNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShyZW1vdGVTdG9yZSwgaXNQcmltYXJ5KSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgaWYgKGlzUHJpbWFyeSkge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XHJcbiAgICAgICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDIgLyogT2ZmbGluZUNhdXNlLklzU2Vjb25kYXJ5ICovKTtcclxuICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV2F0Y2hTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXHJcbiAqIGNhbGxiYWNrIHdpdGggYHJlbW90ZVN0b3JlSW1wbGAuIFJldHVybnMgdGhlIGV4aXN0aW5nIHN0cmVhbSBpZiBvbmUgaXNcclxuICogYWxyZWFkeSBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogT24gaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2F0Y2hTdHJlYW0gZ2V0cyByZWdpc3RlcmVkIG9uIHN0YXJ0dXAuXHJcbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0gPSBuZXdQZXJzaXN0ZW50V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZSwgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUsIHtcclxuICAgICAgICAgICAgb25Db25uZWN0ZWQ6IG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxyXG4gICAgICAgICAgICBvbk9wZW46IG9uV2F0Y2hTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25DbG9zZTogb25XYXRjaFN0cmVhbUNsb3NlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25XYXRjaENoYW5nZTogb25XYXRjaFN0cmVhbUNoYW5nZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbS5pbmhpYml0QmFja29mZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3RlU3RvcmVJbXBsLndhdGNoU3RyZWFtLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIGNsZWFuVXBXYXRjaFN0cmVhbVN0YXRlKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW07XHJcbn1cclxuLyoqXHJcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV3JpdGVTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXHJcbiAqIGNhbGxiYWNrIHdpdGggYHJlbW90ZVN0b3JlSW1wbGAuIFJldHVybnMgdGhlIGV4aXN0aW5nIHN0cmVhbSBpZiBvbmUgaXNcclxuICogYWxyZWFkeSBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogT24gaU9TIGFuZCBBbmRyb2lkLCB0aGUgV3JpdGVTdHJlYW0gZ2V0cyByZWdpc3RlcmVkIG9uIHN0YXJ0dXAuXHJcbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW0gPSBuZXdQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZSwgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUsIHtcclxuICAgICAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgICBvbk9wZW46IG9uV3JpdGVTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25DbG9zZTogb25Xcml0ZVN0cmVhbUNsb3NlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25IYW5kc2hha2VDb21wbGV0ZTogb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25NdXRhdGlvblJlc3VsdDogb25NdXRhdGlvblJlc3VsdC5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5pbmhpYml0QmFja29mZigpO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHN0YXJ0IHRoZSB3cml0ZSBzdHJlYW0gaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgYFN0b3BwaW5nIHdyaXRlIHN0cmVhbSB3aXRoICR7cmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RofSBwZW5kaW5nIHdyaXRlc2ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ0ID0gJ0FzeW5jUXVldWUnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gc2NoZWR1bGVkIHRvIGJlIHJ1biBpbiB0aGUgZnV0dXJlIG9uIGFuIEFzeW5jUXVldWUuXHJcbiAqXHJcbiAqIEl0IGlzIGNyZWF0ZWQgdmlhIERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUoKS5cclxuICpcclxuICogU3VwcG9ydHMgY2FuY2VsbGF0aW9uICh2aWEgY2FuY2VsKCkpIGFuZCBlYXJseSBleGVjdXRpb24gKHZpYSBza2lwRGVsYXkoKSkuXHJcbiAqXHJcbiAqIE5vdGU6IFdlIGltcGxlbWVudCBgUHJvbWlzZUxpa2VgIGluc3RlYWQgb2YgYFByb21pc2VgLCBhcyB0aGUgYFByb21pc2VgIHR5cGVcclxuICogaW4gbmV3ZXIgdmVyc2lvbnMgb2YgVHlwZVNjcmlwdCBkZWZpbmVzIGBmaW5hbGx5YCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpblxyXG4gKiBJRS5cclxuICovXHJcbmNsYXNzIERlbGF5ZWRPcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgdGltZXJJZCwgdGFyZ2V0VGltZU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSB0aW1lcklkO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0VGltZU1zID0gdGFyZ2V0VGltZU1zO1xyXG4gICAgICAgIHRoaXMub3AgPSBvcDtcclxuICAgICAgICB0aGlzLnJlbW92YWxDYWxsYmFjayA9IHJlbW92YWxDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy50aGVuID0gdGhpcy5kZWZlcnJlZC5wcm9taXNlLnRoZW4uYmluZCh0aGlzLmRlZmVycmVkLnByb21pc2UpO1xyXG4gICAgICAgIC8vIEl0J3Mgbm9ybWFsIGZvciB0aGUgZGVmZXJyZWQgcHJvbWlzZSB0byBiZSBjYW5jZWxlZCAoZHVlIHRvIGNhbmNlbGxhdGlvbilcclxuICAgICAgICAvLyBhbmQgc28gd2UgYXR0YWNoIGEgZHVtbXkgY2F0Y2ggY2FsbGJhY2sgdG8gYXZvaWRcclxuICAgICAgICAvLyAnVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbldhcm5pbmcnIGxvZyBzcGFtLlxyXG4gICAgICAgIHRoaXMuZGVmZXJyZWQucHJvbWlzZS5jYXRjaChlcnIgPT4geyB9KTtcclxuICAgIH1cclxuICAgIGdldCBwcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBEZWxheWVkT3BlcmF0aW9uIHRoYXQgaGFzIGJlZW4gc2NoZWR1bGVkIHRvIGJlXHJcbiAgICAgKiBleGVjdXRlZCBvbiB0aGUgcHJvdmlkZWQgYXN5bmNRdWV1ZSBhZnRlciB0aGUgcHJvdmlkZWQgZGVsYXlNcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXN5bmNRdWV1ZSAtIFRoZSBxdWV1ZSB0byBzY2hlZHVsZSB0aGUgb3BlcmF0aW9uIG9uLlxyXG4gICAgICogQHBhcmFtIGlkIC0gQSBUaW1lciBJRCBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiBvcGVyYXRpb24gdGhpcyBpcy5cclxuICAgICAqIEBwYXJhbSBkZWxheU1zIC0gVGhlIGRlbGF5IChtcykgYmVmb3JlIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlIHNjaGVkdWxlZC5cclxuICAgICAqIEBwYXJhbSBvcCAtIFRoZSBvcGVyYXRpb24gdG8gcnVuLlxyXG4gICAgICogQHBhcmFtIHJlbW92YWxDYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgb25jZSB0aGVcclxuICAgICAqICAgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLCBub3RpZnlpbmcgdGhlIEFzeW5jUXVldWUgdG8gcmVtb3ZlIGl0XHJcbiAgICAgKiAgIGZyb20gaXRzIGRlbGF5ZWRPcGVyYXRpb25zIGxpc3QuXHJcbiAgICAgKiAgIFBPUlRJTkcgTk9URTogVGhpcyBleGlzdHMgdG8gcHJldmVudCBtYWtpbmcgcmVtb3ZlRGVsYXllZE9wZXJhdGlvbigpIGFuZFxyXG4gICAgICogICB0aGUgRGVsYXllZE9wZXJhdGlvbiBjbGFzcyBwdWJsaWMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVBbmRTY2hlZHVsZShhc3luY1F1ZXVlLCB0aW1lcklkLCBkZWxheU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IERhdGUubm93KCkgKyBkZWxheU1zO1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ZWRPcCA9IG5ldyBEZWxheWVkT3BlcmF0aW9uKGFzeW5jUXVldWUsIHRpbWVySWQsIHRhcmdldFRpbWUsIG9wLCByZW1vdmFsQ2FsbGJhY2spO1xyXG4gICAgICAgIGRlbGF5ZWRPcC5zdGFydChkZWxheU1zKTtcclxuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVyLiBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBjb25zdHJ1Y3Rpb24gYnlcclxuICAgICAqIGNyZWF0ZUFuZFNjaGVkdWxlKCkuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KGRlbGF5TXMpIHtcclxuICAgICAgICB0aGlzLnRpbWVySGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZURlbGF5RWxhcHNlZCgpLCBkZWxheU1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVldWVzIHRoZSBvcGVyYXRpb24gdG8gcnVuIGltbWVkaWF0ZWx5IChpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJ1biBvclxyXG4gICAgICogY2FuY2VsZWQpLlxyXG4gICAgICovXHJcbiAgICBza2lwRGVsYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVsYXlFbGFwc2VkKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgdGhlIG9wZXJhdGlvbiBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLiBUaGVcclxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBBcyBsb25nIGFzIHRoZSBvcGVyYXRpb24gaGFzIG5vdCB5ZXQgYmVlbiBydW4sIGNhbGxpbmcgY2FuY2VsKCkgcHJvdmlkZXMgYVxyXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSBydW4uXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbChyZWFzb24pIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsICdPcGVyYXRpb24gY2FuY2VsbGVkJyArIChyZWFzb24gPyAnOiAnICsgcmVhc29uIDogJycpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlRGVsYXlFbGFwc2VkKCkge1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJIYW5kbGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZhbENhbGxiYWNrKHRoaXMpO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckhhbmRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJIYW5kbGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIEZpcmVzdG9yZUVycm9yIHRoYXQgY2FuIGJlIHN1cmZhY2VkIHRvIHRoZSB1c2VyIGlmIHRoZSBwcm92aWRlZFxyXG4gKiBlcnJvciBpcyBhbiBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yLiBSZS10aHJvd3MgdGhlIGVycm9yIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgbXNnKSB7XHJcbiAgICBsb2dFcnJvcihMT0dfVEFHJDQsIGAke21zZ306ICR7ZX1gKTtcclxuICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsIGAke21zZ306ICR7ZX1gKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERvY3VtZW50U2V0IGlzIGFuIGltbXV0YWJsZSAoY29weS1vbi13cml0ZSkgY29sbGVjdGlvbiB0aGF0IGhvbGRzIGRvY3VtZW50c1xyXG4gKiBpbiBvcmRlciBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuIFdlIGFsd2F5cyBhZGQgYSBkb2N1bWVudCBrZXlcclxuICogY29tcGFyYXRvciBvbiB0b3Agb2Ygd2hhdCBpcyBwcm92aWRlZCB0byBndWFyYW50ZWUgZG9jdW1lbnQgZXF1YWxpdHkgYmFzZWQgb25cclxuICogdGhlIGtleS5cclxuICovXHJcbmNsYXNzIERvY3VtZW50U2V0IHtcclxuICAgIC8qKiBUaGUgZGVmYXVsdCBvcmRlcmluZyBpcyBieSBrZXkgaWYgdGhlIGNvbXBhcmF0b3IgaXMgb21pdHRlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tcCkge1xyXG4gICAgICAgIC8vIFdlIGFyZSBhZGRpbmcgZG9jdW1lbnQga2V5IGNvbXBhcmF0b3IgdG8gdGhlIGVuZCBhcyBpdCdzIHRoZSBvbmx5XHJcbiAgICAgICAgLy8gZ3VhcmFudGVlZCB1bmlxdWUgcHJvcGVydHkgb2YgYSBkb2N1bWVudC5cclxuICAgICAgICBpZiAoY29tcCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSAoZDEsIGQyKSA9PiBjb21wKGQxLCBkMikgfHwgRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSAoZDEsIGQyKSA9PiBEb2N1bWVudEtleS5jb21wYXJhdG9yKGQxLmtleSwgZDIua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5rZXllZE1hcCA9IGRvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgdGhpcy5zb3J0ZWRTZXQgPSBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgY29weSBvZiB0aGUgZXhpc3RpbmcgRG9jdW1lbnRTZXQsIHVzaW5nIHRoZSBzYW1lXHJcbiAgICAgKiBjb21wYXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZW1wdHlTZXQob2xkU2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNldChvbGRTZXQuY29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ZWRNYXAuZ2V0KGtleSkgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXllZE1hcC5nZXQoa2V5KTtcclxuICAgIH1cclxuICAgIGZpcnN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIGxhc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0Lm1heEtleSgpO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgcHJvdmlkZWQga2V5IGluIHRoZSBkb2N1bWVudCBzZXQsIG9yIC0xIGlmIHRoZVxyXG4gICAgICogZG9jdW1lbnQga2V5IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzZXQ7XHJcbiAgICAgKi9cclxuICAgIGluZGV4T2Yoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5rZXllZE1hcC5nZXQoa2V5KTtcclxuICAgICAgICByZXR1cm4gZG9jID8gdGhpcy5zb3J0ZWRTZXQuaW5kZXhPZihkb2MpIDogLTE7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKiBJdGVyYXRlcyBkb2N1bWVudHMgaW4gb3JkZXIgZGVmaW5lZCBieSBcImNvbXBhcmF0b3JcIiAqL1xyXG4gICAgZm9yRWFjaChjYikge1xyXG4gICAgICAgIHRoaXMuc29ydGVkU2V0Lmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcclxuICAgICAgICAgICAgY2Ioayk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGtleSAqL1xyXG4gICAgYWRkKGRvYykge1xyXG4gICAgICAgIC8vIEZpcnN0IHJlbW92ZSB0aGUgZWxlbWVudCBpZiB3ZSBoYXZlIGl0LlxyXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuZGVsZXRlKGRvYy5rZXkpO1xyXG4gICAgICAgIHJldHVybiBzZXQuY29weShzZXQua2V5ZWRNYXAuaW5zZXJ0KGRvYy5rZXksIGRvYyksIHNldC5zb3J0ZWRTZXQuaW5zZXJ0KGRvYywgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIERlbGV0ZXMgYSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4ga2V5ICovXHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIWRvYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmtleWVkTWFwLnJlbW92ZShrZXkpLCB0aGlzLnNvcnRlZFNldC5yZW1vdmUoZG9jKSk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEb2N1bWVudFNldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGhpc0l0ID0gdGhpcy5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICBjb25zdCBvdGhlckl0ID0gb3RoZXIuc29ydGVkU2V0LmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXNJdC5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGhpc0RvYyA9IHRoaXNJdC5nZXROZXh0KCkua2V5O1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckRvYyA9IG90aGVySXQuZ2V0TmV4dCgpLmtleTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzRG9jLmlzRXF1YWwob3RoZXJEb2MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBjb25zdCBkb2NTdHJpbmdzID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGRvY1N0cmluZ3MucHVzaChkb2MudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRvY1N0cmluZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnRG9jdW1lbnRTZXQgKCknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoXFxuICAnICsgZG9jU3RyaW5ncy5qb2luKCcgIFxcbicpICsgJ1xcbiknO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvcHkoa2V5ZWRNYXAsIHNvcnRlZFNldCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBEb2N1bWVudFNldCgpO1xyXG4gICAgICAgIG5ld1NldC5jb21wYXJhdG9yID0gdGhpcy5jb21wYXJhdG9yO1xyXG4gICAgICAgIG5ld1NldC5rZXllZE1hcCA9IGtleWVkTWFwO1xyXG4gICAgICAgIG5ld1NldC5zb3J0ZWRTZXQgPSBzb3J0ZWRTZXQ7XHJcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9jdW1lbnRDaGFuZ2VTZXQga2VlcHMgdHJhY2sgb2YgYSBzZXQgb2YgY2hhbmdlcyB0byBkb2NzIGluIGEgcXVlcnksIG1lcmdpbmdcclxuICogZHVwbGljYXRlIGV2ZW50cyBmb3IgdGhlIHNhbWUgZG9jLlxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRDaGFuZ2VTZXQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgdHJhY2soY2hhbmdlKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gY2hhbmdlLmRvYy5rZXk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hhbmdlID0gdGhpcy5jaGFuZ2VNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFvbGRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCBjaGFuZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1lcmdlIHRoZSBuZXcgY2hhbmdlIHdpdGggdGhlIGV4aXN0aW5nIGNoYW5nZS5cclxuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwgY2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSAhPT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBvbGRDaGFuZ2UudHlwZSxcclxuICAgICAgICAgICAgICAgIGRvYzogY2hhbmdlLmRvY1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovICYmXHJcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8sXHJcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sXHJcbiAgICAgICAgICAgICAgICBkb2M6IG9sZENoYW5nZS5kb2NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8gJiZcclxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyB0aGVzZSBjYXNlcywgd2hpY2ggZG9uJ3QgbWFrZSBzZW5zZTpcclxuICAgICAgICAgICAgLy8gQWRkZWQtPkFkZGVkXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPlJlbW92ZWRcclxuICAgICAgICAgICAgLy8gTW9kaWZpZWQtPkFkZGVkXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPk1vZGlmaWVkXHJcbiAgICAgICAgICAgIC8vIE1ldGFkYXRhLT5BZGRlZFxyXG4gICAgICAgICAgICAvLyBSZW1vdmVkLT5NZXRhZGF0YVxyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAuaW5vcmRlclRyYXZlcnNhbCgoa2V5LCBjaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVmlld1NuYXBzaG90IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBkb2NzLCBvbGREb2NzLCBkb2NDaGFuZ2VzLCBtdXRhdGVkS2V5cywgZnJvbUNhY2hlLCBzeW5jU3RhdGVDaGFuZ2VkLCBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcywgaGFzQ2FjaGVkUmVzdWx0cykge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLmRvY3MgPSBkb2NzO1xyXG4gICAgICAgIHRoaXMub2xkRG9jcyA9IG9sZERvY3M7XHJcbiAgICAgICAgdGhpcy5kb2NDaGFuZ2VzID0gZG9jQ2hhbmdlcztcclxuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gbXV0YXRlZEtleXM7XHJcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XHJcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVDaGFuZ2VkID0gc3luY1N0YXRlQ2hhbmdlZDtcclxuICAgICAgICB0aGlzLmV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzID0gZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM7XHJcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gaGFzQ2FjaGVkUmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgdmlldyBzbmFwc2hvdCBhcyBpZiBhbGwgZG9jdW1lbnRzIGluIHRoZSBzbmFwc2hvdCB3ZXJlIGFkZGVkLiAqL1xyXG4gICAgc3RhdGljIGZyb21Jbml0aWFsRG9jdW1lbnRzKHF1ZXJ5LCBkb2N1bWVudHMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIGhhc0NhY2hlZFJlc3VsdHMpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2MgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3U25hcHNob3QocXVlcnksIGRvY3VtZW50cywgRG9jdW1lbnRTZXQuZW1wdHlTZXQoZG9jdW1lbnRzKSwgY2hhbmdlcywgbXV0YXRlZEtleXMsIGZyb21DYWNoZSwgXHJcbiAgICAgICAgLyogc3luY1N0YXRlQ2hhbmdlZD0gKi8gdHJ1ZSwgXHJcbiAgICAgICAgLyogZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM9ICovIGZhbHNlLCBoYXNDYWNoZWRSZXN1bHRzKTtcclxuICAgIH1cclxuICAgIGdldCBoYXNQZW5kaW5nV3JpdGVzKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5tdXRhdGVkS2V5cy5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbUNhY2hlICE9PSBvdGhlci5mcm9tQ2FjaGUgfHxcclxuICAgICAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzICE9PSBvdGhlci5oYXNDYWNoZWRSZXN1bHRzIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCAhPT0gb3RoZXIuc3luY1N0YXRlQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICAhdGhpcy5tdXRhdGVkS2V5cy5pc0VxdWFsKG90aGVyLm11dGF0ZWRLZXlzKSB8fFxyXG4gICAgICAgICAgICAhcXVlcnlFcXVhbHModGhpcy5xdWVyeSwgb3RoZXIucXVlcnkpIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmRvY3MuaXNFcXVhbChvdGhlci5kb2NzKSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5vbGREb2NzLmlzRXF1YWwob3RoZXIub2xkRG9jcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kb2NDaGFuZ2VzO1xyXG4gICAgICAgIGNvbnN0IG90aGVyQ2hhbmdlcyA9IG90aGVyLmRvY0NoYW5nZXM7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoICE9PSBvdGhlckNoYW5nZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzW2ldLnR5cGUgIT09IG90aGVyQ2hhbmdlc1tpXS50eXBlIHx8XHJcbiAgICAgICAgICAgICAgICAhY2hhbmdlc1tpXS5kb2MuaXNFcXVhbChvdGhlckNoYW5nZXNbaV0uZG9jKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgbGlzdGVuZXJzIGFuZCB0aGUgbGFzdCByZWNlaXZlZCBWaWV3U25hcHNob3QgZm9yIGEgcXVlcnkgYmVpbmdcclxuICogdHJhY2tlZCBieSBFdmVudE1hbmFnZXIuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUxpc3RlbmVyc0luZm8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3U25hcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gSGVscGVyIG1ldGhvZHMgdGhhdCBjaGVja3MgaWYgdGhlIHF1ZXJ5IGhhcyBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW5pbmcgdG8gcmVtb3RlIHN0b3JlXHJcbiAgICBoYXNSZW1vdGVMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNvbWUobGlzdGVuZXIgPT4gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3RXZlbnRNYW5hZ2VyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBFdmVudE1hbmFnZXJJbXBsKCk7XHJcbn1cclxuY2xhc3MgRXZlbnRNYW5hZ2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgT2JqZWN0TWFwKHEgPT4gY2Fub25pZnlRdWVyeShxKSwgcXVlcnlFcXVhbHMpO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGV2ZW50TWFuYWdlckxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBsZXQgbGlzdGVuZXJBY3Rpb24gPSAzIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uTm9BY3Rpb25SZXF1aXJlZCAqLztcclxuICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuZXIucXVlcnk7XHJcbiAgICBsZXQgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XHJcbiAgICBpZiAoIXF1ZXJ5SW5mbykge1xyXG4gICAgICAgIHF1ZXJ5SW5mbyA9IG5ldyBRdWVyeUxpc3RlbmVyc0luZm8oKTtcclxuICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKClcclxuICAgICAgICAgICAgPyAwIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoQ29ubmVjdGlvbiAqL1xyXG4gICAgICAgICAgICA6IDEgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5Jbml0aWFsaXplTG9jYWxMaXN0ZW5Pbmx5ICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIXF1ZXJ5SW5mby5oYXNSZW1vdGVMaXN0ZW5lcnMoKSAmJlxyXG4gICAgICAgIGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKCkpIHtcclxuICAgICAgICAvLyBRdWVyeSBoYXMgYmVlbiBsaXN0ZW5pbmcgdG8gbG9jYWwgY2FjaGUsIGFuZCB0cmllcyB0byBhZGQgYSBuZXcgbGlzdGVuZXIgc291cmNlZCBmcm9tIHdhdGNoLlxyXG4gICAgICAgIGxpc3RlbmVyQWN0aW9uID0gMiAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLlJlcXVpcmVXYXRjaENvbm5lY3Rpb25Pbmx5ICovO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBzd2l0Y2ggKGxpc3RlbmVyQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaENvbm5lY3Rpb24gKi86XHJcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcclxuICAgICAgICAgICAgICAgIC8qKiBlbmFibGVSZW1vdGVMaXN0ZW49ICovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3Rlbk9ubHkgKi86XHJcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcclxuICAgICAgICAgICAgICAgIC8qKiBlbmFibGVSZW1vdGVMaXN0ZW49ICovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5SZXF1aXJlV2F0Y2hDb25uZWN0aW9uT25seSAqLzpcclxuICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50TWFuYWdlckltcGwub25GaXJzdFJlbW90ZVN0b3JlTGlzdGVuKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEluaXRpYWxpemF0aW9uIG9mIHF1ZXJ5ICcke3N0cmluZ2lmeVF1ZXJ5KGxpc3RlbmVyLnF1ZXJ5KX0nIGZhaWxlZGApO1xyXG4gICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5zZXQocXVlcnksIHF1ZXJ5SW5mbyk7XHJcbiAgICBxdWVyeUluZm8ubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXHJcbiAgICBsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUpO1xyXG4gICAgaWYgKHF1ZXJ5SW5mby52aWV3U25hcCkge1xyXG4gICAgICAgIGNvbnN0IHJhaXNlZEV2ZW50ID0gbGlzdGVuZXIub25WaWV3U25hcHNob3QocXVlcnlJbmZvLnZpZXdTbmFwKTtcclxuICAgICAgICBpZiAocmFpc2VkRXZlbnQpIHtcclxuICAgICAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5lci5xdWVyeTtcclxuICAgIGxldCBsaXN0ZW5lckFjdGlvbiA9IDMgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLk5vQWN0aW9uUmVxdWlyZWQgKi87XHJcbiAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcclxuICAgIGlmIChxdWVyeUluZm8pIHtcclxuICAgICAgICBjb25zdCBpID0gcXVlcnlJbmZvLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SW5mby5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyQWN0aW9uID0gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKVxyXG4gICAgICAgICAgICAgICAgICAgID8gMCAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uVGVybWluYXRlTG9jYWxMaXN0ZW5BbmRSZXF1aXJlV2F0Y2hEaXNjb25uZWN0aW9uICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiAxIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3Rlbk9ubHkgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXF1ZXJ5SW5mby5oYXNSZW1vdGVMaXN0ZW5lcnMoKSAmJlxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlbW92ZWQgbGlzdGVuZXIgaXMgdGhlIGxhc3Qgb25lIHRoYXQgc291cmNlZCBmcm9tIHdhdGNoLlxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBY3Rpb24gPSAyIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5SZXF1aXJlV2F0Y2hEaXNjb25uZWN0aW9uT25seSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaCAobGlzdGVuZXJBY3Rpb24pIHtcclxuICAgICAgICBjYXNlIDAgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbiAqLzpcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJJbXBsLm9uVW5saXN0ZW4ocXVlcnksIFxyXG4gICAgICAgICAgICAvKiogZGlzYWJsZVJlbW90ZUxpc3Rlbj0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgY2FzZSAxIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3Rlbk9ubHkgKi86XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vblVubGlzdGVuKHF1ZXJ5LCBcclxuICAgICAgICAgICAgLyoqIGRpc2FibGVSZW1vdGVMaXN0ZW49ICovIGZhbHNlKTtcclxuICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb25Pbmx5ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vbkxhc3RSZW1vdGVTdG9yZVVubGlzdGVuKHF1ZXJ5KTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaENoYW5nZShldmVudE1hbmFnZXIsIHZpZXdTbmFwcykge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgbGV0IHJhaXNlZEV2ZW50ID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IHZpZXdTbmFwIG9mIHZpZXdTbmFwcykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdmlld1NuYXAucXVlcnk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vblZpZXdTbmFwc2hvdCh2aWV3U25hcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gdmlld1NuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJhaXNlZEV2ZW50KSB7XHJcbiAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbldhdGNoRXJyb3IoZXZlbnRNYW5hZ2VyLCBxdWVyeSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcclxuICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xyXG4gICAgaWYgKHF1ZXJ5SW5mbykge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5vbkVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy4gTk9URTogV2UgZG9uJ3QgbmVlZCB0byBjYWxsIHN5bmNFbmdpbmUudW5saXN0ZW4oKVxyXG4gICAgLy8gYWZ0ZXIgYW4gZXJyb3IuXHJcbiAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5KTtcclxufVxyXG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpIHtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcclxuICAgIGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmZvckVhY2goKF8sIHF1ZXJ5SW5mbykgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xyXG4gICAgICAgICAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLmFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChyYWlzZWRFdmVudCkge1xyXG4gICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBvYnNlcnZlcikge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuYWRkKG9ic2VydmVyKTtcclxuICAgIC8vIEltbWVkaWF0ZWx5IGZpcmUgYW4gaW5pdGlhbCBldmVudCwgaW5kaWNhdGluZyBhbGwgZXhpc3RpbmcgbGlzdGVuZXJzXHJcbiAgICAvLyBhcmUgaW4tc3luYy5cclxuICAgIG9ic2VydmVyLm5leHQoKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihldmVudE1hbmFnZXIsIG9ic2VydmVyKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBldmVudE1hbmFnZXJJbXBsLnNuYXBzaG90c0luU3luY0xpc3RlbmVycy5kZWxldGUob2JzZXJ2ZXIpO1xyXG59XHJcbi8vIENhbGwgYWxsIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gc2V0LlxyXG5mdW5jdGlvbiByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpIHtcclxuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQoKTtcclxuICAgIH0pO1xyXG59XHJcbnZhciBMaXN0ZW5lckRhdGFTb3VyY2U7XHJcbihmdW5jdGlvbiAoTGlzdGVuZXJEYXRhU291cmNlKSB7XHJcbiAgICAvKiogTGlzdGVuIHRvIGJvdGggY2FjaGUgYW5kIHNlcnZlciBjaGFuZ2VzICovXHJcbiAgICBMaXN0ZW5lckRhdGFTb3VyY2VbXCJEZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XHJcbiAgICAvKiogTGlzdGVuIHRvIGNoYW5nZXMgaW4gY2FjaGUgb25seSAqL1xyXG4gICAgTGlzdGVuZXJEYXRhU291cmNlW1wiQ2FjaGVcIl0gPSBcImNhY2hlXCI7XHJcbn0pKExpc3RlbmVyRGF0YVNvdXJjZSB8fCAoTGlzdGVuZXJEYXRhU291cmNlID0ge30pKTtcclxuLyoqXHJcbiAqIFF1ZXJ5TGlzdGVuZXIgdGFrZXMgYSBzZXJpZXMgb2YgaW50ZXJuYWwgdmlldyBzbmFwc2hvdHMgYW5kIGRldGVybWluZXNcclxuICogd2hlbiB0byByYWlzZSB0aGUgZXZlbnQuXHJcbiAqXHJcbiAqIEl0IHVzZXMgYW4gT2JzZXJ2ZXIgdG8gZGlzcGF0Y2ggZXZlbnRzLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlMaXN0ZW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcXVlcnlPYnNlcnZlciwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIgPSBxdWVyeU9ic2VydmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWwgc25hcHNob3RzIChlLmcuIGZyb20gY2FjaGUpIG1heSBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgd3JhcHBlZFxyXG4gICAgICAgICAqIG9ic2VydmVyLiBUaGlzIGZsYWcgaXMgc2V0IHRvIHRydWUgb25jZSB3ZSd2ZSBhY3R1YWxseSByYWlzZWQgYW4gZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNuYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIG5ldyBWaWV3U25hcHNob3QgdG8gdGhpcyBsaXN0ZW5lciwgcmFpc2luZyBhIHVzZXItZmFjaW5nIGV2ZW50XHJcbiAgICAgKiBpZiBhcHBsaWNhYmxlIChkZXBlbmRpbmcgb24gd2hhdCBjaGFuZ2VkLCB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbnRvXHJcbiAgICAgKiBtZXRhZGF0YS1vbmx5IGNoYW5nZXMsIGV0Yy4pLiBSZXR1cm5zIHRydWUgaWYgYSB1c2VyLWZhY2luZyBldmVudCB3YXNcclxuICAgICAqIGluZGVlZCByYWlzZWQuXHJcbiAgICAgKi9cclxuICAgIG9uVmlld1NuYXBzaG90KHNuYXApIHtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWV0YWRhdGEgb25seSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHNuYXAuZG9jQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS50eXBlICE9PSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzLnB1c2goZG9jQ2hhbmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbmFwID0gbmV3IFZpZXdTbmFwc2hvdChzbmFwLnF1ZXJ5LCBzbmFwLmRvY3MsIHNuYXAub2xkRG9jcywgZG9jQ2hhbmdlcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuc3luY1N0YXRlQ2hhbmdlZCwgXHJcbiAgICAgICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyB0cnVlLCBzbmFwLmhhc0NhY2hlZFJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHNuYXAsIHRoaXMub25saW5lU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlSW5pdGlhbEV2ZW50KHNuYXApO1xyXG4gICAgICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2hvdWxkUmFpc2VFdmVudChzbmFwKSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIubmV4dChzbmFwKTtcclxuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNuYXAgPSBzbmFwO1xyXG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcclxuICAgIH1cclxuICAgIG9uRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgd2hldGhlciBhIHNuYXBzaG90IHdhcyByYWlzZWQuICovXHJcbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xyXG4gICAgICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnNuYXAgJiZcclxuICAgICAgICAgICAgIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUmFpc2VJbml0aWFsRXZlbnQodGhpcy5zbmFwLCBvbmxpbmVTdGF0ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yYWlzZUluaXRpYWxFdmVudCh0aGlzLnNuYXApO1xyXG4gICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcclxuICAgIH1cclxuICAgIHNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHNuYXAsIG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgLy8gQWx3YXlzIHJhaXNlIHRoZSBmaXJzdCBldmVudCB3aGVuIHdlJ3JlIHN5bmNlZFxyXG4gICAgICAgIGlmICghc25hcC5mcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsd2F5cyByYWlzZSBldmVudCBpZiBsaXN0ZW5pbmcgdG8gY2FjaGVcclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogV2UgY29uc2lkZXIgT25saW5lU3RhdGUuVW5rbm93biBhcyBvbmxpbmUgKGl0IHNob3VsZCBiZWNvbWUgT2ZmbGluZVxyXG4gICAgICAgIC8vIG9yIE9ubGluZSBpZiB3ZSB3YWl0IGxvbmcgZW5vdWdoKS5cclxuICAgICAgICBjb25zdCBtYXliZU9ubGluZSA9IG9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovO1xyXG4gICAgICAgIC8vIERvbid0IHJhaXNlIHRoZSBldmVudCBpZiB3ZSdyZSBvbmxpbmUsIGFyZW4ndCBzeW5jZWQgeWV0IChjaGVja2VkXHJcbiAgICAgICAgLy8gYWJvdmUpIGFuZCBhcmUgd2FpdGluZyBmb3IgYSBzeW5jLlxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FpdEZvclN5bmNXaGVuT25saW5lICYmIG1heWJlT25saW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmFpc2UgZGF0YSBmcm9tIGNhY2hlIGlmIHdlIGhhdmUgYW55IGRvY3VtZW50cywgaGF2ZSBjYWNoZWQgcmVzdWx0cyBiZWZvcmUsXHJcbiAgICAgICAgLy8gb3Igd2UgYXJlIG9mZmxpbmUuXHJcbiAgICAgICAgcmV0dXJuICghc25hcC5kb2NzLmlzRW1wdHkoKSB8fFxyXG4gICAgICAgICAgICBzbmFwLmhhc0NhY2hlZFJlc3VsdHMgfHxcclxuICAgICAgICAgICAgb25saW5lU3RhdGUgPT09IFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xyXG4gICAgfVxyXG4gICAgc2hvdWxkUmFpc2VFdmVudChzbmFwKSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBoYW5kbGUgaW5jbHVkZURvY3VtZW50TWV0YWRhdGFDaGFuZ2VzIGhlcmUgYmVjYXVzZVxyXG4gICAgICAgIC8vIHRoZSBNZXRhZGF0YSBvbmx5IGNoYW5nZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc3RyaXBwZWQgb3V0IGlmIG5lZWRlZC5cclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBvbmx5IGNoYW5nZXMgd2Ugd2lsbCBzZWUgYXJlIHRoZSBvbmVzIHdlIHNob3VsZFxyXG4gICAgICAgIC8vIHByb3BhZ2F0ZS5cclxuICAgICAgICBpZiAoc25hcC5kb2NDaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhc1BlbmRpbmdXcml0ZXNDaGFuZ2VkID0gdGhpcy5zbmFwICYmIHRoaXMuc25hcC5oYXNQZW5kaW5nV3JpdGVzICE9PSBzbmFwLmhhc1BlbmRpbmdXcml0ZXM7XHJcbiAgICAgICAgaWYgKHNuYXAuc3luY1N0YXRlQ2hhbmdlZCB8fCBoYXNQZW5kaW5nV3JpdGVzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPT09IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdlbmVyYWxseSB3ZSBzaG91bGQgaGF2ZSBoaXQgb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgYnV0IGl0J3MgcG9zc2libGVcclxuICAgICAgICAvLyB0byBnZXQgaGVyZSBpZiB0aGVyZSB3ZXJlIG9ubHkgbWV0YWRhdGEgZG9jQ2hhbmdlcyBhbmQgdGhleSBnb3RcclxuICAgICAgICAvLyBzdHJpcHBlZCBvdXQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmFpc2VJbml0aWFsRXZlbnQoc25hcCkge1xyXG4gICAgICAgIHNuYXAgPSBWaWV3U25hcHNob3QuZnJvbUluaXRpYWxEb2N1bWVudHMoc25hcC5xdWVyeSwgc25hcC5kb2NzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSwgc25hcC5oYXNDYWNoZWRSZXN1bHRzKTtcclxuICAgICAgICB0aGlzLnJhaXNlZEluaXRpYWxFdmVudCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XHJcbiAgICB9XHJcbiAgICBsaXN0ZW5zVG9SZW1vdGVTdG9yZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZSAhPT0gTGlzdGVuZXJEYXRhU291cmNlLkNhY2hlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHNldCBvZiBjaGFuZ2VzIHRvIHdoYXQgZG9jdW1lbnRzIGFyZSBjdXJyZW50bHkgaW4gdmlldyBhbmQgb3V0IG9mIHZpZXcgZm9yXHJcbiAqIGEgZ2l2ZW4gcXVlcnkuIFRoZXNlIGNoYW5nZXMgYXJlIHNlbnQgdG8gdGhlIExvY2FsU3RvcmUgYnkgdGhlIFZpZXcgKHZpYVxyXG4gKiB0aGUgU3luY0VuZ2luZSkgYW5kIGFyZSB1c2VkIHRvIHBpbiAvIHVucGluIGRvY3VtZW50cyBhcyBhcHByb3ByaWF0ZS5cclxuICovXHJcbmNsYXNzIExvY2FsVmlld0NoYW5nZXMge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcclxuICAgICAgICB0aGlzLmFkZGVkS2V5cyA9IGFkZGVkS2V5cztcclxuICAgICAgICB0aGlzLnJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVNuYXBzaG90KHRhcmdldElkLCB2aWV3U25hcHNob3QpIHtcclxuICAgICAgICBsZXQgYWRkZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBsZXQgcmVtb3ZlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHZpZXdTbmFwc2hvdC5kb2NDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jQ2hhbmdlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkS2V5cyA9IGFkZGVkS2V5cy5hZGQoZG9jQ2hhbmdlLmRvYy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cyA9IHJlbW92ZWRLZXlzLmFkZChkb2NDaGFuZ2UuZG9jLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZXdDaGFuZ2VzKHRhcmdldElkLCB2aWV3U25hcHNob3QuZnJvbUNhY2hlLCBhZGRlZEtleXMsIHJlbW92ZWRLZXlzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGNvbnZlcnQgb2JqZWN0cyBmcm9tIGJ1bmRsZXMgdG8gbW9kZWwgb2JqZWN0cyBpbiB0aGUgU0RLLlxyXG4gKi9cclxuY2xhc3MgQnVuZGxlQ29udmVydGVySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHRvRG9jdW1lbnRLZXkobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tTmFtZSh0aGlzLnNlcmlhbGl6ZXIsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIEJ1bmRsZURvY3VtZW50IHRvIGEgTXV0YWJsZURvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICB0b011dGFibGVEb2N1bWVudChidW5kbGVkRG9jKSB7XHJcbiAgICAgICAgaWYgKGJ1bmRsZWREb2MubWV0YWRhdGEuZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tRG9jdW1lbnQodGhpcy5zZXJpYWxpemVyLCBidW5kbGVkRG9jLmRvY3VtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQodGhpcy50b0RvY3VtZW50S2V5KGJ1bmRsZWREb2MubWV0YWRhdGEubmFtZSksIHRoaXMudG9TbmFwc2hvdFZlcnNpb24oYnVuZGxlZERvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU25hcHNob3RWZXJzaW9uKHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gZnJvbVZlcnNpb24odGltZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgdG8gcHJvY2VzcyB0aGUgZWxlbWVudHMgZnJvbSBhIGJ1bmRsZSwgbG9hZCB0aGVtIGludG8gbG9jYWxcclxuICogc3RvcmFnZSBhbmQgcHJvdmlkZSBwcm9ncmVzcyB1cGRhdGUgd2hpbGUgbG9hZGluZy5cclxuICovXHJcbmNsYXNzIEJ1bmRsZUxvYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihidW5kbGVNZXRhZGF0YSwgbG9jYWxTdG9yZSwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMuYnVuZGxlTWV0YWRhdGEgPSBidW5kbGVNZXRhZGF0YTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgLyoqIEJhdGNoZWQgcXVlcmllcyB0byBiZSBzYXZlZCBpbnRvIHN0b3JhZ2UgKi9cclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAvKiogQmF0Y2hlZCBkb2N1bWVudHMgdG8gYmUgc2F2ZWQgaW50byBzdG9yYWdlICovXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudHMgPSBbXTtcclxuICAgICAgICAvKiogVGhlIGNvbGxlY3Rpb24gZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoaXMgYnVuZGxlLiAqL1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gYnVuZGxlSW5pdGlhbFByb2dyZXNzKGJ1bmRsZU1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBlbGVtZW50IGZyb20gdGhlIGJ1bmRsZSB0byB0aGUgbG9hZGVyLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBuZXcgcHJvZ3Jlc3MgaWYgYWRkaW5nIHRoZSBlbGVtZW50IGxlYWRzIHRvIGEgbmV3IHByb2dyZXNzLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzLmJ5dGVzTG9hZGVkICs9IGVsZW1lbnQuYnl0ZUxlbmd0aDtcclxuICAgICAgICBsZXQgZG9jdW1lbnRzTG9hZGVkID0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5wdXNoKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHMucHVzaCh7IG1ldGFkYXRhOiBlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YSB9KTtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5leGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICsrZG9jdW1lbnRzTG9hZGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXBzLmFkZChwYXRoLmdldChwYXRoLmxlbmd0aCAtIDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRzW3RoaXMuZG9jdW1lbnRzLmxlbmd0aCAtIDFdLmRvY3VtZW50ID1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudDtcclxuICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudHNMb2FkZWQgIT09IHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkID0gZG9jdW1lbnRzTG9hZGVkO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0UXVlcnlEb2N1bWVudE1hcHBpbmcoZG9jdW1lbnRzKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlEb2N1bWVudE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBidW5kbGVDb252ZXJ0ZXIgPSBuZXcgQnVuZGxlQ29udmVydGVySW1wbCh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYnVuZGxlRG9jIG9mIGRvY3VtZW50cykge1xyXG4gICAgICAgICAgICBpZiAoYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50S2V5ID0gYnVuZGxlQ29udmVydGVyLnRvRG9jdW1lbnRLZXkoYnVuZGxlRG9jLm1ldGFkYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeU5hbWUgb2YgYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleXMgPSAocXVlcnlEb2N1bWVudE1hcC5nZXQocXVlcnlOYW1lKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5RG9jdW1lbnRNYXAuc2V0KHF1ZXJ5TmFtZSwgZG9jdW1lbnRLZXlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcnlEb2N1bWVudE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBwcm9ncmVzcyB0byAnU3VjY2VzcycgYW5kIHJldHVybiB0aGUgdXBkYXRlZCBwcm9ncmVzcy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY29tcGxldGUoKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZERvY3MgPSBhd2FpdCBsb2NhbFN0b3JlQXBwbHlCdW5kbGVkRG9jdW1lbnRzKHRoaXMubG9jYWxTdG9yZSwgbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKSwgdGhpcy5kb2N1bWVudHMsIHRoaXMuYnVuZGxlTWV0YWRhdGEuaWQpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSB0aGlzLmdldFF1ZXJ5RG9jdW1lbnRNYXBwaW5nKHRoaXMuZG9jdW1lbnRzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgdGhpcy5xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlTmFtZWRRdWVyeSh0aGlzLmxvY2FsU3RvcmUsIHEsIHF1ZXJ5RG9jdW1lbnRNYXAuZ2V0KHEubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2dyZXNzLnRhc2tTdGF0ZSA9ICdTdWNjZXNzJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9ncmVzczogdGhpcy5wcm9ncmVzcyxcclxuICAgICAgICAgICAgY2hhbmdlZENvbGxlY3Rpb25Hcm91cHM6IHRoaXMuY29sbGVjdGlvbkdyb3VwcyxcclxuICAgICAgICAgICAgY2hhbmdlZERvY3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbCBwcm9ncmVzcyBvZlxyXG4gKiBsb2FkaW5nIGEgYnVuZGxlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVuZGxlSW5pdGlhbFByb2dyZXNzKG1ldGFkYXRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxyXG4gICAgICAgIGRvY3VtZW50c0xvYWRlZDogMCxcclxuICAgICAgICBieXRlc0xvYWRlZDogMCxcclxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXHJcbiAgICAgICAgdG90YWxCeXRlczogbWV0YWRhdGEudG90YWxCeXRlc1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRoYXQgdGhlIGxvYWRpbmdcclxuICogaGFzIHN1Y2NlZWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YXNrU3RhdGU6ICdTdWNjZXNzJyxcclxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IG1ldGFkYXRhLnRvdGFsRG9jdW1lbnRzLFxyXG4gICAgICAgIGJ5dGVzTG9hZGVkOiBtZXRhZGF0YS50b3RhbEJ5dGVzLFxyXG4gICAgICAgIHRvdGFsRG9jdW1lbnRzOiBtZXRhZGF0YS50b3RhbERvY3VtZW50cyxcclxuICAgICAgICB0b3RhbEJ5dGVzOiBtZXRhZGF0YS50b3RhbEJ5dGVzXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFkZGVkTGltYm9Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBSZW1vdmVkTGltYm9Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmlldyBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0aW5nIHRoZSBmaW5hbCBtZXJnZWQgdHJ1dGggb2Ygd2hhdCBkb2NzIGFyZSBpblxyXG4gKiBhIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyB0byBkb2NzLCBhbmQgYXBwbGllc1xyXG4gKiB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0IHBvc3NpYmxlIHJlc3VsdHMuXHJcbiAqL1xyXG5jbGFzcyBWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBcclxuICAgIC8qKiBEb2N1bWVudHMgaW5jbHVkZWQgaW4gdGhlIHJlbW90ZSB0YXJnZXQgKi9cclxuICAgIF9zeW5jZWREb2N1bWVudHMpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgdGhpcy5fc3luY2VkRG9jdW1lbnRzID0gX3N5bmNlZERvY3VtZW50cztcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmbGFnIHdoZXRoZXIgdGhlIHZpZXcgaXMgY3VycmVudCB3aXRoIHRoZSBiYWNrZW5kLiBBIHZpZXcgaXMgY29uc2lkZXJlZFxyXG4gICAgICAgICAqIGN1cnJlbnQgYWZ0ZXIgaXQgaGFzIHNlZW4gdGhlIGN1cnJlbnQgZmxhZyBmcm9tIHRoZSBiYWNrZW5kIGFuZCBkaWQgbm90XHJcbiAgICAgICAgICogbG9zZSBjb25zaXN0ZW5jeSB3aXRoaW4gdGhlIHdhdGNoIHN0cmVhbSAoZS5nLiBiZWNhdXNlIG9mIGFuIGV4aXN0ZW5jZVxyXG4gICAgICAgICAqIGZpbHRlciBtaXNtYXRjaCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIERvY3VtZW50cyBpbiB0aGUgdmlldyBidXQgbm90IGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgLyoqIERvY3VtZW50IEtleXMgdGhhdCBoYXZlIGxvY2FsIGNoYW5nZXMgKi9cclxuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IgPSBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBuZXcgRG9jdW1lbnRTZXQodGhpcy5kb2NDb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBvZiByZW1vdGUgZG9jdW1lbnRzIHRoYXQgdGhlIHNlcnZlciBoYXMgdG9sZCB1cyBiZWxvbmdzIHRvIHRoZSB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKiB0aGlzIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBzeW5jZWREb2N1bWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N5bmNlZERvY3VtZW50cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIHNldCBvZiBkb2MgY2hhbmdlcywgYXBwbGllcyB0aGUgcXVlcnkgbGltaXQsIGFuZCBjb21wdXRlc1xyXG4gICAgICogd2hhdCB0aGUgbmV3IHJlc3VsdHMgc2hvdWxkIGJlLCB3aGF0IHRoZSBjaGFuZ2VzIHdlcmUsIGFuZCB3aGV0aGVyIHdlIG1heVxyXG4gICAgICogbmVlZCB0byBnbyBiYWNrIHRvIHRoZSBsb2NhbCBjYWNoZSBmb3IgbW9yZSByZXN1bHRzLiBEb2VzIG5vdCBtYWtlIGFueVxyXG4gICAgICogY2hhbmdlcyB0byB0aGUgdmlldy5cclxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIGRvYyBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoaXMgdmlldy5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0NoYW5nZXMgLSBJZiB0aGlzIGlzIGJlaW5nIGNhbGxlZCB3aXRoIGEgcmVmaWxsLCB0aGVuIHN0YXJ0XHJcbiAgICAgKiAgICAgICAgd2l0aCB0aGlzIHNldCBvZiBkb2NzIGFuZCBjaGFuZ2VzIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgdmlldy5cclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHNldCBvZiBkb2NzLCBjaGFuZ2VzLCBhbmQgcmVmaWxsIGZsYWcuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVEb2NDaGFuZ2VzKGRvY0NoYW5nZXMsIHByZXZpb3VzQ2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHByZXZpb3VzQ2hhbmdlc1xyXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5jaGFuZ2VTZXRcclxuICAgICAgICAgICAgOiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKTtcclxuICAgICAgICBjb25zdCBvbGREb2N1bWVudFNldCA9IHByZXZpb3VzQ2hhbmdlc1xyXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5kb2N1bWVudFNldFxyXG4gICAgICAgICAgICA6IHRoaXMuZG9jdW1lbnRTZXQ7XHJcbiAgICAgICAgbGV0IG5ld011dGF0ZWRLZXlzID0gcHJldmlvdXNDaGFuZ2VzXHJcbiAgICAgICAgICAgID8gcHJldmlvdXNDaGFuZ2VzLm11dGF0ZWRLZXlzXHJcbiAgICAgICAgICAgIDogdGhpcy5tdXRhdGVkS2V5cztcclxuICAgICAgICBsZXQgbmV3RG9jdW1lbnRTZXQgPSBvbGREb2N1bWVudFNldDtcclxuICAgICAgICBsZXQgbmVlZHNSZWZpbGwgPSBmYWxzZTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgbGFzdCBkb2MgaW4gYSAoZnVsbCkgbGltaXQuIFRoaXMgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIHNvbWVcclxuICAgICAgICAvLyB1cGRhdGUgKGEgZGVsZXRlLCBvciBhbiB1cGRhdGUgbW92aW5nIGEgZG9jIHBhc3QgdGhlIG9sZCBsaW1pdCkgbWlnaHRcclxuICAgICAgICAvLyBtZWFuIHRoZXJlIGlzIHNvbWUgb3RoZXIgZG9jdW1lbnQgaW4gdGhlIGxvY2FsIGNhY2hlIHRoYXQgZWl0aGVyIHNob3VsZFxyXG4gICAgICAgIC8vIGNvbWUgKDEpIGJldHdlZW4gdGhlIG9sZCBsYXN0IGxpbWl0IGRvYyBhbmQgdGhlIG5ldyBsYXN0IGRvY3VtZW50LCBpbiB0aGVcclxuICAgICAgICAvLyBjYXNlIG9mIHVwZGF0ZXMsIG9yICgyKSBhZnRlciB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZSBjYXNlIG9mXHJcbiAgICAgICAgLy8gZGVsZXRlcy4gU28gd2Uga2VlcCB0aGlzIGRvYyBhdCB0aGUgb2xkIGxpbWl0IHRvIGNvbXBhcmUgdGhlIHVwZGF0ZXMgdG8uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGQgbmV2ZXIgZ2V0IHVzZWQgaW4gYSByZWZpbGwgKHdoZW4gcHJldmlvdXNDaGFuZ2VzIGlzXHJcbiAgICAgICAgLy8gc2V0KSwgYmVjYXVzZSB0aGVyZSB3aWxsIG9ubHkgYmUgYWRkcyAtLSBubyBkZWxldGVzIG9yIHVwZGF0ZXMuXHJcbiAgICAgICAgY29uc3QgbGFzdERvY0luTGltaXQgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovICYmXHJcbiAgICAgICAgICAgIG9sZERvY3VtZW50U2V0LnNpemUgPT09IHRoaXMucXVlcnkubGltaXRcclxuICAgICAgICAgICAgPyBvbGREb2N1bWVudFNldC5sYXN0KClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxyXG4gICAgICAgICAgICBvbGREb2N1bWVudFNldC5zaXplID09PSB0aGlzLnF1ZXJ5LmxpbWl0XHJcbiAgICAgICAgICAgID8gb2xkRG9jdW1lbnRTZXQuZmlyc3QoKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgZG9jQ2hhbmdlcy5pbm9yZGVyVHJhdmVyc2FsKChrZXksIGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZERvYyA9IG9sZERvY3VtZW50U2V0LmdldChrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBxdWVyeU1hdGNoZXModGhpcy5xdWVyeSwgZW50cnkpID8gZW50cnkgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBvbGREb2NIYWRQZW5kaW5nTXV0YXRpb25zID0gb2xkRG9jXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMubXV0YXRlZEtleXMuaGFzKG9sZERvYy5rZXkpXHJcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zID0gbmV3RG9jXHJcbiAgICAgICAgICAgICAgICA/IG5ld0RvYy5oYXNMb2NhbE11dGF0aW9ucyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY29uc2lkZXIgY29tbWl0dGVkIG11dGF0aW9ucyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG11dGF0ZWQgZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGUgdmlldy5cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5tdXRhdGVkS2V5cy5oYXMobmV3RG9jLmtleSkgJiYgbmV3RG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucylcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VBcHBsaWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjaGFuZ2VcclxuICAgICAgICAgICAgaWYgKG9sZERvYyAmJiBuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3NFcXVhbCA9IG9sZERvYy5kYXRhLmlzRXF1YWwobmV3RG9jLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2NzRXF1YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jOiBuZXdEb2NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3REb2NJbkxpbWl0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IobmV3RG9jLCBsYXN0RG9jSW5MaW1pdCkgPiAwKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpcnN0RG9jSW5MaW1pdCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGZpcnN0RG9jSW5MaW1pdCkgPCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkb2MgbW92ZWQgZnJvbSBpbnNpZGUgdGhlIGxpbWl0IHRvIG91dHNpZGUgdGhlIGxpbWl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhhdCBtZWFucyB0aGVyZSBtYXkgYmUgc29tZSBvdGhlciBkb2MgaW4gdGhlIGxvY2FsIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyAhPT0gbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLywgZG9jOiBuZXdEb2MgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW9sZERvYyAmJiBuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLywgZG9jOiBuZXdEb2MgfSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvbGREb2MgJiYgIW5ld0RvYykge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdERvY0luTGltaXQgfHwgZmlyc3REb2NJbkxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBkb2Mgd2FzIHJlbW92ZWQgZnJvbSBhIGZ1bGwgbGltaXQgcXVlcnkuIFdlJ2xsIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IGZyb20gdGhlIGxvY2FsIGNhY2hlIHRvIHNlZSBpZiB3ZSBrbm93IGFib3V0IHNvbWUgb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb2MgdGhhdCBzaG91bGQgYmUgaW4gdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VBcHBsaWVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RG9jdW1lbnRTZXQgPSBuZXdEb2N1bWVudFNldC5hZGQobmV3RG9jKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEcm9wIGRvY3VtZW50cyBvdXQgdG8gbWVldCBsaW1pdC9saW1pdFRvTGFzdCByZXF1aXJlbWVudC5cclxuICAgICAgICBpZiAodGhpcy5xdWVyeS5saW1pdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3aGlsZSAobmV3RG9jdW1lbnRTZXQuc2l6ZSA+IHRoaXMucXVlcnkubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZERvYyA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi9cclxuICAgICAgICAgICAgICAgICAgICA/IG5ld0RvY3VtZW50U2V0Lmxhc3QoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV3RG9jdW1lbnRTZXQuZmlyc3QoKTtcclxuICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKG9sZERvYy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUob2xkRG9jLmtleSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLywgZG9jOiBvbGREb2MgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZG9jdW1lbnRTZXQ6IG5ld0RvY3VtZW50U2V0LFxyXG4gICAgICAgICAgICBjaGFuZ2VTZXQsXHJcbiAgICAgICAgICAgIG5lZWRzUmVmaWxsLFxyXG4gICAgICAgICAgICBtdXRhdGVkS2V5czogbmV3TXV0YXRlZEtleXNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSB7XHJcbiAgICAgICAgLy8gV2Ugc3VwcHJlc3MgdGhlIGluaXRpYWwgY2hhbmdlIGV2ZW50IGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIG1vZGlmaWVkIGFzXHJcbiAgICAgICAgLy8gcGFydCBvZiBhIHdyaXRlIGFja25vd2xlZGdtZW50IChlLmcuIHdoZW4gdGhlIHZhbHVlIG9mIGEgc2VydmVyIHRyYW5zZm9ybVxyXG4gICAgICAgIC8vIGlzIGFwcGxpZWQpIGFzIFdhdGNoIHdpbGwgc2VuZCB1cyB0aGUgc2FtZSBkb2N1bWVudCBhZ2Fpbi5cclxuICAgICAgICAvLyBCeSBzdXBwcmVzc2luZyB0aGUgZXZlbnQsIHdlIG9ubHkgcmFpc2UgdHdvIHVzZXIgdmlzaWJsZSBldmVudHMgKG9uZSB3aXRoXHJcbiAgICAgICAgLy8gYGhhc1BlbmRpbmdXcml0ZXNgIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50KSBpbnN0ZWFkIG9mIHRocmVlXHJcbiAgICAgICAgLy8gKG9uZSB3aXRoIGBoYXNQZW5kaW5nV3JpdGVzYCwgdGhlIG1vZGlmaWVkIGRvY3VtZW50IHdpdGhcclxuICAgICAgICAvLyBgaGFzUGVuZGluZ1dyaXRlc2AgYW5kIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQpLlxyXG4gICAgICAgIHJldHVybiAob2xkRG9jLmhhc0xvY2FsTXV0YXRpb25zICYmXHJcbiAgICAgICAgICAgIG5ld0RvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMgJiZcclxuICAgICAgICAgICAgIW5ld0RvYy5oYXNMb2NhbE11dGF0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gVmlld0RvY3VtZW50Q2hhbmdlcyBhbmQgb3B0aW9uYWxseSB1cGRhdGVzXHJcbiAgICAgKiBsaW1ibyBkb2NzIGFuZCBzeW5jIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIHRhcmdldCBjaGFuZ2UuXHJcbiAgICAgKiBAcGFyYW0gZG9jQ2hhbmdlcyAtIFRoZSBzZXQgb2YgY2hhbmdlcyB0byBtYWtlIHRvIHRoZSB2aWV3J3MgZG9jcy5cclxuICAgICAqIEBwYXJhbSBsaW1ib1Jlc29sdXRpb25FbmFibGVkIC0gV2hldGhlciB0byB1cGRhdGUgbGltYm8gZG9jdW1lbnRzIGJhc2VkIG9uXHJcbiAgICAgKiAgICAgICAgdGhpcyBjaGFuZ2UuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0Q2hhbmdlIC0gQSB0YXJnZXQgY2hhbmdlIHRvIGFwcGx5IGZvciBjb21wdXRpbmcgbGltYm8gZG9jcyBhbmRcclxuICAgICAqICAgICAgICBzeW5jIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIHRhcmdldElzUGVuZGluZ1Jlc2V0IC0gV2hldGhlciB0aGUgdGFyZ2V0IGlzIHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvXHJcbiAgICAgKiAgICAgICAgZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC4gSWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBpdCBpcyB0cmVhdGVkXHJcbiAgICAgKiAgICAgICAgZXF1aXZhbGVudGx5IHRvIGBmYWxzZWAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBWaWV3Q2hhbmdlIHdpdGggdGhlIGdpdmVuIGRvY3MsIGNoYW5nZXMsIGFuZCBzeW5jIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IFRoZSBpT1MvQW5kcm9pZCBjbGllbnRzIGFsd2F5cyBjb21wdXRlIGxpbWJvIGRvY3VtZW50IGNoYW5nZXMuXHJcbiAgICBhcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgbGltYm9SZXNvbHV0aW9uRW5hYmxlZCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCkge1xyXG4gICAgICAgIGNvbnN0IG9sZERvY3MgPSB0aGlzLmRvY3VtZW50U2V0O1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBkb2NDaGFuZ2VzLmRvY3VtZW50U2V0O1xyXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2NDaGFuZ2VzLm11dGF0ZWRLZXlzO1xyXG4gICAgICAgIC8vIFNvcnQgY2hhbmdlcyBiYXNlZCBvbiB0eXBlIGFuZCBxdWVyeSBjb21wYXJhdG9yXHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGRvY0NoYW5nZXMuY2hhbmdlU2V0LmdldENoYW5nZXMoKTtcclxuICAgICAgICBjaGFuZ2VzLnNvcnQoKGMxLCBjMikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmVDaGFuZ2VUeXBlKGMxLnR5cGUsIGMyLnR5cGUpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IoYzEuZG9jLCBjMi5kb2MpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSk7XHJcbiAgICAgICAgdGFyZ2V0SXNQZW5kaW5nUmVzZXQgPSB0YXJnZXRJc1BlbmRpbmdSZXNldCAhPT0gbnVsbCAmJiB0YXJnZXRJc1BlbmRpbmdSZXNldCAhPT0gdm9pZCAwID8gdGFyZ2V0SXNQZW5kaW5nUmVzZXQgOiBmYWxzZTtcclxuICAgICAgICBjb25zdCBsaW1ib0NoYW5nZXMgPSBsaW1ib1Jlc29sdXRpb25FbmFibGVkICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldFxyXG4gICAgICAgICAgICA/IHRoaXMudXBkYXRlTGltYm9Eb2N1bWVudHMoKVxyXG4gICAgICAgICAgICA6IFtdO1xyXG4gICAgICAgIC8vIFdlIGFyZSBhdCBzeW5jZWQgc3RhdGUgaWYgdGhlcmUgaXMgbm8gbGltYm8gZG9jcyBhcmUgd2FpdGluZyB0byBiZSByZXNvbHZlZCwgdmlldyBpcyBjdXJyZW50XHJcbiAgICAgICAgLy8gd2l0aCB0aGUgYmFja2VuZCwgYW5kIHRoZSBxdWVyeSBpcyBub3QgcGVuZGluZyB0byByZXNldCBkdWUgdG8gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC5cclxuICAgICAgICBjb25zdCBzeW5jZWQgPSB0aGlzLmxpbWJvRG9jdW1lbnRzLnNpemUgPT09IDAgJiYgdGhpcy5jdXJyZW50ICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldDtcclxuICAgICAgICBjb25zdCBuZXdTeW5jU3RhdGUgPSBzeW5jZWQgPyAxIC8qIFN5bmNTdGF0ZS5TeW5jZWQgKi8gOiAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLztcclxuICAgICAgICBjb25zdCBzeW5jU3RhdGVDaGFuZ2VkID0gbmV3U3luY1N0YXRlICE9PSB0aGlzLnN5bmNTdGF0ZTtcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG5ld1N5bmNTdGF0ZTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXN5bmNTdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgLy8gbm8gY2hhbmdlc1xyXG4gICAgICAgICAgICByZXR1cm4geyBsaW1ib0NoYW5nZXMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXAgPSBuZXcgVmlld1NuYXBzaG90KHRoaXMucXVlcnksIGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQsIG9sZERvY3MsIGNoYW5nZXMsIGRvY0NoYW5nZXMubXV0YXRlZEtleXMsIG5ld1N5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHN5bmNTdGF0ZUNoYW5nZWQsIFxyXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gZmFsc2UsIHRhcmdldENoYW5nZVxyXG4gICAgICAgICAgICAgICAgPyB0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMFxyXG4gICAgICAgICAgICAgICAgOiBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDogc25hcCxcclxuICAgICAgICAgICAgICAgIGxpbWJvQ2hhbmdlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhbiBPbmxpbmVTdGF0ZSBjaGFuZ2UgdG8gdGhlIHZpZXcsIHBvdGVudGlhbGx5IGdlbmVyYXRpbmcgYVxyXG4gICAgICogVmlld0NoYW5nZSBpZiB0aGUgdmlldydzIHN5bmNTdGF0ZSBjaGFuZ2VzIGFzIGEgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCAmJiBvbmxpbmVTdGF0ZSA9PT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lLCBzZXQgYGN1cnJlbnRgIHRvIGZhbHNlIGFuZCB0aGVuIGNhbGwgYXBwbHlDaGFuZ2VzKClcclxuICAgICAgICAgICAgLy8gdG8gcmVmcmVzaCBvdXIgc3luY1N0YXRlIGFuZCBnZW5lcmF0ZSBhIFZpZXdDaGFuZ2UgYXMgYXBwcm9wcmlhdGUuIFdlXHJcbiAgICAgICAgICAgIC8vIGFyZSBndWFyYW50ZWVkIHRvIGdldCBhIG5ldyBUYXJnZXRDaGFuZ2UgdGhhdCBzZXRzIGBjdXJyZW50YCBiYWNrIHRvXHJcbiAgICAgICAgICAgIC8vIHRydWUgb25jZSB0aGUgY2xpZW50IGlzIGJhY2sgb25saW5lLlxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDaGFuZ2VzKHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50U2V0OiB0aGlzLmRvY3VtZW50U2V0LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0OiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKSxcclxuICAgICAgICAgICAgICAgIG11dGF0ZWRLZXlzOiB0aGlzLm11dGF0ZWRLZXlzLFxyXG4gICAgICAgICAgICAgICAgbmVlZHNSZWZpbGw6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBlZmZlY3QsIGp1c3QgcmV0dXJuIGEgbm8tb3AgVmlld0NoYW5nZS5cclxuICAgICAgICAgICAgcmV0dXJuIHsgbGltYm9DaGFuZ2VzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBkb2MgZm9yIHRoZSBnaXZlbiBrZXkgc2hvdWxkIGJlIGluIGxpbWJvLlxyXG4gICAgICovXHJcbiAgICBzaG91bGRCZUluTGltYm8oa2V5KSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSBlbmQgc2F5cyBpdCdzIHBhcnQgb2YgdGhpcyBxdWVyeSwgaXQncyBub3QgaW4gbGltYm8uXHJcbiAgICAgICAgaWYgKHRoaXMuX3N5bmNlZERvY3VtZW50cy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBsb2NhbCBzdG9yZSBkb2Vzbid0IHRoaW5rIGl0J3MgYSByZXN1bHQsIHNvIGl0IHNob3VsZG4ndCBiZSBpbiBsaW1iby5cclxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbG9jYWwgY2hhbmdlcyB0byB0aGUgZG9jLCB0aGV5IG1pZ2h0IGV4cGxhaW4gd2h5IHRoZSBzZXJ2ZXJcclxuICAgICAgICAvLyBkb2Vzbid0IGtub3cgdGhhdCBpdCdzIHBhcnQgb2YgdGhlIHF1ZXJ5LiBTbyBkb24ndCBwdXQgaXQgaW4gbGltYm8uXHJcbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IElkZWFsbHksIHdlIHdvdWxkIG9ubHkgY29uc2lkZXIgY2hhbmdlcyB0aGF0IG1pZ2h0IGFjdHVhbGx5XHJcbiAgICAgICAgLy8gYWZmZWN0IHRoaXMgc3BlY2lmaWMgcXVlcnkuXHJcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRTZXQuZ2V0KGtleSkuaGFzTG9jYWxNdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgaW4gbGltYm8uXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgc3luY2VkRG9jdW1lbnRzLCBjdXJyZW50LCBhbmQgbGltYm8gZG9jcyBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhbmdlLlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHdoaWNoIGRvY3MgYXJlIGluIGxpbWJvLlxyXG4gICAgICovXHJcbiAgICBhcHBseVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcclxuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiAodGhpcy5fc3luY2VkRG9jdW1lbnRzID0gdGhpcy5fc3luY2VkRG9jdW1lbnRzLmFkZChrZXkpKSk7XHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5tb2RpZmllZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiAodGhpcy5fc3luY2VkRG9jdW1lbnRzID0gdGhpcy5fc3luY2VkRG9jdW1lbnRzLmRlbGV0ZShrZXkpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHRhcmdldENoYW5nZS5jdXJyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnRzKCkge1xyXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRldGVybWluZSBsaW1ibyBkb2N1bWVudHMgd2hlbiB3ZSdyZSBpbi1zeW5jIHdpdGggdGhlIHNlcnZlci5cclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8oa2xpbXQpOiBEbyB0aGlzIGluY3JlbWVudGFsbHkgc28gdGhhdCBpdCdzIG5vdCBxdWFkcmF0aWMgd2hlblxyXG4gICAgICAgIC8vIHVwZGF0aW5nIG1hbnkgZG9jdW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IG9sZExpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cztcclxuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U2V0LmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQmVJbkxpbWJvKGRvYy5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cy5hZGQoZG9jLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEaWZmIHRoZSBuZXcgbGltYm8gZG9jcyB3aXRoIHRoZSBvbGQgbGltYm8gZG9jcy5cclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgb2xkTGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubGltYm9Eb2N1bWVudHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgUmVtb3ZlZExpbWJvRG9jdW1lbnQoa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKCFvbGRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKG5ldyBBZGRlZExpbWJvRG9jdW1lbnQoa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBpbi1tZW1vcnkgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldyB3aXRoIHRoZSBzdGF0ZSByZWFkIGZyb21cclxuICAgICAqIHBlcnNpc3RlbmNlLlxyXG4gICAgICpcclxuICAgICAqIFdlIHVwZGF0ZSB0aGUgcXVlcnkgdmlldyB3aGVuZXZlciBhIGNsaWVudCdzIHByaW1hcnkgc3RhdHVzIGNoYW5nZXM6XHJcbiAgICAgKiAtIFdoZW4gYSBjbGllbnQgdHJhbnNpdGlvbnMgZnJvbSBwcmltYXJ5IHRvIHNlY29uZGFyeSwgaXQgY2FuIG1pc3NcclxuICAgICAqICAgTG9jYWxTdG9yYWdlIHVwZGF0ZXMgYW5kIGl0cyBxdWVyeSB2aWV3cyBtYXkgdGVtcG9yYXJpbHkgbm90IGJlXHJcbiAgICAgKiAgIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzdGF0ZSBvbiBkaXNrLlxyXG4gICAgICogLSBGb3Igc2Vjb25kYXJ5IHRvIHByaW1hcnkgdHJhbnNpdGlvbnMsIHRoZSBjbGllbnQgbmVlZHMgdG8gdXBkYXRlIHRoZSBsaXN0XHJcbiAgICAgKiAgIG9mIGBzeW5jZWREb2N1bWVudHNgIHNpbmNlIHNlY29uZGFyeSBjbGllbnRzIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3c1xyXG4gICAgICogICBiYXNlZCBwdXJlbHkgb24gc3ludGhlc2l6ZWQgUmVtb3RlRXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5kb2N1bWVudHMgLSBUaGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGFjY29yZGluZ1xyXG4gICAgICogdG8gdGhlIExvY2FsU3RvcmUuXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlSZXN1bHQucmVtb3RlS2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGVcclxuICAgICAqIHF1ZXJ5IGFjY29yZGluZyB0byB0aGUgYmFja2VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVmlld0NoYW5nZSB0aGF0IHJlc3VsdGVkIGZyb20gdGhpcyBzeW5jaHJvbml6YXRpb24uXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBzeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXM7XHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRoaXMuY29tcHV0ZURvY0NoYW5nZXMocXVlcnlSZXN1bHQuZG9jdW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIHRoaXMgcXVlcnkgd2FzIGp1c3QgbGlzdGVuZWQgdG8uIENvbnRhaW5zXHJcbiAgICAgKiBhIGRvY3VtZW50IGFkZCBmb3IgZXZlcnkgZXhpc3RpbmcgZG9jdW1lbnQgYW5kIHRoZSBgZnJvbUNhY2hlYCBhbmRcclxuICAgICAqIGBoYXNQZW5kaW5nV3JpdGVzYCBzdGF0dXMgb2YgdGhlIGFscmVhZHkgZXN0YWJsaXNoZWQgdmlldy5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIGNvbXB1dGVJbml0aWFsU25hcHNob3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyh0aGlzLnF1ZXJ5LCB0aGlzLmRvY3VtZW50U2V0LCB0aGlzLm11dGF0ZWRLZXlzLCB0aGlzLnN5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUNoYW5nZVR5cGUoYzEsIGMyKSB7XHJcbiAgICBjb25zdCBvcmRlciA9IChjaGFuZ2UpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGNoYW5nZSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLzpcclxuICAgICAgICAgICAgICAgIC8vIEEgbWV0YWRhdGEgY2hhbmdlIGlzIGNvbnZlcnRlZCB0byBhIG1vZGlmaWVkIGNoYW5nZSBhdCB0aGUgcHVibGljXHJcbiAgICAgICAgICAgICAgICAvLyBhcGkgbGF5ZXIuICBTaW5jZSB3ZSBzb3J0IGJ5IGRvY3VtZW50IGtleSBhbmQgdGhlbiBjaGFuZ2UgdHlwZSxcclxuICAgICAgICAgICAgICAgIC8vIG1ldGFkYXRhIGFuZCBtb2RpZmllZCBjaGFuZ2VzIG11c3QgYmUgc29ydGVkIGVxdWl2YWxlbnRseS5cclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gb3JkZXIoYzEpIC0gb3JkZXIoYzIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckMyA9ICdTeW5jRW5naW5lJztcclxuLyoqXHJcbiAqIFF1ZXJ5VmlldyBjb250YWlucyBhbGwgb2YgdGhlIGRhdGEgdGhhdCBTeW5jRW5naW5lIG5lZWRzIHRvIGtlZXAgdHJhY2sgb2YgZm9yXHJcbiAqIGEgcGFydGljdWxhciBxdWVyeS5cclxuICovXHJcbmNsYXNzIFF1ZXJ5VmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHF1ZXJ5IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcXVlcnksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGFyZ2V0IG51bWJlciBjcmVhdGVkIGJ5IHRoZSBjbGllbnQgdGhhdCBpcyB1c2VkIGluIHRoZSB3YXRjaFxyXG4gICAgICogc3RyZWFtIHRvIGlkZW50aWZ5IHRoaXMgcXVlcnkuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldElkLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZpZXcgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgZmluYWwgbWVyZ2VkIHRydXRoIG9mIHdoYXRcclxuICAgICAqIGRvY3MgYXJlIGluIHRoZSBxdWVyeS4gSXQgZ2V0cyBub3RpZmllZCBvZiBsb2NhbCBhbmQgcmVtb3RlIGNoYW5nZXMsXHJcbiAgICAgKiBhbmQgYXBwbGllcyB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0XHJcbiAgICAgKiBwb3NzaWJsZSByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICB2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgfVxyXG59XHJcbi8qKiBUcmFja3MgYSBsaW1ibyByZXNvbHV0aW9uLiAqL1xyXG5jbGFzcyBMaW1ib1Jlc29sdXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgb25jZSB3ZSd2ZSByZWNlaXZlZCBhIGRvY3VtZW50LiBUaGlzIGlzIHVzZWQgaW5cclxuICAgICAgICAgKiBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KCkgYW5kIHVsdGltYXRlbHkgdXNlZCBieSBXYXRjaENoYW5nZUFnZ3JlZ2F0b3IgdG9cclxuICAgICAgICAgKiBkZWNpZGUgd2hldGhlciBpdCBuZWVkcyB0byBtYW51ZmFjdHVyZSBhIGRlbGV0ZSBldmVudCBmb3IgdGhlIHRhcmdldCBvbmNlXHJcbiAgICAgICAgICogdGhlIHRhcmdldCBpcyBDVVJSRU5ULlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZWREb2N1bWVudCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgU3luY0VuZ2luZWAgY29vcmRpbmF0aW5nIHdpdGggb3RoZXIgcGFydHMgb2YgU0RLLlxyXG4gKlxyXG4gKiBUaGUgcGFydHMgb2YgU3luY0VuZ2luZSB0aGF0IGFjdCBhcyBhIGNhbGxiYWNrIHRvIFJlbW90ZVN0b3JlIG5lZWQgdG8gYmVcclxuICogcmVnaXN0ZXJlZCBpbmRpdmlkdWFsbHkuIFRoaXMgaXMgZG9uZSBpbiBgc3luY0VuZ2luZVdyaXRlKClgIGFuZFxyXG4gKiBgc3luY0VuZ2luZUxpc3RlbigpYCAoYXMgd2VsbCBhcyBgYXBwbHlQcmltYXJ5U3RhdGUoKWApIGFzIHRoZXNlIG1ldGhvZHNcclxuICogc2VydmUgYXMgZW50cnkgcG9pbnRzIHRvIFJlbW90ZVN0b3JlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICpcclxuICogTm90ZTogc29tZSBmaWVsZCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgbWlnaHQgaGF2ZSBwdWJsaWMgYWNjZXNzIGxldmVsLCBidXRcclxuICogdGhlIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBzbyB0aGV5IGFyZSBvbmx5IGFjY2Vzc2libGUgZnJvbSB0aGlzIG1vZHVsZS5cclxuICogVGhpcyBpcyB1c2VmdWwgdG8gaW1wbGVtZW50IG9wdGlvbmFsIGZlYXR1cmVzIChsaWtlIGJ1bmRsZXMpIGluIGZyZWVcclxuICogZnVuY3Rpb25zLCBzdWNoIHRoYXQgdGhleSBhcmUgdHJlZS1zaGFrZWFibGUuXHJcbiAqL1xyXG5jbGFzcyBTeW5jRW5naW5lSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBcclxuICAgIC8vIFBPUlRJTkcgTk9URTogTWFuYWdlcyBzdGF0ZSBzeW5jaHJvbml6YXRpb24gaW4gbXVsdGktdGFiIGVudmlyb25tZW50cy5cclxuICAgIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMucmVtb3RlU3RvcmUgPSByZW1vdGVTdG9yZTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcclxuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gc2hhcmVkQ2xpZW50U3RhdGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IGN1cnJlbnRVc2VyO1xyXG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMgPSBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucztcclxuICAgICAgICB0aGlzLnN5bmNFbmdpbmVMaXN0ZW5lciA9IHt9O1xyXG4gICAgICAgIHRoaXMucXVlcnlWaWV3c0J5UXVlcnkgPSBuZXcgT2JqZWN0TWFwKHEgPT4gY2Fub25pZnlRdWVyeShxKSwgcXVlcnlFcXVhbHMpO1xyXG4gICAgICAgIHRoaXMucXVlcmllc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBrZXlzIG9mIGRvY3VtZW50cyB0aGF0IGFyZSBpbiBsaW1ibyBmb3Igd2hpY2ggd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhXHJcbiAgICAgICAgICogbGltYm8gcmVzb2x1dGlvbiBxdWVyeS4gVGhlIHN0cmluZ3MgaW4gdGhpcyBzZXQgYXJlIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xyXG4gICAgICAgICAqIGBrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKWAgd2hlcmUgYGtleWAgaXMgYSBgRG9jdW1lbnRLZXlgIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBgU2V0YCB0eXBlIHdhcyBjaG9zZW4gYmVjYXVzZSBpdCBwcm92aWRlcyBlZmZpY2llbnQgbG9va3VwIGFuZCByZW1vdmFsXHJcbiAgICAgICAgICogb2YgYXJiaXRyYXJ5IGVsZW1lbnRzIGFuZCBpdCBhbHNvIG1haW50YWlucyBpbnNlcnRpb24gb3JkZXIsIHByb3ZpZGluZyB0aGVcclxuICAgICAgICAgKiBkZXNpcmVkIHF1ZXVlLWxpa2UgRklGTyBzZW1hbnRpY3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIHRhcmdldCBJRCBmb3IgZWFjaCBkb2N1bWVudCB0aGF0IGlzIGluIGxpbWJvIHdpdGggYW5cclxuICAgICAgICAgKiBhY3RpdmUgdGFyZ2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhbiBhY3RpdmUgbGltYm8gcmVzb2x1dGlvbiBmb3IgZWFjaFxyXG4gICAgICAgICAqIGFjdGl2ZSB0YXJnZXQgSUQgdGhhdCB3YXMgc3RhcnRlZCBmb3IgdGhlIHB1cnBvc2Ugb2YgbGltYm8gcmVzb2x1dGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRSZWZzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xyXG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjb21wbGV0aW9uIGhhbmRsZXJzLCBpbmRleGVkIGJ5IFVzZXIgYW5kIEJhdGNoSWQuICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblVzZXJDYWxsYmFja3MgPSB7fTtcclxuICAgICAgICAvKiogU3RvcmVzIHVzZXIgY2FsbGJhY2tzIHdhaXRpbmcgZm9yIGFsbCBwZW5kaW5nIHdyaXRlcyB0byBiZSBhY2tub3dsZWRnZWQuICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubGltYm9UYXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclN5bmNFbmdpbmUoKTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcclxuICAgICAgICAvLyBUaGUgcHJpbWFyeSBzdGF0ZSBpcyBzZXQgdG8gYHRydWVgIG9yIGBmYWxzZWAgaW1tZWRpYXRlbHkgYWZ0ZXIgRmlyZXN0b3JlXHJcbiAgICAgICAgLy8gc3RhcnR1cC4gSW4gdGhlIGludGVyaW0sIGEgY2xpZW50IHNob3VsZCBvbmx5IGJlIGNvbnNpZGVyZWQgcHJpbWFyeSBpZlxyXG4gICAgICAgIC8vIGBpc1ByaW1hcnlgIGlzIHRydWUuXHJcbiAgICAgICAgdGhpcy5faXNQcmltYXJ5Q2xpZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzUHJpbWFyeUNsaWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNQcmltYXJ5Q2xpZW50ID09PSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1N5bmNFbmdpbmUobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXHJcbi8vIFBPUlRJTkcgTk9URTogTWFuYWdlcyBzdGF0ZSBzeW5jaHJvbml6YXRpb24gaW4gbXVsdGktdGFiIGVudmlyb25tZW50cy5cclxuc2hhcmVkQ2xpZW50U3RhdGUsIGN1cnJlbnRVc2VyLCBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucywgaXNQcmltYXJ5KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lID0gbmV3IFN5bmNFbmdpbmVJbXBsKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpO1xyXG4gICAgaWYgKGlzUHJpbWFyeSkge1xyXG4gICAgICAgIHN5bmNFbmdpbmUuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3luY0VuZ2luZTtcclxufVxyXG4vKipcclxuICogSW5pdGlhdGVzIHRoZSBuZXcgbGlzdGVuLCByZXNvbHZlcyBwcm9taXNlIHdoZW4gbGlzdGVuIGVucXVldWVkIHRvIHRoZVxyXG4gKiBzZXJ2ZXIuIEFsbCB0aGUgc3Vic2VxdWVudCB2aWV3IHNuYXBzaG90cyBvciBlcnJvcnMgYXJlIHNlbnQgdG8gdGhlXHJcbiAqIHN1YnNjcmliZWQgaGFuZGxlcnMuIFJldHVybnMgdGhlIGluaXRpYWwgc25hcHNob3QuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lTGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5LCBzaG91bGRMaXN0ZW5Ub1JlbW90ZSA9IHRydWUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XHJcbiAgICBsZXQgdmlld1NuYXBzaG90O1xyXG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcclxuICAgIGlmIChxdWVyeVZpZXcpIHtcclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFdpdGggTXVsdGktVGFiIFdlYiwgaXQgaXMgcG9zc2libGUgdGhhdCBhIHF1ZXJ5IHZpZXdcclxuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cyB3aGVuIEV2ZW50TWFuYWdlciBjYWxscyB1cyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXNcclxuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gdGhlIHByaW1hcnkgdGFiIGlzIGFscmVhZHkgbGlzdGVuaW5nIHRvIHRoaXMgcXVlcnkgb25cclxuICAgICAgICAvLyBiZWhhbGYgb2YgYW5vdGhlciB0YWIgYW5kIHRoZSB1c2VyIG9mIHRoZSBwcmltYXJ5IGFsc28gc3RhcnRzIGxpc3RlbmluZ1xyXG4gICAgICAgIC8vIHRvIHRoZSBxdWVyeS4gRXZlbnRNYW5hZ2VyIHdpbGwgbm90IGhhdmUgYW4gYXNzaWduZWQgdGFyZ2V0IElEIGluIHRoaXNcclxuICAgICAgICAvLyBjYXNlIGFuZCBjYWxscyBgbGlzdGVuYCB0byBvYnRhaW4gdGhpcyBJRC5cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5hZGRMb2NhbFF1ZXJ5VGFyZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgdmlld1NuYXBzaG90ID0gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZUluaXRpYWxTbmFwc2hvdCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld1NuYXBzaG90ID0gYXdhaXQgYWxsb2NhdGVUYXJnZXRBbmRNYXliZUxpc3RlbihzeW5jRW5naW5lSW1wbCwgcXVlcnksIHNob3VsZExpc3RlblRvUmVtb3RlLCBcclxuICAgICAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIHRydWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdTbmFwc2hvdDtcclxufVxyXG4vKiogUXVlcnkgaGFzIGJlZW4gbGlzdGVuaW5nIHRvIHRoZSBjYWNoZSwgYW5kIHRyaWVzIHRvIGluaXRpYXRlIHRoZSByZW1vdGUgc3RvcmUgbGlzdGVuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJSZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcclxuICAgIGF3YWl0IGFsbG9jYXRlVGFyZ2V0QW5kTWF5YmVMaXN0ZW4oc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCBcclxuICAgIC8qKiBzaG91bGRMaXN0ZW5Ub1JlbW90ZT0gKi8gdHJ1ZSwgXHJcbiAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIGZhbHNlKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgc2hvdWxkTGlzdGVuVG9SZW1vdGUsIHNob3VsZEluaXRpYWxpemVWaWV3KSB7XHJcbiAgICBjb25zdCB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcclxuICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgIC8vIFBPUlRJTkcgTk9URTogV2hlbiB0aGUgcXVlcnkgaXMgbGlzdGVuaW5nIHRvIGNhY2hlIG9ubHksIHdlIHNraXAgc2VuZGluZyBpdCBvdmVyIHRvIFdhdGNoIGJ5XHJcbiAgICAvLyBub3QgcmVnaXN0ZXJpbmcgaXQgaW4gc2hhcmVkIGNsaWVudCBzdGF0ZSwgYW5kIGRpcmVjdGx5IGNhbGN1bGF0ZSBpbml0aWFsIHNuYXBzaG90cyBhbmRcclxuICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcyBmcm9tIGNhY2hlLiBPdGhlcndpc2UsIHJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50XHJcbiAgICAvLyBhcyBhY3RpdmUgd2F0Y2ggdGFyZ2V0LlxyXG4gICAgY29uc3Qgc3RhdHVzID0gc2hvdWxkTGlzdGVuVG9SZW1vdGVcclxuICAgICAgICA/IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpXHJcbiAgICAgICAgOiAnbm90LWN1cnJlbnQnO1xyXG4gICAgbGV0IHZpZXdTbmFwc2hvdDtcclxuICAgIGlmIChzaG91bGRJbml0aWFsaXplVmlldykge1xyXG4gICAgICAgIHZpZXdTbmFwc2hvdCA9IGF3YWl0IGluaXRpYWxpemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgdGFyZ2V0SWQsIHN0YXR1cyA9PT0gJ2N1cnJlbnQnLCB0YXJnZXREYXRhLnJlc3VtZVRva2VuKTtcclxuICAgIH1cclxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgc2hvdWxkTGlzdGVuVG9SZW1vdGUpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSB2aWV3IGZvciBhIHByZXZpb3VzbHkgdW5rbm93biBxdWVyeSBhbmQgY29tcHV0ZXMgaXRzIGluaXRpYWxcclxuICogc25hcHNob3QuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBPbiBXZWIgb25seSwgd2UgaW5qZWN0IHRoZSBjb2RlIHRoYXQgcmVnaXN0ZXJzIG5ldyBMaW1ib1xyXG4gICAgLy8gdGFyZ2V0cyBiYXNlZCBvbiB2aWV3IGNoYW5nZXMuIFRoaXMgYWxsb3dzIHVzIHRvIG9ubHkgZGVwZW5kIG9uIExpbWJvXHJcbiAgICAvLyBjaGFuZ2VzIHdoZW4gdXNlciBjb2RlIGluY2x1ZGVzIHF1ZXJpZXMuXHJcbiAgICBzeW5jRW5naW5lSW1wbC5hcHBseURvY0NoYW5nZXMgPSAocXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCkgPT4gYXBwbHlEb2NDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcclxuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeSwgXHJcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xyXG4gICAgY29uc3QgdmlldyA9IG5ldyBWaWV3KHF1ZXJ5LCBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzKTtcclxuICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xyXG4gICAgY29uc3Qgc3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2UgPSBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50ICYmIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovLCByZXN1bWVUb2tlbik7XHJcbiAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxyXG4gICAgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50LCBzeW50aGVzaXplZFRhcmdldENoYW5nZSk7XHJcbiAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBRdWVyeVZpZXcocXVlcnksIHRhcmdldElkLCB2aWV3KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LnNldChxdWVyeSwgZGF0YSk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHRhcmdldElkKS5wdXNoKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5zZXQodGFyZ2V0SWQsIFtxdWVyeV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XHJcbn1cclxuLyoqIFN0b3BzIGxpc3RlbmluZyB0byB0aGUgcXVlcnkuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVVbmxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSwgc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xyXG4gICAgLy8gT25seSBjbGVhbiB1cCB0aGUgcXVlcnkgdmlldyBhbmQgdGFyZ2V0IGlmIHRoaXMgaXMgdGhlIG9ubHkgcXVlcnkgbWFwcGVkXHJcbiAgICAvLyB0byB0aGUgdGFyZ2V0LlxyXG4gICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuc2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCwgcXVlcmllcy5maWx0ZXIocSA9PiAhcXVlcnlFcXVhbHMocSwgcXVlcnkpKSk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBObyBvdGhlciBxdWVyaWVzIGFyZSBtYXBwZWQgdG8gdGhlIHRhcmdldCwgY2xlYW4gdXAgdGhlIHF1ZXJ5IGFuZCB0aGUgdGFyZ2V0LlxyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsb2NhbCBxdWVyeSB0YXJnZXQgZmlyc3QgdG8gYWxsb3cgdXMgdG8gdmVyaWZ5XHJcbiAgICAgICAgLy8gd2hldGhlciBhbnkgb3RoZXIgY2xpZW50IGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhpcyB0YXJnZXQuXHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFJlbWFpbnNBY3RpdmUgPSBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRSZW1haW5zQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXHJcbiAgICAgICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5jbGVhclF1ZXJ5U3RhdGUocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRVbmxpc3RlblRvUmVtb3RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXHJcbiAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKiogVW5saXN0ZW5zIHRvIHRoZSByZW1vdGUgc3RvcmUgd2hpbGUgc3RpbGwgbGlzdGVuaW5nIHRvIHRoZSBjYWNoZS4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcclxuICAgIGNvbnN0IHF1ZXJpZXMgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmIHF1ZXJpZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBVbnJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzXHJcbiAgICAgICAgLy8gd2F0Y2ggdGFyZ2V0LlxyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWF0ZXMgdGhlIHdyaXRlIG9mIGxvY2FsIG11dGF0aW9uIGJhdGNoIHdoaWNoIGludm9sdmVzIGFkZGluZyB0aGVcclxuICogd3JpdGVzIHRvIHRoZSBtdXRhdGlvbiBxdWV1ZSwgbm90aWZ5aW5nIHRoZSByZW1vdGUgc3RvcmUgYWJvdXQgbmV3XHJcbiAqIG11dGF0aW9ucyBhbmQgcmFpc2luZyBldmVudHMgZm9yIGFueSBjaGFuZ2VzIHRoaXMgd3JpdGUgY2F1c2VkLlxyXG4gKlxyXG4gKiBUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGNhbGwgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgYWJvdmUgc3RlcHNcclxuICogaGF2ZSBjb21wbGV0ZWQsICpub3QqIHdoZW4gdGhlIHdyaXRlIHdhcyBhY2tlZCBieSB0aGUgYmFja2VuZC4gVGhlXHJcbiAqIHVzZXJDYWxsYmFjayBpcyByZXNvbHZlZCBvbmNlIHRoZSB3cml0ZSB3YXMgYWNrZWQvcmVqZWN0ZWQgYnkgdGhlXHJcbiAqIGJhY2tlbmQgKG9yIGZhaWxlZCBsb2NhbGx5IGZvciBhbnkgb3RoZXIgcmVhc29uKS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVXcml0ZShzeW5jRW5naW5lLCBiYXRjaCwgdXNlckNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyhzeW5jRW5naW5lKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZVdyaXRlTG9jYWxseShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkUGVuZGluZ011dGF0aW9uKHJlc3VsdC5iYXRjaElkKTtcclxuICAgICAgICBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYmF0Y2hJZCwgdXNlckNhbGxiYWNrKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmNoYW5nZXMpO1xyXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcGVyc2lzdCB0aGUgbXV0YXRpb24sIHdlIHJlamVjdCB0aGUgdXNlciBjYWxsYmFjayBhbmRcclxuICAgICAgICAvLyBkb24ndCBzZW5kIHRoZSBtdXRhdGlvbi4gVGhlIHVzZXIgY2FuIHRoZW4gcmV0cnkgdGhlIHdyaXRlLlxyXG4gICAgICAgIGNvbnN0IGVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIHBlcnNpc3Qgd3JpdGVgKTtcclxuICAgICAgICB1c2VyQ2FsbGJhY2sucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyBvbmUgcmVtb3RlIGV2ZW50IHRvIHRoZSBzeW5jIGVuZ2luZSwgbm90aWZ5aW5nIGFueSB2aWV3cyBvZiB0aGVcclxuICogY2hhbmdlcywgYW5kIHJlbGVhc2luZyBhbnkgcGVuZGluZyBtdXRhdGlvbiBiYXRjaGVzIHRoYXQgd291bGQgYmVjb21lXHJcbiAqIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgc25hcHNob3QgdmVyc2lvbiB0aGUgcmVtb3RlIGV2ZW50IGNvbnRhaW5zLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQoc3luY0VuZ2luZSwgcmVtb3RlRXZlbnQpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUFwcGx5UmVtb3RlRXZlbnRUb0xvY2FsQ2FjaGUoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcmVtb3RlRXZlbnQpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBgcmVjZWl2ZWREb2N1bWVudGAgYXMgYXBwcm9wcmlhdGUgZm9yIGFueSBsaW1ibyB0YXJnZXRzLlxyXG4gICAgICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW1ib1Jlc29sdXRpb24gPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgaWYgKGxpbWJvUmVzb2x1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGxpbWJvIHJlc29sdXRpb24gbG9va3VwLCBpdCdzIGZvciBhIHNpbmdsZSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGl0IGNvdWxkIGJlIGFkZGVkLCBtb2RpZmllZCwgb3IgcmVtb3ZlZCwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSArXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUgPD1cclxuICAgICAgICAgICAgICAgICAgICAxKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHByb2JhYmx5IGp1c3QgYSBDVVJSRU5UIHRhcmdldENoYW5nZSBvciBzaW1pbGFyLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYW4gT25saW5lU3RhdGUgY2hhbmdlIHRvIHRoZSBzeW5jIGVuZ2luZSBhbmQgbm90aWZpZXMgYW55IHZpZXdzIG9mXHJcbiAqIHRoZSBjaGFuZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShzeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgc291cmNlKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIC8vIElmIHdlIGFyZSB0aGUgc2Vjb25kYXJ5IGNsaWVudCwgd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlIHJlbW90ZSBzdG9yZSdzXHJcbiAgICAvLyBvbmxpbmUgc3RhdGUgKHRoZSBsb2NhbCBjbGllbnQgbWF5IGdvIG9mZmxpbmUsIGV2ZW4gdGhvdWdoIHRoZSBwcmltYXJ5XHJcbiAgICAvLyB0YWIgcmVtYWlucyBvbmxpbmUpIGFuZCBvbmx5IGFwcGx5IHRoZSBwcmltYXJ5IHRhYidzIG9ubGluZSBzdGF0ZSBmcm9tXHJcbiAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cclxuICAgIGlmICgoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXHJcbiAgICAgICAgc291cmNlID09PSAwIC8qIE9ubGluZVN0YXRlU291cmNlLlJlbW90ZVN0b3JlICovKSB8fFxyXG4gICAgICAgICghc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXHJcbiAgICAgICAgICAgIHNvdXJjZSA9PT0gMSAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5TaGFyZWRDbGllbnRTdGF0ZSAqLykpIHtcclxuICAgICAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgocXVlcnksIHF1ZXJ5VmlldykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gcXVlcnlWaWV3LnZpZXcuYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpO1xyXG4gICAgICAgIGlmIChuZXdWaWV3U25hcHNob3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlamVjdHMgdGhlIGxpc3RlbiBmb3IgdGhlIGdpdmVuIHRhcmdldElELiBUaGlzIGNhbiBiZSB0cmlnZ2VyZWQgYnkgdGhlXHJcbiAqIGJhY2tlbmQgZm9yIGFueSBhY3RpdmUgdGFyZ2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3luY0VuZ2luZSAtIFRoZSBzeW5jIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cclxuICogQHBhcmFtIHRhcmdldElkIC0gVGhlIHRhcmdldElEIGNvcnJlc3BvbmRzIHRvIG9uZSBwcmV2aW91c2x5IGluaXRpYXRlZCBieSB0aGVcclxuICogdXNlciBhcyBwYXJ0IG9mIFRhcmdldERhdGEgcGFzc2VkIHRvIGxpc3RlbigpIG9uIFJlbW90ZVN0b3JlLlxyXG4gKiBAcGFyYW0gZXJyIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY29uZGl0aW9uIHRoYXQgaGFzIGZvcmNlZCB0aGUgcmVqZWN0aW9uLlxyXG4gKiBOZWFybHkgYWx3YXlzIHRoaXMgd2lsbCBiZSBhbiBpbmRpY2F0aW9uIHRoYXQgdGhlIHVzZXIgaXMgbm8gbG9uZ2VyXHJcbiAqIGF1dGhvcml6ZWQgdG8gc2VlIHRoZSBkYXRhIG1hdGNoaW5nIHRoZSB0YXJnZXQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVqZWN0TGlzdGVuKHN5bmNFbmdpbmUsIHRhcmdldElkLCBlcnIpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsICdyZWplY3RlZCcsIGVycik7XHJcbiAgICBjb25zdCBsaW1ib1Jlc29sdXRpb24gPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgIGNvbnN0IGxpbWJvS2V5ID0gbGltYm9SZXNvbHV0aW9uICYmIGxpbWJvUmVzb2x1dGlvbi5rZXk7XHJcbiAgICBpZiAobGltYm9LZXkpIHtcclxuICAgICAgICAvLyBUT0RPKGtsaW10KTogV2UgcmVhbGx5IG9ubHkgc2hvdWxkIGRvIHRoZSBmb2xsb3dpbmcgb24gcGVybWlzc2lvblxyXG4gICAgICAgIC8vIGRlbmllZCBlcnJvcnMsIGJ1dCB3ZSBkb24ndCBoYXZlIHRoZSBjYXVzZSBjb2RlIGhlcmUuXHJcbiAgICAgICAgLy8gSXQncyBhIGxpbWJvIGRvYy4gQ3JlYXRlIGEgc3ludGhldGljIGV2ZW50IHNheWluZyBpdCB3YXMgZGVsZXRlZC5cclxuICAgICAgICAvLyBUaGlzIGlzIGtpbmQgb2YgYSBoYWNrLiBJZGVhbGx5LCB3ZSB3b3VsZCBoYXZlIGEgbWV0aG9kIGluIHRoZSBsb2NhbFxyXG4gICAgICAgIC8vIHN0b3JlIHRvIHB1cmdlIGEgZG9jdW1lbnQuIEhvd2V2ZXIsIGl0IHdvdWxkIGJlIHRyaWNreSB0byBrZWVwIGFsbCBvZlxyXG4gICAgICAgIC8vIHRoZSBsb2NhbCBzdG9yZSdzIGludmFyaWFudHMgd2l0aCBhbm90aGVyIG1ldGhvZC5cclxuICAgICAgICBsZXQgZG9jdW1lbnRVcGRhdGVzID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICAvLyBUT0RPKGIvMjE3MTg5MjE2KTogVGhpcyBsaW1ibyBkb2N1bWVudCBzaG91bGQgaWRlYWxseSBoYXZlIGEgcmVhZCB0aW1lLFxyXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgcGlja2VkIHVwIGJ5IGFueSByZWFkLXRpbWUgYmFzZWQgc2NhbnMuIFRoZSBiYWNrZW5kLFxyXG4gICAgICAgIC8vIGhvd2V2ZXIsIGRvZXMgbm90IHNlbmQgYSByZWFkIHRpbWUgZm9yIHRhcmdldCByZW1vdmFscy5cclxuICAgICAgICBkb2N1bWVudFVwZGF0ZXMgPSBkb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGxpbWJvS2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChsaW1ib0tleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKSk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvS2V5KTtcclxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBSZW1vdGVFdmVudChTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgICAgIC8qIHRhcmdldENoYW5nZXM9ICovIG5ldyBNYXAoKSwgXHJcbiAgICAgICAgLyogdGFyZ2V0TWlzbWF0Y2hlcz0gKi8gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgZG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lQXBwbHlSZW1vdGVFdmVudChzeW5jRW5naW5lSW1wbCwgZXZlbnQpO1xyXG4gICAgICAgIC8vIFNpbmNlIHRoaXMgcXVlcnkgZmFpbGVkLCB3ZSB3b24ndCB3YW50IHRvIG1hbnVhbGx5IHVubGlzdGVuIHRvIGl0LlxyXG4gICAgICAgIC8vIFdlIG9ubHkgcmVtb3ZlIGl0IGZyb20gYm9va2tlZXBpbmcgYWZ0ZXIgd2Ugc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgdGhlXHJcbiAgICAgICAgLy8gUmVtb3RlRXZlbnQuIElmIGBhcHBseVJlbW90ZUV2ZW50KClgIHRocm93cywgd2Ugd2FudCB0byByZS1saXN0ZW4gdG9cclxuICAgICAgICAvLyB0aGlzIHF1ZXJ5IHdoZW4gdGhlIFJlbW90ZVN0b3JlIHJlc3RhcnRzIHRoZSBXYXRjaCBzdHJlYW0sIHdoaWNoIHNob3VsZFxyXG4gICAgICAgIC8vIHJlLXRyaWdnZXIgdGhlIHRhcmdldCBmYWlsdXJlLlxyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID1cclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkucmVtb3ZlKGxpbWJvS2V5KTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKHRhcmdldElkKTtcclxuICAgICAgICBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcclxuICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyBmYWxzZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycikpXHJcbiAgICAgICAgICAgIC5jYXRjaChpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVN1Y2Nlc3NmdWxXcml0ZShzeW5jRW5naW5lLCBtdXRhdGlvbkJhdGNoUmVzdWx0KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IGJhdGNoSWQgPSBtdXRhdGlvbkJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlQWNrbm93bGVkZ2VCYXRjaChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBtdXRhdGlvbkJhdGNoUmVzdWx0KTtcclxuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxyXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0XHJcbiAgICAgICAgLy8gdXApLCBzbyB3ZSByYWlzZSB1c2VyIGNhbGxiYWNrcyBmaXJzdCBzbyB0aGF0IHRoZXkgY29uc2lzdGVudGx5IGhhcHBlblxyXG4gICAgICAgIC8vIGJlZm9yZSBsaXN0ZW4gZXZlbnRzLlxyXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIC8qZXJyb3I9Ki8gbnVsbCk7XHJcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ2Fja25vd2xlZGdlZCcpO1xyXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVJlamVjdEZhaWxlZFdyaXRlKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGVycm9yKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVSZWplY3RCYXRjaChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaElkKTtcclxuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxyXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0IHVwKSxcclxuICAgICAgICAvLyBzbyB3ZSByYWlzZSB1c2VyIGNhbGxiYWNrcyBmaXJzdCBzbyB0aGF0IHRoZXkgY29uc2lzdGVudGx5IGhhcHBlbiBiZWZvcmVcclxuICAgICAgICAvLyBsaXN0ZW4gZXZlbnRzLlxyXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIGVycm9yKTtcclxuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCAncmVqZWN0ZWQnLCBlcnJvcik7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgdXNlciBjYWxsYmFjayB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHBlbmRpbmcgbXV0YXRpb25zIGF0IHRoZSBtb21lbnQgb2YgY2FsbGluZ1xyXG4gKiBhcmUgYWNrbm93bGVkZ2VkIC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVSZWdpc3RlclBlbmRpbmdXcml0ZXNDYWxsYmFjayhzeW5jRW5naW5lLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBpZiAoIWNhblVzZU5ldHdvcmsoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnVGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQuIFRoZSB0YXNrIHJldHVybmVkIGJ5ICcgK1xyXG4gICAgICAgICAgICBcIidhd2FpdFBlbmRpbmdXcml0ZXMoKScgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhlIG5ldHdvcmsgaXMgZW5hYmxlZC5cIik7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RCYXRjaElkID0gYXdhaXQgbG9jYWxTdG9yZUdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSk7XHJcbiAgICAgICAgaWYgKGhpZ2hlc3RCYXRjaElkID09PSBCQVRDSElEX1VOS05PV04pIHtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheSBpZiB0aGVyZSBpcyBubyBwZW5kaW5nIHdyaXRlcyBhdCB0aGUgbW9tZW50LlxyXG4gICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5nZXQoaGlnaGVzdEJhdGNoSWQpIHx8IFtdO1xyXG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLnNldChoaWdoZXN0QmF0Y2hJZCwgY2FsbGJhY2tzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsICdJbml0aWFsaXphdGlvbiBvZiB3YWl0Rm9yUGVuZGluZ1dyaXRlcygpIG9wZXJhdGlvbiBmYWlsZWQnKTtcclxuICAgICAgICBjYWxsYmFjay5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUcmlnZ2VycyB0aGUgY2FsbGJhY2tzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoaXMgYmF0Y2ggaWQgdG8gZ2V0IGFja25vd2xlZGdlZCBieSBzZXJ2ZXIsXHJcbiAqIGlmIHRoZXJlIGFyZSBhbnkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCkge1xyXG4gICAgKHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZ2V0KGJhdGNoSWQpIHx8IFtdKS5mb3JFYWNoKGNhbGxiYWNrID0+IHtcclxuICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZGVsZXRlKGJhdGNoSWQpO1xyXG59XHJcbi8qKiBSZWplY3QgYWxsIG91dHN0YW5kaW5nIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyB0byBjb21wbGV0ZS4gKi9cclxuZnVuY3Rpb24gcmVqZWN0T3V0c3RhbmRpbmdQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFja3MgPT4ge1xyXG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2sucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkNBTkNFTExFRCwgZXJyb3JNZXNzYWdlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuY2xlYXIoKTtcclxufVxyXG5mdW5jdGlvbiBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBjYWxsYmFjaykge1xyXG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcclxuICAgIGlmICghbmV3Q2FsbGJhY2tzKSB7XHJcbiAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIG5ld0NhbGxiYWNrcyA9IG5ld0NhbGxiYWNrcy5pbnNlcnQoYmF0Y2hJZCwgY2FsbGJhY2spO1xyXG4gICAgc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldID1cclxuICAgICAgICBuZXdDYWxsYmFja3M7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmVzIG9yIHJlamVjdHMgdGhlIHVzZXIgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiBiYXRjaCBhbmQgdGhlbiBkaXNjYXJkc1xyXG4gKiBpdC5cclxuICovXHJcbmZ1bmN0aW9uIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZSwgYmF0Y2hJZCwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcclxuICAgIC8vIE5PVEU6IE11dGF0aW9ucyByZXN0b3JlZCBmcm9tIHBlcnNpc3RlbmNlIHdvbid0IGhhdmUgY2FsbGJhY2tzLCBzbyBpdCdzXHJcbiAgICAvLyBva2F5IGZvciB0aGVyZSB0byBiZSBubyBjYWxsYmFjayBmb3IgdGhpcyBJRC5cclxuICAgIGlmIChuZXdDYWxsYmFja3MpIHtcclxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IG5ld0NhbGxiYWNrcy5nZXQoYmF0Y2hJZCk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBuZXdDYWxsYmFja3MucmVtb3ZlKGJhdGNoSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV0gPVxyXG4gICAgICAgICAgICBuZXdDYWxsYmFja3M7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycm9yID0gbnVsbCkge1xyXG4gICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hFcnJvcihxdWVyeSwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIGNvbnN0IGxpbWJvS2V5cyA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZVJlZmVyZW5jZXNGb3JJZCh0YXJnZXRJZCk7XHJcbiAgICAgICAgbGltYm9LZXlzLmZvckVhY2gobGltYm9LZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0tleSk7XHJcbiAgICAgICAgICAgIGlmICghaXNSZWZlcmVuY2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSByZW1vdmVkIHRoZSBsYXN0IHJlZmVyZW5jZSBmb3IgdGhpcyBrZXlcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0tleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwga2V5KSB7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcclxuICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgdGFyZ2V0IGFscmVhZHkgZ290IHJlbW92ZWQgYmVjYXVzZSB0aGUgcXVlcnkgZmFpbGVkLiBJbiB0aGF0IGNhc2UsXHJcbiAgICAvLyB0aGUga2V5IHdvbid0IGV4aXN0IGluIGBsaW1ib1RhcmdldHNCeUtleWAuIE9ubHkgZG8gdGhlIGNsZWFudXAgaWYgd2Ugc3RpbGwgaGF2ZSB0aGUgdGFyZ2V0LlxyXG4gICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpO1xyXG4gICAgaWYgKGxpbWJvVGFyZ2V0SWQgPT09IG51bGwpIHtcclxuICAgICAgICAvLyBUaGlzIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkLCBiZWNhdXNlIHRoZSBxdWVyeSBmYWlsZWQuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgbGltYm9UYXJnZXRJZCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkucmVtb3ZlKGtleSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKGxpbWJvVGFyZ2V0SWQpO1xyXG4gICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGxpbWJvQ2hhbmdlcykge1xyXG4gICAgZm9yIChjb25zdCBsaW1ib0NoYW5nZSBvZiBsaW1ib0NoYW5nZXMpIHtcclxuICAgICAgICBpZiAobGltYm9DaGFuZ2UgaW5zdGFuY2VvZiBBZGRlZExpbWJvRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMuYWRkUmVmZXJlbmNlKGxpbWJvQ2hhbmdlLmtleSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgUmVtb3ZlZExpbWJvRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnRG9jdW1lbnQgbm8gbG9uZ2VyIGluIGxpbWJvOiAnICsgbGltYm9DaGFuZ2Uua2V5KTtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMucmVtb3ZlUmVmZXJlbmNlKGxpbWJvQ2hhbmdlLmtleSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0NoYW5nZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgcmVtb3ZlZCB0aGUgbGFzdCByZWZlcmVuY2UgZm9yIHRoaXMga2V5XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2Uua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSkge1xyXG4gICAgY29uc3Qga2V5ID0gbGltYm9DaGFuZ2Uua2V5O1xyXG4gICAgY29uc3Qga2V5U3RyaW5nID0ga2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICBpZiAoIXN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpICYmXHJcbiAgICAgICAgIXN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5oYXMoa2V5U3RyaW5nKSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ05ldyBkb2N1bWVudCBpbiBsaW1ibzogJyArIGtleSk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmFkZChrZXlTdHJpbmcpO1xyXG4gICAgICAgIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdGFydHMgbGlzdGVucyBmb3IgZG9jdW1lbnRzIGluIGxpbWJvIHRoYXQgYXJlIGVucXVldWVkIGZvciByZXNvbHV0aW9uLFxyXG4gKiBzdWJqZWN0IHRvIGEgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCByZXNvbHV0aW9ucy5cclxuICpcclxuICogV2l0aG91dCBib3VuZGluZyB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMsIHRoZSBzZXJ2ZXIgY2FuIGZhaWxcclxuICogd2l0aCBcInJlc291cmNlIGV4aGF1c3RlZFwiIGVycm9ycyB3aGljaCBjYW4gbGVhZCB0byBwYXRob2xvZ2ljYWwgY2xpZW50XHJcbiAqIGJlaGF2aW9yIGFzIHNlZW4gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvMjY4My5cclxuICovXHJcbmZ1bmN0aW9uIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpIHtcclxuICAgIHdoaWxlIChzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuc2l6ZSA+IDAgJiZcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5zaXplIDxcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpIHtcclxuICAgICAgICBjb25zdCBrZXlTdHJpbmcgPSBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnNcclxuICAgICAgICAgICAgLnZhbHVlcygpXHJcbiAgICAgICAgICAgIC5uZXh0KCkudmFsdWU7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmRlbGV0ZShrZXlTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhrZXlTdHJpbmcpKTtcclxuICAgICAgICBjb25zdCBsaW1ib1RhcmdldElkID0gc3luY0VuZ2luZUltcGwubGltYm9UYXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LnNldChsaW1ib1RhcmdldElkLCBuZXcgTGltYm9SZXNvbHV0aW9uKGtleSkpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID1cclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkuaW5zZXJ0KGtleSwgbGltYm9UYXJnZXRJZCk7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIG5ldyBUYXJnZXREYXRhKHF1ZXJ5VG9UYXJnZXQobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSksIGxpbWJvVGFyZ2V0SWQsIFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZSwgY2hhbmdlcywgcmVtb3RlRXZlbnQpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgbmV3U25hcHMgPSBbXTtcclxuICAgIGNvbnN0IGRvY0NoYW5nZXNJbkFsbFZpZXdzID0gW107XHJcbiAgICBjb25zdCBxdWVyaWVzUHJvY2Vzc2VkID0gW107XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IHNpbmNlIGBvbldhdGNoQ2hhbmdlKClgIG1pZ2h0IG5vdCBoYXZlIGJlZW4gYXNzaWduZWQgeWV0LlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmZvckVhY2goKF8sIHF1ZXJ5VmlldykgPT4ge1xyXG4gICAgICAgIHF1ZXJpZXNQcm9jZXNzZWQucHVzaChzeW5jRW5naW5lSW1wbFxyXG4gICAgICAgICAgICAuYXBwbHlEb2NDaGFuZ2VzKHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpXHJcbiAgICAgICAgICAgIC50aGVuKHZpZXdTbmFwc2hvdCA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNoYW5nZXMsIG9yIHdlIGFyZSBoYW5kbGluZyBhIGdsb2JhbCBzbmFwc2hvdCwgbm90aWZ5XHJcbiAgICAgICAgICAgIC8vIHNlY29uZGFyeSBjbGllbnRzIHRvIHVwZGF0ZSBxdWVyeSBzdGF0ZS5cclxuICAgICAgICAgICAgaWYgKHZpZXdTbmFwc2hvdCB8fCByZW1vdGVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFF1ZXJ5IHN0YXRlIGlzIHNldCB0byBgY3VycmVudGAgaWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHZpZXcgY2hhbmdlIGFuZCBpdCBpcyB1cC10by1kYXRlLCBvcixcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIFRoZXJlIGlzIGEgZ2xvYmFsIHNuYXBzaG90LCB0aGUgVGFyZ2V0IGlzIGN1cnJlbnQsIGFuZCBubyBjaGFuZ2VzIHRvIGJlIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50ID0gdmlld1NuYXBzaG90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gIXZpZXdTbmFwc2hvdC5mcm9tQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoX2EgPSByZW1vdGVFdmVudCA9PT0gbnVsbCB8fCByZW1vdGVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlUXVlcnlTdGF0ZShxdWVyeVZpZXcudGFyZ2V0SWQsIGlzQ3VycmVudCA/ICdjdXJyZW50JyA6ICdub3QtY3VycmVudCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2aWV3cyBpZiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMuXHJcbiAgICAgICAgICAgIGlmICghIXZpZXdTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICAgICAgbmV3U25hcHMucHVzaCh2aWV3U25hcHNob3QpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IExvY2FsVmlld0NoYW5nZXMuZnJvbVNuYXBzaG90KHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld1NuYXBzaG90KTtcclxuICAgICAgICAgICAgICAgIGRvY0NoYW5nZXNJbkFsbFZpZXdzLnB1c2goZG9jQ2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9KTtcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKHF1ZXJpZXNQcm9jZXNzZWQpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UobmV3U25hcHMpO1xyXG4gICAgYXdhaXQgbG9jYWxTdG9yZU5vdGlmeUxvY2FsVmlld0NoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgZG9jQ2hhbmdlc0luQWxsVmlld3MpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGFwcGx5RG9jQ2hhbmdlcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCkge1xyXG4gICAgbGV0IHZpZXdEb2NDaGFuZ2VzID0gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZURvY0NoYW5nZXMoY2hhbmdlcyk7XHJcbiAgICBpZiAodmlld0RvY0NoYW5nZXMubmVlZHNSZWZpbGwpIHtcclxuICAgICAgICAvLyBUaGUgcXVlcnkgaGFzIGEgbGltaXQgYW5kIHNvbWUgZG9jcyB3ZXJlIHJlbW92ZWQsIHNvIHdlIG5lZWRcclxuICAgICAgICAvLyB0byByZS1ydW4gdGhlIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHN0b3JlIHRvIG1ha2Ugc3VyZSB3ZVxyXG4gICAgICAgIC8vIGRpZG4ndCBsb3NlIGFueSBnb29kIGRvY3MgdGhhdCBoYWQgYmVlbiBwYXN0IHRoZSBsaW1pdC5cclxuICAgICAgICB2aWV3RG9jQ2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcclxuICAgICAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIGZhbHNlKS50aGVuKCh7IGRvY3VtZW50cyB9KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVZpZXcudmlldy5jb21wdXRlRG9jQ2hhbmdlcyhkb2N1bWVudHMsIHZpZXdEb2NDaGFuZ2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IHJlbW90ZUV2ZW50ICYmIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICBjb25zdCB0YXJnZXRJc1BlbmRpbmdSZXNldCA9IHJlbW90ZUV2ZW50ICYmIHJlbW90ZUV2ZW50LnRhcmdldE1pc21hdGNoZXMuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCkgIT0gbnVsbDtcclxuICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSBxdWVyeVZpZXcudmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxyXG4gICAgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50LCB0YXJnZXRDaGFuZ2UsIHRhcmdldElzUGVuZGluZ1Jlc2V0KTtcclxuICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xyXG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uoc3luY0VuZ2luZSwgdXNlcikge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCB1c2VyQ2hhbmdlZCA9ICFzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci5pc0VxdWFsKHVzZXIpO1xyXG4gICAgaWYgKHVzZXJDaGFuZ2VkKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnVXNlciBjaGFuZ2UuIE5ldyB1c2VyOicsIHVzZXIudG9LZXkoKSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2Uoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdXNlcik7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIgPSB1c2VyO1xyXG4gICAgICAgIC8vIEZhaWxzIHRhc2tzIHdhaXRpbmcgZm9yIHBlbmRpbmcgd3JpdGVzIHJlcXVlc3RlZCBieSBwcmV2aW91cyB1c2VyLlxyXG4gICAgICAgIHJlamVjdE91dHN0YW5kaW5nUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgXCInd2FpdEZvclBlbmRpbmdXcml0ZXMnIHByb21pc2UgaXMgcmVqZWN0ZWQgZHVlIHRvIGEgdXNlciBjaGFuZ2UuXCIpO1xyXG4gICAgICAgIC8vIFRPRE8oYi8xMTQyMjY0MTcpOiBDb25zaWRlciBjYWxsaW5nIHRoaXMgb25seSBpbiB0aGUgcHJpbWFyeSB0YWIuXHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaGFuZGxlVXNlckNoYW5nZSh1c2VyLCByZXN1bHQucmVtb3ZlZEJhdGNoSWRzLCByZXN1bHQuYWRkZWRCYXRjaElkcyk7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIHJlc3VsdC5hZmZlY3RlZERvY3VtZW50cyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3luY0VuZ2luZUdldFJlbW90ZUtleXNGb3JUYXJnZXQoc3luY0VuZ2luZSwgdGFyZ2V0SWQpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICBpZiAobGltYm9SZXNvbHV0aW9uICYmIGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvUmVzb2x1dGlvbi5rZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGtleVNldCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICghcXVlcmllcykge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5U2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcclxuICAgICAgICAgICAga2V5U2V0ID0ga2V5U2V0LnVuaW9uV2l0aChxdWVyeVZpZXcudmlldy5zeW5jZWREb2N1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5U2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWNvbmNpbGUgdGhlIGxpc3Qgb2Ygc3luY2VkIGRvY3VtZW50cyBpbiBhbiBleGlzdGluZyB2aWV3IHdpdGggdGhvc2VcclxuICogZnJvbSBwZXJzaXN0ZW5jZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNocm9uaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lLCBxdWVyeVZpZXcpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy5xdWVyeSwgXHJcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xyXG4gICAgY29uc3Qgdmlld1NuYXBzaG90ID0gcXVlcnlWaWV3LnZpZXcuc3luY2hyb25pemVXaXRoUGVyc2lzdGVkU3RhdGUocXVlcnlSZXN1bHQpO1xyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld1NuYXBzaG90LmxpbWJvQ2hhbmdlcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgbmV3bHkgY2hhbmdlZCBkb2N1bWVudHMgZnJvbSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgYW5kIHJhaXNlc1xyXG4gKiBzbmFwc2hvdHMgaWYgbmVlZGVkLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoc3luY0VuZ2luZSwgY29sbGVjdGlvbkdyb3VwKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGNvbGxlY3Rpb25Hcm91cCkudGhlbihjaGFuZ2VzID0+IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKSk7XHJcbn1cclxuLyoqIEFwcGxpZXMgYSBtdXRhdGlvbiBzdGF0ZSB0byBhbiBleGlzdGluZyBiYXRjaC4gICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseUJhdGNoU3RhdGUoc3luY0VuZ2luZSwgYmF0Y2hJZCwgYmF0Y2hTdGF0ZSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgbG9jYWxTdG9yZUxvb2t1cE11dGF0aW9uRG9jdW1lbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGJhdGNoSWQpO1xyXG4gICAgaWYgKGRvY3VtZW50cyA9PT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEEgdGhyb3R0bGVkIHRhYiBtYXkgbm90IGhhdmUgc2VlbiB0aGUgbXV0YXRpb24gYmVmb3JlIGl0IHdhcyBjb21wbGV0ZWRcclxuICAgICAgICAvLyBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZSwgaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBoYXZlIGNhY2hlZFxyXG4gICAgICAgIC8vIHRoZSBhZmZlY3RlZCBkb2N1bWVudHMuIEluIHRoaXMgY2FzZSB3ZSBjYW4gc2FmZWx5IGlnbm9yZSB0aGUgdXBkYXRlXHJcbiAgICAgICAgLy8gc2luY2UgdGhhdCBtZWFucyB3ZSBkaWRuJ3QgYXBwbHkgdGhlIG11dGF0aW9uIGxvY2FsbHkgYXQgYWxsIChpZiB3ZVxyXG4gICAgICAgIC8vIGhhZCwgd2Ugd291bGQgaGF2ZSBjYWNoZWQgdGhlIGFmZmVjdGVkIGRvY3VtZW50cyksIGFuZCBzbyB3ZSB3aWxsIGp1c3RcclxuICAgICAgICAvLyBzZWUgYW55IHJlc3VsdGluZyBkb2N1bWVudCBjaGFuZ2VzIHZpYSBub3JtYWwgcmVtb3RlIGRvY3VtZW50IHVwZGF0ZXNcclxuICAgICAgICAvLyBhcyBhcHBsaWNhYmxlLlxyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0Nhbm5vdCBhcHBseSBtdXRhdGlvbiBiYXRjaCB3aXRoIGlkOiAnICsgYmF0Y2hJZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGJhdGNoU3RhdGUgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgIC8vIElmIHdlIGFyZSB0aGUgcHJpbWFyeSBjbGllbnQsIHdlIG5lZWQgdG8gc2VuZCB0aGlzIHdyaXRlIHRvIHRoZVxyXG4gICAgICAgIC8vIGJhY2tlbmQuIFNlY29uZGFyeSBjbGllbnRzIHdpbGwgaWdub3JlIHRoZXNlIHdyaXRlcyBzaW5jZSB0aGVpciByZW1vdGVcclxuICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGRpc2FibGVkLlxyXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGJhdGNoU3RhdGUgPT09ICdhY2tub3dsZWRnZWQnIHx8IGJhdGNoU3RhdGUgPT09ICdyZWplY3RlZCcpIHtcclxuICAgICAgICAvLyBOT1RFOiBCb3RoIHRoZXNlIG1ldGhvZHMgYXJlIG5vLW9wcyBmb3IgYmF0Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgZnJvbVxyXG4gICAgICAgIC8vIG90aGVyIGNsaWVudHMuXHJcbiAgICAgICAgcHJvY2Vzc1VzZXJDYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCwgZXJyb3IgPyBlcnJvciA6IG51bGwpO1xyXG4gICAgICAgIHRyaWdnZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkKTtcclxuICAgICAgICBsb2NhbFN0b3JlUmVtb3ZlQ2FjaGVkTXV0YXRpb25CYXRjaE1ldGFkYXRhKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGJhdGNoSWQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGRvY3VtZW50cyk7XHJcbn1cclxuLyoqIEFwcGxpZXMgYSBxdWVyeSB0YXJnZXQgY2hhbmdlIGZyb20gYSBkaWZmZXJlbnQgdGFiLiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZSwgaXNQcmltYXJ5KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCk7XHJcbiAgICBpZiAoaXNQcmltYXJ5ID09PSB0cnVlICYmIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgIT09IHRydWUpIHtcclxuICAgICAgICAvLyBTZWNvbmRhcnkgdGFicyBvbmx5IG1haW50YWluIFZpZXdzIGZvciB0aGVpciBsb2NhbCBsaXN0ZW5lcnMgYW5kIHRoZVxyXG4gICAgICAgIC8vIFZpZXdzIGludGVybmFsIHN0YXRlIG1heSBub3QgYmUgMTAwJSBwb3B1bGF0ZWQgKGluIHBhcnRpY3VsYXJcclxuICAgICAgICAvLyBzZWNvbmRhcnkgdGFicyBkb24ndCB0cmFjayBzeW5jZWREb2N1bWVudHMsIHRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoZVxyXG4gICAgICAgIC8vIHNlcnZlciBjb25zaWRlcnMgdG8gYmUgaW4gdGhlIHRhcmdldCkuIFNvIHdoZW4gYSBzZWNvbmRhcnkgYmVjb21lc1xyXG4gICAgICAgIC8vIHByaW1hcnksIHdlIG5lZWQgdG8gbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgdmlld3MgZm9yIGFsbCB0YXJnZXRzXHJcbiAgICAgICAgLy8gbWF0Y2ggdGhlIHN0YXRlIG9uIGRpc2suXHJcbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpO1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVF1ZXJpZXMgPSBhd2FpdCBzeW5jaHJvbml6ZVF1ZXJ5Vmlld3NBbmRSYWlzZVNuYXBzaG90cyhzeW5jRW5naW5lSW1wbCwgYWN0aXZlVGFyZ2V0cy50b0FycmF5KCkpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgPSB0cnVlO1xyXG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRydWUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0RGF0YSBvZiBhY3RpdmVRdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1ByaW1hcnkgPT09IGZhbHNlICYmIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIGxldCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcCA9IHAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhd2FpdCBwO1xyXG4gICAgICAgIGF3YWl0IHN5bmNocm9uaXplUXVlcnlWaWV3c0FuZFJhaXNlU25hcHNob3RzKHN5bmNFbmdpbmVJbXBsLCBhY3RpdmVUYXJnZXRzKTtcclxuICAgICAgICByZXNldExpbWJvRG9jdW1lbnRzKHN5bmNFbmdpbmVJbXBsKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgYXdhaXQgcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgZmFsc2UpO1xyXG4gICAgfVxyXG59XHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmZ1bmN0aW9uIHJlc2V0TGltYm9Eb2N1bWVudHMoc3luY0VuZ2luZSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XHJcbiAgICB9KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZUFsbFJlZmVyZW5jZXMoKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldCA9IG5ldyBNYXAoKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxufVxyXG4vKipcclxuICogUmVjb25jaWxlIHRoZSBxdWVyeSB2aWV3cyBvZiB0aGUgcHJvdmlkZWQgcXVlcnkgdGFyZ2V0cyB3aXRoIHRoZSBzdGF0ZSBmcm9tXHJcbiAqIHBlcnNpc3RlbmNlLiBSYWlzZXMgc25hcHNob3RzIGZvciBhbnkgY2hhbmdlcyB0aGF0IGFmZmVjdCB0aGUgbG9jYWxcclxuICogY2xpZW50IGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIHN0YXRlIG9mIGFsbCB0YXJnZXQncyBxdWVyeSBkYXRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3luY0VuZ2luZSAtIFRoZSBzeW5jIGVuZ2luZSBpbXBsZW1lbnRhdGlvblxyXG4gKiBAcGFyYW0gdGFyZ2V0cyAtIHRoZSBsaXN0IG9mIHRhcmdldHMgd2l0aCB2aWV3cyB0aGF0IG5lZWQgdG8gYmUgcmVjb21wdXRlZFxyXG4gKiBAcGFyYW0gdHJhbnNpdGlvblRvUHJpbWFyeSAtIGB0cnVlYCBpZmYgdGhlIHRhYiB0cmFuc2l0aW9ucyBmcm9tIGEgc2Vjb25kYXJ5XHJcbiAqIHRhYiB0byBhIHByaW1hcnkgdGFiXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5hc3luYyBmdW5jdGlvbiBzeW5jaHJvbml6ZVF1ZXJ5Vmlld3NBbmRSYWlzZVNuYXBzaG90cyhzeW5jRW5naW5lLCB0YXJnZXRzLCB0cmFuc2l0aW9uVG9QcmltYXJ5KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IGFjdGl2ZVF1ZXJpZXMgPSBbXTtcclxuICAgIGNvbnN0IG5ld1ZpZXdTbmFwc2hvdHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgdGFyZ2V0cykge1xyXG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBpZiAocXVlcmllcyAmJiBxdWVyaWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IGhhdmUgYSBsb2NhbCBWaWV3LCB3ZSBmZXRjaCB0aGVpciBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgICAgIC8vIGZyb20gTG9jYWxTdG9yZSAoYXMgdGhlIHJlc3VtZSB0b2tlbiBhbmQgdGhlIHNuYXBzaG90IHZlcnNpb25cclxuICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBjaGFuZ2VkKSBhbmQgcmVjb25jaWxlIHRoZWlyIHZpZXdzIHdpdGggdGhlIHBlcnNpc3RlZFxyXG4gICAgICAgICAgICAvLyBzdGF0ZSAodGhlIGxpc3Qgb2Ygc3luY2VkRG9jdW1lbnRzIG1heSBoYXZlIGdvdHRlbiBvdXQgb2Ygc3luYykuXHJcbiAgICAgICAgICAgIHRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlUb1RhcmdldChxdWVyaWVzWzBdKSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSBhd2FpdCBzeW5jaHJvbml6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0NoYW5nZS5zbmFwc2hvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdTbmFwc2hvdHMucHVzaCh2aWV3Q2hhbmdlLnNuYXBzaG90KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9yIHF1ZXJpZXMgdGhhdCBuZXZlciBleGVjdXRlZCBvbiB0aGlzIGNsaWVudCwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgdGFyZ2V0IGluIExvY2FsU3RvcmUgYW5kIGluaXRpYWxpemUgYSBuZXcgVmlldy5cclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldElkLCBcclxuICAgICAgICAgICAgLypjdXJyZW50PSovIGZhbHNlLCB0YXJnZXREYXRhLnJlc3VtZVRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUXVlcmllcy5wdXNoKHRhcmdldERhdGEpO1xyXG4gICAgfVxyXG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UobmV3Vmlld1NuYXBzaG90cyk7XHJcbiAgICByZXR1cm4gYWN0aXZlUXVlcmllcztcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeWAgb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBgVGFyZ2V0YC4gVGhlcmUgaXMgbm8gd2F5IHRvXHJcbiAqIG9idGFpbiB0aGUgb3JpZ2luYWwgYFF1ZXJ5YCwgc28gd2Ugc3ludGhlc2l6ZSBhIGBRdWVyeWAgZnJvbSB0aGUgYFRhcmdldGBcclxuICogb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGUgc3ludGhlc2l6ZWQgcmVzdWx0IG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbCBgUXVlcnlgLCBidXRcclxuICogc2luY2UgdGhlIHN5bnRoZXNpemVkIGBRdWVyeWAgc2hvdWxkIHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIHRoZVxyXG4gKiBvcmlnaW5hbCBvbmUgKG9ubHkgdGhlIHByZXNlbnRhdGlvbiBvZiByZXN1bHRzIG1pZ2h0IGRpZmZlciksIHRoZSBwb3RlbnRpYWxcclxuICogZGlmZmVyZW5jZSB3aWxsIG5vdCBjYXVzZSBpc3N1ZXMuXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBzeW50aGVzaXplVGFyZ2V0VG9RdWVyeSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBuZXdRdWVyeSh0YXJnZXQucGF0aCwgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCwgdGFyZ2V0Lm9yZGVyQnksIHRhcmdldC5maWx0ZXJzLCB0YXJnZXQubGltaXQsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLywgdGFyZ2V0LnN0YXJ0QXQsIHRhcmdldC5lbmRBdCk7XHJcbn1cclxuLyoqIFJldHVybnMgdGhlIElEcyBvZiB0aGUgY2xpZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlKTtcclxufVxyXG4vKiogQXBwbGllcyBhIHF1ZXJ5IHRhcmdldCBjaGFuZ2UgZnJvbSBhIGRpZmZlcmVudCB0YWIuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVRhcmdldFN0YXRlKHN5bmNFbmdpbmUsIHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQpIHtcclxuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIGEgdGFyZ2V0IHN0YXRlIG5vdGlmaWNhdGlvbiB2aWEgV2ViU3RvcmFnZSwgd2UgYXJlXHJcbiAgICAgICAgLy8gZWl0aGVyIGFscmVhZHkgc2Vjb25kYXJ5IG9yIGFub3RoZXIgdGFiIGhhcyB0YWtlbiB0aGUgcHJpbWFyeSBsZWFzZS5cclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdJZ25vcmluZyB1bmV4cGVjdGVkIHF1ZXJ5IHN0YXRlIG5vdGlmaWNhdGlvbi4nKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBxdWVyeSA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbnQnOlxyXG4gICAgICAgICAgICBjYXNlICdub3QtY3VycmVudCc6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Q29sbGVjdGlvbkdyb3VwKHF1ZXJ5WzBdKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeW50aGVzaXplZFJlbW90ZUV2ZW50ID0gUmVtb3RlRXZlbnQuY3JlYXRlU3ludGhlc2l6ZWRSZW1vdGVFdmVudEZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIHN0YXRlID09PSAnY3VycmVudCcsIEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHN5bnRoZXNpemVkUmVtb3RlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXHJcbiAgICAgICAgICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogQWRkcyBvciByZW1vdmVzIFdhdGNoIHRhcmdldHMgZm9yIHF1ZXJpZXMgZnJvbSBkaWZmZXJlbnQgdGFicy4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZShzeW5jRW5naW5lLCBhZGRlZCwgcmVtb3ZlZCkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcclxuICAgIGlmICghc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgYWRkZWQpIHtcclxuICAgICAgICAvLyBBIHRhcmdldCBpcyBhbHJlYWR5IGxpc3RlbmluZyB0byByZW1vdGUgc3RvcmUgaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvXHJcbiAgICAgICAgLy8gc2hhcmVkQ2xpZW50U3RhdGUuXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0QWxyZWFkeUxpc3RlbmluZ1RvUmVtb3RlU3RvcmUgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSAmJlxyXG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBpZiAodGFyZ2V0QWxyZWFkeUxpc3RlbmluZ1RvUmVtb3RlU3RvcmUpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQWRkaW5nIGFuIGFscmVhZHkgYWN0aXZlIHRhcmdldCAnICsgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xyXG4gICAgICAgIGF3YWl0IGluaXRpYWxpemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBzeW50aGVzaXplVGFyZ2V0VG9RdWVyeSh0YXJnZXQpLCB0YXJnZXREYXRhLnRhcmdldElkLCBcclxuICAgICAgICAvKmN1cnJlbnQ9Ki8gZmFsc2UsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgcmVtb3ZlZCkge1xyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUgc2luY2UgdGhlIHRhcmdldCBtaWdodCBoYXZlIGJlZW5cclxuICAgICAgICAvLyByZW1vdmVkIGlmIGl0IGhhcyBiZWVuIHJlamVjdGVkIGJ5IHRoZSBiYWNrZW5kLlxyXG4gICAgICAgIGlmICghc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbGVhc2UgcXVlcmllcyB0aGF0IGFyZSBzdGlsbCBhY3RpdmUuXHJcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxyXG4gICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIGZhbHNlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcclxuICAgICAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVHZXRSZW1vdGVLZXlzRm9yVGFyZ2V0LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLnJlamVjdExpc3RlbiA9XHJcbiAgICAgICAgc3luY0VuZ2luZVJlamVjdExpc3Rlbi5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlID1cclxuICAgICAgICBldmVudE1hbmFnZXJPbldhdGNoQ2hhbmdlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoRXJyb3IgPVxyXG4gICAgICAgIGV2ZW50TWFuYWdlck9uV2F0Y2hFcnJvci5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlcik7XHJcbiAgICByZXR1cm4gc3luY0VuZ2luZUltcGw7XHJcbn1cclxuZnVuY3Rpb24gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmFwcGx5U3VjY2Vzc2Z1bFdyaXRlID1cclxuICAgICAgICBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVSZWplY3RGYWlsZWRXcml0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIHJldHVybiBzeW5jRW5naW5lSW1wbDtcclxufVxyXG4vKipcclxuICogTG9hZHMgYSBGaXJlc3RvcmUgYnVuZGxlIGludG8gdGhlIFNESy4gVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlblxyXG4gKiB0aGUgYnVuZGxlIGZpbmlzaGVkIGxvYWRpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gU3luY0VuZ2luZSB0byB1c2UuXHJcbiAqIEBwYXJhbSBidW5kbGVSZWFkZXIgLSBCdW5kbGUgdG8gbG9hZCBpbnRvIHRoZSBTREsuXHJcbiAqIEBwYXJhbSB0YXNrIC0gTG9hZEJ1bmRsZVRhc2sgdXNlZCB0byB1cGRhdGUgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgdG8gcHVibGljIEFQSS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNFbmdpbmVMb2FkQnVuZGxlKHN5bmNFbmdpbmUsIGJ1bmRsZVJlYWRlciwgdGFzaykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lSW1wbCwgYnVuZGxlUmVhZGVyLCB0YXNrKS50aGVuKGNvbGxlY3Rpb25Hcm91cHMgPT4ge1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLm5vdGlmeUJ1bmRsZUxvYWRlZChjb2xsZWN0aW9uR3JvdXBzKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKiBMb2FkcyBhIGJ1bmRsZSBhbmQgcmV0dXJucyB0aGUgbGlzdCBvZiBhZmZlY3RlZCBjb2xsZWN0aW9uIGdyb3Vwcy4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbG9hZEJ1bmRsZUltcGwoc3luY0VuZ2luZSwgcmVhZGVyLCB0YXNrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgcmVhZGVyLmdldE1ldGFkYXRhKCk7XHJcbiAgICAgICAgY29uc3Qgc2tpcCA9IGF3YWl0IGxvY2FsU3RvcmVIYXNOZXdlckJ1bmRsZShzeW5jRW5naW5lLmxvY2FsU3RvcmUsIG1ldGFkYXRhKTtcclxuICAgICAgICBpZiAoc2tpcCkge1xyXG4gICAgICAgICAgICBhd2FpdCByZWFkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGFzay5fY29tcGxldGVXaXRoKGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTZXQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhc2suX3VwZGF0ZVByb2dyZXNzKGJ1bmRsZUluaXRpYWxQcm9ncmVzcyhtZXRhZGF0YSkpO1xyXG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBCdW5kbGVMb2FkZXIobWV0YWRhdGEsIHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgcmVhZGVyLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gYXdhaXQgcmVhZGVyLm5leHRFbGVtZW50KCk7XHJcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGF3YWl0IGxvYWRlci5hZGRTaXplZEVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgdGFzay5fdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBhd2FpdCByZWFkZXIubmV4dEVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZSwgcmVzdWx0LmNoYW5nZWREb2NzLCBcclxuICAgICAgICAvKiByZW1vdGVFdmVudCAqLyB1bmRlZmluZWQpO1xyXG4gICAgICAgIC8vIFNhdmUgbWV0YWRhdGEsIHNvIGxvYWRpbmcgdGhlIHNhbWUgYnVuZGxlIHdpbGwgc2tpcC5cclxuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlU2F2ZUJ1bmRsZShzeW5jRW5naW5lLmxvY2FsU3RvcmUsIG1ldGFkYXRhKTtcclxuICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgocmVzdWx0LnByb2dyZXNzKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC5jaGFuZ2VkQ29sbGVjdGlvbkdyb3Vwcyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxvZ1dhcm4oTE9HX1RBRyQzLCBgTG9hZGluZyBidW5kbGUgZmFpbGVkIHdpdGggJHtlfWApO1xyXG4gICAgICAgIHRhc2suX2ZhaWxXaXRoKGUpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFNldCgpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAqIFVzZXMgRWFnZXJHQyBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVRhYnMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQpO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUgPSB0aGlzLmNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZyk7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHRoaXMuY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gdGhpcy5jcmVhdGVMb2NhbFN0b3JlKGNmZyk7XHJcbiAgICAgICAgdGhpcy5nY1NjaGVkdWxlciA9IHRoaXMuY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCB0aGlzLmxvY2FsU3RvcmUpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyID0gdGhpcy5jcmVhdGVJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLCB0aGlzLmxvY2FsU3RvcmUpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVMb2NhbFN0b3JlKGNmZykge1xyXG4gICAgICAgIHJldHVybiBuZXdMb2NhbFN0b3JlKHRoaXMucGVyc2lzdGVuY2UsIG5ldyBRdWVyeUVuZ2luZSgpLCBjZmcuaW5pdGlhbFVzZXIsIHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKE1lbW9yeUVhZ2VyRGVsZWdhdGUuZmFjdG9yeSwgdGhpcy5zZXJpYWxpemVyKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5U2hhcmVkQ2xpZW50U3RhdGUoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHRlcm1pbmF0ZSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIChfYSA9IHRoaXMuZ2NTY2hlZHVsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XHJcbiAgICAgICAgKF9iID0gdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5zaHV0ZG93bigpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2h1dGRvd24oKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBMcnVHY01lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVNpemVCeXRlcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9IGNhY2hlU2l6ZUJ5dGVzO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlIGluc3RhbmNlb2YgTWVtb3J5THJ1RGVsZWdhdGUpO1xyXG4gICAgICAgIGNvbnN0IGdhcmJhZ2VDb2xsZWN0b3IgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmdhcmJhZ2VDb2xsZWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVTY2hlZHVsZXIoZ2FyYmFnZUNvbGxlY3RvciwgY2ZnLmFzeW5jUXVldWUsIGxvY2FsU3RvcmUpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XHJcbiAgICAgICAgY29uc3QgbHJ1UGFyYW1zID0gdGhpcy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gTHJ1UGFyYW1zLndpdGhDYWNoZVNpemUodGhpcy5jYWNoZVNpemVCeXRlcylcclxuICAgICAgICAgICAgOiBMcnVQYXJhbXMuREVGQVVMVDtcclxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKHAgPT4gTWVtb3J5THJ1RGVsZWdhdGUuZmFjdG9yeShwLCBscnVQYXJhbXMpLCB0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIEZpcmVzdG9yZSB3aXRoIEluZGV4ZWREQiBwZXJzaXN0ZW5jZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMsIGZvcmNlT3duZXJzaGlwKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9IGNhY2hlU2l6ZUJ5dGVzO1xyXG4gICAgICAgIHRoaXMuZm9yY2VPd25lcnNoaXAgPSBmb3JjZU93bmVyc2hpcDtcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplVGFicyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZShjZmcpIHtcclxuICAgICAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKGNmZyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKHRoaXMsIGNmZyk7XHJcbiAgICAgICAgLy8gRW5xdWV1ZSB3cml0ZXMgZnJvbSBhIHByZXZpb3VzIHNlc3Npb25cclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3ModGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcclxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZSh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlKTtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIHdpbGwgaW1tZWRpYXRlbHkgY2FsbCB0aGUgbGlzdGVuZXIsIHNvIHdlIG1ha2Ugc3VyZSB0b1xyXG4gICAgICAgIC8vIHNldCBpdCBhZnRlciBsb2NhbFN0b3JlIC8gcmVtb3RlU3RvcmUgYXJlIHN0YXJ0ZWQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdjU2NoZWR1bGVyICYmICF0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIgJiZcclxuICAgICAgICAgICAgICAgICF0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUxvY2FsU3RvcmUoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld0xvY2FsU3RvcmUodGhpcy5wZXJzaXN0ZW5jZSwgbmV3IFF1ZXJ5RW5naW5lKCksIGNmZy5pbml0aWFsVXNlciwgdGhpcy5zZXJpYWxpemVyKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xyXG4gICAgICAgIGNvbnN0IGdhcmJhZ2VDb2xsZWN0b3IgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmdhcmJhZ2VDb2xsZWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVTY2hlZHVsZXIoZ2FyYmFnZUNvbGxlY3RvciwgY2ZnLmFzeW5jUXVldWUsIGxvY2FsU3RvcmUpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4QmFja2ZpbGxlciA9IG5ldyBJbmRleEJhY2tmaWxsZXIobG9jYWxTdG9yZSwgdGhpcy5wZXJzaXN0ZW5jZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLmFzeW5jUXVldWUsIGluZGV4QmFja2ZpbGxlcik7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcclxuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZUtleSA9IGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkLCBjZmcuZGF0YWJhc2VJbmZvLnBlcnNpc3RlbmNlS2V5KTtcclxuICAgICAgICBjb25zdCBscnVQYXJhbXMgPSB0aGlzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBMcnVQYXJhbXMud2l0aENhY2hlU2l6ZSh0aGlzLmNhY2hlU2l6ZUJ5dGVzKVxyXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUGVyc2lzdGVuY2UodGhpcy5zeW5jaHJvbml6ZVRhYnMsIHBlcnNpc3RlbmNlS2V5LCBjZmcuY2xpZW50SWQsIGxydVBhcmFtcywgY2ZnLmFzeW5jUXVldWUsIGdldFdpbmRvdygpLCBnZXREb2N1bWVudCgpLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsICEhdGhpcy5mb3JjZU93bmVyc2hpcCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVTaGFyZWRDbGllbnRTdGF0ZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggbXVsdGktdGFiIEluZGV4ZWREQlxyXG4gKiBwZXJzaXN0ZW5jZS5cclxuICpcclxuICogSW4gdGhlIGxlZ2FjeSBjbGllbnQsIHRoaXMgcHJvdmlkZXIgaXMgdXNlZCB0byBwcm92aWRlIGJvdGggbXVsdGktdGFiIGFuZFxyXG4gKiBub24tbXVsdGktdGFiIHBlcnNpc3RlbmNlIHNpbmNlIHdlIGNhbm5vdCB0ZWxsIGF0IGJ1aWxkIHRpbWUgd2hldGhlclxyXG4gKiBgc3luY2hyb25pemVUYWJzYCB3aWxsIGJlIGVuYWJsZWQuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMpIHtcclxuICAgICAgICBzdXBlcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMsIC8qIGZvcmNlT3duZXJzaGlwPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplVGFicyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xyXG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcclxuICAgICAgICBjb25zdCBzeW5jRW5naW5lID0gdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYXJlZENsaWVudFN0YXRlIGluc3RhbmNlb2YgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUuc3luY0VuZ2luZSA9IHtcclxuICAgICAgICAgICAgICAgIGFwcGx5QmF0Y2hTdGF0ZTogc3luY0VuZ2luZUFwcGx5QmF0Y2hTdGF0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxyXG4gICAgICAgICAgICAgICAgYXBwbHlUYXJnZXRTdGF0ZTogc3luY0VuZ2luZUFwcGx5VGFyZ2V0U3RhdGUuYmluZChudWxsLCBzeW5jRW5naW5lKSxcclxuICAgICAgICAgICAgICAgIGFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZTogc3luY0VuZ2luZUFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZS5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxyXG4gICAgICAgICAgICAgICAgZ2V0QWN0aXZlQ2xpZW50czogc3luY0VuZ2luZUdldEFjdGl2ZUNsaWVudHMuYmluZChudWxsLCBzeW5jRW5naW5lKSxcclxuICAgICAgICAgICAgICAgIHN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHM6IHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzLmJpbmQobnVsbCwgc3luY0VuZ2luZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5zdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBUaGlzIHdpbGwgaW1tZWRpYXRlbHkgY2FsbCB0aGUgbGlzdGVuZXIsIHNvIHdlIG1ha2Ugc3VyZSB0b1xyXG4gICAgICAgIC8vIHNldCBpdCBhZnRlciBsb2NhbFN0b3JlIC8gcmVtb3RlU3RvcmUgYXJlIHN0YXJ0ZWQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihhc3luYyAoaXNQcmltYXJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHN5bmNFbmdpbmVBcHBseVByaW1hcnlTdGF0ZSh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUsIGlzUHJpbWFyeSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdjU2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ByaW1hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xyXG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xyXG4gICAgICAgIGlmICghV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlLmlzQXZhaWxhYmxlKHdpbmRvdykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgJ0luZGV4ZWREQiBwZXJzaXN0ZW5jZSBpcyBvbmx5IGF2YWlsYWJsZSBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IExvY2FsU3RvcmFnZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VLZXkgPSBpbmRleGVkRGJTdG9yYWdlUHJlZml4KGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCwgY2ZnLmRhdGFiYXNlSW5mby5wZXJzaXN0ZW5jZUtleSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGUod2luZG93LCBjZmcuYXN5bmNRdWV1ZSwgcGVyc2lzdGVuY2VLZXksIGNmZy5jbGllbnRJZCwgY2ZnLmluaXRpYWxVc2VyKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYW5kIHdpcmVzIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbnRlcmZhY2Ugd2l0aCB0aGVcclxuICogbmV0d29yay5cclxuICovXHJcbmNsYXNzIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIHtcclxuICAgIGFzeW5jIGluaXRpYWxpemUob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLCBjZmcpIHtcclxuICAgICAgICBpZiAodGhpcy5sb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgICAgIC8vIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIG1heSBnZXQgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMgaWZcclxuICAgICAgICAgICAgLy8gbXVsdGktdGFiIHBlcnNpc3RlbmNlIGlzIHVzZWQuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmxvY2FsU3RvcmU7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5zaGFyZWRDbGllbnRTdGF0ZTtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IHRoaXMuY3JlYXRlRGF0YXN0b3JlKGNmZyk7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZSA9IHRoaXMuY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IHRoaXMuY3JlYXRlRXZlbnRNYW5hZ2VyKGNmZyk7XHJcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gdGhpcy5jcmVhdGVTeW5jRW5naW5lKGNmZywgXHJcbiAgICAgICAgLyogc3RhcnRBc1ByaW1hcnk9Ki8gIW9mZmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jaHJvbml6ZVRhYnMpO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGUgPT4gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2UodGhpcy5zeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgMSAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5TaGFyZWRDbGllbnRTdGF0ZSAqLyk7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuaGFuZGxlQ3JlZGVudGlhbENoYW5nZSA9XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlLmJpbmQobnVsbCwgdGhpcy5zeW5jRW5naW5lKTtcclxuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHRoaXMucmVtb3RlU3RvcmUsIHRoaXMuc3luY0VuZ2luZS5pc1ByaW1hcnlDbGllbnQpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnRNYW5hZ2VyKGNmZykge1xyXG4gICAgICAgIHJldHVybiBuZXdFdmVudE1hbmFnZXIoKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZURhdGFzdG9yZShjZmcpIHtcclxuICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQpO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uKGNmZy5kYXRhYmFzZUluZm8pO1xyXG4gICAgICAgIHJldHVybiBuZXdEYXRhc3RvcmUoY2ZnLmF1dGhDcmVkZW50aWFscywgY2ZnLmFwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1JlbW90ZVN0b3JlKHRoaXMubG9jYWxTdG9yZSwgdGhpcy5kYXRhc3RvcmUsIGNmZy5hc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZSA9PiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZSh0aGlzLnN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCAwIC8qIE9ubGluZVN0YXRlU291cmNlLlJlbW90ZVN0b3JlICovKSwgbmV3Q29ubmVjdGl2aXR5TW9uaXRvcigpKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVN5bmNFbmdpbmUoY2ZnLCBzdGFydEFzUHJpbWFyeSkge1xyXG4gICAgICAgIHJldHVybiBuZXdTeW5jRW5naW5lKHRoaXMubG9jYWxTdG9yZSwgdGhpcy5yZW1vdGVTdG9yZSwgdGhpcy5ldmVudE1hbmFnZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsIGNmZy5pbml0aWFsVXNlciwgY2ZnLm1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zLCBzdGFydEFzUHJpbWFyeSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlU2h1dGRvd24odGhpcy5yZW1vdGVTdG9yZSk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5kYXRhc3RvcmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXJtaW5hdGUoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSG93IG1hbnkgYnl0ZXMgdG8gcmVhZCBlYWNoIHRpbWUgd2hlbiBgUmVhZGFibGVTdHJlYW1SZWFkZXIucmVhZCgpYCBpc1xyXG4gKiBjYWxsZWQuIE9ubHkgYXBwbGljYWJsZSBmb3IgYnl0ZSBzdHJlYW1zIHRoYXQgd2UgY29udHJvbCAoZS5nLiB0aG9zZSBiYWNrZWRcclxuICogYnkgYW4gVUludDhBcnJheSkuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JZVEVTX1BFUl9SRUFEID0gMTAyNDA7XHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBgQnl0ZVN0cmVhbVJlYWRlcmAgZnJvbSBhIFVJbnQ4QXJyYXkuXHJcbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgZGF0YSBzb3VyY2UgdG8gdXNlLlxyXG4gKiBAcGFyYW0gYnl0ZXNQZXJSZWFkIC0gSG93IG1hbnkgYnl0ZXMgZWFjaCBgcmVhZCgpYCBmcm9tIHRoZSByZXR1cm5lZCByZWFkZXJcclxuICogICAgICAgIHdpbGwgcmVhZC5cclxuICovXHJcbmZ1bmN0aW9uIHRvQnl0ZVN0cmVhbVJlYWRlckhlbHBlcihzb3VyY2UsIGJ5dGVzUGVyUmVhZCA9IERFRkFVTFRfQllURVNfUEVSX1JFQUQpIHtcclxuICAgIGxldCByZWFkRnJvbSA9IDA7XHJcbiAgICAvLyBUaGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZvciBSZWFkYWJsZVN0cmVhbVJlYWRlciBjaGFuZ2VkLiBXZSB1c2VcclxuICAgIC8vIGBhbnlgIGhlcmUgdG8gYWxsb3cgdGhpcyBjb2RlIHRvIGNvbXBpbGUgd2l0aCBkaWZmZXJlbnQgdmVyc2lvbnMuXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80Mjk3MFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGNvbnN0IHJlYWRlciA9IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWFkRnJvbSA8IHNvdXJjZS5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShyZWFkRnJvbSwgcmVhZEZyb20gKyBieXRlc1BlclJlYWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVhZEZyb20gKz0gYnl0ZXNQZXJSZWFkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhc3luYyBjYW5jZWwoKSB7IH0sXHJcbiAgICAgICAgcmVsZWFzZUxvY2soKSB7IH0sXHJcbiAgICAgICAgY2xvc2VkOiBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgfTtcclxuICAgIHJldHVybiByZWFkZXI7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBhcmd1bWVudCkge1xyXG4gICAgaWYgKCFhcmd1bWVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oKSBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgJHthcmd1bWVudE5hbWV9LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCB0d28gYm9vbGVhbiBvcHRpb25zIGFyZSBub3Qgc2V0IGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlcihvcHRpb25OYW1lMSwgYXJndW1lbnQxLCBvcHRpb25OYW1lMiwgYXJndW1lbnQyKSB7XHJcbiAgICBpZiAoYXJndW1lbnQxID09PSB0cnVlICYmIGFyZ3VtZW50MiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGAke29wdGlvbk5hbWUxfSBhbmQgJHtvcHRpb25OYW1lMn0gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIuYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBkb2N1bWVudCAoaW5kaWNhdGVkIGJ5IHRoZSBmYWN0IGl0IGNvbnRhaW5zXHJcbiAqIGFuIGV2ZW4gbnVtYmVycyBvZiBzZWdtZW50cykuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURvY3VtZW50UGF0aChwYXRoKSB7XHJcbiAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBkb2N1bWVudCByZWZlcmVuY2UuIERvY3VtZW50IHJlZmVyZW5jZXMgbXVzdCBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHtwYXRofSBoYXMgJHtwYXRoLmxlbmd0aH0uYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBjb2xsZWN0aW9uIChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXRcclxuICogY29udGFpbnMgYW4gb2RkIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChwYXRoKSB7XHJcbiAgICBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGNvbGxlY3Rpb24gcmVmZXJlbmNlLiBDb2xsZWN0aW9uIHJlZmVyZW5jZXMgbXVzdCBoYXZlIGFuIG9kZCBudW1iZXIgb2Ygc2VnbWVudHMsIGJ1dCAke3BhdGh9IGhhcyAke3BhdGgubGVuZ3RofS5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGl0J3MgYSBub24tbnVsbCBvYmplY3Qgd2l0aG91dCBhIGN1c3RvbSBwcm90b3R5cGVcclxuICogKGkuZS4gZXhjbHVkZXMgQXJyYXksIERhdGUsIGV0Yy4pLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChpbnB1dCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgaW5wdXQgIT09IG51bGwgJiZcclxuICAgICAgICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxyXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSk7XHJcbn1cclxuLyoqIFJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSAvIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBpbnB1dC4gKi9cclxuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCkge1xyXG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpbnB1dCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDIwKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDIwKX0uLi5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHJldHVybiAnJyArIGlucHV0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnYW4gYXJyYXknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3VzdG9tT2JqZWN0TmFtZSA9IHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tT2JqZWN0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBhIGN1c3RvbSAke2N1c3RvbU9iamVjdE5hbWV9IG9iamVjdGA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FuIG9iamVjdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gJ2EgZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogdHJ5IHRvIGdldCB0aGUgY29uc3RydWN0b3IgbmFtZSBmb3IgYW4gb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiB0cnlHZXRDdXN0b21PYmplY3RUeXBlKGlucHV0KSB7XHJcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAsIG9wdGlvbmFsbHkgdW53cmFwcGluZyBDb21wYXQgdHlwZXMgdG8gZXhwb3NlIHRoZVxyXG4gKiB1bmRlcmx5aW5nIGluc3RhbmNlLiBUaHJvd3MgaWYgIGBvYmpgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgVGAuXHJcbiAqXHJcbiAqIFRoaXMgY2FzdCBpcyB1c2VkIGluIHRoZSBMaXRlIGFuZCBGdWxsIFNESyB0byB2ZXJpZnkgaW5zdGFuY2UgdHlwZXMgZm9yXHJcbiAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHB1YmxpYyBBUEkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gY2FzdChvYmosIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdHJ1Y3Rvcikge1xyXG4gICAgaWYgKCdfZGVsZWdhdGUnIGluIG9iaikge1xyXG4gICAgICAgIC8vIFVud3JhcCBDb21wYXQgdHlwZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIG9iaiA9IG9iai5fZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICBpZiAoY29uc3RydWN0b3IubmFtZSA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1R5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGluc3RhbmNlLiBEaWQgeW91IHBhc3MgYSAnICtcclxuICAgICAgICAgICAgICAgIGByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgU0RLP2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZURlc2NyaXB0aW9uKG9iaik7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBFeHBlY3RlZCB0eXBlICcke2NvbnN0cnVjdG9yLm5hbWV9JywgYnV0IGl0IHdhczogJHtkZXNjcmlwdGlvbn1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoZnVuY3Rpb25OYW1lLCBuKSB7XHJcbiAgICBpZiAobiA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIHJlcXVpcmVzIGEgcG9zaXRpdmUgbnVtYmVyLCBidXQgaXQgd2FzOiAke259LmApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBPbiBOb2RlLCBvbmx5IHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBpcyBhIGBVaW50OEFycmF5YCBmb3Igbm93LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9CeXRlU3RyZWFtUmVhZGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkKSB7XHJcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBOb2RlUGxhdGZvcm0udG9CeXRlU3RyZWFtUmVhZGVyIGV4cGVjdHMgc291cmNlIHRvIGJlIFVpbnQ4QXJyYXksIGdvdCAke3ZhbHVlRGVzY3JpcHRpb24oc291cmNlKX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qXHJcbiAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiBPYnNlcnZlcjxUPiB0aGF0IHdpbGwgZGlzcGF0Y2ggZXZlbnRzXHJcbiAqIGFzeW5jaHJvbm91c2x5LiBUbyBhbGxvdyBpbW1lZGlhdGUgc2lsZW5jaW5nLCBhIG11dGUgY2FsbCBpcyBhZGRlZCB3aGljaFxyXG4gKiBjYXVzZXMgZXZlbnRzIHNjaGVkdWxlZCB0byBubyBsb25nZXIgYmUgcmFpc2VkLlxyXG4gKi9cclxuY2xhc3MgQXN5bmNPYnNlcnZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHNldCB0byB0cnVlLCB3aWxsIG5vdCByYWlzZSBmdXR1cmUgZXZlbnRzLiBOZWNlc3NhcnkgdG8gZGVhbCB3aXRoXHJcbiAgICAgICAgICogYXN5bmMgZGV0YWNobWVudCBvZiBsaXN0ZW5lci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBuZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIubmV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5uZXh0LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXJyb3IoZXJyb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5lcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5lcnJvciwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoJ1VuY2F1Z2h0IEVycm9yIGluIHNuYXBzaG90IGxpc3RlbmVyOicsIGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG11dGUoKSB7XHJcbiAgICAgICAgdGhpcy5tdXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZUV2ZW50KGV2ZW50SGFuZGxlciwgZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY29tcGxldGUgZWxlbWVudCBpbiB0aGUgYnVuZGxlIHN0cmVhbSwgdG9nZXRoZXIgd2l0aCB0aGUgYnl0ZSBsZW5ndGggaXRcclxuICogb2NjdXBpZXMgaW4gdGhlIHN0cmVhbS5cclxuICovXHJcbmNsYXNzIFNpemVkQnVuZGxlRWxlbWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBcclxuICAgIC8vIEhvdyBtYW55IGJ5dGVzIHRoaXMgZWxlbWVudCB0YWtlcyB0byBzdG9yZSBpbiB0aGUgYnVuZGxlLlxyXG4gICAgYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIGlzQnVuZGxlTWV0YWRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtZXRhZGF0YScgaW4gdGhpcy5wYXlsb2FkO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGJ1bmRsZS5cclxuICpcclxuICogVGFrZXMgYSBidW5kbGUgc3RyZWFtIG9yIGJ1ZmZlciwgYW5kIHByZXNlbnRzIGFic3RyYWN0aW9ucyB0byByZWFkIGJ1bmRsZWRcclxuICogZWxlbWVudHMgb3V0IG9mIHRoZSB1bmRlcmx5aW5nIGNvbnRlbnQuXHJcbiAqL1xyXG5jbGFzcyBCdW5kbGVSZWFkZXJJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSByZWFkZXIgdG8gcmVhZCBmcm9tIHVuZGVybHlpbmcgYmluYXJ5IGJ1bmRsZSBkYXRhIHNvdXJjZS4gKi9cclxuICAgIHJlYWRlciwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgLyoqIENhY2hlZCBidW5kbGUgbWV0YWRhdGEuICovXHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybmFsIGJ1ZmZlciB0byBob2xkIGJ1bmRsZSBjb250ZW50LCBhY2N1bXVsYXRpbmcgaW5jb21wbGV0ZSBlbGVtZW50XHJcbiAgICAgICAgICogY29udGVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IG5ld1RleHREZWNvZGVyKCk7XHJcbiAgICAgICAgLy8gUmVhZCB0aGUgbWV0YWRhdGEgKHdoaWNoIGlzIHRoZSBmaXJzdCBlbGVtZW50KS5cclxuICAgICAgICB0aGlzLm5leHRFbGVtZW50SW1wbCgpLnRoZW4oZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXNCdW5kbGVNZXRhZGF0YSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJlc29sdmUoZWxlbWVudC5wYXlsb2FkLm1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEucmVqZWN0KG5ldyBFcnJvcihgVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJ1bmRsZSBpcyBub3QgYSBtZXRhZGF0YSwgaXQgaXNcbiAgICAgICAgICAgICAke0pTT04uc3RyaW5naWZ5KGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5wYXlsb2FkKX1gKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBlcnJvciA9PiB0aGlzLm1ldGFkYXRhLnJlamVjdChlcnJvcikpO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGFzeW5jIG5leHRFbGVtZW50KCkge1xyXG4gICAgICAgIC8vIE1ha2VzIHN1cmUgbWV0YWRhdGEgaXMgcmVhZCBiZWZvcmUgcHJvY2VlZGluZy5cclxuICAgICAgICBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEVsZW1lbnRJbXBsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGZyb20gdGhlIGhlYWQgb2YgaW50ZXJuYWwgYnVmZmVyLCBhbmQgcHVsbGluZyBtb3JlIGRhdGEgZnJvbVxyXG4gICAgICogdW5kZXJseWluZyBzdHJlYW0gaWYgYSBjb21wbGV0ZSBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZCwgdW50aWwgYW5cclxuICAgICAqIGVsZW1lbnQoaW5jbHVkaW5nIHRoZSBwcmVmaXhlZCBsZW5ndGggYW5kIHRoZSBKU09OIHN0cmluZykgaXMgZm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogT25jZSBhIGNvbXBsZXRlIGVsZW1lbnQgaXMgcmVhZCwgaXQgaXMgZHJvcHBlZCBmcm9tIGludGVybmFsIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGVpdGhlciB0aGUgYnVuZGxlZCBlbGVtZW50LCBvciBudWxsIGlmIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mXHJcbiAgICAgKiB0aGUgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBuZXh0RWxlbWVudEltcGwoKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyID0gYXdhaXQgdGhpcy5yZWFkTGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aEJ1ZmZlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoU3RyaW5nID0gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUobGVuZ3RoQnVmZmVyKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIobGVuZ3RoU3RyaW5nKTtcclxuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoYGxlbmd0aCBzdHJpbmcgKCR7bGVuZ3RoU3RyaW5nfSkgaXMgbm90IHZhbGlkIG51bWJlcmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gYXdhaXQgdGhpcy5yZWFkSnNvblN0cmluZyhsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2l6ZWRCdW5kbGVFbGVtZW50KEpTT04ucGFyc2UoanNvblN0cmluZyksIGxlbmd0aEJ1ZmZlci5sZW5ndGggKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEZpcnN0IGluZGV4IG9mICd7JyBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci4gKi9cclxuICAgIGluZGV4T2ZPcGVuQnJhY2tldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuZmluZEluZGV4KHYgPT4gdiA9PT0gJ3snLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGludGVybmFsIGJ1ZmZlciwgdW50aWwgdGhlIGZpcnN0ICd7JywgYW5kXHJcbiAgICAgKiByZXR1cm4gdGhlIGNvbnRlbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgcmVhY2hlZCBlbmQgb2YgdGhlIHN0cmVhbSwgcmV0dXJucyBhIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWRMZW5ndGgoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXhPZk9wZW5CcmFja2V0KCkgPCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBhd2FpdCB0aGlzLnB1bGxNb3JlRGF0YVRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCcm9rZSBvdXQgb2YgdGhlIGxvb3AgYmVjYXVzZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWQsIGFuZCB0aGVyZVxyXG4gICAgICAgIC8vIGhhcHBlbnMgdG8gYmUgbm8gbW9yZSBkYXRhIHRvIHByb2Nlc3MuXHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmluZGV4T2ZPcGVuQnJhY2tldCgpO1xyXG4gICAgICAgIC8vIEJyb2tlIG91dCBvZiB0aGUgbG9vcCBiZWNhdXNlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZCwgYnV0IHN0aWxsXHJcbiAgICAgICAgLy8gY2Fubm90IGZpbmQgYW4gb3BlbiBicmFja2V0LlxyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKCdSZWFjaGVkIHRoZSBlbmQgb2YgYnVuZGxlIHdoZW4gYSBsZW5ndGggc3RyaW5nIGlzIGV4cGVjdGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5zbGljZSgwLCBwb3NpdGlvbik7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gZHJvcCB0aGUgcmVhZCBsZW5ndGguXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShwb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgZnJvbSBhIHNwZWNpZmllZCBwb3NpdGlvbiBmcm9tIHRoZSBpbnRlcm5hbCBidWZmZXIsIGZvciBhIHNwZWNpZmllZFxyXG4gICAgICogbnVtYmVyIG9mIGJ5dGVzLCBwdWxsaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpZiBuZWVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBkZWNvZGVkIGZyb20gdGhlIHJlYWQgYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWRKc29uU3RyaW5nKGxlbmd0aCkge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlci5sZW5ndGggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IGF3YWl0IHRoaXMucHVsbE1vcmVEYXRhVG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvcignUmVhY2hlZCB0aGUgZW5kIG9mIGJ1bmRsZSB3aGVuIG1vcmUgaXMgZXhwZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoKSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gZHJvcCB0aGUgcmVhZCBqc29uIHN0cmluZy5cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJhaXNlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnJlYWRlci5jYW5jZWwoKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVuZGxlIGZvcm1hdDogJHttZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQdWxscyBtb3JlIGRhdGEgZnJvbSB1bmRlcmx5aW5nIHN0cmVhbSB0byBpbnRlcm5hbCBidWZmZXIuXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcHVsbE1vcmVEYXRhVG9CdWZmZXIoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xyXG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIubGVuZ3RoICsgcmVzdWx0LnZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpO1xyXG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KHJlc3VsdC52YWx1ZSwgdGhpcy5idWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQuZG9uZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdCdW5kbGVSZWFkZXIocmVhZGVyLCBzZXJpYWxpemVyKSB7XHJcbiAgICByZXR1cm4gbmV3IEJ1bmRsZVJlYWRlckltcGwocmVhZGVyLCBzZXJpYWxpemVyKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJuYWwgdHJhbnNhY3Rpb24gb2JqZWN0IHJlc3BvbnNpYmxlIGZvciBhY2N1bXVsYXRpbmcgdGhlIG11dGF0aW9ucyB0b1xyXG4gKiBwZXJmb3JtIGFuZCB0aGUgYmFzZSB2ZXJzaW9ucyBmb3IgYW55IGRvY3VtZW50cyByZWFkLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb24kMiB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhc3RvcmUpIHtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcclxuICAgICAgICAvLyBUaGUgdmVyc2lvbiBvZiBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgdGhpcy5yZWFkVmVyc2lvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZGVmZXJyZWQgdXNhZ2UgZXJyb3IgdGhhdCBvY2N1cnJlZCBwcmV2aW91c2x5IGluIHRoaXMgdHJhbnNhY3Rpb24gdGhhdFxyXG4gICAgICAgICAqIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uIHRvIGZhaWwgb25jZSBpdCBhY3R1YWxseSBjb21taXRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBvZiBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gd3JpdHRlbiBpbiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSB3cml0ZSB0byB0aGUgc2FtZSBrZXkgaW4gYSB0cmFuc2FjdGlvbiwgYW55XHJcbiAgICAgICAgICogd3JpdGVzIGFmdGVyIHRoZSBmaXJzdCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbG9va3VwKGtleXMpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmlyZXN0b3JlIHRyYW5zYWN0aW9ucyByZXF1aXJlIGFsbCByZWFkcyB0byBiZSBleGVjdXRlZCBiZWZvcmUgYWxsIHdyaXRlcy4nKTtcclxuICAgICAgICAgICAgdGhyb3cgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZG9jcyA9IGF3YWl0IGludm9rZUJhdGNoR2V0RG9jdW1lbnRzUnBjKHRoaXMuZGF0YXN0b3JlLCBrZXlzKTtcclxuICAgICAgICBkb2NzLmZvckVhY2goZG9jID0+IHRoaXMucmVjb3JkVmVyc2lvbihkb2MpKTtcclxuICAgICAgICByZXR1cm4gZG9jcztcclxuICAgIH1cclxuICAgIHNldChrZXksIGRhdGEpIHtcclxuICAgICAgICB0aGlzLndyaXRlKGRhdGEudG9NdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcclxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLnRvTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgdGhpcy53cml0ZShuZXcgRGVsZXRlTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XHJcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY29tbWl0KCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW53cml0dGVuID0gdGhpcy5yZWFkVmVyc2lvbnM7XHJcbiAgICAgICAgLy8gRm9yIGVhY2ggbXV0YXRpb24sIG5vdGUgdGhhdCB0aGUgZG9jIHdhcyB3cml0dGVuLlxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xyXG4gICAgICAgICAgICB1bndyaXR0ZW4uZGVsZXRlKG11dGF0aW9uLmtleS50b1N0cmluZygpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBGb3IgZWFjaCBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGJ1dCBub3Qgd3JpdHRlbiB0bywgd2Ugd2FudCB0byBwZXJmb3JtXHJcbiAgICAgICAgLy8gYSBgdmVyaWZ5YCBvcGVyYXRpb24uXHJcbiAgICAgICAgdW53cml0dGVuLmZvckVhY2goKF8sIHBhdGgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zLnB1c2gobmV3IFZlcmlmeU11dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGF3YWl0IGludm9rZUNvbW1pdFJwYyh0aGlzLmRhdGFzdG9yZSwgdGhpcy5tdXRhdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuY29tbWl0dGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlY29yZFZlcnNpb24oZG9jKSB7XHJcbiAgICAgICAgbGV0IGRvY1ZlcnNpb247XHJcbiAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICBkb2NWZXJzaW9uID0gZG9jLnZlcnNpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvYy5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAvLyBSZXByZXNlbnQgYSBkZWxldGVkIGRvYyB1c2luZyBTbmFwc2hvdFZlcnNpb24ubWluKCkuXHJcbiAgICAgICAgICAgIGRvY1ZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChkb2Mua2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ1ZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKCFkb2NWZXJzaW9uLmlzRXF1YWwoZXhpc3RpbmdWZXJzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3aWxsIGZhaWwgbm8gbWF0dGVyIHdoYXQuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5BQk9SVEVELCAnRG9jdW1lbnQgdmVyc2lvbiBjaGFuZ2VkIGJldHdlZW4gdHdvIHJlYWRzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRWZXJzaW9ucy5zZXQoZG9jLmtleS50b1N0cmluZygpLCBkb2NWZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhpcyBkb2N1bWVudCB3aGVuIGl0IHdhcyByZWFkIGluIHRoaXMgdHJhbnNhY3Rpb24sXHJcbiAgICAgKiBhcyBhIHByZWNvbmRpdGlvbiwgb3Igbm8gcHJlY29uZGl0aW9uIGlmIGl0IHdhcyBub3QgcmVhZC5cclxuICAgICAqL1xyXG4gICAgcHJlY29uZGl0aW9uKGtleSkge1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGlmICghdGhpcy53cml0dGVuRG9jcy5oYXMoa2V5LnRvU3RyaW5nKCkpICYmIHZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLmV4aXN0cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUodmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24ubm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJlY29uZGl0aW9uIGZvciBhIGRvY3VtZW50IGlmIHRoZSBvcGVyYXRpb24gaXMgYW4gdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICBwcmVjb25kaXRpb25Gb3JVcGRhdGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgYSBkb2N1bWVudCBpcyB3cml0dGVuLCB3ZSB3YW50IHRvIHRha2UgaW50byBhY2NvdW50IHRoZVxyXG4gICAgICAgIC8vIHJlYWQgdGltZSBhbmQgZXhpc3RlbmNlXHJcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xyXG4gICAgICAgICAgICBpZiAodmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LCBzbyBmYWlsIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIHZhbGlkYXRlZCBsb2NhbGx5IGJlY2F1c2UgeW91IGNhbid0IHNlbmQgYVxyXG4gICAgICAgICAgICAgICAgLy8gcHJlY29uZGl0aW9uIHRoYXQgYSBkb2N1bWVudCBkb2VzIG5vdCBleGlzdCB3aXRob3V0IGNoYW5naW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBiYWNrZW5kIHdyaXRlIHRvIGJlIGFuIGluc2VydC4gVGhpcyBpcyB0aGUgcmV2ZXJzZVxyXG4gICAgICAgICAgICAgICAgLy8gb2Ygd2hhdCB3ZSB3YW50LCBzaW5jZSB3ZSB3YW50IHRvIGFzc2VydCB0aGF0IHRoZSBkb2N1bWVudCBkb2Vzbid0XHJcbiAgICAgICAgICAgICAgICAvLyBleGlzdCBidXQgdGhlbiBzZW5kIHRoZSB1cGRhdGUgYW5kIGhhdmUgaXQgZmFpbC4gU2luY2Ugd2UgY2FuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3MgdGhhdCB0byB0aGUgYmFja2VuZCwgd2UgaGF2ZSB0byB2YWxpZGF0ZSBsb2NhbGx5LlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBjYW4gY2hhbmdlIG9uY2Ugd2UgY2FuIHNlbmQgc2VwYXJhdGUgdmVyaWZ5IHdyaXRlcyBpbiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJDYW4ndCB1cGRhdGUgYSBkb2N1bWVudCB0aGF0IGRvZXNuJ3QgZXhpc3QuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvY3VtZW50IGV4aXN0cywgYmFzZSBwcmVjb25kaXRpb24gb24gZG9jdW1lbnQgdXBkYXRlIHRpbWUuXHJcbiAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZSh2ZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERvY3VtZW50IHdhcyBub3QgcmVhZCwgc28gd2UganVzdCB1c2UgdGhlIHByZWNvbmRpdGlvbnMgZm9yIGEgYmxpbmRcclxuICAgICAgICAgICAgLy8gdXBkYXRlLlxyXG4gICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLmV4aXN0cyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cml0ZShtdXRhdGlvbikge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVDb21taXROb3RDYWxsZWQoKSB7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRyYW5zYWN0aW9uUnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zXHJcbiAqIHdpdGggYmFja29mZi5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uUnVubmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFzeW5jUXVldWUsIGRhdGFzdG9yZSwgb3B0aW9ucywgdXBkYXRlRnVuY3Rpb24sIGRlZmVycmVkKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRnVuY3Rpb24gPSB1cGRhdGVGdW5jdGlvbjtcclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gZGVmZXJyZWQ7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyA9IG9wdGlvbnMubWF4QXR0ZW1wdHM7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZih0aGlzLmFzeW5jUXVldWUsIFwidHJhbnNhY3Rpb25fcmV0cnlcIiAvKiBUaW1lcklkLlRyYW5zYWN0aW9uUmV0cnkgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJ1bnMgdGhlIHRyYW5zYWN0aW9uIGFuZCBzZXRzIHRoZSByZXN1bHQgb24gZGVmZXJyZWQuICovXHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xyXG4gICAgICAgIHRoaXMucnVuV2l0aEJhY2tPZmYoKTtcclxuICAgIH1cclxuICAgIHJ1bldpdGhCYWNrT2ZmKCkge1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24kMih0aGlzLmRhdGFzdG9yZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9taXNlID0gdGhpcy50cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh1c2VyUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgdXNlclByb21pc2VcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29tbWl0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbW1pdEVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihjb21taXRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godXNlclByb21pc2VFcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2FjdGlvbkVycm9yKHVzZXJQcm9taXNlRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyeVJ1blVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB0aGlzLnVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHVzZXJQcm9taXNlKSB8fFxyXG4gICAgICAgICAgICAgICAgIXVzZXJQcm9taXNlLmNhdGNoIHx8XHJcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UudGhlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbGxiYWNrIG11c3QgcmV0dXJuIGEgUHJvbWlzZScpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCByZXRyeSBlcnJvcnMgdGhyb3duIGJ5IHVzZXIgcHJvdmlkZWQgdXBkYXRlRnVuY3Rpb24uXHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzUmVtYWluaW5nID4gMCAmJiB0aGlzLmlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikpIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcclxuICAgICAgICAgICAgLy8gSW4gdHJhbnNhY3Rpb25zLCB0aGUgYmFja2VuZCB3aWxsIGZhaWwgb3V0ZGF0ZWQgcmVhZHMgd2l0aCBGQUlMRURfUFJFQ09ORElUSU9OIGFuZFxyXG4gICAgICAgICAgICAvLyBub24tbWF0Y2hpbmcgZG9jdW1lbnQgdmVyc2lvbnMgd2l0aCBBQk9SVEVELiBUaGVzZSBlcnJvcnMgc2hvdWxkIGJlIHJldHJpZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvci5jb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvZGUgPT09ICdhYm9ydGVkJyB8fFxyXG4gICAgICAgICAgICAgICAgY29kZSA9PT0gJ2ZhaWxlZC1wcmVjb25kaXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICBjb2RlID09PSAnYWxyZWFkeS1leGlzdHMnIHx8XHJcbiAgICAgICAgICAgICAgICAhaXNQZXJtYW5lbnRFcnJvcihjb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDIgPSAnRmlyZXN0b3JlQ2xpZW50JztcclxuY29uc3QgTUFYX0NPTkNVUlJFTlRfTElNQk9fUkVTT0xVVElPTlMgPSAxMDA7XHJcbi8qKiBET01FeGNlcHRpb24gZXJyb3IgY29kZSBjb25zdGFudHMuICovXHJcbmNvbnN0IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSA9IDExO1xyXG5jb25zdCBET01fRVhDRVBUSU9OX0FCT1JURUQgPSAyMDtcclxuY29uc3QgRE9NX0VYQ0VQVElPTl9RVU9UQV9FWENFRURFRCA9IDIyO1xyXG4vKipcclxuICogRmlyZXN0b3JlQ2xpZW50IGlzIGEgdG9wLWxldmVsIGNsYXNzIHRoYXQgY29uc3RydWN0cyBhbmQgb3ducyBhbGwgb2YgdGhlIC8vXHJcbiAqIHBpZWNlcyBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUuIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgLy9cclxuICogYXN5bmMgcXVldWUgdGhhdCBpcyBzaGFyZWQgYnkgYWxsIG9mIHRoZSBvdGhlciBjb21wb25lbnRzIGluIHRoZSBzeXN0ZW0uIC8vXHJcbiAqL1xyXG5jbGFzcyBGaXJlc3RvcmVDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBcclxuICAgIC8qKlxyXG4gICAgICogQXN5bmNocm9ub3VzIHF1ZXVlIHJlc3BvbnNpYmxlIGZvciBhbGwgb2Ygb3VyIGludGVybmFsIHByb2Nlc3NpbmcuIFdoZW5cclxuICAgICAqIHdlIGdldCBpbmNvbWluZyB3b3JrIGZyb20gdGhlIHVzZXIgKHZpYSBwdWJsaWMgQVBJKSBvciB0aGUgbmV0d29ya1xyXG4gICAgICogKGluY29taW5nIEdSUEMgbWVzc2FnZXMpLCB3ZSBzaG91bGQgYWx3YXlzIHNjaGVkdWxlIG9udG8gdGhpcyBxdWV1ZS5cclxuICAgICAqIFRoaXMgZW5zdXJlcyBhbGwgb2Ygb3VyIHdvcmsgaXMgcHJvcGVybHkgc2VyaWFsaXplZCAoZS5nLiB3ZSBkb24ndFxyXG4gICAgICogc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBvcGVyYXRpb24gd2hpbGUgdGhlIHByZXZpb3VzIG9uZSBpcyB3YWl0aW5nIGZvclxyXG4gICAgICogYW4gYXN5bmMgSS9PIHRvIGNvbXBsZXRlKS5cclxuICAgICAqL1xyXG4gICAgYXN5bmNRdWV1ZSwgZGF0YWJhc2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJbmZvID0gZGF0YWJhc2VJbmZvO1xyXG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuVU5BVVRIRU5USUNBVEVEO1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBBdXRvSWQubmV3SWQoKTtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsTGlzdGVuZXIgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuc3RhcnQoYXN5bmNRdWV1ZSwgYXN5bmMgKHVzZXIpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnUmVjZWl2ZWQgdXNlcj0nLCB1c2VyLnVpZCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lcih1c2VyKTtcclxuICAgICAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuc3RhcnQoYXN5bmNRdWV1ZSwgbmV3QXBwQ2hlY2tUb2tlbiA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIG5ldyBhcHAgY2hlY2sgdG9rZW49JywgbmV3QXBwQ2hlY2tUb2tlbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyKG5ld0FwcENoZWNrVG9rZW4sIHRoaXMudXNlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlndXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhc3luY1F1ZXVlOiB0aGlzLmFzeW5jUXVldWUsXHJcbiAgICAgICAgICAgIGRhdGFiYXNlSW5mbzogdGhpcy5kYXRhYmFzZUluZm8sXHJcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxyXG4gICAgICAgICAgICBhdXRoQ3JlZGVudGlhbHM6IHRoaXMuYXV0aENyZWRlbnRpYWxzLFxyXG4gICAgICAgICAgICBhcHBDaGVja0NyZWRlbnRpYWxzOiB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMsXHJcbiAgICAgICAgICAgIGluaXRpYWxVc2VyOiB0aGlzLnVzZXIsXHJcbiAgICAgICAgICAgIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zOiBNQVhfQ09OQ1VSUkVOVF9MSU1CT19SRVNPTFVUSU9OU1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsTGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgIH1cclxuICAgIHNldEFwcENoZWNrVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsTGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIGNsaWVudCBoYXMgbm90IGJlZW4gdGVybWluYXRlZC4gRW5zdXJlcyB0aGF0IG90aGVyIG1ldGhvZHMgb24gLy9cclxuICAgICAqIHRoaXMgY2xhc3MgY2Fubm90IGJlIGNhbGxlZCBhZnRlciB0aGUgY2xpZW50IGlzIHRlcm1pbmF0ZWQuIC8vXHJcbiAgICAgKi9cclxuICAgIHZlcmlmeU5vdFRlcm1pbmF0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXN5bmNRdWV1ZS5pc1NodXR0aW5nRG93bikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29ubGluZUNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vbmxpbmVDb21wb25lbnRzLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZmxpbmVDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fb2ZmbGluZUNvbXBvbmVudHMudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY3JlZGVudGlhbHMgcHJvdmlkZXIgbXVzdCBiZSB0ZXJtaW5hdGVkIGFmdGVyIHNodXR0aW5nIGRvd24gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBhcyBpdCB3aWxsIHByZXZlbnQgdGhlIFJlbW90ZVN0b3JlIGZyb20gcmV0cmlldmluZyBhdXRoXHJcbiAgICAgICAgICAgICAgICAvLyB0b2tlbnMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5zaHV0ZG93bigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIHNodXRkb3duIHBlcnNpc3RlbmNlYCk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XHJcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdJbml0aWFsaXppbmcgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gY2xpZW50LmNvbmZpZ3VyYXRpb247XHJcbiAgICBhd2FpdCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIuaW5pdGlhbGl6ZShjb25maWd1cmF0aW9uKTtcclxuICAgIGxldCBjdXJyZW50VXNlciA9IGNvbmZpZ3VyYXRpb24uaW5pdGlhbFVzZXI7XHJcbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKGFzeW5jICh1c2VyKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50VXNlci5pc0VxdWFsKHVzZXIpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5sb2NhbFN0b3JlLCB1c2VyKTtcclxuICAgICAgICAgICAgY3VycmVudFVzZXIgPSB1c2VyO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gV2hlbiBhIHVzZXIgY2FsbHMgY2xlYXJQZXJzaXN0ZW5jZSgpIGluIG9uZSBjbGllbnQsIGFsbCBvdGhlciBjbGllbnRzXHJcbiAgICAvLyBuZWVkIHRvIGJlIHRlcm1pbmF0ZWQgdG8gYWxsb3cgdGhlIGRlbGV0ZSB0byBzdWNjZWVkLlxyXG4gICAgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnBlcnNpc3RlbmNlLnNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCgpID0+IGNsaWVudC50ZXJtaW5hdGUoKSk7XHJcbiAgICBjbGllbnQuX29mZmxpbmVDb21wb25lbnRzID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIpIHtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcclxuICAgIGNvbnN0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IGF3YWl0IGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCk7XHJcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdJbml0aWFsaXppbmcgT25saW5lQ29tcG9uZW50UHJvdmlkZXInKTtcclxuICAgIGF3YWl0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLCBjbGllbnQuY29uZmlndXJhdGlvbik7XHJcbiAgICAvLyBUaGUgQ3JlZGVudGlhbENoYW5nZUxpc3RlbmVyIG9mIHRoZSBvbmxpbmUgY29tcG9uZW50IHByb3ZpZGVyIHRha2VzXHJcbiAgICAvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9mZmxpbmUgY29tcG9uZW50IHByb3ZpZGVyLlxyXG4gICAgY2xpZW50LnNldENyZWRlbnRpYWxDaGFuZ2VMaXN0ZW5lcih1c2VyID0+IHJlbW90ZVN0b3JlSGFuZGxlQ3JlZGVudGlhbENoYW5nZShvbmxpbmVDb21wb25lbnRQcm92aWRlci5yZW1vdGVTdG9yZSwgdXNlcikpO1xyXG4gICAgY2xpZW50LnNldEFwcENoZWNrVG9rZW5DaGFuZ2VMaXN0ZW5lcigoXywgdXNlcikgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XHJcbiAgICBjbGllbnQuX29ubGluZUNvbXBvbmVudHMgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlcjtcclxufVxyXG4vKipcclxuICogRGVjaWRlcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlcnJvciBhbGxvd3MgdXMgdG8gZ3JhY2VmdWxseSBkaXNhYmxlXHJcbiAqIHBlcnNpc3RlbmNlIChhcyBvcHBvc2VkIHRvIGNyYXNoaW5nIHRoZSBjbGllbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FuRmFsbGJhY2tGcm9tSW5kZXhlZERiRXJyb3IoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcclxuICAgICAgICByZXR1cm4gKGVycm9yLmNvZGUgPT09IENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiB8fFxyXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOSU1QTEVNRU5URUQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikge1xyXG4gICAgICAgIC8vIFRoZXJlIGFyZSBhIGZldyBrbm93biBjaXJjdW1zdGFuY2VzIHdoZXJlIHdlIGNhbiBvcGVuIEluZGV4ZWREYiBidXRcclxuICAgICAgICAvLyB0cnlpbmcgdG8gcmVhZC93cml0ZSB3aWxsIGZhaWwgKGUuZy4gcXVvdGEgZXhjZWVkZWQpLiBGb3JcclxuICAgICAgICAvLyB3ZWxsLXVuZGVyc3Rvb2QgY2FzZXMsIHdlIGF0dGVtcHQgdG8gZGV0ZWN0IHRoZXNlIGFuZCB0aGVuIGdyYWNlZnVsbHlcclxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIC8vIE5PVEU6IFJhdGhlciB0aGFuIGNvbnRpbnVlIHRvIGFkZCB0byB0aGlzIGxpc3QsIHdlIGNvdWxkIGRlY2lkZSB0b1xyXG4gICAgICAgIC8vIGFsd2F5cyBmYWxsIGJhY2ssIHdpdGggdGhlIHJpc2sgdGhhdCB3ZSBtaWdodCBhY2NpZGVudGFsbHkgaGlkZSBlcnJvcnNcclxuICAgICAgICAvLyByZXByZXNlbnRpbmcgYWN0dWFsIFNESyBidWdzLlxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgYnJvd3NlciBpcyBvdXQgb2YgcXVvdGEgd2UgY291bGQgZ2V0IGVpdGhlciBxdW90YSBleGNlZWRlZFxyXG4gICAgICAgIC8vIG9yIGFuIGFib3J0ZWQgZXJyb3IgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVycm9yIGhhcHBlbmVkIGR1cmluZ1xyXG4gICAgICAgIC8vIHNjaGVtYSBtaWdyYXRpb24uXHJcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9RVU9UQV9FWENFRURFRCB8fFxyXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBET01fRVhDRVBUSU9OX0FCT1JURUQgfHxcclxuICAgICAgICAgICAgLy8gRmlyZWZveCBQcml2YXRlIEJyb3dzaW5nIG1vZGUgZGlzYWJsZXMgSW5kZXhlZERiIGFuZCByZXR1cm5zXHJcbiAgICAgICAgICAgIC8vIElOVkFMSURfU1RBVEUgZm9yIGFueSB1c2FnZS5cclxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9JTlZBTElEX1NUQVRFKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkge1xyXG4gICAgaWYgKCFjbGllbnQuX29mZmxpbmVDb21wb25lbnRzKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyB1c2VyIHByb3ZpZGVkIE9mZmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyLl9vZmZsaW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5GYWxsYmFja0Zyb21JbmRleGVkRGJFcnJvcihlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0Vycm9yIHVzaW5nIHVzZXIgcHJvdmlkZWQgY2FjaGUuIEZhbGxpbmcgYmFjayB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnbWVtb3J5IGNhY2hlOiAnICtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBuZXcgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyBkZWZhdWx0IE9mZmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBuZXcgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjbGllbnQuX29mZmxpbmVDb21wb25lbnRzO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KSB7XHJcbiAgICBpZiAoIWNsaWVudC5fb25saW5lQ29tcG9uZW50cykge1xyXG4gICAgICAgIGlmIChjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnVXNpbmcgdXNlciBwcm92aWRlZCBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb25saW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIGRlZmF1bHQgT25saW5lQ29tcG9uZW50UHJvdmlkZXInKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsaWVudC5fb25saW5lQ29tcG9uZW50cztcclxufVxyXG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW5jZShjbGllbnQpIHtcclxuICAgIHJldHVybiBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLnBlcnNpc3RlbmNlKTtcclxufVxyXG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JlKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMubG9jYWxTdG9yZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVtb3RlU3RvcmUoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLnJlbW90ZVN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTeW5jRW5naW5lKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5zeW5jRW5naW5lKTtcclxufVxyXG5mdW5jdGlvbiBnZXREYXRhc3RvcmUoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLmRhdGFzdG9yZSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCkge1xyXG4gICAgY29uc3Qgb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBhd2FpdCBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCk7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlci5ldmVudE1hbmFnZXI7XHJcbiAgICBldmVudE1hbmFnZXIub25MaXN0ZW4gPSBzeW5jRW5naW5lTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XHJcbiAgICBldmVudE1hbmFnZXIub25Vbmxpc3RlbiA9IHN5bmNFbmdpbmVVbmxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xyXG4gICAgZXZlbnRNYW5hZ2VyLm9uRmlyc3RSZW1vdGVTdG9yZUxpc3RlbiA9IHRyaWdnZXJSZW1vdGVTdG9yZUxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xyXG4gICAgZXZlbnRNYW5hZ2VyLm9uTGFzdFJlbW90ZVN0b3JlVW5saXN0ZW4gPSB0cmlnZ2VyUmVtb3RlU3RvcmVVbmxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xyXG4gICAgcmV0dXJuIGV2ZW50TWFuYWdlcjtcclxufVxyXG4vKiogRW5hYmxlcyB0aGUgbmV0d29yayBjb25uZWN0aW9uIGFuZCByZS1lbnF1ZXVlcyBhbGwgcGVuZGluZyBvcGVyYXRpb25zLiAqL1xyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRFbmFibGVOZXR3b3JrKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gYXdhaXQgZ2V0UGVyc2lzdGVuY2UoY2xpZW50KTtcclxuICAgICAgICBjb25zdCByZW1vdGVTdG9yZSA9IGF3YWl0IGdldFJlbW90ZVN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgcGVyc2lzdGVuY2Uuc2V0TmV0d29ya0VuYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKiogRGlzYWJsZXMgdGhlIG5ldHdvcmsgY29ubmVjdGlvbi4gUGVuZGluZyBvcGVyYXRpb25zIHdpbGwgbm90IGNvbXBsZXRlLiAqL1xyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnREaXNhYmxlTmV0d29yayhjbGllbnQpIHtcclxuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IGF3YWl0IGdldFBlcnNpc3RlbmNlKGNsaWVudCk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlU3RvcmUgPSBhd2FpdCBnZXRSZW1vdGVTdG9yZShjbGllbnQpO1xyXG4gICAgICAgIHBlcnNpc3RlbmNlLnNldE5ldHdvcmtFbmFibGVkKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlU3RvcmVEaXNhYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCB3cml0ZXMgdGhhdCB3ZXJlIHBlbmRpbmcgYXQgdGhlIHRpbWVcclxuICogdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCByZWNlaXZlZCBzZXJ2ZXIgYWNrbm93bGVkZ2VtZW50LiBBbiBhY2tub3dsZWRnZW1lbnRcclxuICogY2FuIGJlIGVpdGhlciBhY2NlcHRhbmNlIG9yIHJlamVjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFdhaXRGb3JQZW5kaW5nV3JpdGVzKGNsaWVudCkge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSBhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVSZWdpc3RlclBlbmRpbmdXcml0ZXNDYWxsYmFjayhzeW5jRW5naW5lLCBkZWZlcnJlZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudExpc3RlbihjbGllbnQsIHF1ZXJ5LCBvcHRpb25zLCBvYnNlcnZlcikge1xyXG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCBvcHRpb25zKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xyXG4gICAgICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgd3JhcHBlZE9ic2VydmVyLm11dGUoKTtcclxuICAgICAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRGcm9tTG9jYWxDYWNoZShjbGllbnQsIGRvY0tleSkge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHJlYWREb2N1bWVudEZyb21DYWNoZShsb2NhbFN0b3JlLCBkb2NLZXksIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwga2V5LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gcmVhZERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGNsaWVudC5hc3luY1F1ZXVlLCBrZXksIG9wdGlvbnMsIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzRnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBxdWVyeSkge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeUZyb21DYWNoZShsb2NhbFN0b3JlLCBxdWVyeSwgZGVmZXJyZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnksIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xyXG4gICAgICAgIHJldHVybiBleGVjdXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgY2xpZW50LmFzeW5jUXVldWUsIHF1ZXJ5LCBvcHRpb25zLCBkZWZlcnJlZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyBJbXBsZW1lbnQgYW5kIGNhbGwgZXhlY3V0ZUFnZ3JlZ2F0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lciwgc2ltaWxhclxyXG4gICAgICAgIC8vIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBpbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyXHJcbiAgICAgICAgLy8gYWJvdmVcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBUT0RPKGIvMjc3NjI4Mzg0KTogY2hlY2sgYGNhblVzZU5ldHdvcmsoKWAgYW5kIGhhbmRsZSBtdWx0aS10YWIuXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzdG9yZSA9IGF3YWl0IGdldERhdGFzdG9yZShjbGllbnQpO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGludm9rZVJ1bkFnZ3JlZ2F0aW9uUXVlcnlScGMoZGF0YXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucykge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSBhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVXcml0ZShzeW5jRW5naW5lLCBtdXRhdGlvbnMsIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50QWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoY2xpZW50LCBvYnNlcnZlcikge1xyXG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xyXG4gICAgICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGFuIHVwZGF0ZUZ1bmN0aW9uIGluIHdoaWNoIGEgc2V0IG9mIHJlYWRzIGFuZCB3cml0ZXMgY2FuIGJlIHBlcmZvcm1lZFxyXG4gKiBhdG9taWNhbGx5LiBJbiB0aGUgdXBkYXRlRnVuY3Rpb24sIHRoZSBjbGllbnQgY2FuIHJlYWQgYW5kIHdyaXRlIHZhbHVlc1xyXG4gKiB1c2luZyB0aGUgc3VwcGxpZWQgdHJhbnNhY3Rpb24gb2JqZWN0LiBBZnRlciB0aGUgdXBkYXRlRnVuY3Rpb24sIGFsbFxyXG4gKiBjaGFuZ2VzIHdpbGwgYmUgY29tbWl0dGVkLiBJZiBhIHJldHJ5YWJsZSBlcnJvciBvY2N1cnMgKGV4OiBzb21lIG90aGVyXHJcbiAqIGNsaWVudCBoYXMgY2hhbmdlZCBhbnkgb2YgdGhlIGRhdGEgcmVmZXJlbmNlZCksIHRoZW4gdGhlIHVwZGF0ZUZ1bmN0aW9uXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFnYWluIGFmdGVyIGEgYmFja29mZi4gSWYgdGhlIHVwZGF0ZUZ1bmN0aW9uIHN0aWxsIGZhaWxzXHJcbiAqIGFmdGVyIGFsbCByZXRyaWVzLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlamVjdGVkLlxyXG4gKlxyXG4gKiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgdXBkYXRlRnVuY3Rpb24gY29udGFpbnMgbWV0aG9kcyBmb3JcclxuICogYWNjZXNzaW5nIGRvY3VtZW50cyBhbmQgY29sbGVjdGlvbnMuIFVubGlrZSBvdGhlciBkYXRhc3RvcmUgYWNjZXNzLCBkYXRhXHJcbiAqIGFjY2Vzc2VkIHdpdGggdGhlIHRyYW5zYWN0aW9uIHdpbGwgbm90IHJlZmxlY3QgbG9jYWwgY2hhbmdlcyB0aGF0IGhhdmUgbm90XHJcbiAqIGJlZW4gY29tbWl0dGVkLiBGb3IgdGhpcyByZWFzb24sIGl0IGlzIHJlcXVpcmVkIHRoYXQgYWxsIHJlYWRzIGFyZVxyXG4gKiBwZXJmb3JtZWQgYmVmb3JlIGFueSB3cml0ZXMuIFRyYW5zYWN0aW9ucyBtdXN0IGJlIHBlcmZvcm1lZCB3aGlsZSBvbmxpbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRUcmFuc2FjdGlvbihjbGllbnQsIHVwZGF0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgbmV3IFRyYW5zYWN0aW9uUnVubmVyKGNsaWVudC5hc3luY1F1ZXVlLCBkYXRhc3RvcmUsIG9wdGlvbnMsIHVwZGF0ZUZ1bmN0aW9uLCBkZWZlcnJlZCkucnVuKCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWREb2N1bWVudEZyb21DYWNoZShsb2NhbFN0b3JlLCBkb2NLZXksIHJlc3VsdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IGxvY2FsU3RvcmVSZWFkRG9jdW1lbnQobG9jYWxTdG9yZSwgZG9jS2V5KTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoZG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gY2FjaGUuIChIb3dldmVyLCB0aGlzIGRvY3VtZW50IG1heSAnICtcclxuICAgICAgICAgICAgICAgIFwiZXhpc3Qgb24gdGhlIHNlcnZlci4gUnVuIGFnYWluIHdpdGhvdXQgc2V0dGluZyAnc291cmNlJyBpbiBcIiArXHJcbiAgICAgICAgICAgICAgICAndGhlIEdldE9wdGlvbnMgdG8gYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgJyArXHJcbiAgICAgICAgICAgICAgICAnc2VydmVyLiknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBnZXQgZG9jdW1lbnQgJyR7ZG9jS2V5fSBmcm9tIGNhY2hlYCk7XHJcbiAgICAgICAgcmVzdWx0LnJlamVjdChmaXJlc3RvcmVFcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgZG9jdW1lbnQgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxyXG4gKiBTbmFwc2hvdExpc3RlbmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgcmVzdWx0KSB7XHJcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcih7XHJcbiAgICAgICAgbmV4dDogKHNuYXApID0+IHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gdXNlciBhY3Rpb25zIGFmZmVjdGluZyB0aGUgbm93IHN0YWxlIHF1ZXJ5LlxyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdHMgPSBzbmFwLmRvY3MuaGFzKGtleSk7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RzICYmIHNuYXAuZnJvbUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElmIHdlJ3JlIG9ubGluZSBhbmQgdGhlIGRvY3VtZW50IGRvZXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGV4aXN0IHRoZW4gd2UgcmVzb2x2ZSB3aXRoIGEgZG9jLmV4aXN0cyBzZXQgdG8gZmFsc2UuIElmXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBvZmZsaW5lIGhvd2V2ZXIsIHdlIHJlamVjdCB0aGUgUHJvbWlzZSBpbiB0aGlzXHJcbiAgICAgICAgICAgICAgICAvLyBjYXNlLiBUd28gb3B0aW9uczogMSkgQ2FjaGUgdGhlIG5lZ2F0aXZlIHJlc3BvbnNlIGZyb21cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgc28gd2UgY2FuIGRlbGl2ZXIgdGhhdCBldmVuIHdoZW4geW91J3JlXHJcbiAgICAgICAgICAgICAgICAvLyBvZmZsaW5lIDIpIEFjdHVhbGx5IHJlamVjdCB0aGUgUHJvbWlzZSBpbiB0aGUgb25saW5lIGNhc2VcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnQgYmVjYXVzZSB0aGUgY2xpZW50IGlzIG9mZmxpbmUuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0cyAmJlxyXG4gICAgICAgICAgICAgICAgc25hcC5mcm9tQ2FjaGUgJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID09PSAnc2VydmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnQgZnJvbSBzZXJ2ZXIuIChIb3dldmVyLCB0aGlzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudCBkb2VzIGV4aXN0IGluIHRoZSBsb2NhbCBjYWNoZS4gUnVuIGFnYWluICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JldHJpZXZlIHRoZSBjYWNoZWQgZG9jdW1lbnQuKScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKHNuYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZSA9PiByZXN1bHQucmVqZWN0KGUpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSwgd3JhcHBlZE9ic2VydmVyLCB7XHJcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogdHJ1ZSxcclxuICAgICAgICB3YWl0Rm9yU3luY1doZW5PbmxpbmU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV2ZW50TWFuYWdlckxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIHJlc3VsdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkobG9jYWxTdG9yZSwgcXVlcnksIFxyXG4gICAgICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBWaWV3KHF1ZXJ5LCBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzKTtcclxuICAgICAgICBjb25zdCB2aWV3RG9jQ2hhbmdlcyA9IHZpZXcuY29tcHV0ZURvY0NoYW5nZXMocXVlcnlSZXN1bHQuZG9jdW1lbnRzKTtcclxuICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxyXG4gICAgICAgIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIGZhbHNlKTtcclxuICAgICAgICByZXN1bHQucmVzb2x2ZSh2aWV3Q2hhbmdlLnNuYXBzaG90KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gZXhlY3V0ZSBxdWVyeSAnJHtxdWVyeX0gYWdhaW5zdCBjYWNoZWApO1xyXG4gICAgICAgIHJlc3VsdC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSBsYXRlbmN5LWNvbXBlbnNhdGVkIHF1ZXJ5IHNuYXBzaG90IGZyb20gdGhlIGJhY2tlbmQgdmlhIGFcclxuICogU25hcHNob3RMaXN0ZW5lci5cclxuICovXHJcbmZ1bmN0aW9uIGV4ZWN1dGVRdWVyeVZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBhc3luY1F1ZXVlLCBxdWVyeSwgb3B0aW9ucywgcmVzdWx0KSB7XHJcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcih7XHJcbiAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgcXVlcnkgZmlyc3QgYmVmb3JlIHBhc3NpbmcgZXZlbnQgdG8gdXNlciB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyB1c2VyIGFjdGlvbnMgYWZmZWN0aW5nIHRoZSBub3cgc3RhbGUgcXVlcnkuXHJcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSk7XHJcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdC5mcm9tQ2FjaGUgJiYgb3B0aW9ucy5zb3VyY2UgPT09ICdzZXJ2ZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudHMgZnJvbSBzZXJ2ZXIuIChIb3dldmVyLCB0aGVzZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnZG9jdW1lbnRzIG1heSBleGlzdCBpbiB0aGUgbG9jYWwgY2FjaGUuIFJ1biBhZ2FpbiAnICtcclxuICAgICAgICAgICAgICAgICAgICAnd2l0aG91dCBzZXR0aW5nIHNvdXJjZSB0byBcInNlcnZlclwiIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50cy4pJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoc25hcHNob3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZSA9PiByZXN1bHQucmVqZWN0KGUpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIocXVlcnksIHdyYXBwZWRPYnNlcnZlciwge1xyXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXHJcbiAgICAgICAgd2FpdEZvclN5bmNXaGVuT25saW5lOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50TG9hZEJ1bmRsZShjbGllbnQsIGRhdGFiYXNlSWQsIGRhdGEsIHJlc3VsdFRhc2spIHtcclxuICAgIGNvbnN0IHJlYWRlciA9IGNyZWF0ZUJ1bmRsZVJlYWRlcihkYXRhLCBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHN5bmNFbmdpbmVMb2FkQnVuZGxlKGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KSwgcmVhZGVyLCByZXN1bHRUYXNrKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldE5hbWVkUXVlcnkoY2xpZW50LCBxdWVyeU5hbWUpIHtcclxuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IGxvY2FsU3RvcmVHZXROYW1lZFF1ZXJ5KGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgcXVlcnlOYW1lKSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlUmVhZGVyKGRhdGEsIHNlcmlhbGl6ZXIpIHtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnRlbnQgPSBuZXdUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnQgPSBkYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0J1bmRsZVJlYWRlcih0b0J5dGVTdHJlYW1SZWFkZXIoY29udGVudCksIHNlcmlhbGl6ZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFNldEluZGV4Q29uZmlndXJhdGlvbihjbGllbnQsIGluZGV4ZXMpIHtcclxuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUNvbmZpZ3VyZUZpZWxkSW5kZXhlcyhhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCksIGluZGV4ZXMpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50U2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGNsaWVudCwgaXNFbmFibGVkKSB7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVTZXRJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpLCBpc0VuYWJsZWQpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RGVsZXRlQWxsRmllbGRJbmRleGVzKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlRGVsZXRlQWxsRmllbGRJbmRleGVzKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSk7XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIGBFeHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnNgIG9iamVjdHMgZm9yIGVxdWFsaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XHJcbiAgICByZXR1cm4gb3B0aW9uczEudGltZW91dFNlY29uZHMgPT09IG9wdGlvbnMyLnRpbWVvdXRTZWNvbmRzO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBFeHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnNgIHdpdGggdGhlIHNhbWVcclxuICogb3B0aW9uIHZhbHVlcyBhcyB0aGUgZ2l2ZW4gaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjbG9uZSA9IHt9O1xyXG4gICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNsb25lLnRpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcztcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDEgPSAnQ29tcG9uZW50UHJvdmlkZXInO1xyXG4vKipcclxuICogQW4gaW5zdGFuY2UgbWFwIHRoYXQgZW5zdXJlcyBvbmx5IG9uZSBEYXRhc3RvcmUgZXhpc3RzIHBlciBGaXJlc3RvcmVcclxuICogaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBkYXRhc3RvcmVJbnN0YW5jZXMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuIE11c3QgYmUgY2FsbGVkXHJcbiAqIHdoZW4gdGhlIGBGaXJlc3RvcmVgIGluc3RhbmNlIGlzIHRlcm1pbmF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVDb21wb25lbnRzKGZpcmVzdG9yZSkge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlID0gZGF0YXN0b3JlSW5zdGFuY2VzLmdldChmaXJlc3RvcmUpO1xyXG4gICAgaWYgKGRhdGFzdG9yZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ1JlbW92aW5nIERhdGFzdG9yZScpO1xyXG4gICAgICAgIGRhdGFzdG9yZUluc3RhbmNlcy5kZWxldGUoZmlyZXN0b3JlKTtcclxuICAgICAgICBkYXRhc3RvcmUudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFrZURhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzLmhvc3QsIHNldHRpbmdzLnNzbCwgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpLCBzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIHNldHRpbmdzKCkgZGVmYXVsdHM6XHJcbmNvbnN0IERFRkFVTFRfSE9TVCA9ICdmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb20nO1xyXG5jb25zdCBERUZBVUxUX1NTTCA9IHRydWU7XHJcbi8vIFRoZSBtaW5pbXVtIGxvbmctcG9sbGluZyB0aW1lb3V0IGlzIGhhcmRjb2RlZCBvbiB0aGUgc2VydmVyLiBUaGUgdmFsdWUgaGVyZVxyXG4vLyBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHZhbHVlIHVzZWQgYnkgdGhlIHNlcnZlciwgYXMgdGhlIHNlcnZlciB3aWxsXHJcbi8vIHNpbGVudGx5IGlnbm9yZSBhIHZhbHVlIGJlbG93IHRoZSBtaW5pbXVtIGFuZCBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQuXHJcbi8vIEdvb2dsZXJzIHNlZSBiLzI2Njg2ODg3MSBmb3IgcmVsZXZhbnQgZGlzY3Vzc2lvbi5cclxuY29uc3QgTUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMgPSA1O1xyXG4vLyBObyBtYXhpbXVtIGxvbmctcG9sbGluZyB0aW1lb3V0IGlzIGNvbmZpZ3VyZWQgaW4gdGhlIHNlcnZlciwgYW5kIGRlZmF1bHRzIHRvXHJcbi8vIDMwIHNlY29uZHMsIHdoaWNoIGlzIHdoYXQgV2F0Y2ggYXBwZWFycyB0byB1c2UuXHJcbi8vIEdvb2dsZXJzIHNlZSBiLzI2Njg2ODg3MSBmb3IgcmVsZXZhbnQgZGlzY3Vzc2lvbi5cclxuY29uc3QgTUFYX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMgPSAzMDtcclxuLy8gV2hldGhlciBsb25nLXBvbGxpbmcgYXV0by1kZXRlY3RlZCBpcyBlbmFibGVkIGJ5IGRlZmF1bHQuXHJcbmNvbnN0IERFRkFVTFRfQVVUT19ERVRFQ1RfTE9OR19QT0xMSU5HID0gdHJ1ZTtcclxuLyoqXHJcbiAqIEEgY29uY3JldGUgdHlwZSBkZXNjcmliaW5nIGFsbCB0aGUgdmFsdWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdmlhIGFcclxuICogdXNlci1zdXBwbGllZCBgRmlyZXN0b3JlU2V0dGluZ3NgIG9iamVjdC4gVGhpcyBpcyBhIHNlcGFyYXRlIHR5cGUgc28gdGhhdFxyXG4gKiBkZWZhdWx0cyBjYW4gYmUgc3VwcGxpZWQgYW5kIHRoZSB2YWx1ZSBjYW4gYmUgY2hlY2tlZCBmb3IgZXF1YWxpdHkuXHJcbiAqL1xyXG5jbGFzcyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwge1xyXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5ob3N0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNzbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHByb3ZpZGUgc3NsIG9wdGlvbiBpZiBob3N0IG9wdGlvbiBpcyBub3Qgc2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IERFRkFVTFRfSE9TVDtcclxuICAgICAgICAgICAgdGhpcy5zc2wgPSBERUZBVUxUX1NTTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IHNldHRpbmdzLmhvc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuc3NsID0gKF9hID0gc2V0dGluZ3Muc3NsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1NTTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHNldHRpbmdzLmNyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9ICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcclxuICAgICAgICB0aGlzLmxvY2FsQ2FjaGUgPSBzZXR0aW5ncy5sb2NhbENhY2hlO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBMUlVfREVGQVVMVF9DQUNIRV9TSVpFX0JZVEVTO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCAmJlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgPCBMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGVTaXplQnl0ZXMgbXVzdCBiZSBhdCBsZWFzdCAke0xSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVN9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlcignZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcsICdleHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcnLCBzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcpO1xyXG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9ICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZztcclxuICAgICAgICBpZiAodGhpcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID0gREVGQVVMVF9BVVRPX0RFVEVDVF9MT05HX1BPTExJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGNvZXJjZSB0aGUgdmFsdWUgdG8gYm9vbGVhbiBldmVuIHRob3VnaFxyXG4gICAgICAgICAgICAvLyB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBoYXMgbmFycm93ZWQgdGhlIHR5cGUgdG8gYm9vbGVhbiBhbHJlYWR5LlxyXG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gUG9pbnRsZXNzQm9vbGVhbkV4cHJlc3Npb25KU1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9XHJcbiAgICAgICAgICAgICAgICAhIXNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMgPSBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucygoX2IgPSBzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KTtcclxuICAgICAgICB2YWxpZGF0ZUxvbmdQb2xsaW5nT3B0aW9ucyh0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPSAhIXNldHRpbmdzLnVzZUZldGNoU3RyZWFtcztcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaG9zdCA9PT0gb3RoZXIuaG9zdCAmJlxyXG4gICAgICAgICAgICB0aGlzLnNzbCA9PT0gb3RoZXIuc3NsICYmXHJcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPT09IG90aGVyLmNyZWRlbnRpYWxzICYmXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPT09IG90aGVyLmNhY2hlU2l6ZUJ5dGVzICYmXHJcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9PT1cclxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgJiZcclxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPT09XHJcbiAgICAgICAgICAgICAgICBvdGhlci5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgJiZcclxuICAgICAgICAgICAgbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwodGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMsIG90aGVyLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucykgJiZcclxuICAgICAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID09PSBvdGhlci5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzICYmXHJcbiAgICAgICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID09PSBvdGhlci51c2VGZXRjaFN0cmVhbXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTG9uZ1BvbGxpbmdPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoaXNOYU4ob3B0aW9ucy50aW1lb3V0U2Vjb25kcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGludmFsaWQgbG9uZyBwb2xsaW5nIHRpbWVvdXQ6IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gKG11c3Qgbm90IGJlIE5hTilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgPCBNSU5fTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSBgICtcclxuICAgICAgICAgICAgICAgIGAobWluaW11bSBhbGxvd2VkIHZhbHVlIGlzICR7TUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFN9KWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyA+IE1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBpbnZhbGlkIGxvbmcgcG9sbGluZyB0aW1lb3V0OiAke29wdGlvbnMudGltZW91dFNlY29uZHN9IGAgK1xyXG4gICAgICAgICAgICAgICAgYChtYXhpbXVtIGFsbG93ZWQgdmFsdWUgaXMgJHtNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EU30pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgQ2xvdWQgRmlyZXN0b3JlIHNlcnZpY2UgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Uge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9LlxyXG4gKi9cclxuY2xhc3MgRmlyZXN0b3JlJDEge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9hdXRoQ3JlZGVudGlhbHMsIF9hcHBDaGVja0NyZWRlbnRpYWxzLCBfZGF0YWJhc2VJZCwgX2FwcCkge1xyXG4gICAgICAgIHRoaXMuX2F1dGhDcmVkZW50aWFscyA9IF9hdXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5fYXBwQ2hlY2tDcmVkZW50aWFscyA9IF9hcHBDaGVja0NyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuX2RhdGFiYXNlSWQgPSBfZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLl9hcHAgPSBfYXBwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgaXQncyBhIEZpcmVzdG9yZSBvciBGaXJlc3RvcmUgTGl0ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlLWxpdGUnO1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlS2V5ID0gJyhsaXRlKSc7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBuZXcgRmlyZXN0b3JlU2V0dGluZ3NJbXBsKHt9KTtcclxuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGBGaXJlc3RvcmVgIHNlcnZpY2VcclxuICAgICAqIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXQgYXBwKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYXBwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFwiRmlyZXN0b3JlIHdhcyBub3QgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIEZpcmViYXNlIFNESy4gJ2FwcCcgaXMgXCIgK1xyXG4gICAgICAgICAgICAgICAgJ25vdCBhdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcDtcclxuICAgIH1cclxuICAgIGdldCBfaW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzRnJvemVuO1xyXG4gICAgfVxyXG4gICAgZ2V0IF90ZXJtaW5hdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXJtaW5hdGVUYXNrICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBfc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3NGcm96ZW4pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0ZpcmVzdG9yZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgYW5kIGl0cyBzZXR0aW5ncyBjYW4gbm8gbG9uZ2VyICcgK1xyXG4gICAgICAgICAgICAgICAgJ2JlIGNoYW5nZWQuIFlvdSBjYW4gb25seSBtb2RpZnkgc2V0dGluZ3MgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xyXG4gICAgICAgICAgICAgICAgJ21ldGhvZHMgb24gYSBGaXJlc3RvcmUgb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoc2V0dGluZ3MpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1dGhDcmVkZW50aWFscyA9IG1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihzZXR0aW5ncy5jcmVkZW50aWFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFNldHRpbmdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcclxuICAgIH1cclxuICAgIF9mcmVlemVTZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xyXG4gICAgfVxyXG4gICAgX2RlbGV0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Rlcm1pbmF0ZVRhc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fdGVybWluYXRlVGFzayA9IHRoaXMuX3Rlcm1pbmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzaztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgRmlyZXN0b3JlYCBpbnN0YW5jZS4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhcHA6IHRoaXMuX2FwcCxcclxuICAgICAgICAgICAgZGF0YWJhc2VJZDogdGhpcy5fZGF0YWJhc2VJZCxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuX3NldHRpbmdzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVybWluYXRlcyBhbGwgY29tcG9uZW50cyB1c2VkIGJ5IHRoaXMgY2xpZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxyXG4gICAgICogdGhpcyBtZXRob2QgdG8gY2xlYW4gdXAgdGhlaXIgb3duIGRlcGVuZGVuY2llcywgYnV0IG11c3QgYWxzbyBjYWxsIHRoaXNcclxuICAgICAqIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBPbmx5IGV2ZXIgY2FsbGVkIG9uY2UuXHJcbiAgICAgKi9cclxuICAgIF90ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgcmVtb3ZlQ29tcG9uZW50cyh0aGlzKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1vZGlmeSB0aGlzIGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIEZpcmVzdG9yZSBlbXVsYXRvci5cclxuICpcclxuICogTm90ZTogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIHRvIGRvIGFueVxyXG4gKiBvcGVyYXRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIGBGaXJlc3RvcmVgIGluc3RhbmNlIHRvIGNvbmZpZ3VyZSB0byBjb25uZWN0IHRvIHRoZVxyXG4gKiBlbXVsYXRvci5cclxuICogQHBhcmFtIGhvc3QgLSB0aGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdCkuXHJcbiAqIEBwYXJhbSBwb3J0IC0gdGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA5MDAwKS5cclxuICogQHBhcmFtIG9wdGlvbnMubW9ja1VzZXJUb2tlbiAtIHRoZSBtb2NrIGF1dGggdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmdcclxuICogU2VjdXJpdHkgUnVsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IoZmlyZXN0b3JlLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcclxuICAgIHZhciBfYTtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUkMSk7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZ2V0U2V0dGluZ3MoKTtcclxuICAgIGNvbnN0IG5ld0hvc3RTZXR0aW5nID0gYCR7aG9zdH06JHtwb3J0fWA7XHJcbiAgICBpZiAoc2V0dGluZ3MuaG9zdCAhPT0gREVGQVVMVF9IT1NUICYmIHNldHRpbmdzLmhvc3QgIT09IG5ld0hvc3RTZXR0aW5nKSB7XHJcbiAgICAgICAgbG9nV2FybignSG9zdCBoYXMgYmVlbiBzZXQgaW4gYm90aCBzZXR0aW5ncygpIGFuZCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IoKSwgZW11bGF0b3IgaG9zdCAnICtcclxuICAgICAgICAgICAgJ3dpbGwgYmUgdXNlZC4nKTtcclxuICAgIH1cclxuICAgIGZpcmVzdG9yZS5fc2V0U2V0dGluZ3MoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyksIHsgaG9zdDogbmV3SG9zdFNldHRpbmcsIHNzbDogZmFsc2UgfSkpO1xyXG4gICAgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgIGxldCB0b2tlbjtcclxuICAgICAgICBsZXQgdXNlcjtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBvcHRpb25zLm1vY2tVc2VyVG9rZW47XHJcbiAgICAgICAgICAgIHVzZXIgPSBVc2VyLk1PQ0tfVVNFUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIExldCBjcmVhdGVNb2NrVXNlclRva2VuIHZhbGlkYXRlIGZpcnN0IChjYXRjaGVzIGNvbW1vbiBtaXN0YWtlcyBsaWtlXHJcbiAgICAgICAgICAgIC8vIGludmFsaWQgZmllbGQgXCJ1aWRcIiBhbmQgbWlzc2luZyBmaWVsZCBcInN1YlwiIC8gXCJ1c2VyX2lkXCIuKVxyXG4gICAgICAgICAgICB0b2tlbiA9IGNyZWF0ZU1vY2tVc2VyVG9rZW4ob3B0aW9ucy5tb2NrVXNlclRva2VuLCAoX2EgPSBmaXJlc3RvcmUuX2FwcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgICAgICAgICAgY29uc3QgdWlkID0gb3B0aW9ucy5tb2NrVXNlclRva2VuLnN1YiB8fCBvcHRpb25zLm1vY2tVc2VyVG9rZW4udXNlcl9pZDtcclxuICAgICAgICAgICAgaWYgKCF1aWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1c2VyID0gbmV3IFVzZXIodWlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlyZXN0b3JlLl9hdXRoQ3JlZGVudGlhbHMgPSBuZXcgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihuZXcgT0F1dGhUb2tlbih0b2tlbiwgdXNlcikpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGBRdWVyeWAgcmVmZXJzIHRvIGEgcXVlcnkgd2hpY2ggeW91IGNhbiByZWFkIG9yIGxpc3RlbiB0by4gWW91IGNhbiBhbHNvXHJcbiAqIGNvbnN0cnVjdCByZWZpbmVkIGBRdWVyeWAgb2JqZWN0cyBieSBhZGRpbmcgZmlsdGVycyBhbmQgb3JkZXJpbmcuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeSB7XHJcbiAgICAvLyBUaGlzIGlzIHRoZSBsaXRlIHZlcnNpb24gb2YgdGhlIFF1ZXJ5IGNsYXNzIGluIHRoZSBtYWluIFNESy5cclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcclxuICAgIC8qKlxyXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRlciwgX3F1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XHJcbiAgICAgICAgdGhpcy5fcXVlcnkgPSBfcXVlcnk7XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgRmlyZXN0b3JlIHJlZmVyZW5jZS4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAncXVlcnknO1xyXG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xyXG4gICAgfVxyXG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIHRoaXMuX3F1ZXJ5KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgRG9jdW1lbnRSZWZlcmVuY2VgIHJlZmVycyB0byBhIGRvY3VtZW50IGxvY2F0aW9uIGluIGEgRmlyZXN0b3JlIGRhdGFiYXNlXHJcbiAqIGFuZCBjYW4gYmUgdXNlZCB0byB3cml0ZSwgcmVhZCwgb3IgbGlzdGVuIHRvIHRoZSBsb2NhdGlvbi4gVGhlIGRvY3VtZW50IGF0XHJcbiAqIHRoZSByZWZlcmVuY2VkIGxvY2F0aW9uIG1heSBvciBtYXkgbm90IGV4aXN0LlxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRSZWZlcmVuY2Uge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgXHJcbiAgICAvKipcclxuICAgICAqIElmIHByb3ZpZGVkLCB0aGUgYEZpcmVzdG9yZURhdGFDb252ZXJ0ZXJgIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0ZXIsIF9rZXkpIHtcclxuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2RvY3VtZW50JztcclxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIGdldCBfcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkb2N1bWVudCdzIGlkZW50aWZpZXIgd2l0aGluIGl0cyBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcGF0aCBvZiB0aGUgcmVmZXJlbmNlZCBkb2N1bWVudCAocmVsYXRpdmVcclxuICAgICAqIHRvIHRoZSByb290IG9mIHRoZSBkYXRhYmFzZSkuXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbGxlY3Rpb24gdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGJlbG9uZ3MgdG8uXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCB0aGlzLmNvbnZlcnRlciwgdGhpcy5fa2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgIH1cclxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9rZXkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBDb2xsZWN0aW9uUmVmZXJlbmNlYCBvYmplY3QgY2FuIGJlIHVzZWQgZm9yIGFkZGluZyBkb2N1bWVudHMsIGdldHRpbmdcclxuICogZG9jdW1lbnQgcmVmZXJlbmNlcywgYW5kIHF1ZXJ5aW5nIGZvciBkb2N1bWVudHMgKHVzaW5nIHtAbGluayAocXVlcnk6MSl9KS5cclxuICovXHJcbmNsYXNzIENvbGxlY3Rpb25SZWZlcmVuY2UgZXh0ZW5kcyBRdWVyeSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIF9wYXRoKSB7XHJcbiAgICAgICAgc3VwZXIoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIG5ld1F1ZXJ5Rm9yUGF0aChfcGF0aCkpO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdjb2xsZWN0aW9uJztcclxuICAgIH1cclxuICAgIC8qKiBUaGUgY29sbGVjdGlvbidzIGlkZW50aWZpZXIuICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwYXRoIG9mIHRoZSByZWZlcmVuY2VkIGNvbGxlY3Rpb24gKHJlbGF0aXZlXHJcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5pbmcgYERvY3VtZW50UmVmZXJlbmNlYCBpZiB0aGlzIGlzIGFcclxuICAgICAqIHN1YmNvbGxlY3Rpb24uIElmIHRoaXMgaXNuJ3QgYSBzdWJjb2xsZWN0aW9uLCB0aGUgcmVmZXJlbmNlIGlzIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHRoaXMuX3BhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgIGlmIChwYXJlbnRQYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIFxyXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIG5ldyBEb2N1bWVudEtleShwYXJlbnRQYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIGNvbnZlcnRlciwgdGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29sbGVjdGlvbihwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoJ2NvbGxlY3Rpb24nLCAncGF0aCcsIHBhdGgpO1xyXG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEZpcmVzdG9yZSQxKSB7XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcclxuICAgICAgICB2YWxpZGF0ZUNvbGxlY3Rpb25QYXRoKGFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHBhcmVudCwgLyogY29udmVydGVyPSAqLyBudWxsLCBhYnNvbHV0ZVBhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXHJcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGNvbGxlY3Rpb24oKSB0byBiZSBhIENvbGxlY3Rpb25SZWZlcmVuY2UsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGFyZW50Ll9wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgsIC4uLnBhdGhTZWdtZW50cykpO1xyXG4gICAgICAgIHZhbGlkYXRlQ29sbGVjdGlvblBhdGgoYWJzb2x1dGVQYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgXHJcbiAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBhYnNvbHV0ZVBhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8oZmlyZXN0b3JlbGl0ZSk6IENvbnNpZGVyIHVzaW5nIEVycm9yRmFjdG9yeSAtXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvYmxvYi8wMTMxZTFmL3BhY2thZ2VzL3V0aWwvc3JjL2Vycm9ycy50cyNMMTA2XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBRdWVyeWAgaW5zdGFuY2UgdGhhdCBpbmNsdWRlcyBhbGwgZG9jdW1lbnRzIGluIHRoZVxyXG4gKiBkYXRhYmFzZSB0aGF0IGFyZSBjb250YWluZWQgaW4gYSBjb2xsZWN0aW9uIG9yIHN1YmNvbGxlY3Rpb24gd2l0aCB0aGVcclxuICogZ2l2ZW4gYGNvbGxlY3Rpb25JZGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBBIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBgRmlyZXN0b3JlYCBpbnN0YW5jZS5cclxuICogQHBhcmFtIGNvbGxlY3Rpb25JZCAtIElkZW50aWZpZXMgdGhlIGNvbGxlY3Rpb25zIHRvIHF1ZXJ5IG92ZXIuIEV2ZXJ5XHJcbiAqIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoaXMgSUQgYXMgdGhlIGxhc3Qgc2VnbWVudCBvZiBpdHMgcGF0aFxyXG4gKiB3aWxsIGJlIGluY2x1ZGVkLiBDYW5ub3QgY29udGFpbiBhIHNsYXNoLlxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBgUXVlcnlgLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGVjdGlvbkdyb3VwKGZpcmVzdG9yZSwgY29sbGVjdGlvbklkKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlJDEpO1xyXG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uR3JvdXAnLCAnY29sbGVjdGlvbiBpZCcsIGNvbGxlY3Rpb25JZCk7XHJcbiAgICBpZiAoY29sbGVjdGlvbklkLmluZGV4T2YoJy8nKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXHJcbiAgICAgICAgICAgIGBjb2xsZWN0aW9uR3JvdXAoKS4gQ29sbGVjdGlvbiBJRHMgbXVzdCBub3QgY29udGFpbiAnLycuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXHJcbiAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIG5ld1F1ZXJ5Rm9yQ29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCkpO1xyXG59XHJcbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICAvLyBXZSBhbGxvdyBvbWlzc2lvbiBvZiAncGF0aFN0cmluZycgYnV0IGV4cGxpY2l0bHkgcHJvaGliaXQgcGFzc2luZyBpbiBib3RoXHJcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwYXRoID0gQXV0b0lkLm5ld0lkKCk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoJ2RvYycsICdwYXRoJywgcGF0aCk7XHJcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xyXG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZShwYXJlbnQsIFxyXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXHJcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGNvbGxlY3Rpb24oKSB0byBiZSBhIENvbGxlY3Rpb25SZWZlcmVuY2UsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGFyZW50Ll9wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgsIC4uLnBhdGhTZWdtZW50cykpO1xyXG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZShwYXJlbnQuZmlyZXN0b3JlLCBwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlID8gcGFyZW50LmNvbnZlcnRlciA6IG51bGwsIG5ldyBEb2N1bWVudEtleShhYnNvbHV0ZVBhdGgpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCByZWZlcmVuY2VzIGFyZSBlcXVhbC5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBBIHJlZmVyZW5jZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0gcmlnaHQgLSBBIHJlZmVyZW5jZSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXHJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZkVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBsZWZ0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGxlZnQpO1xyXG4gICAgcmlnaHQgPSBnZXRNb2R1bGFySW5zdGFuY2UocmlnaHQpO1xyXG4gICAgaWYgKChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHxcclxuICAgICAgICBsZWZ0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkgJiZcclxuICAgICAgICAocmlnaHQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSB8fCByaWdodCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIGxlZnQucGF0aCA9PT0gcmlnaHQucGF0aCAmJlxyXG4gICAgICAgICAgICBsZWZ0LmNvbnZlcnRlciA9PT0gcmlnaHQuY29udmVydGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBxdWVyaWVzIHBvaW50IHRvIHRoZSBzYW1lIGNvbGxlY3Rpb24gYW5kIGFwcGx5XHJcbiAqIHRoZSBzYW1lIGNvbnN0cmFpbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVmdCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0gcmlnaHQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeUVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBsZWZ0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGxlZnQpO1xyXG4gICAgcmlnaHQgPSBnZXRNb2R1bGFySW5zdGFuY2UocmlnaHQpO1xyXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeSAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIHF1ZXJ5RXF1YWxzKGxlZnQuX3F1ZXJ5LCByaWdodC5fcXVlcnkpICYmXHJcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUcgPSAnQXN5bmNRdWV1ZSc7XHJcbmNsYXNzIEFzeW5jUXVldWVJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIFRoZSBsYXN0IHByb21pc2UgaW4gdGhlIHF1ZXVlLlxyXG4gICAgICAgIHRoaXMudGFpbCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIC8vIEEgbGlzdCBvZiByZXRyeWFibGUgb3BlcmF0aW9ucy4gUmV0cnlhYmxlIG9wZXJhdGlvbnMgYXJlIHJ1biBpbiBvcmRlciBhbmRcclxuICAgICAgICAvLyByZXRyaWVkIHdpdGggYmFja29mZi5cclxuICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcyA9IFtdO1xyXG4gICAgICAgIC8vIElzIHRoaXMgQXN5bmNRdWV1ZSBiZWluZyBzaHV0IGRvd24/IE9uY2UgaXQgaXMgc2V0IHRvIHRydWUsIGl0IHdpbGwgbm90XHJcbiAgICAgICAgLy8gYmUgY2hhbmdlZCBhZ2Fpbi5cclxuICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IGZhbHNlO1xyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgc2NoZWR1bGVkIHRvIGJlIHF1ZXVlZCBpbiB0aGUgZnV0dXJlLiBPcGVyYXRpb25zIGFyZVxyXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciB0aGV5IGFyZSBydW4gb3IgY2FuY2VsZWQuXHJcbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuICAgICAgICB0aGlzLmZhaWx1cmUgPSBudWxsO1xyXG4gICAgICAgIC8vIEZsYWcgc2V0IHdoaWxlIHRoZXJlJ3MgYW4gb3V0c3RhbmRpbmcgQXN5bmNRdWV1ZSBvcGVyYXRpb24sIHVzZWQgZm9yXHJcbiAgICAgICAgLy8gYXNzZXJ0aW9uIHNhbml0eS1jaGVja3MuXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gRW5hYmxlZCBkdXJpbmcgc2h1dGRvd24gb24gU2FmYXJpIHRvIHByZXZlbnQgZnV0dXJlIGFjY2VzcyB0byBJbmRleGVkREIuXHJcbiAgICAgICAgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gTGlzdCBvZiBUaW1lcklkcyB0byBmYXN0LWZvcndhcmQgZGVsYXlzIGZvci5cclxuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwID0gW107XHJcbiAgICAgICAgLy8gQmFja29mZiB0aW1lciB1c2VkIHRvIHNjaGVkdWxlIHJldHJpZXMgZm9yIHJldHJ5YWJsZSBvcGVyYXRpb25zXHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZih0aGlzLCBcImFzeW5jX3F1ZXVlX3JldHJ5XCIgLyogVGltZXJJZC5Bc3luY1F1ZXVlUmV0cnkgKi8pO1xyXG4gICAgICAgIC8vIFZpc2liaWxpdHkgaGFuZGxlciB0aGF0IHRyaWdnZXJzIGFuIGltbWVkaWF0ZSByZXRyeSBvZiBhbGwgcmV0cnlhYmxlXHJcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gTWVhbnQgdG8gc3BlZWQgdXAgcmVjb3Zlcnkgd2hlbiB3ZSByZWdhaW4gZmlsZSBzeXN0ZW0gYWNjZXNzXHJcbiAgICAgICAgLy8gYWZ0ZXIgcGFnZSBjb21lcyBpbnRvIGZvcmVncm91bmQuXHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnNraXBCYWNrb2ZmKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldCBpc1NodXR0aW5nRG93bigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNTaHV0dGluZ0Rvd247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZSB3aXRob3V0IHdhaXRpbmcgZm9yIGl0IHRvIGNvbXBsZXRlIChpLmUuXHJcbiAgICAgKiB3ZSBpZ25vcmUgdGhlIFByb21pc2UgcmVzdWx0KS5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZUFuZEZvcmdldChvcCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLmVucXVldWUob3ApO1xyXG4gICAgfVxyXG4gICAgZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQob3ApIHtcclxuICAgICAgICB0aGlzLnZlcmlmeU5vdEZhaWxlZCgpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLmVucXVldWVJbnRlcm5hbChvcCk7XHJcbiAgICB9XHJcbiAgICBlbnRlclJlc3RyaWN0ZWRNb2RlKHB1cmdlRXhpc3RpbmdUYXNrcykge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNTaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5faXNTaHV0dGluZ0Rvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNraXBOb25SZXN0cmljdGVkVGFza3MgPSBwdXJnZUV4aXN0aW5nVGFza3MgfHwgZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5xdWV1ZShvcCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzU2h1dHRpbmdEb3duKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBhIFByb21pc2Ugd2hpY2ggbmV2ZXIgcmVzb2x2ZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBQcm9taXNlIHRoYXQgd2UgY2FuIHJldHVybiB0byB0aGUgY2FsbGVlLiBUaGlzXHJcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIHJldHVybiBhIFwiaGFuZ2luZyBQcm9taXNlXCIgb25seSB0byB0aGUgY2FsbGVlIGFuZCBzdGlsbFxyXG4gICAgICAgIC8vIGFkdmFuY2UgdGhlIHF1ZXVlIGV2ZW4gd2hlbiB0aGUgb3BlcmF0aW9uIGlzIG5vdCBydW4uXHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVJbnRlcm5hbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NodXR0aW5nRG93biAmJiB0aGlzLnNraXBOb25SZXN0cmljdGVkVGFza3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCByZXNvbHZlICd0YXNrJ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wKCkudGhlbih0YXNrLnJlc29sdmUsIHRhc2sucmVqZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRhc2sucHJvbWlzZTtcclxuICAgICAgICB9KS50aGVuKCgpID0+IHRhc2sucHJvbWlzZSk7XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlUmV0cnlhYmxlKG9wKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXRyeWFibGVPcHMucHVzaChvcCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5TmV4dE9wKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIG5leHQgb3BlcmF0aW9uIGZyb20gdGhlIHJldHJ5YWJsZSBxdWV1ZS4gSWYgdGhlIG9wZXJhdGlvbiBmYWlscyxcclxuICAgICAqIHJlc2NoZWR1bGVzIHdpdGggYmFja29mZi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmV0cnlOZXh0T3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmV0cnlhYmxlT3BzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmV0cnlhYmxlT3BzWzBdKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmV0cnlhYmxlT3BzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHLCAnT3BlcmF0aW9uIGZhaWxlZCB3aXRoIHJldHJ5YWJsZSBlcnJvcjogJyArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTsgLy8gRmFpbHVyZSB3aWxsIGJlIGhhbmRsZWQgYnkgQXN5bmNRdWV1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJldHJ5YWJsZU9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhZGRpdGlvbmFsIG9wZXJhdGlvbnMsIHdlIHJlLXNjaGVkdWxlIGByZXRyeU5leHRPcCgpYC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gcnVuIHJldHJ5YWJsZSBvcGVyYXRpb25zIHRoYXQgZmFpbGVkIGR1cmluZ1xyXG4gICAgICAgICAgICAvLyB0aGVpciBpbml0aWFsIGF0dGVtcHQgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZXkgYXJlIGFscmVhZHlcclxuICAgICAgICAgICAgLy8gZW5xdWV1ZWQuIElmLCBmb3IgZXhhbXBsZSwgYG9wMWAsIGBvcDJgLCBgb3AzYCBhcmUgZW5xdWV1ZWQgYW5kIGBvcDFgXHJcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvICBiZSByZS1ydW4sIHdlIHdpbGwgcnVuIGBvcDFgLCBgb3AxYCwgYG9wMmAgdXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZW5xdWV1ZWQgY2FsbHMgdG8gYHJldHJ5TmV4dE9wKClgLiBgb3AzKClgIHdpbGwgdGhlbiBydW4gaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIGNhbGwgc2NoZWR1bGVkIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIFNpbmNlIGBiYWNrb2ZmQW5kUnVuKClgIGNhbmNlbHMgYW4gZXhpc3RpbmcgYmFja29mZiBhbmQgc2NoZWR1bGVzIGFcclxuICAgICAgICAgICAgLy8gbmV3IGJhY2tvZmYgb24gZXZlcnkgY2FsbCwgdGhlcmUgaXMgb25seSBldmVyIGEgc2luZ2xlIGFkZGl0aW9uYWxcclxuICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGluIHRoZSBxdWV1ZS5cclxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLmJhY2tvZmZBbmRSdW4oKCkgPT4gdGhpcy5yZXRyeU5leHRPcCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlSW50ZXJuYWwob3ApIHtcclxuICAgICAgICBjb25zdCBuZXdUYWlsID0gdGhpcy50YWlsLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gb3AoKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsdXJlID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBsb2dFcnJvcignSU5URVJOQUwgVU5IQU5ETEVEIEVSUk9SOiAnLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZSBlcnJvciBzbyB0aGF0IHRoaXMudGFpbCBiZWNvbWVzIGEgcmVqZWN0ZWQgUHJvbWlzZSBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGFsbCBmdXJ0aGVyIGF0dGVtcHRzIHRvIGNoYWluICh2aWEgLnRoZW4pIHdpbGwganVzdCBzaG9ydC1jaXJjdWl0XHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSByZWplY3RlZCBQcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnRhaWwgPSBuZXdUYWlsO1xyXG4gICAgICAgIHJldHVybiBuZXdUYWlsO1xyXG4gICAgfVxyXG4gICAgZW5xdWV1ZUFmdGVyRGVsYXkodGltZXJJZCwgZGVsYXlNcywgb3ApIHtcclxuICAgICAgICB0aGlzLnZlcmlmeU5vdEZhaWxlZCgpO1xyXG4gICAgICAgIC8vIEZhc3QtZm9yd2FyZCBkZWxheXMgZm9yIHRpbWVySWRzIHRoYXQgaGF2ZSBiZWVuIG92ZXJyaWRlbi5cclxuICAgICAgICBpZiAodGhpcy50aW1lcklkc1RvU2tpcC5pbmRleE9mKHRpbWVySWQpID4gLTEpIHtcclxuICAgICAgICAgICAgZGVsYXlNcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlbGF5ZWRPcCA9IERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUodGhpcywgdGltZXJJZCwgZGVsYXlNcywgb3AsIHJlbW92ZWRPcCA9PiB0aGlzLnJlbW92ZURlbGF5ZWRPcGVyYXRpb24ocmVtb3ZlZE9wKSk7XHJcbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5wdXNoKGRlbGF5ZWRPcCk7XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRPcDtcclxuICAgIH1cclxuICAgIHZlcmlmeU5vdEZhaWxlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5mYWlsdXJlKSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0cyB1bnRpbCBhbGwgY3VycmVudGx5IHF1ZXVlZCB0YXNrcyBhcmUgZmluaXNoZWQgZXhlY3V0aW5nLiBEZWxheWVkXHJcbiAgICAgKiBvcGVyYXRpb25zIGFyZSBub3QgcnVuLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBkcmFpbigpIHtcclxuICAgICAgICAvLyBPcGVyYXRpb25zIGluIHRoZSBxdWV1ZSBwcmlvciB0byBkcmFpbmluZyBtYXkgaGF2ZSBlbnF1ZXVlZCBhZGRpdGlvbmFsXHJcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gS2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlIHRhaWwgaXMgbm8gbG9uZ2VyIGFkdmFuY2VkLFxyXG4gICAgICAgIC8vIHdoaWNoIGluZGljYXRlcyB0aGF0IG5vIG1vcmUgbmV3IG9wZXJhdGlvbnMgd2VyZSBlbnF1ZXVlZCBhbmQgdGhhdCBhbGxcclxuICAgICAgICAvLyBvcGVyYXRpb25zIHdlcmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgbGV0IGN1cnJlbnRUYWlsO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY3VycmVudFRhaWwgPSB0aGlzLnRhaWw7XHJcbiAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUYWlsO1xyXG4gICAgICAgIH0gd2hpbGUgKGN1cnJlbnRUYWlsICE9PSB0aGlzLnRhaWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHM6IERldGVybWluZSBpZiBhIGRlbGF5ZWQgb3BlcmF0aW9uIHdpdGggYSBwYXJ0aWN1bGFyIFRpbWVySWRcclxuICAgICAqIGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnNEZWxheWVkT3BlcmF0aW9uKHRpbWVySWQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wLnRpbWVySWQgPT09IHRpbWVySWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIFRlc3RzOiBSdW5zIHNvbWUgb3IgYWxsIGRlbGF5ZWQgb3BlcmF0aW9ucyBlYXJseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGFzdFRpbWVySWQgLSBEZWxheWVkIG9wZXJhdGlvbnMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGlzIFRpbWVySWRcclxuICAgICAqIHdpbGwgYmUgZHJhaW5lZC4gUGFzcyBUaW1lcklkLkFsbCB0byBydW4gYWxsIGRlbGF5ZWQgb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIHJ1bi5cclxuICAgICAqL1xyXG4gICAgcnVuQWxsRGVsYXllZE9wZXJhdGlvbnNVbnRpbChsYXN0VGltZXJJZCkge1xyXG4gICAgICAgIC8vIE5vdGUgdGhhdCBkcmFpbmluZyBtYXkgZ2VuZXJhdGUgbW9yZSBkZWxheWVkIG9wcywgc28gd2UgZG8gdGhhdCBmaXJzdC5cclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBSdW4gb3BzIGluIHRoZSBzYW1lIG9yZGVyIHRoZXknZCBydW4gaWYgdGhleSByYW4gbmF0dXJhbGx5LlxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnNvcnQoKGEsIGIpID0+IGEudGFyZ2V0VGltZU1zIC0gYi50YXJnZXRUaW1lTXMpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIG9wLnNraXBEZWxheSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUaW1lcklkICE9PSBcImFsbFwiIC8qIFRpbWVySWQuQWxsICovICYmIG9wLnRpbWVySWQgPT09IGxhc3RUaW1lcklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIFRlc3RzOiBTa2lwIGFsbCBzdWJzZXF1ZW50IGRlbGF5cyBmb3IgYSB0aW1lciBpZC5cclxuICAgICAqL1xyXG4gICAgc2tpcERlbGF5c0ZvclRpbWVySWQodGltZXJJZCkge1xyXG4gICAgICAgIHRoaXMudGltZXJJZHNUb1NraXAucHVzaCh0aW1lcklkKTtcclxuICAgIH1cclxuICAgIC8qKiBDYWxsZWQgb25jZSBhIERlbGF5ZWRPcGVyYXRpb24gaXMgcnVuIG9yIGNhbmNlbGVkLiAqL1xyXG4gICAgcmVtb3ZlRGVsYXllZE9wZXJhdGlvbihvcCkge1xyXG4gICAgICAgIC8vIE5PVEU6IGluZGV4T2YgLyBzbGljZSBhcmUgTyhuKSwgYnV0IGRlbGF5ZWRPcGVyYXRpb25zIGlzIGV4cGVjdGVkIHRvIGJlIHNtYWxsLlxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5pbmRleE9mKG9wKTtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3QXN5bmNRdWV1ZSgpIHtcclxuICAgIHJldHVybiBuZXcgQXN5bmNRdWV1ZUltcGwoKTtcclxufVxyXG4vKipcclxuICogQ2hyb21lIGluY2x1ZGVzIEVycm9yLm1lc3NhZ2UgaW4gRXJyb3Iuc3RhY2suIE90aGVyIGJyb3dzZXJzIGRvIG5vdC5cclxuICogVGhpcyByZXR1cm5zIGV4cGVjdGVkIG91dHB1dCBvZiBtZXNzYWdlICsgc3RhY2sgd2hlbiBhdmFpbGFibGUuXHJcbiAqIEBwYXJhbSBlcnJvciAtIEVycm9yIG9yIEZpcmVzdG9yZUVycm9yXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcikge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8ICcnO1xyXG4gICAgaWYgKGVycm9yLnN0YWNrKSB7XHJcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5zdGFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlICsgJ1xcbicgKyBlcnJvci5zdGFjaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgdGFzayBvZiBsb2FkaW5nIGEgRmlyZXN0b3JlIGJ1bmRsZS4gSXQgcHJvdmlkZXMgcHJvZ3Jlc3Mgb2YgYnVuZGxlXHJcbiAqIGxvYWRpbmcsIGFzIHdlbGwgYXMgdGFzayBjb21wbGV0aW9uIGFuZCBlcnJvciBldmVudHMuXHJcbiAqXHJcbiAqIFRoZSBBUEkgaXMgY29tcGF0aWJsZSB3aXRoIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+YC5cclxuICovXHJcbmNsYXNzIExvYWRCdW5kbGVUYXNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIgPSB7fTtcclxuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xyXG4gICAgICAgICAgICB0YXNrU3RhdGU6ICdSdW5uaW5nJyxcclxuICAgICAgICAgICAgdG90YWxCeXRlczogMCxcclxuICAgICAgICAgICAgdG90YWxEb2N1bWVudHM6IDAsXHJcbiAgICAgICAgICAgIGJ5dGVzTG9hZGVkOiAwLFxyXG4gICAgICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgZnVuY3Rpb25zIHRvIGxpc3RlbiB0byBidW5kbGUgbG9hZGluZyBwcm9ncmVzcyBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gbmV4dCAtIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgcHJvZ3Jlc3MgdXBkYXRlIGZyb20gYnVuZGxlIGxvYWRpbmcuIFR5cGljYWxseSBgbmV4dGAgY2FsbHMgb2NjdXJcclxuICAgICAqICAgZWFjaCB0aW1lIGEgRmlyZXN0b3JlIGRvY3VtZW50IGlzIGxvYWRlZCBmcm9tIHRoZSBidW5kbGUuXHJcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBDYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGJ1bmRsZSBsb2FkaW5nLiBUaGUgdGFzayBhYm9ydHMgYWZ0ZXIgcmVwb3J0aW5nIHRoZVxyXG4gICAgICogICBlcnJvciwgYW5kIHRoZXJlIHNob3VsZCBiZSBubyBtb3JlIHVwZGF0ZXMgYWZ0ZXIgdGhpcy5cclxuICAgICAqIEBwYXJhbSBjb21wbGV0ZSAtIENhbGxlZCB3aGVuIHRoZSBsb2FkaW5nIHRhc2sgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIG9uUHJvZ3Jlc3MobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHtcclxuICAgICAgICAgICAgbmV4dCxcclxuICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgIGNvbXBsZXRlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50cyB0aGUgYFByb21pc2U8TG9hZEJ1bmRsZVRhc2tQcm9ncmVzcz4uY2F0Y2hgIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuXHJcbiAgICAgKi9cclxuICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5wcm9taXNlLmNhdGNoKG9uUmVqZWN0ZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi50aGVuYCBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9uRnVsZmlsbGVkIC0gQ2FsbGVkIG9uIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBsb2FkaW5nIHRhc2sgd2l0aCBhIGZpbmFsIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCB1cGRhdGUuXHJcbiAgICAgKiAgIFRoZSB1cGRhdGUgd2lsbCBhbHdheXMgaGF2ZSBpdHMgYHRhc2tTdGF0ZWAgc2V0IHRvIGBcIlN1Y2Nlc3NcImAuXHJcbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuXHJcbiAgICAgKi9cclxuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5wcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyBhbGwgb2JzZXJ2ZXJzIHRoYXQgYnVuZGxlIGxvYWRpbmcgaGFzIGNvbXBsZXRlZCwgd2l0aCBhIHByb3ZpZGVkXHJcbiAgICAgKiBgTG9hZEJ1bmRsZVRhc2tQcm9ncmVzc2Agb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jb21wbGV0ZVdpdGgocHJvZ3Jlc3MpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyhwcm9ncmVzcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuY29tcGxldGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnJlc29sdmUocHJvZ3Jlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyBhbGwgb2JzZXJ2ZXJzIHRoYXQgYnVuZGxlIGxvYWRpbmcgaGFzIGZhaWxlZCwgd2l0aCBhIHByb3ZpZGVkXHJcbiAgICAgKiBgRXJyb3JgIGFzIHRoZSByZWFzb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2ZhaWxXaXRoKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzLnRhc2tTdGF0ZSA9ICdFcnJvcic7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQodGhpcy5fbGFzdFByb2dyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm90aWZpZXMgYSBwcm9ncmVzcyB1cGRhdGUgb2YgbG9hZGluZyBhIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyAtIFRoZSBuZXcgcHJvZ3Jlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQocHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29uc3RhbnQgdXNlZCB0byBpbmRpY2F0ZSB0aGUgTFJVIGdhcmJhZ2UgY29sbGVjdGlvbiBzaG91bGQgYmUgZGlzYWJsZWQuXHJcbiAqIFNldCB0aGlzIHZhbHVlIGFzIHRoZSBgY2FjaGVTaXplQnl0ZXNgIG9uIHRoZSBzZXR0aW5ncyBwYXNzZWQgdG8gdGhlXHJcbiAqIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxyXG4gKi9cclxuY29uc3QgQ0FDSEVfU0laRV9VTkxJTUlURUQgPSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRDtcclxuLyoqXHJcbiAqIFRoZSBDbG91ZCBGaXJlc3RvcmUgc2VydmljZSBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXHJcbiAqL1xyXG5jbGFzcyBGaXJlc3RvcmUgZXh0ZW5kcyBGaXJlc3RvcmUkMSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciwgZGF0YWJhc2VJZCwgYXBwKSB7XHJcbiAgICAgICAgc3VwZXIoYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciwgZGF0YWJhc2VJZCwgYXBwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIGl0J3MgYSB7QGxpbmsgRmlyZXN0b3JlfSBvciBGaXJlc3RvcmUgTGl0ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlJztcclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ld0FzeW5jUXVldWUoKTtcclxuICAgICAgICB0aGlzLl9wZXJzaXN0ZW5jZUtleSA9IChhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAubmFtZSkgfHwgJ1tERUZBVUxUXSc7XHJcbiAgICB9XHJcbiAgICBfdGVybWluYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZmlyZXN0b3JlQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBjbGllbnQgbXVzdCBiZSBpbml0aWFsaXplZCB0byBlbnN1cmUgdGhhdCBhbGwgc3Vic2VxdWVudCBBUElcclxuICAgICAgICAgICAgLy8gdXNhZ2UgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cclxuICAgICAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlyZXN0b3JlQ2xpZW50LnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRmlyZXN0b3JlfSB3aXRoIHRoZSBwcm92aWRlZCBzZXR0aW5ncy5cclxuICogQ2FuIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBhbnkgb3RoZXIgZnVuY3Rpb24sIGluY2x1ZGluZ1xyXG4gKiB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uIElmIHRoZSBjdXN0b20gc2V0dGluZ3MgYXJlIGVtcHR5LCB0aGlzIGZ1bmN0aW9uIGlzXHJcbiAqIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IHdpdGggd2hpY2ggdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGxcclxuICogYmUgYXNzb2NpYXRlZC5cclxuICogQHBhcmFtIHNldHRpbmdzIC0gQSBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGRhdGFiYXNlSWQgLSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UuXHJcbiAqIEByZXR1cm5zIEEgbmV3bHkgaW5pdGlhbGl6ZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0aWFsaXplRmlyZXN0b3JlKGFwcCwgc2V0dGluZ3MsIGRhdGFiYXNlSWQpIHtcclxuICAgIGlmICghZGF0YWJhc2VJZCkge1xyXG4gICAgICAgIGRhdGFiYXNlSWQgPSBERUZBVUxUX0RBVEFCQVNFX05BTUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKTtcclxuICAgIGlmIChwcm92aWRlci5pc0luaXRpYWxpemVkKGRhdGFiYXNlSWQpKSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHByb3ZpZGVyLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBpbml0aWFsU2V0dGluZ3MgPSBwcm92aWRlci5nZXRPcHRpb25zKGRhdGFiYXNlSWQpO1xyXG4gICAgICAgIGlmIChkZWVwRXF1YWwoaW5pdGlhbFNldHRpbmdzLCBzZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnaW5pdGlhbGl6ZUZpcmVzdG9yZSgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIHdpdGggJyArXHJcbiAgICAgICAgICAgICAgICAnZGlmZmVyZW50IG9wdGlvbnMuIFRvIGF2b2lkIHRoaXMgZXJyb3IsIGNhbGwgaW5pdGlhbGl6ZUZpcmVzdG9yZSgpIHdpdGggdGhlICcgK1xyXG4gICAgICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRGaXJlc3RvcmUoKSB0byByZXR1cm4gdGhlJyArXHJcbiAgICAgICAgICAgICAgICAnIGFscmVhZHkgaW5pdGlhbGl6ZWQgaW5zdGFuY2UuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICBzZXR0aW5ncy5sb2NhbENhY2hlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGUgYW5kIGNhY2hlU2l6ZUJ5dGVzIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXQgdGhlIHNhbWUgdGltZSBhcyBjYWNoZVNpemVCeXRlcyB3aWxsYCArXHJcbiAgICAgICAgICAgIGBiZSBkZXByZWNhdGVkLiBJbnN0ZWFkLCBzcGVjaWZ5IHRoZSBjYWNoZSBzaXplIGluIHRoZSBjYWNoZSBvYmplY3RgKTtcclxuICAgIH1cclxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgIT09IENBQ0hFX1NJWkVfVU5MSU1JVEVEICYmXHJcbiAgICAgICAgc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgPCBMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3ZpZGVyLmluaXRpYWxpemUoe1xyXG4gICAgICAgIG9wdGlvbnM6IHNldHRpbmdzLFxyXG4gICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogZGF0YWJhc2VJZFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RmlyZXN0b3JlKGFwcE9yRGF0YWJhc2VJZCwgb3B0aW9uYWxEYXRhYmFzZUlkKSB7XHJcbiAgICBjb25zdCBhcHAgPSB0eXBlb2YgYXBwT3JEYXRhYmFzZUlkID09PSAnb2JqZWN0JyA/IGFwcE9yRGF0YWJhc2VJZCA6IGdldEFwcCgpO1xyXG4gICAgY29uc3QgZGF0YWJhc2VJZCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgPyBhcHBPckRhdGFiYXNlSWRcclxuICAgICAgICA6IG9wdGlvbmFsRGF0YWJhc2VJZCB8fCBERUZBVUxUX0RBVEFCQVNFX05BTUU7XHJcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKS5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcclxuICAgIH0pO1xyXG4gICAgaWYgKCFkYi5faW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnZmlyZXN0b3JlJyk7XHJcbiAgICAgICAgaWYgKGVtdWxhdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYjtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSkge1xyXG4gICAgaWYgKCFmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudCkge1xyXG4gICAgICAgIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQudmVyaWZ5Tm90VGVybWluYXRlZCgpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50O1xyXG59XHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZUluZm8gPSBtYWtlRGF0YWJhc2VJbmZvKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgKChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5hcHBJZCkgfHwgJycsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKTtcclxuICAgIGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50ID0gbmV3IEZpcmVzdG9yZUNsaWVudChmaXJlc3RvcmUuX2F1dGhDcmVkZW50aWFscywgZmlyZXN0b3JlLl9hcHBDaGVja0NyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX3F1ZXVlLCBkYXRhYmFzZUluZm8pO1xyXG4gICAgaWYgKCgoX2IgPSBzZXR0aW5ncy5sb2NhbENhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuX29mZmxpbmVDb21wb25lbnRQcm92aWRlcikgJiZcclxuICAgICAgICAoKF9jID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLl9vbmxpbmVDb21wb25lbnRQcm92aWRlcikpIHtcclxuICAgICAgICBmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlciA9IHtcclxuICAgICAgICAgICAgX29mZmxpbmVLaW5kOiBzZXR0aW5ncy5sb2NhbENhY2hlLmtpbmQsXHJcbiAgICAgICAgICAgIF9vZmZsaW5lOiBzZXR0aW5ncy5sb2NhbENhY2hlLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsXHJcbiAgICAgICAgICAgIF9vbmxpbmU6IHNldHRpbmdzLmxvY2FsQ2FjaGUuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuXHJcbiAqXHJcbiAqIE9uIGZhaWx1cmUsIGBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBvclxyXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uIFRoZXJlIGFyZSBzZXZlcmFsIHJlYXNvbnMgd2h5IHRoaXMgY2FuIGZhaWwsIHdoaWNoIGNhbiBiZVxyXG4gKiBpZGVudGlmaWVkIGJ5IHRoZSBgY29kZWAgb24gdGhlIGVycm9yLlxyXG4gKlxyXG4gKiAgICogZmFpbGVkLXByZWNvbmRpdGlvbjogVGhlIGFwcCBpcyBhbHJlYWR5IG9wZW4gaW4gYW5vdGhlciBicm93c2VyIHRhYi5cclxuICogICAqIHVuaW1wbGVtZW50ZWQ6IFRoZSBicm93c2VyIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBvZmZsaW5lIHBlcnNpc3RlbmNlXHJcbiAqICAgICBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogTm90ZSB0aGF0IGV2ZW4gYWZ0ZXIgYSBmYWlsdXJlLCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbCByZW1haW5cclxuICogdXNhYmxlLCBob3dldmVyIG9mZmxpbmUgcGVyc2lzdGVuY2Ugd2lsbCBiZSBkaXNhYmxlZC5cclxuICpcclxuICogTm90ZTogYGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKClgIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBhbnkgb3RoZXIgZnVuY3Rpb25zXHJcbiAqIChvdGhlciB0aGFuIHtAbGluayBpbml0aWFsaXplRmlyZXN0b3JlfSwge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9IG9yXHJcbiAqIHtAbGluayBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlfS5cclxuICpcclxuICogUGVyc2lzdGVuY2UgY2Fubm90IGJlIHVzZWQgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGVuYWJsZSBwZXJzaXN0ZW5jZSBmb3IuXHJcbiAqIEBwYXJhbSBwZXJzaXN0ZW5jZVNldHRpbmdzIC0gT3B0aW9uYWwgc2V0dGluZ3Mgb2JqZWN0IHRvIGNvbmZpZ3VyZVxyXG4gKiBwZXJzaXN0ZW5jZS5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXByZXNlbnRzIHN1Y2Nlc3NmdWxseSBlbmFibGluZyBwZXJzaXN0ZW50IHN0b3JhZ2UuXHJcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIEluc3RlYWQsIHNldFxyXG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xyXG4gKiB0dXJuIG9uIEluZGV4ZWREYiBjYWNoZS4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdoZW4gYEZpcmVzdG9yZVNldHRpbmdzLmxvY2FsQ2FjaGVgXHJcbiAqIGlzIGFscmVhZHkgc3BlY2lmaWVkIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UoZmlyZXN0b3JlLCBwZXJzaXN0ZW5jZVNldHRpbmdzKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIHZlcmlmeU5vdEluaXRpYWxpemVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1NESyBjYWNoZSBpcyBhbHJlYWR5IHNwZWNpZmllZC4nKTtcclxuICAgIH1cclxuICAgIGxvZ1dhcm4oJ2VuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKCkgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUsICcgK1xyXG4gICAgICAgICd5b3UgY2FuIHVzZSBgRmlyZXN0b3JlU2V0dGluZ3MuY2FjaGVgIGluc3RlYWQuJyk7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcclxuICAgIGNvbnN0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKCk7XHJcbiAgICBjb25zdCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcywgcGVyc2lzdGVuY2VTZXR0aW5ncyA9PT0gbnVsbCB8fCBwZXJzaXN0ZW5jZVNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJzaXN0ZW5jZVNldHRpbmdzLmZvcmNlT3duZXJzaGlwKTtcclxuICAgIHJldHVybiBzZXRQZXJzaXN0ZW5jZVByb3ZpZGVycyhjbGllbnQsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgbXVsdGktdGFiIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuIElmIGVuYWJsZWRcclxuICogYWNyb3NzIGFsbCB0YWJzLCBhbGwgb3BlcmF0aW9ucyBzaGFyZSBhY2Nlc3MgdG8gbG9jYWwgcGVyc2lzdGVuY2UsIGluY2x1ZGluZ1xyXG4gKiBzaGFyZWQgZXhlY3V0aW9uIG9mIHF1ZXJpZXMgYW5kIGxhdGVuY3ktY29tcGVuc2F0ZWQgbG9jYWwgZG9jdW1lbnQgdXBkYXRlc1xyXG4gKiBhY3Jvc3MgYWxsIGNvbm5lY3RlZCBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIE9uIGZhaWx1cmUsIGBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIG9yXHJcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gVGhlcmUgYXJlIHNldmVyYWwgcmVhc29ucyB3aHkgdGhpcyBjYW4gZmFpbCwgd2hpY2ggY2FuIGJlXHJcbiAqIGlkZW50aWZpZWQgYnkgdGhlIGBjb2RlYCBvbiB0aGUgZXJyb3IuXHJcbiAqXHJcbiAqICAgKiBmYWlsZWQtcHJlY29uZGl0aW9uOiBUaGUgYXBwIGlzIGFscmVhZHkgb3BlbiBpbiBhbm90aGVyIGJyb3dzZXIgdGFiIGFuZFxyXG4gKiAgICAgbXVsdGktdGFiIGlzIG5vdCBlbmFibGVkLlxyXG4gKiAgICogdW5pbXBsZW1lbnRlZDogVGhlIGJyb3dzZXIgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIG9mZmxpbmUgcGVyc2lzdGVuY2VcclxuICogICAgIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgZXZlbiBhZnRlciBhIGZhaWx1cmUsIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB3aWxsIHJlbWFpblxyXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGVuYWJsZSBwZXJzaXN0ZW5jZSBmb3IuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudFxyXG4gKiBzdG9yYWdlLlxyXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBJbnN0ZWFkLCBzZXRcclxuICogYEZpcmVzdG9yZVNldHRpbmdzLmxvY2FsQ2FjaGVgIHRvIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TG9jYWxDYWNoZWAgdG9cclxuICogdHVybiBvbiBpbmRleGVkZGIgY2FjaGUuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aGVuIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYFxyXG4gKiBpcyBhbHJlYWR5IHNwZWNpZmllZCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIHZlcmlmeU5vdEluaXRpYWxpemVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1NESyBjYWNoZSBpcyBhbHJlYWR5IHNwZWNpZmllZC4nKTtcclxuICAgIH1cclxuICAgIGxvZ1dhcm4oJ2VuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZSwgJyArXHJcbiAgICAgICAgJ3lvdSBjYW4gdXNlIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgaW5zdGVhZC4nKTtcclxuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xyXG4gICAgY29uc3Qgb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKTtcclxuICAgIGNvbnN0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMpO1xyXG4gICAgcmV0dXJuIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGNsaWVudCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcik7XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBib3RoIHRoZSBgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyYCBhbmQgYE9ubGluZUNvbXBvbmVudFByb3ZpZGVyYC5cclxuICogSWYgdGhlIG9wZXJhdGlvbiBmYWlscyB3aXRoIGEgcmVjb3ZlcmFibGUgZXJyb3IgKHNlZVxyXG4gKiBgY2FuUmVjb3ZlckZyb21JbmRleGVkRGJFcnJvcigpYCBiZWxvdyksIHRoZSByZXR1cm5lZCBQcm9taXNlIGlzIHJlamVjdGVkXHJcbiAqIGJ1dCB0aGUgY2xpZW50IHJlbWFpbnMgdXNhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlciwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW5jZVJlc3VsdCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlXHJcbiAgICAgICAgLmVucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcik7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBwZXJzaXN0ZW5jZVJlc3VsdC5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcclxuICAgICAgICAgICAgaWYgKCFjYW5GYWxsYmFja0Zyb21JbmRleGVkRGJFcnJvcihlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZ1dhcm4oJ0Vycm9yIGVuYWJsaW5nIGluZGV4ZWRkYiBjYWNoZS4gRmFsbGluZyBiYWNrIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgJ21lbW9yeSBjYWNoZTogJyArXHJcbiAgICAgICAgICAgICAgICBlcnJvcik7XHJcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlUmVzdWx0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgICAgICAudGhlbigoKSA9PiBwZXJzaXN0ZW5jZVJlc3VsdC5wcm9taXNlKTtcclxufVxyXG4vKipcclxuICogQ2xlYXJzIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UuIFRoaXMgaW5jbHVkZXMgcGVuZGluZyB3cml0ZXMgYW5kIGNhY2hlZFxyXG4gKiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIE11c3QgYmUgY2FsbGVkIHdoaWxlIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBpcyBub3Qgc3RhcnRlZCAoYWZ0ZXIgdGhlIGFwcCBpc1xyXG4gKiB0ZXJtaW5hdGVkIG9yIHdoZW4gdGhlIGFwcCBpcyBmaXJzdCBpbml0aWFsaXplZCkuIE9uIHN0YXJ0dXAsIHRoaXMgZnVuY3Rpb25cclxuICogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIGZ1bmN0aW9ucyAob3RoZXIgdGhhbiB7QGxpbmtcclxuICogaW5pdGlhbGl6ZUZpcmVzdG9yZX0gb3Ige0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9KSkuIElmIHRoZSB7QGxpbmsgRmlyZXN0b3JlfVxyXG4gKiBpbnN0YW5jZSBpcyBzdGlsbCBydW5uaW5nLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIGVycm9yIGNvZGVcclxuICogb2YgYGZhaWxlZC1wcmVjb25kaXRpb25gLlxyXG4gKlxyXG4gKiBOb3RlOiBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgdG8gaGVscCB3cml0ZVxyXG4gKiByZWxpYWJsZSB0ZXN0cyB0aGF0IHVzZSBDbG91ZCBGaXJlc3RvcmUuIEl0IHVzZXMgYW4gZWZmaWNpZW50IG1lY2hhbmlzbSBmb3JcclxuICogZHJvcHBpbmcgZXhpc3RpbmcgZGF0YSBidXQgZG9lcyBub3QgYXR0ZW1wdCB0byBzZWN1cmVseSBvdmVyd3JpdGUgb3JcclxuICogb3RoZXJ3aXNlIG1ha2UgY2FjaGVkIGRhdGEgdW5yZWNvdmVyYWJsZS4gRm9yIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBzZW5zaXRpdmVcclxuICogdG8gdGhlIGRpc2Nsb3N1cmUgb2YgY2FjaGVkIGRhdGEgaW4gYmV0d2VlbiB1c2VyIHNlc3Npb25zLCB3ZSBzdHJvbmdseVxyXG4gKiByZWNvbW1lbmQgbm90IGVuYWJsaW5nIHBlcnNpc3RlbmNlIGF0IGFsbC5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBjbGVhciBwZXJzaXN0ZW5jZSBmb3IuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcGVyc2lzdGVudCBzdG9yYWdlIGlzXHJcbiAqIGNsZWFyZWQuIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cclxuICovXHJcbmZ1bmN0aW9uIGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2UoZmlyZXN0b3JlKSB7XHJcbiAgICBpZiAoZmlyZXN0b3JlLl9pbml0aWFsaXplZCAmJiAhZmlyZXN0b3JlLl90ZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1BlcnNpc3RlbmNlIGNhbiBvbmx5IGJlIGNsZWFyZWQgYmVmb3JlIGEgRmlyZXN0b3JlIGluc3RhbmNlIGlzICcgK1xyXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZWQgb3IgYWZ0ZXIgaXQgaXMgdGVybWluYXRlZC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBmaXJlc3RvcmUuX3F1ZXVlLmVucXVldWVBbmRGb3JnZXRFdmVuV2hpbGVSZXN0cmljdGVkKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBpbmRleGVkRGJDbGVhclBlcnNpc3RlbmNlKGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBmaXJlc3RvcmUuX3BlcnNpc3RlbmNlS2V5KSk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFdhaXRzIHVudGlsIGFsbCBjdXJyZW50bHkgcGVuZGluZyB3cml0ZXMgZm9yIHRoZSBhY3RpdmUgdXNlciBoYXZlIGJlZW5cclxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gb3V0c3RhbmRpbmcgd3JpdGVzLlxyXG4gKiBPdGhlcndpc2UsIHRoZSBwcm9taXNlIHdhaXRzIGZvciBhbGwgcHJldmlvdXNseSBpc3N1ZWQgd3JpdGVzIChpbmNsdWRpbmdcclxuICogdGhvc2Ugd3JpdHRlbiBpbiBhIHByZXZpb3VzIGFwcCBzZXNzaW9uKSwgYnV0IGl0IGRvZXMgbm90IHdhaXQgZm9yIHdyaXRlc1xyXG4gKiB0aGF0IHdlcmUgYWRkZWQgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gSWYgeW91IHdhbnQgdG8gd2FpdCBmb3JcclxuICogYWRkaXRpb25hbCB3cml0ZXMsIGNhbGwgYHdhaXRGb3JQZW5kaW5nV3JpdGVzKClgIGFnYWluLlxyXG4gKlxyXG4gKiBBbnkgb3V0c3RhbmRpbmcgYHdhaXRGb3JQZW5kaW5nV3JpdGVzKClgIHByb21pc2VzIGFyZSByZWplY3RlZCBkdXJpbmcgdXNlclxyXG4gKiBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB3aGljaCByZXNvbHZlcyB3aGVuIGFsbCBjdXJyZW50bHkgcGVuZGluZyB3cml0ZXMgaGF2ZSBiZWVuXHJcbiAqIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZC5cclxuICovXHJcbmZ1bmN0aW9uIHdhaXRGb3JQZW5kaW5nV3JpdGVzKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50V2FpdEZvclBlbmRpbmdXcml0ZXMoY2xpZW50KTtcclxufVxyXG4vKipcclxuICogUmUtZW5hYmxlcyB1c2Ugb2YgdGhlIG5ldHdvcmsgZm9yIHRoaXMge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgYWZ0ZXIgYSBwcmlvclxyXG4gKiBjYWxsIHRvIHtAbGluayBkaXNhYmxlTmV0d29ya30uXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBlbmFibGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5hYmxlTmV0d29yayhmaXJlc3RvcmUpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEVuYWJsZU5ldHdvcmsoY2xpZW50KTtcclxufVxyXG4vKipcclxuICogRGlzYWJsZXMgbmV0d29yayB1c2FnZSBmb3IgdGhpcyBpbnN0YW5jZS4gSXQgY2FuIGJlIHJlLWVuYWJsZWQgdmlhIHtAbGlua1xyXG4gKiBlbmFibGVOZXR3b3JrfS4gV2hpbGUgdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQsIGFueSBzbmFwc2hvdCBsaXN0ZW5lcnMsXHJcbiAqIGBnZXREb2MoKWAgb3IgYGdldERvY3MoKWAgY2FsbHMgd2lsbCByZXR1cm4gcmVzdWx0cyBmcm9tIGNhY2hlLCBhbmQgYW55IHdyaXRlXHJcbiAqIG9wZXJhdGlvbnMgd2lsbCBiZSBxdWV1ZWQgdW50aWwgdGhlIG5ldHdvcmsgaXMgcmVzdG9yZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBkaXNhYmxlZC5cclxuICovXHJcbmZ1bmN0aW9uIGRpc2FibGVOZXR3b3JrKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50RGlzYWJsZU5ldHdvcmsoY2xpZW50KTtcclxufVxyXG4vKipcclxuICogVGVybWluYXRlcyB0aGUgcHJvdmlkZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEFmdGVyIGNhbGxpbmcgYHRlcm1pbmF0ZSgpYCBvbmx5IHRoZSBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBmdW5jdGlvblxyXG4gKiBtYXkgYmUgdXNlZC4gQW55IG90aGVyIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYSBgRmlyZXN0b3JlRXJyb3JgLlxyXG4gKlxyXG4gKiBUbyByZXN0YXJ0IGFmdGVyIHRlcm1pbmF0aW9uLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRmlyZWJhc2VGaXJlc3RvcmUgd2l0aFxyXG4gKiB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXHJcbiAqXHJcbiAqIFRlcm1pbmF0aW9uIGRvZXMgbm90IGNhbmNlbCBhbnkgcGVuZGluZyB3cml0ZXMsIGFuZCBhbnkgcHJvbWlzZXMgdGhhdCBhcmVcclxuICogYXdhaXRpbmcgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcmVzb2x2ZWQuIElmIHlvdSBoYXZlXHJcbiAqIHBlcnNpc3RlbmNlIGVuYWJsZWQsIHRoZSBuZXh0IHRpbWUgeW91IHN0YXJ0IHRoaXMgaW5zdGFuY2UsIGl0IHdpbGwgcmVzdW1lXHJcbiAqIHNlbmRpbmcgdGhlc2Ugd3JpdGVzIHRvIHRoZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIE5vdGU6IFVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgaXMgbm90IHJlcXVpcmVkLiBUaGlzXHJcbiAqIGZ1bmN0aW9uIGlzIHVzZWZ1bCBvbmx5IHdoZW4geW91IHdhbnQgdG8gZm9yY2UgdGhpcyBpbnN0YW5jZSB0byByZWxlYXNlIGFsbFxyXG4gKiBvZiBpdHMgcmVzb3VyY2VzIG9yIGluIGNvbWJpbmF0aW9uIHdpdGggYGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgdG9cclxuICogZW5zdXJlIHRoYXQgYWxsIGxvY2FsIHN0YXRlIGlzIGRlc3Ryb3llZCBiZXR3ZWVuIHRlc3QgcnVucy5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHlcclxuICogdGVybWluYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHRlcm1pbmF0ZShmaXJlc3RvcmUpIHtcclxuICAgIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoZmlyZXN0b3JlLmFwcCwgJ2ZpcmVzdG9yZScsIGZpcmVzdG9yZS5fZGF0YWJhc2VJZC5kYXRhYmFzZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlLl9kZWxldGUoKTtcclxufVxyXG4vKipcclxuICogTG9hZHMgYSBGaXJlc3RvcmUgYnVuZGxlIGludG8gdGhlIGxvY2FsIGNhY2hlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGxvYWQgYnVuZGxlcyBmb3IuXHJcbiAqIEBwYXJhbSBidW5kbGVEYXRhIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYnVuZGxlIHRvIGJlIGxvYWRlZC4gVmFsaWRcclxuICogb2JqZWN0cyBhcmUgYEFycmF5QnVmZmVyYCwgYFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+YCBvciBgc3RyaW5nYC5cclxuICpcclxuICogQHJldHVybnMgQSBgTG9hZEJ1bmRsZVRhc2tgIG9iamVjdCwgd2hpY2ggbm90aWZpZXMgY2FsbGVycyB3aXRoIHByb2dyZXNzXHJcbiAqIHVwZGF0ZXMsIGFuZCBjb21wbGV0aW9uIG9yIGVycm9yIGV2ZW50cy4gSXQgY2FuIGJlIHVzZWQgYXMgYVxyXG4gKiBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkQnVuZGxlKGZpcmVzdG9yZSwgYnVuZGxlRGF0YSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCByZXN1bHRUYXNrID0gbmV3IExvYWRCdW5kbGVUYXNrKCk7XHJcbiAgICBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBidW5kbGVEYXRhLCByZXN1bHRUYXNrKTtcclxuICAgIHJldHVybiByZXN1bHRUYXNrO1xyXG59XHJcbi8qKlxyXG4gKiBSZWFkcyBhIEZpcmVzdG9yZSB7QGxpbmsgUXVlcnl9IGZyb20gbG9jYWwgY2FjaGUsIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuXHJcbiAqIG5hbWUuXHJcbiAqXHJcbiAqIFRoZSBuYW1lZCBxdWVyaWVzIGFyZSBwYWNrYWdlZCAgaW50byBidW5kbGVzIG9uIHRoZSBzZXJ2ZXIgc2lkZSAoYWxvbmdcclxuICogd2l0aCByZXN1bHRpbmcgZG9jdW1lbnRzKSwgYW5kIGxvYWRlZCB0byBsb2NhbCBjYWNoZSB1c2luZyBgbG9hZEJ1bmRsZWAuIE9uY2VcclxuICogaW4gbG9jYWwgY2FjaGUsIHVzZSB0aGlzIG1ldGhvZCB0byBleHRyYWN0IGEge0BsaW5rIFF1ZXJ5fSBieSBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIHJlYWQgdGhlIHF1ZXJ5IGZyb20uXHJcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIFF1ZXJ5IG9yIGBudWxsYC5cclxuICovXHJcbmZ1bmN0aW9uIG5hbWVkUXVlcnkoZmlyZXN0b3JlLCBuYW1lKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXROYW1lZFF1ZXJ5KGNsaWVudCwgbmFtZSkudGhlbihuYW1lZFF1ZXJ5ID0+IHtcclxuICAgICAgICBpZiAoIW5hbWVkUXVlcnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkoZmlyZXN0b3JlLCBudWxsLCBuYW1lZFF1ZXJ5LnF1ZXJ5KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHZlcmlmeU5vdEluaXRpYWxpemVkKGZpcmVzdG9yZSkge1xyXG4gICAgaWYgKGZpcmVzdG9yZS5faW5pdGlhbGl6ZWQgfHwgZmlyZXN0b3JlLl90ZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0ZpcmVzdG9yZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgYW5kIHBlcnNpc3RlbmNlIGNhbiBubyBsb25nZXIgYmUgJyArXHJcbiAgICAgICAgICAgICdlbmFibGVkLiBZb3UgY2FuIG9ubHkgZW5hYmxlIHBlcnNpc3RlbmNlIGJlZm9yZSBjYWxsaW5nIGFueSBvdGhlciAnICtcclxuICAgICAgICAgICAgJ21ldGhvZHMgb24gYSBGaXJlc3RvcmUgb2JqZWN0LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRmlyZXN0b3JlKHZhcmlhbnQsIHVzZUZldGNoU3RyZWFtcyA9IHRydWUpIHtcclxuICAgIHNldFNES1ZlcnNpb24oU0RLX1ZFUlNJT04kMSk7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnZmlyZXN0b3JlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWQsIG9wdGlvbnM6IHNldHRpbmdzIH0pID0+IHtcclxuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUluc3RhbmNlID0gbmV3IEZpcmVzdG9yZShuZXcgRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKSksIG5ldyBGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcihjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcpKSwgZGF0YWJhc2VJZEZyb21BcHAoYXBwLCBkYXRhYmFzZUlkKSwgYXBwKTtcclxuICAgICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oeyB1c2VGZXRjaFN0cmVhbXMgfSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIGZpcmVzdG9yZUluc3RhbmNlLl9zZXRTZXR0aW5ncyhzZXR0aW5ncyk7XHJcbiAgICAgICAgcmV0dXJuIGZpcmVzdG9yZUluc3RhbmNlO1xyXG4gICAgfSwgJ1BVQkxJQycpLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBZ2dyZWdhdGUgdHlwZS5cclxuICovXHJcbmNsYXNzIEFnZ3JlZ2F0ZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoYWxpYXMsIGFnZ3JlZ2F0ZVR5cGUsIGZpZWxkUGF0aCkge1xyXG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZVR5cGUgPSBhZ2dyZWdhdGVUeXBlO1xyXG4gICAgICAgIHRoaXMuZmllbGRQYXRoID0gZmllbGRQYXRoO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFnZ3JlZ2F0aW9uIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBieSBGaXJlc3RvcmUuXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbmNsYXNzIEFnZ3JlZ2F0ZUZpZWxkIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEFnZ3JlZ2F0ZUZpZWxkPFQ+XHJcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRlVHlwZSBTcGVjaWZpZXMgdGhlIHR5cGUgb2YgYWdncmVnYXRpb24gb3BlcmF0aW9uIHRvIHBlcmZvcm0uXHJcbiAgICAgKiBAcGFyYW0gX2ludGVybmFsRmllbGRQYXRoIE9wdGlvbmFsbHkgc3BlY2lmaWVzIHRoZSBmaWVsZCB0aGF0IGlzIGFnZ3JlZ2F0ZWQuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWdncmVnYXRlVHlwZSA9ICdjb3VudCcsIF9pbnRlcm5hbEZpZWxkUGF0aCkge1xyXG4gICAgICAgIHRoaXMuX2ludGVybmFsRmllbGRQYXRoID0gX2ludGVybmFsRmllbGRQYXRoO1xyXG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdBZ2dyZWdhdGVGaWVsZCc7XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVUeXBlID0gYWdncmVnYXRlVHlwZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIHJlc3VsdHMgb2YgZXhlY3V0aW5nIGFuIGFnZ3JlZ2F0aW9uIHF1ZXJ5LlxyXG4gKi9cclxuY2xhc3MgQWdncmVnYXRlUXVlcnlTbmFwc2hvdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IocXVlcnksIF91c2VyRGF0YVdyaXRlciwgX2RhdGEpIHtcclxuICAgICAgICB0aGlzLl91c2VyRGF0YVdyaXRlciA9IF91c2VyRGF0YVdyaXRlcjtcclxuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XHJcbiAgICAgICAgLyoqIEEgdHlwZSBzdHJpbmcgdG8gdW5pcXVlbHkgaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QnO1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXHJcbiAgICAgKiBxdWVyeS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUga2V5cyBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgdGhlXHJcbiAgICAgKiBgQWdncmVnYXRlU3BlY2Agb2JqZWN0IHNwZWNpZmllZCB0byB0aGUgYWdncmVnYXRpb24gbWV0aG9kLCBhbmQgdGhlIHZhbHVlc1xyXG4gICAgICogd2lsbCBiZSB0aGUgY29ycmVzcG9uZGluZyBhZ2dyZWdhdGlvbiByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdHMgb2YgdGhlIGFnZ3JlZ2F0aW9ucyBwZXJmb3JtZWQgb3ZlciB0aGUgdW5kZXJseWluZ1xyXG4gICAgICogcXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRPYmplY3RNYXAodGhpcy5fZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIGJ5dGVzLlxyXG4gKi9cclxuY2xhc3MgQnl0ZXMge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJ5dGVTdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9ieXRlU3RyaW5nID0gYnl0ZVN0cmluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBCYXNlNjQgc3RyaW5nLCBjb252ZXJ0aW5nIGl0IHRvXHJcbiAgICAgKiBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmFzZTY0IC0gVGhlIEJhc2U2NCBzdHJpbmcgdXNlZCB0byBjcmVhdGUgdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyhiYXNlNjQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhiYXNlNjQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgZGF0YSBmcm9tIEJhc2U2NCBzdHJpbmc6ICcgKyBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYEJ5dGVzYCBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gVWludDhBcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgVWludDhBcnJheSB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheShhcnJheSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGFzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgY3JlYXRlZCBmcm9tIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9CYXNlNjQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9CYXNlNjQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBpbiBhIG5ldyBgVWludDhBcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIFVpbnQ4QXJyYXkgY3JlYXRlZCBmcm9tIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9VaW50OEFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ieXRlU3RyaW5nLnRvVWludDhBcnJheSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnQnl0ZXMoYmFzZTY0OiAnICsgdGhpcy50b0Jhc2U2NCgpICsgJyknO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgQnl0ZXNgIG9iamVjdCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgQnl0ZXNgIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqL1xyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ieXRlU3RyaW5nLmlzRXF1YWwob3RoZXIuX2J5dGVTdHJpbmcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGBGaWVsZFBhdGhgIHJlZmVycyB0byBhIGZpZWxkIGluIGEgZG9jdW1lbnQuIFRoZSBwYXRoIG1heSBjb25zaXN0IG9mIGFcclxuICogc2luZ2xlIGZpZWxkIG5hbWUgKHJlZmVycmluZyB0byBhIHRvcC1sZXZlbCBmaWVsZCBpbiB0aGUgZG9jdW1lbnQpLCBvciBhXHJcbiAqIGxpc3Qgb2YgZmllbGQgbmFtZXMgKHJlZmVycmluZyB0byBhIG5lc3RlZCBmaWVsZCBpbiB0aGUgZG9jdW1lbnQpLlxyXG4gKlxyXG4gKiBDcmVhdGUgYSBgRmllbGRQYXRoYCBieSBwcm92aWRpbmcgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcclxuICogbmFtZSBpcyBwcm92aWRlZCwgdGhlIHBhdGggd2lsbCBwb2ludCB0byBhIG5lc3RlZCBmaWVsZCBpbiBhIGRvY3VtZW50LlxyXG4gKi9cclxuY2xhc3MgRmllbGRQYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGBGaWVsZFBhdGhgIGZyb20gdGhlIHByb3ZpZGVkIGZpZWxkIG5hbWVzLiBJZiBtb3JlIHRoYW4gb25lIGZpZWxkXHJcbiAgICAgKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkTmFtZXMgLSBBIGxpc3Qgb2YgZmllbGQgbmFtZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKC4uLmZpZWxkTmFtZXMpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBuYW1lIGF0IGFyZ3VtZW50ICQoaSArIDEpLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAnRmllbGQgbmFtZXMgbXVzdCBub3QgYmUgZW1wdHkuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxQYXRoID0gbmV3IEZpZWxkUGF0aCQxKGZpZWxkTmFtZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgRmllbGRQYXRoYCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEZpZWxkUGF0aGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqL1xyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFBhdGguaXNFcXVhbChvdGhlci5faW50ZXJuYWxQYXRoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNwZWNpYWwgc2VudGluZWwgYEZpZWxkUGF0aGAgdG8gcmVmZXIgdG8gdGhlIElEIG9mIGEgZG9jdW1lbnQuXHJcbiAqIEl0IGNhbiBiZSB1c2VkIGluIHF1ZXJpZXMgdG8gc29ydCBvciBmaWx0ZXIgYnkgdGhlIGRvY3VtZW50IElELlxyXG4gKi9cclxuZnVuY3Rpb24gZG9jdW1lbnRJZCgpIHtcclxuICAgIHJldHVybiBuZXcgRmllbGRQYXRoKERPQ1VNRU5UX0tFWV9OQU1FKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogU2VudGluZWwgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiB3cml0aW5nIGRvY3VtZW50IGZpZWxkcyB3aXRoIGBzZXQoKWBcclxuICogb3IgYHVwZGF0ZSgpYC5cclxuICovXHJcbmNsYXNzIEZpZWxkVmFsdWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gX21ldGhvZE5hbWUgLSBUaGUgcHVibGljIEFQSSBlbmRwb2ludCB0aGF0IHJldHVybnMgdGhpcyBjbGFzcy5cclxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX21ldGhvZE5hbWUpIHtcclxuICAgICAgICB0aGlzLl9tZXRob2ROYW1lID0gX21ldGhvZE5hbWU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBpbiBGaXJlc3RvcmUuIFRoZVxyXG4gKiBsb2NhdGlvbiBpcyByZXByZXNlbnRlZCBhcyBsYXRpdHVkZS9sb25naXR1ZGUgcGFpci5cclxuICpcclxuICogTGF0aXR1ZGUgdmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2Ugb2YgWy05MCwgOTBdLlxyXG4gKiBMb25naXR1ZGUgdmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2Ugb2YgWy0xODAsIDE4MF0uXHJcbiAqL1xyXG5jbGFzcyBHZW9Qb2ludCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIGBHZW9Qb2ludGAgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGxhdGl0dWRlIGFuZFxyXG4gICAgICogbG9uZ2l0dWRlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBsYXRpdHVkZSAtIFRoZSBsYXRpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtOTAgYW5kIDkwLlxyXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgYXMgbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XHJcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsYXRpdHVkZSkgfHwgbGF0aXR1ZGUgPCAtOTAgfHwgbGF0aXR1ZGUgPiA5MCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTGF0aXR1ZGUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAsIGJ1dCB3YXM6ICcgKyBsYXRpdHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNGaW5pdGUobG9uZ2l0dWRlKSB8fCBsb25naXR1ZGUgPCAtMTgwIHx8IGxvbmdpdHVkZSA+IDE4MCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTG9uZ2l0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAsIGJ1dCB3YXM6ICcgKyBsb25naXR1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXQgPSBsYXRpdHVkZTtcclxuICAgICAgICB0aGlzLl9sb25nID0gbG9uZ2l0dWRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGF0aXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbGF0aXR1ZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvbmdpdHVkZSBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBsb25naXR1ZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBHZW9Qb2ludGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEdlb1BvaW50YCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdCA9PT0gb3RoZXIuX2xhdCAmJiB0aGlzLl9sb25nID09PSBvdGhlci5fbG9uZztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBHZW9Qb2ludC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogdGhpcy5fbGF0LCBsb25naXR1ZGU6IHRoaXMuX2xvbmcgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgcHJpdmF0ZSB0byBKUyBjb25zdW1lcnMgb2Ygb3VyIEFQSSwgc28gdGhpcyBmdW5jdGlvbiBpcyBwcmVmaXhlZFxyXG4gICAgICogd2l0aCBhbiB1bmRlcnNjb3JlLlxyXG4gICAgICovXHJcbiAgICBfY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xhdCwgb3RoZXIuX2xhdCkgfHxcclxuICAgICAgICAgICAgcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLl9sb25nLCBvdGhlci5fbG9uZykpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFJFU0VSVkVEX0ZJRUxEX1JFR0VYID0gL15fXy4qX18kLztcclxuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBkb2N1bWVudCBkYXRhIChlLmcuIGZvciBhIHNldERhdGEgY2FsbCkuICovXHJcbmNsYXNzIFBhcnNlZFNldERhdGEge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZmllbGRNYXNrLCBmaWVsZFRyYW5zZm9ybXMpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgfVxyXG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpZWxkTWFzayAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIHRoaXMuZmllbGRUcmFuc2Zvcm1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIFwidXBkYXRlXCIgZGF0YSAoaS5lLiBmb3IgYW4gdXBkYXRlRGF0YSBjYWxsKS4gKi9cclxuY2xhc3MgUGFyc2VkVXBkYXRlRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBcclxuICAgIC8vIFRoZSBmaWVsZE1hc2sgZG9lcyBub3QgaW5jbHVkZSBkb2N1bWVudCB0cmFuc2Zvcm1zLlxyXG4gICAgZmllbGRNYXNrLCBmaWVsZFRyYW5zZm9ybXMpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgfVxyXG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgdGhpcy5maWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzV3JpdGUoZGF0YVNvdXJjZSkge1xyXG4gICAgc3dpdGNoIChkYXRhU291cmNlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLzogLy8gZmFsbCB0aHJvdWdoXHJcbiAgICAgICAgY2FzZSAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovOiAvLyBmYWxsIHRocm91Z2hcclxuICAgICAgICBjYXNlIDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjYXNlIDMgLyogVXNlckRhdGFTb3VyY2UuQXJndW1lbnQgKi86XHJcbiAgICAgICAgY2FzZSA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEEgXCJjb250ZXh0XCIgb2JqZWN0IHBhc3NlZCBhcm91bmQgd2hpbGUgcGFyc2luZyB1c2VyIGRhdGEuICovXHJcbmNsYXNzIFBhcnNlQ29udGV4dEltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhIFBhcnNlQ29udGV4dCB3aXRoIHRoZSBnaXZlbiBzb3VyY2UgYW5kIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIGZvciB0aGUgcGFyc2VyLlxyXG4gICAgICogQHBhcmFtIGRhdGFiYXNlSWQgLSBUaGUgZGF0YWJhc2UgSUQgb2YgdGhlIEZpcmVzdG9yZSBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBWYWx1ZSBwcm90by5cclxuICAgICAqIEBwYXJhbSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzIC0gV2hldGhlciB0byBpZ25vcmUgdW5kZWZpbmVkIHByb3BlcnRpZXNcclxuICAgICAqIHJhdGhlciB0aGFuIHRocm93LlxyXG4gICAgICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIEEgbXV0YWJsZSBsaXN0IG9mIGZpZWxkIHRyYW5zZm9ybXMgZW5jb3VudGVyZWRcclxuICAgICAqIHdoaWxlIHBhcnNpbmcgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gZmllbGRNYXNrIC0gQSBtdXRhYmxlIGxpc3Qgb2YgZmllbGQgcGF0aHMgZW5jb3VudGVyZWQgd2hpbGUgcGFyc2luZ1xyXG4gICAgICogdGhlIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyhiLzM0ODcxMTMxKTogV2UgZG9uJ3Qgc3VwcG9ydCBhcnJheSBwYXRocyByaWdodCBub3csIHNvIHBhdGggY2FuIGJlXHJcbiAgICAgKiBudWxsIHRvIGluZGljYXRlIHRoZSBjb250ZXh0IHJlcHJlc2VudHMgYW55IGxvY2F0aW9uIHdpdGhpbiBhbiBhcnJheSAoaW5cclxuICAgICAqIHdoaWNoIGNhc2UgY2VydGFpbiBmZWF0dXJlcyB3aWxsIG5vdCB3b3JrIGFuZCBlcnJvcnMgd2lsbCBiZSBzb21ld2hhdFxyXG4gICAgICogY29tcHJvbWlzZWQpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgZGF0YWJhc2VJZCwgc2VyaWFsaXplciwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgZmllbGRUcmFuc2Zvcm1zLCBmaWVsZE1hc2spIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9IGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gTWlub3IgaGFjazogSWYgZmllbGRUcmFuc2Zvcm1zIGlzIHVuZGVmaW5lZCwgd2UgYXNzdW1lIHRoaXMgaXMgYW5cclxuICAgICAgICAvLyBleHRlcm5hbCBjYWxsIGFuZCB3ZSBuZWVkIHRvIHZhbGlkYXRlIHRoZSBlbnRpcmUgcGF0aC5cclxuICAgICAgICBpZiAoZmllbGRUcmFuc2Zvcm1zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXMgfHwgW107XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2sgfHwgW107XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5wYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGFTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZGF0YVNvdXJjZTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGNvbnRleHQgd2l0aCB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIG92ZXJ3cml0dGVuLiAqL1xyXG4gICAgY29udGV4dFdpdGgoY29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2V0dGluZ3MpLCBjb25maWd1cmF0aW9uKSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgdGhpcy5maWVsZFRyYW5zZm9ybXMsIHRoaXMuZmllbGRNYXNrKTtcclxuICAgIH1cclxuICAgIGNoaWxkQ29udGV4dEZvckZpZWxkKGZpZWxkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcclxuICAgICAgICBjb250ZXh0LnZhbGlkYXRlUGF0aFNlZ21lbnQoZmllbGQpO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgY2hpbGRDb250ZXh0Rm9yRmllbGRQYXRoKGZpZWxkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcclxuICAgICAgICBjb250ZXh0LnZhbGlkYXRlUGF0aCgpO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgY2hpbGRDb250ZXh0Rm9yQXJyYXkoaW5kZXgpIHtcclxuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdzsgc28gbWFrZSBwYXRoXHJcbiAgICAgICAgLy8gdW5kZWZpbmVkLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogdW5kZWZpbmVkLCBhcnJheUVsZW1lbnQ6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFcnJvcihyZWFzb24pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3IocmVhc29uLCB0aGlzLnNldHRpbmdzLm1ldGhvZE5hbWUsIHRoaXMuc2V0dGluZ3MuaGFzQ29udmVydGVyIHx8IGZhbHNlLCB0aGlzLnBhdGgsIHRoaXMuc2V0dGluZ3MudGFyZ2V0RG9jKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zICd0cnVlJyBpZiAnZmllbGRQYXRoJyB3YXMgdHJhdmVyc2VkIHdoZW4gY3JlYXRpbmcgdGhpcyBjb250ZXh0LiAqL1xyXG4gICAgY29udGFpbnMoZmllbGRQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZpZWxkTWFzay5maW5kKGZpZWxkID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKGZpZWxkKSkgIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3Jtcy5maW5kKHRyYW5zZm9ybSA9PiBmaWVsZFBhdGguaXNQcmVmaXhPZih0cmFuc2Zvcm0uZmllbGQpKSAhPT0gdW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aCgpIHtcclxuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBSZW1vdmUgbnVsbCBjaGVjayBvbmNlIHdlIGhhdmUgcHJvcGVyIHBhdGhzIGZvciBmaWVsZHNcclxuICAgICAgICAvLyB3aXRoaW4gYXJyYXlzLlxyXG4gICAgICAgIGlmICghdGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGhTZWdtZW50KHRoaXMucGF0aC5nZXQoaSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFNlZ21lbnQoc2VnbWVudCkge1xyXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKCdEb2N1bWVudCBmaWVsZHMgbXVzdCBub3QgYmUgZW1wdHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzV3JpdGUodGhpcy5kYXRhU291cmNlKSAmJiBSRVNFUlZFRF9GSUVMRF9SRUdFWC50ZXN0KHNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBjYW5ub3QgYmVnaW4gYW5kIGVuZCB3aXRoIFwiX19cIicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIGZvciBwYXJzaW5nIHJhdyB1c2VyIGlucHV0IChwcm92aWRlZCB2aWEgdGhlIEFQSSkgaW50byBpbnRlcm5hbCBtb2RlbFxyXG4gKiBjbGFzc2VzLlxyXG4gKi9cclxuY2xhc3MgVXNlckRhdGFSZWFkZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyIHx8IG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB0b3AtbGV2ZWwgcGFyc2UgY29udGV4dC4gKi9cclxuICAgIGNyZWF0ZUNvbnRleHQoZGF0YVNvdXJjZSwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbCh7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UsXHJcbiAgICAgICAgICAgIG1ldGhvZE5hbWUsXHJcbiAgICAgICAgICAgIHRhcmdldERvYyxcclxuICAgICAgICAgICAgcGF0aDogRmllbGRQYXRoJDEuZW1wdHlQYXRoKCksXHJcbiAgICAgICAgICAgIGFycmF5RWxlbWVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGhhc0NvbnZlcnRlclxyXG4gICAgICAgIH0sIHRoaXMuZGF0YWJhc2VJZCwgdGhpcy5zZXJpYWxpemVyLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSkge1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihmaXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xyXG4gICAgcmV0dXJuIG5ldyBVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUuX2RhdGFiYXNlSWQsICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcik7XHJcbn1cclxuLyoqIFBhcnNlIGRvY3VtZW50IGRhdGEgZnJvbSBhIHNldCgpIGNhbGwuICovXHJcbmZ1bmN0aW9uIHBhcnNlU2V0RGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCwgaGFzQ29udmVydGVyLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KG9wdGlvbnMubWVyZ2UgfHwgb3B0aW9ucy5tZXJnZUZpZWxkc1xyXG4gICAgICAgID8gMiAvKiBVc2VyRGF0YVNvdXJjZS5NZXJnZVNldCAqL1xyXG4gICAgICAgIDogMCAvKiBVc2VyRGF0YVNvdXJjZS5TZXQgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaGFzQ29udmVydGVyKTtcclxuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xyXG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcclxuICAgIGxldCBmaWVsZE1hc2s7XHJcbiAgICBsZXQgZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgaWYgKG9wdGlvbnMubWVyZ2UpIHtcclxuICAgICAgICBmaWVsZE1hc2sgPSBuZXcgRmllbGRNYXNrKGNvbnRleHQuZmllbGRNYXNrKTtcclxuICAgICAgICBmaWVsZFRyYW5zZm9ybXMgPSBjb250ZXh0LmZpZWxkVHJhbnNmb3JtcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMubWVyZ2VGaWVsZHMpIHtcclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGaWVsZFBhdGhzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBzdHJpbmdPckZpZWxkUGF0aCBvZiBvcHRpb25zLm1lcmdlRmllbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHN0cmluZ09yRmllbGRQYXRoLCB0YXJnZXREb2MpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuY29udGFpbnMoZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZpZWxkICcke2ZpZWxkUGF0aH0nIGlzIHNwZWNpZmllZCBpbiB5b3VyIGZpZWxkIG1hc2sgYnV0IG1pc3NpbmcgZnJvbSB5b3VyIGlucHV0IGRhdGEuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyh2YWxpZGF0ZWRGaWVsZFBhdGhzLCBmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZWRGaWVsZFBhdGhzLnB1c2goZmllbGRQYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaWVsZE1hc2sgPSBuZXcgRmllbGRNYXNrKHZhbGlkYXRlZEZpZWxkUGF0aHMpO1xyXG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zLmZpbHRlcih0cmFuc2Zvcm0gPT4gZmllbGRNYXNrLmNvdmVycyh0cmFuc2Zvcm0uZmllbGQpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpZWxkTWFzayA9IG51bGw7XHJcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlZFNldERhdGEobmV3IE9iamVjdFZhbHVlKHVwZGF0ZURhdGEpLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcyk7XHJcbn1cclxuY2xhc3MgRGVsZXRlRmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zZm9ybSB0byBhZGQgZm9yIGEgZGVsZXRlLCBidXQgd2UgbmVlZCB0byBhZGQgaXQgdG8gb3VyXHJcbiAgICAgICAgICAgIC8vIGZpZWxkTWFzayBzbyBpdCBnZXRzIGRlbGV0ZWQuXHJcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLykge1xyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWwgYCArXHJcbiAgICAgICAgICAgICAgICAnb2YgeW91ciB1cGRhdGUgZGF0YScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkbid0IGVuY291bnRlciBkZWxldGUgc2VudGluZWxzIGZvciBxdWVyaWVzIG9yIG5vbi1tZXJnZSBzZXQoKSBjYWxscy5cclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt0aGlzLl9tZXRob2ROYW1lfSgpIGNhbm5vdCBiZSB1c2VkIHdpdGggc2V0KCkgdW5sZXNzIHlvdSBwYXNzIGAgK1xyXG4gICAgICAgICAgICAgICAgJ3ttZXJnZTp0cnVlfScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNoaWxkIGNvbnRleHQgZm9yIHBhcnNpbmcgU2VyaWFsaXphYmxlRmllbGRWYWx1ZXMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gY2FsbGluZyBgUGFyc2VDb250ZXh0LmNvbnRleHRXaXRoYCBiZWNhdXNlIGl0IGtlZXBzXHJcbiAqIHRoZSBmaWVsZFRyYW5zZm9ybXMgYW5kIGZpZWxkTWFzayBzZXBhcmF0ZS5cclxuICpcclxuICogVGhlIGNyZWF0ZWQgY29udGV4dCBoYXMgaXRzIGBkYXRhU291cmNlYCBzZXQgdG8gYFVzZXJEYXRhU291cmNlLkFyZ3VtZW50YC5cclxuICogQWx0aG91Z2ggdGhlc2UgdmFsdWVzIGFyZSB1c2VkIHdpdGggd3JpdGVzLCBhbnkgZWxlbWVudHMgaW4gdGhlc2UgRmllbGRWYWx1ZXNcclxuICogYXJlIG5vdCBjb25zaWRlcmVkIHdyaXRlcyBzaW5jZSB0aGV5IGNhbm5vdCBjb250YWluIGFueSBGaWVsZFZhbHVlIHNlbnRpbmVscyxcclxuICogZXRjLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmllbGRWYWx1ZSAtIFRoZSBzZW50aW5lbCBGaWVsZFZhbHVlIGZvciB3aGljaCB0byBjcmVhdGUgYSBjaGlsZFxyXG4gKiAgICAgY29udGV4dC5cclxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgcGFyZW50IGNvbnRleHQuXHJcbiAqIEBwYXJhbSBhcnJheUVsZW1lbnQgLSBXaGV0aGVyIG9yIG5vdCB0aGUgRmllbGRWYWx1ZSBoYXMgYW4gYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dChmaWVsZFZhbHVlLCBjb250ZXh0LCBhcnJheUVsZW1lbnQpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbCh7XHJcbiAgICAgICAgZGF0YVNvdXJjZTogMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLyxcclxuICAgICAgICB0YXJnZXREb2M6IGNvbnRleHQuc2V0dGluZ3MudGFyZ2V0RG9jLFxyXG4gICAgICAgIG1ldGhvZE5hbWU6IGZpZWxkVmFsdWUuX21ldGhvZE5hbWUsXHJcbiAgICAgICAgYXJyYXlFbGVtZW50XHJcbiAgICB9LCBjb250ZXh0LmRhdGFiYXNlSWQsIGNvbnRleHQuc2VyaWFsaXplciwgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKTtcclxufVxyXG5jbGFzcyBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBuZXcgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKCkpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgX2VsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfZWxlbWVudHM7XHJcbiAgICB9XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VDb250ZXh0ID0gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQodGhpcywgY29udGV4dCwgXHJcbiAgICAgICAgLyphcnJheT0qLyB0cnVlKTtcclxuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcclxuICAgICAgICBjb25zdCBhcnJheVVuaW9uID0gbmV3IEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24ocGFyc2VkRWxlbWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsICYmXHJcbiAgICAgICAgICAgIGRlZXBFcXVhbCh0aGlzLl9lbGVtZW50cywgb3RoZXIuX2VsZW1lbnRzKSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgX2VsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfZWxlbWVudHM7XHJcbiAgICB9XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VDb250ZXh0ID0gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQodGhpcywgY29udGV4dCwgXHJcbiAgICAgICAgLyphcnJheT0qLyB0cnVlKTtcclxuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcclxuICAgICAgICBjb25zdCBhcnJheVVuaW9uID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGNvbnRleHQucGF0aCwgYXJyYXlVbmlvbik7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlRmllbGRWYWx1ZUltcGwgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKHRoaXMuX2VsZW1lbnRzLCBvdGhlci5fZWxlbWVudHMpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9vcGVyYW5kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fb3BlcmFuZCA9IF9vcGVyYW5kO1xyXG4gICAgfVxyXG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IG51bWVyaWNJbmNyZW1lbnQgPSBuZXcgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbihjb250ZXh0LnNlcmlhbGl6ZXIsIHRvTnVtYmVyKGNvbnRleHQuc2VyaWFsaXplciwgdGhpcy5fb3BlcmFuZCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBudW1lcmljSW5jcmVtZW50KTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudEZpZWxkVmFsdWVJbXBsICYmXHJcbiAgICAgICAgICAgIHRoaXMuX29wZXJhbmQgPT09IG90aGVyLl9vcGVyYW5kKTtcclxuICAgIH1cclxufVxyXG4vKiogUGFyc2UgdXBkYXRlIGRhdGEgZnJvbSBhbiB1cGRhdGUoKSBjYWxsLiAqL1xyXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZURhdGEodXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaW5wdXQpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MpO1xyXG4gICAgdmFsaWRhdGVQbGFpbk9iamVjdCgnRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczonLCBjb250ZXh0LCBpbnB1dCk7XHJcbiAgICBjb25zdCBmaWVsZE1hc2tQYXRocyA9IFtdO1xyXG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XHJcbiAgICBmb3JFYWNoKGlucHV0LCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIGtleSwgdGFyZ2V0RG9jKTtcclxuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGVsZXRlRmllbGRWYWx1ZUltcGwpIHtcclxuICAgICAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBmaWVsZCBtYXNrLCBidXQgZG9uJ3QgYWRkIGFueXRoaW5nIHRvIHVwZGF0ZURhdGEuXHJcbiAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG1hc2sgPSBuZXcgRmllbGRNYXNrKGZpZWxkTWFza1BhdGhzKTtcclxuICAgIHJldHVybiBuZXcgUGFyc2VkVXBkYXRlRGF0YSh1cGRhdGVEYXRhLCBtYXNrLCBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcyk7XHJcbn1cclxuLyoqIFBhcnNlIHVwZGF0ZSBkYXRhIGZyb20gYSBsaXN0IG9mIGZpZWxkL3ZhbHVlIGFyZ3VtZW50cy4gKi9cclxuZnVuY3Rpb24gcGFyc2VVcGRhdGVWYXJhcmdzKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGZpZWxkLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcykge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XHJcbiAgICBjb25zdCBrZXlzID0gW2ZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIGZpZWxkLCB0YXJnZXREb2MpXTtcclxuICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZV07XHJcbiAgICBpZiAobW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGggJSAyICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7bWV0aG9kTmFtZX0oKSBuZWVkcyB0byBiZSBjYWxsZWQgd2l0aCBhbiBldmVuIG51bWJlciBgICtcclxuICAgICAgICAgICAgJ29mIGFyZ3VtZW50cyB0aGF0IGFsdGVybmF0ZSBiZXR3ZWVuIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXMuJyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vcmVGaWVsZHNBbmRWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICBrZXlzLnB1c2goZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgbW9yZUZpZWxkc0FuZFZhbHVlc1tpXSkpO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKG1vcmVGaWVsZHNBbmRWYWx1ZXNbaSArIDFdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciB0byBwaWNrIHRoZSBsYXN0IHZhbHVlIGZvciBhIGZpZWxkIGlmIHRoZVxyXG4gICAgLy8gdXNlciBzcGVjaWZpZWQgdGhlIGZpZWxkIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBpZiAoIWZpZWxkTWFza0NvbnRhaW5zKGZpZWxkTWFza1BhdGhzLCBrZXlzW2ldKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXHJcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cclxuICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlZFVwZGF0ZURhdGEodXBkYXRlRGF0YSwgbWFzaywgY29udGV4dC5maWVsZFRyYW5zZm9ybXMpO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZSBhIFwicXVlcnkgdmFsdWVcIiAoZS5nLiB2YWx1ZSBpbiBhIHdoZXJlIGZpbHRlciBvciBhIHZhbHVlIGluIGEgY3Vyc29yXHJcbiAqIGJvdW5kKS5cclxuICpcclxuICogQHBhcmFtIGFsbG93QXJyYXlzIC0gV2hldGhlciB0aGUgcXVlcnkgdmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBtYXkgZGlyZWN0bHlcclxuICogY29udGFpbiBhZGRpdGlvbmFsIGFycmF5cyAoZS5nLiB0aGUgb3BlcmFuZCBvZiBhbiBgaW5gIHF1ZXJ5KS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlUXVlcnlWYWx1ZSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgaW5wdXQsIGFsbG93QXJyYXlzID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KGFsbG93QXJyYXlzID8gNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovIDogMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLywgbWV0aG9kTmFtZSk7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHBhcnNlZDtcclxufVxyXG4vKipcclxuICogUGFyc2VzIHVzZXIgZGF0YSB0byBQcm90b2J1ZiBWYWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCAtIERhdGEgdG8gYmUgcGFyc2VkLlxyXG4gKiBAcGFyYW0gY29udGV4dCAtIEEgY29udGV4dCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHBhdGggYmVpbmcgcGFyc2VkLFxyXG4gKiB0aGUgc291cmNlIG9mIHRoZSBkYXRhIGJlaW5nIHBhcnNlZCwgZXRjLlxyXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLCBvciBudWxsIGlmIHRoZSB2YWx1ZSB3YXMgYSBGaWVsZFZhbHVlIHNlbnRpbmVsXHJcbiAqIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIHBhcnNlZCBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEYXRhKGlucHV0LCBjb250ZXh0KSB7XHJcbiAgICAvLyBVbndyYXAgdGhlIEFQSSB0eXBlIGZyb20gdGhlIENvbXBhdCBTREsuIFRoaXMgd2lsbCByZXR1cm4gdGhlIEFQSSB0eXBlXHJcbiAgICAvLyBmcm9tIGZpcmVzdG9yZS1leHAuXHJcbiAgICBpbnB1dCA9IGdldE1vZHVsYXJJbnN0YW5jZShpbnB1dCk7XHJcbiAgICBpZiAobG9va3NMaWtlSnNvbk9iamVjdChpbnB1dCkpIHtcclxuICAgICAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTonLCBjb250ZXh0LCBpbnB1dCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRmllbGRWYWx1ZSkge1xyXG4gICAgICAgIC8vIEZpZWxkVmFsdWVzIHVzdWFsbHkgcGFyc2UgaW50byB0cmFuc2Zvcm1zIChleGNlcHQgZGVsZXRlRmllbGQoKSlcclxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgdGhpcyBmaWVsZCBpbiBvdXIgcGFyc2VkIGRhdGFcclxuICAgICAgICAvLyAoYXMgZG9pbmcgc28gd2lsbCBvdmVyd3JpdGUgdGhlIGZpZWxkIGRpcmVjdGx5IHByaW9yIHRvIHRoZSB0cmFuc2Zvcm1cclxuICAgICAgICAvLyB0cnlpbmcgdG8gdHJhbnNmb3JtIGl0KS4gU28gd2UgZG9uJ3QgYWRkIHRoaXMgbG9jYXRpb24gdG9cclxuICAgICAgICAvLyBjb250ZXh0LmZpZWxkTWFzayBhbmQgd2UgcmV0dXJuIG51bGwgYXMgb3VyIHBhcnNpbmcgcmVzdWx0LlxyXG4gICAgICAgIHBhcnNlU2VudGluZWxGaWVsZFZhbHVlKGlucHV0LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlucHV0ID09PSB1bmRlZmluZWQgJiYgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCBpdCBjYW4gbmV2ZXIgcGFydGljaXBhdGUgaW4gdGhlIGZpZWxkTWFzaywgc29cclxuICAgICAgICAvLyBkb24ndCBoYW5kbGUgdGhpcyBiZWxvdy4gSWYgYGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXNgIGlzIGZhbHNlLFxyXG4gICAgICAgIC8vIGBwYXJzZVNjYWxhclZhbHVlYCB3aWxsIHJlamVjdCBhbiB1bmRlZmluZWQgdmFsdWUuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBJZiBjb250ZXh0LnBhdGggaXMgbnVsbCB3ZSBhcmUgaW5zaWRlIGFuIGFycmF5IGFuZCB3ZSBkb24ndCBzdXBwb3J0XHJcbiAgICAgICAgLy8gZmllbGQgbWFzayBwYXRocyBtb3JlIGdyYW51bGFyIHRoYW4gdGhlIHRvcC1sZXZlbCBhcnJheS5cclxuICAgICAgICBpZiAoY29udGV4dC5wYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogSW5jbHVkZSB0aGUgcGF0aCBjb250YWluaW5nIHRoZSBhcnJheSBpbiB0aGUgZXJyb3JcclxuICAgICAgICAgICAgLy8gbWVzc2FnZS5cclxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgSU4gcXVlcmllcywgdGhlIHBhcnNlZCBkYXRhIGlzIGFuIGFycmF5IChyZXByZXNlbnRpbmdcclxuICAgICAgICAgICAgLy8gdGhlIHNldCBvZiB2YWx1ZXMgdG8gYmUgaW5jbHVkZWQgZm9yIHRoZSBJTiBxdWVyeSkgdGhhdCBtYXkgZGlyZWN0bHlcclxuICAgICAgICAgICAgLy8gY29udGFpbiBhZGRpdGlvbmFsIGFycmF5cyAoZWFjaCByZXByZXNlbnRpbmcgYW4gaW5kaXZpZHVhbCBmaWVsZFxyXG4gICAgICAgICAgICAvLyB2YWx1ZSksIHNvIHdlIGRpc2FibGUgdGhpcyB2YWxpZGF0aW9uLlxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zZXR0aW5ncy5hcnJheUVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGF0YVNvdXJjZSAhPT0gNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdOZXN0ZWQgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXkoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2NhbGFyVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmosIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xyXG4gICAgaWYgKGlzRW1wdHkob2JqKSkge1xyXG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlbXB0eSBvYmplY3QsIHdlIGV4cGxpY2l0bHkgYWRkIGl0IHRvIHRoZSB1cGRhdGVcclxuICAgICAgICAvLyBtYXNrIHRvIGVuc3VyZSB0aGF0IHRoZSBzZXJ2ZXIgY3JlYXRlcyBhIG1hcCBlbnRyeS5cclxuICAgICAgICBpZiAoY29udGV4dC5wYXRoICYmIGNvbnRleHQucGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3JFYWNoKG9iaiwgKGtleSwgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbCwgY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZChrZXkpKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gcGFyc2VkVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1hcFZhbHVlOiB7IGZpZWxkcyB9IH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBcnJheShhcnJheSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBsZXQgZW50cnlJbmRleCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFycmF5KSB7XHJcbiAgICAgICAgbGV0IHBhcnNlZEVudHJ5ID0gcGFyc2VEYXRhKGVudHJ5LCBjb250ZXh0LmNoaWxkQ29udGV4dEZvckFycmF5KGVudHJ5SW5kZXgpKTtcclxuICAgICAgICBpZiAocGFyc2VkRW50cnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGluY2x1ZGUgbnVsbHMgaW4gdGhlIGFycmF5IGZvciBmaWVsZHMgYmVpbmcgcmVwbGFjZWQgd2l0aCBhXHJcbiAgICAgICAgICAgIC8vIHNlbnRpbmVsLlxyXG4gICAgICAgICAgICBwYXJzZWRFbnRyeSA9IHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkRW50cnkpO1xyXG4gICAgICAgIGVudHJ5SW5kZXgrKztcclxuICAgIH1cclxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcclxufVxyXG4vKipcclxuICogXCJQYXJzZXNcIiB0aGUgcHJvdmlkZWQgRmllbGRWYWx1ZUltcGwsIGFkZGluZyBhbnkgbmVjZXNzYXJ5IHRyYW5zZm9ybXMgdG9cclxuICogY29udGV4dC5maWVsZFRyYW5zZm9ybXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVNlbnRpbmVsRmllbGRWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgLy8gU2VudGluZWxzIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIHdyaXRlcywgYW5kIG5vdCB3aXRoaW4gYXJyYXlzLlxyXG4gICAgaWYgKCFpc1dyaXRlKGNvbnRleHQuZGF0YVNvdXJjZSkpIHtcclxuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3ZhbHVlLl9tZXRob2ROYW1lfSgpIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB1cGRhdGUoKSBhbmQgc2V0KClgKTtcclxuICAgIH1cclxuICAgIGlmICghY29udGV4dC5wYXRoKSB7XHJcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt2YWx1ZS5fbWV0aG9kTmFtZX0oKSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbnNpZGUgYXJyYXlzYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IHZhbHVlLl90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpO1xyXG4gICAgaWYgKGZpZWxkVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29udGV4dC5maWVsZFRyYW5zZm9ybXMucHVzaChmaWVsZFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBwYXJzZSBhIHNjYWxhciB2YWx1ZSAoaS5lLiBub3QgYW4gT2JqZWN0LCBBcnJheSwgb3IgRmllbGRWYWx1ZSlcclxuICpcclxuICogQHJldHVybnMgVGhlIHBhcnNlZCB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VTY2FsYXJWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgdmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UodmFsdWUpO1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogdmFsdWUgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogdmFsdWUgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5mcm9tRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWVzdGFtcCkge1xyXG4gICAgICAgIC8vIEZpcmVzdG9yZSBiYWNrZW5kIHRydW5jYXRlcyBwcmVjaXNpb24gZG93biB0byBtaWNyb3NlY29uZHMuIFRvIGVuc3VyZVxyXG4gICAgICAgIC8vIG9mZmxpbmUgbW9kZSB3b3JrcyB0aGUgc2FtZSB3aXRoIHJlZ2FyZHMgdG8gdHJ1bmNhdGlvbiwgcGVyZm9ybSB0aGVcclxuICAgICAgICAvLyB0cnVuY2F0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIGJhY2tlbmQgdG8gZG8gdGhhdC5cclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKHZhbHVlLnNlY29uZHMsIE1hdGguZmxvb3IodmFsdWUubmFub3NlY29uZHMgLyAxMDAwKSAqIDEwMDApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB0b1RpbWVzdGFtcChjb250ZXh0LnNlcmlhbGl6ZXIsIHRpbWVzdGFtcClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBHZW9Qb2ludCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdlb1BvaW50VmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiB2YWx1ZS5sYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogdmFsdWUubG9uZ2l0dWRlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCeXRlcykge1xyXG4gICAgICAgIHJldHVybiB7IGJ5dGVzVmFsdWU6IHRvQnl0ZXMoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZS5fYnl0ZVN0cmluZykgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcclxuICAgICAgICBjb25zdCB0aGlzRGIgPSBjb250ZXh0LmRhdGFiYXNlSWQ7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEYiA9IHZhbHVlLmZpcmVzdG9yZS5fZGF0YWJhc2VJZDtcclxuICAgICAgICBpZiAoIW90aGVyRGIuaXNFcXVhbCh0aGlzRGIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IHJlZmVyZW5jZSBpcyBmb3IgZGF0YWJhc2UgJyArXHJcbiAgICAgICAgICAgICAgICBgJHtvdGhlckRiLnByb2plY3RJZH0vJHtvdGhlckRiLmRhdGFiYXNlfSBidXQgc2hvdWxkIGJlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGZvciBkYXRhYmFzZSAke3RoaXNEYi5wcm9qZWN0SWR9LyR7dGhpc0RiLmRhdGFiYXNlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZWZlcmVuY2VWYWx1ZTogdG9SZXNvdXJjZU5hbWUodmFsdWUuZmlyZXN0b3JlLl9kYXRhYmFzZUlkIHx8IGNvbnRleHQuZGF0YWJhc2VJZCwgdmFsdWUuX2tleS5wYXRoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGBVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTogJHt2YWx1ZURlc2NyaXB0aW9uKHZhbHVlKX1gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGxvb2tzIGxpa2UgYSBKU09OIG9iamVjdCB0aGF0IHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICogaW50byBhIHN0cnVjdC4gTm9ybWFsIGNsYXNzL3Byb3RvdHlwZSBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlXHJcbiAqIEpTT04gb2JqZWN0cyBzaW5jZSB0aGV5IHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJ1Y3QgdmFsdWUuIEFycmF5cywgRGF0ZXMsXHJcbiAqIEdlb1BvaW50cywgZXRjLiBhcmUgbm90IGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlIEpTT04gb2JqZWN0cyBzaW5jZSB0aGV5IG1hcFxyXG4gKiB0byBzcGVjaWZpYyBGaWVsZFZhbHVlIHR5cGVzIG90aGVyIHRoYW4gT2JqZWN0VmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICBpbnB1dCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgVGltZXN0YW1wKSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBHZW9Qb2ludCkgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgQnl0ZXMpICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQbGFpbk9iamVjdChtZXNzYWdlLCBjb250ZXh0LCBpbnB1dCkge1xyXG4gICAgaWYgKCFsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSB8fCAhaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlRGVzY3JpcHRpb24oaW5wdXQpO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJ2FuIG9iamVjdCcpIHtcclxuICAgICAgICAgICAgLy8gTWFzc2FnZSB0aGUgZXJyb3IgaWYgaXQgd2FzIGFuIG9iamVjdC5cclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyBhIGN1c3RvbSBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IobWVzc2FnZSArICcgJyArIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0aGF0IGNhbGxzIGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoKSBidXQgd3JhcHMgYW55IGVycm9yIHRocm93bi5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHBhdGgsIHRhcmdldERvYykge1xyXG4gICAgLy8gSWYgcmVxdWlyZWQsIHJlcGxhY2UgdGhlIEZpZWxkUGF0aCBDb21wYXQgY2xhc3Mgd2l0aCB3aXRoIHRoZSBmaXJlc3RvcmUtZXhwXHJcbiAgICAvLyBGaWVsZFBhdGguXHJcbiAgICBwYXRoID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhdGgpO1xyXG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5faW50ZXJuYWxQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ZpZWxkIHBhdGggYXJndW1lbnRzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgJztcclxuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihtZXNzYWdlLCBtZXRob2ROYW1lLCBcclxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hdGNoZXMgYW55IGNoYXJhY3RlcnMgaW4gYSBmaWVsZCBwYXRoIHN0cmluZyB0aGF0IGFyZSByZXNlcnZlZC5cclxuICovXHJcbmNvbnN0IEZJRUxEX1BBVEhfUkVTRVJWRUQgPSBuZXcgUmVnRXhwKCdbflxcXFwqL1xcXFxbXFxcXF1dJyk7XHJcbi8qKlxyXG4gKiBXcmFwcyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCB0aGUgbWV0aG9kIHRoYXRcclxuICogd2FzIHRocm93bi5cclxuICogQHBhcmFtIG1ldGhvZE5hbWUgLSBUaGUgcHVibGljbHkgdmlzaWJsZSBtZXRob2QgbmFtZVxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBkb3Qtc2VwYXJhdGVkIHN0cmluZyBmb3JtIG9mIGEgZmllbGQgcGF0aCB3aGljaCB3aWxsIGJlXHJcbiAqIHNwbGl0IG9uIGRvdHMuXHJcbiAqIEBwYXJhbSB0YXJnZXREb2MgLSBUaGUgZG9jdW1lbnQgYWdhaW5zdCB3aGljaCB0aGUgZmllbGQgcGF0aCB3aWxsIGJlXHJcbiAqIGV2YWx1YXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgcGF0aCwgdGFyZ2V0RG9jKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IHBhdGguc2VhcmNoKEZJRUxEX1BBVEhfUkVTRVJWRUQpO1xyXG4gICAgaWYgKGZvdW5kID49IDApIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgY29udGFpbiBgICtcclxuICAgICAgICAgICAgYCd+JywgJyonLCAnLycsICdbJywgb3IgJ10nYCwgbWV0aG9kTmFtZSwgXHJcbiAgICAgICAgLyogaGFzQ29udmVydGVyPSAqLyBmYWxzZSwgXHJcbiAgICAgICAgLyogcGF0aD0gKi8gdW5kZWZpbmVkLCB0YXJnZXREb2MpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCguLi5wYXRoLnNwbGl0KCcuJykpLl9pbnRlcm5hbFBhdGg7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBiZSBlbXB0eSwgYCArXHJcbiAgICAgICAgICAgIGBiZWdpbiB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgLCBtZXRob2ROYW1lLCBcclxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRXJyb3IocmVhc29uLCBtZXRob2ROYW1lLCBoYXNDb252ZXJ0ZXIsIHBhdGgsIHRhcmdldERvYykge1xyXG4gICAgY29uc3QgaGFzUGF0aCA9IHBhdGggJiYgIXBhdGguaXNFbXB0eSgpO1xyXG4gICAgY29uc3QgaGFzRG9jdW1lbnQgPSB0YXJnZXREb2MgIT09IHVuZGVmaW5lZDtcclxuICAgIGxldCBtZXNzYWdlID0gYEZ1bmN0aW9uICR7bWV0aG9kTmFtZX0oKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGRhdGFgO1xyXG4gICAgaWYgKGhhc0NvbnZlcnRlcikge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gJyAodmlhIGB0b0ZpcmVzdG9yZSgpYCknO1xyXG4gICAgfVxyXG4gICAgbWVzc2FnZSArPSAnLiAnO1xyXG4gICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XHJcbiAgICBpZiAoaGFzUGF0aCB8fCBoYXNEb2N1bWVudCkge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcgKGZvdW5kJztcclxuICAgICAgICBpZiAoaGFzUGF0aCkge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgIGluIGZpZWxkICR7cGF0aH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCBpbiBkb2N1bWVudCAke3RhcmdldERvY31gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnKSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgbWVzc2FnZSArIHJlYXNvbiArIGRlc2NyaXB0aW9uKTtcclxufVxyXG4vKiogQ2hlY2tzIGBoYXlzdGFja2AgaWYgRmllbGRQYXRoIGBuZWVkbGVgIGlzIHByZXNlbnQuIFJ1bnMgaW4gTyhuKS4gKi9cclxuZnVuY3Rpb24gZmllbGRNYXNrQ29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSkge1xyXG4gICAgcmV0dXJuIGhheXN0YWNrLnNvbWUodiA9PiB2LmlzRXF1YWwobmVlZGxlKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91ciBGaXJlc3RvcmVcclxuICogZGF0YWJhc2UuIFRoZSBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvXHJcbiAqIGdldCBhIHNwZWNpZmljIGZpZWxkLlxyXG4gKlxyXG4gKiBGb3IgYSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwb2ludHMgdG8gYSBub24tZXhpc3RpbmcgZG9jdW1lbnQsIGFueSBkYXRhXHJcbiAqIGFjY2VzcyB3aWxsIHJldHVybiAndW5kZWZpbmVkJy4gWW91IGNhbiB1c2UgdGhlIGBleGlzdHMoKWAgbWV0aG9kIHRvXHJcbiAqIGV4cGxpY2l0bHkgdmVyaWZ5IGEgZG9jdW1lbnQncyBleGlzdGVuY2UuXHJcbiAqL1xyXG5jbGFzcyBEb2N1bWVudFNuYXBzaG90JDEge1xyXG4gICAgLy8gTm90ZTogVGhpcyBjbGFzcyBpcyBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIERvY3VtZW50U25hcHNob3QgaW5cclxuICAgIC8vIHRoZSBsZWdhY3kgU0RLLiBUaGUgY2hhbmdlcyBhcmU6XHJcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90TWV0YWRhdGEuXHJcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90T3B0aW9ucy5cclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3VzZXJEYXRhV3JpdGVyLCBfa2V5LCBfZG9jdW1lbnQsIF9jb252ZXJ0ZXIpIHtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fY29udmVydGVyID0gX2NvbnZlcnRlcjtcclxuICAgIH1cclxuICAgIC8qKiBQcm9wZXJ0eSBvZiB0aGUgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcHJvdmlkZXMgdGhlIGRvY3VtZW50J3MgSUQuICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgRG9jdW1lbnRSZWZlcmVuY2VgIGZvciB0aGUgZG9jdW1lbnQgaW5jbHVkZWQgaW4gdGhlIGBEb2N1bWVudFNuYXBzaG90YC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fY29udmVydGVyLCB0aGlzLl9rZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduYWxzIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBhdCB0aGUgc25hcHNob3QncyBsb2NhdGlvbiBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50ICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGBcclxuICAgICAqIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcclxuICAgICAgICAgICAgLy8gaWYgYSBjb252ZXJ0ZXIgaGFzIGJlZW4gcHJvdmlkZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIFxyXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUoc25hcHNob3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh0aGlzLl9kb2N1bWVudC5kYXRhLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxyXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xyXG4gICAgICogZmllbGQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSBhdCB0aGUgc3BlY2lmaWVkIGZpZWxkIGxvY2F0aW9uIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoXHJcbiAgICAgKiBmaWVsZCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICAvLyBXZSBhcmUgdXNpbmcgYGFueWAgaGVyZSB0byBhdm9pZCBhbiBleHBsaWNpdCBjYXN0IGJ5IG91ciB1c2Vycy5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBnZXQoZmllbGRQYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcclxuICogRmlyZXN0b3JlIGRhdGFiYXNlIGFzIHBhcnQgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50IGlzIGd1YXJhbnRlZWQgdG8gZXhpc3RcclxuICogYW5kIGl0cyBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvIGdldCBhXHJcbiAqIHNwZWNpZmljIGZpZWxkLlxyXG4gKlxyXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIG9mZmVycyB0aGUgc2FtZSBBUEkgc3VyZmFjZSBhcyBhXHJcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcclxuICogYGV4aXN0c2AgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgdHJ1ZSBhbmQgYGRhdGEoKWAgd2lsbCBuZXZlciByZXR1cm5cclxuICogJ3VuZGVmaW5lZCcuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeURvY3VtZW50U25hcHNob3QkMSBleHRlbmRzIERvY3VtZW50U25hcHNob3QkMSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRoYXQgY2FsbHMgYGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoKWAgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWVsZFBhdGhGcm9tQXJndW1lbnQobWV0aG9kTmFtZSwgYXJnKSB7XHJcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBhcmcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZy5faW50ZXJuYWxQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZy5fZGVsZWdhdGUuX2ludGVybmFsUGF0aDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHF1ZXJ5KSB7XHJcbiAgICBpZiAocXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxyXG4gICAgICAgIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnbGltaXRUb0xhc3QoKSBxdWVyaWVzIHJlcXVpcmUgc3BlY2lmeWluZyBhdCBsZWFzdCBvbmUgb3JkZXJCeSgpIGNsYXVzZScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBgQXBwbGlhYmxlQ29uc3RyYWludGAgaXMgYW4gYWJzdHJhY3Rpb24gb2YgYSBjb25zdHJhaW50IHRoYXQgY2FuIGJlIGFwcGxpZWRcclxuICogdG8gYSBGaXJlc3RvcmUgcXVlcnkuXHJcbiAqL1xyXG5jbGFzcyBBcHBsaWFibGVDb25zdHJhaW50IHtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXHJcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayB3aGVyZX0sXHJcbiAqIHtAbGluayBvcmRlckJ5fSwge0BsaW5rIChzdGFydEF0OjEpfSwge0BsaW5rIChzdGFydEFmdGVyOjEpfSwge0BsaW5rXHJcbiAqIChlbmRCZWZvcmU6MSl9LCB7QGxpbmsgKGVuZEF0OjEpfSwge0BsaW5rIGxpbWl0fSwge0BsaW5rIGxpbWl0VG9MYXN0fSBhbmRcclxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0XHJcbiAqIGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5Q29uc3RyYWludCBleHRlbmRzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5KHF1ZXJ5LCBxdWVyeUNvbnN0cmFpbnQsIC4uLmFkZGl0aW9uYWxRdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICBsZXQgcXVlcnlDb25zdHJhaW50cyA9IFtdO1xyXG4gICAgaWYgKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIEFwcGxpYWJsZUNvbnN0cmFpbnQpIHtcclxuICAgICAgICBxdWVyeUNvbnN0cmFpbnRzLnB1c2gocXVlcnlDb25zdHJhaW50KTtcclxuICAgIH1cclxuICAgIHF1ZXJ5Q29uc3RyYWludHMgPSBxdWVyeUNvbnN0cmFpbnRzLmNvbmNhdChhZGRpdGlvbmFsUXVlcnlDb25zdHJhaW50cyk7XHJcbiAgICB2YWxpZGF0ZVF1ZXJ5Q29uc3RyYWludEFycmF5KHF1ZXJ5Q29uc3RyYWludHMpO1xyXG4gICAgZm9yIChjb25zdCBjb25zdHJhaW50IG9mIHF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICBxdWVyeSA9IGNvbnN0cmFpbnQuX2FwcGx5KHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5XHJcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5IGJ5IGZpbHRlcmluZyBvbiBvbmUgb3IgbW9yZSBkb2N1bWVudCBmaWVsZHMuXHJcbiAqIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayB3aGVyZX0gYW5kIGNhbiB0aGVuXHJcbiAqIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zXHJcbiAqIHRoaXMgYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maWVsZCwgX29wLCBfdmFsdWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2ZpZWxkID0gX2ZpZWxkO1xyXG4gICAgICAgIHRoaXMuX29wID0gX29wO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnd2hlcmUnO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUoX2ZpZWxkLCBfb3AsIF92YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQoX2ZpZWxkLCBfb3AsIF92YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9wYXJzZShxdWVyeSk7XHJcbiAgICAgICAgdmFsaWRhdGVOZXdGaWVsZEZpbHRlcihxdWVyeS5fcXVlcnksIGZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBmaWx0ZXIpKTtcclxuICAgIH1cclxuICAgIF9wYXJzZShxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHF1ZXJ5LmZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gbmV3UXVlcnlGaWx0ZXIocXVlcnkuX3F1ZXJ5LCAnd2hlcmUnLCByZWFkZXIsIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgdGhpcy5fZmllbGQsIHRoaXMuX29wLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0gdGhhdCBlbmZvcmNlcyB0aGF0IGRvY3VtZW50c1xyXG4gKiBtdXN0IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCBhbmQgdGhhdCB0aGUgdmFsdWUgc2hvdWxkIHNhdGlzZnkgdGhlXHJcbiAqIHJlbGF0aW9uIGNvbnN0cmFpbnQgcHJvdmlkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCB0byBjb21wYXJlXHJcbiAqIEBwYXJhbSBvcFN0ciAtIFRoZSBvcGVyYXRpb24gc3RyaW5nIChlLmcgXCImbHQ7XCIsIFwiJmx0Oz1cIiwgXCI9PVwiLCBcIiZsdDtcIixcclxuICogICBcIiZsdDs9XCIsIFwiIT1cIikuXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgY29tcGFyaXNvblxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gd2hlcmUoZmllbGRQYXRoLCBvcFN0ciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IG9wID0gb3BTdHI7XHJcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnd2hlcmUnLCBmaWVsZFBhdGgpO1xyXG4gICAgcmV0dXJuIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoZmllbGQsIG9wLCB2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHNcclxuICogcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkgYnkgcGVyZm9ybWluZyB0aGUgbG9naWNhbCBPUiBvciBBTkQgb2YgbXVsdGlwbGVcclxuICoge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fXMgb3Ige0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH1zLlxyXG4gKiBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIG9yfSBvclxyXG4gKiB7QGxpbmsgYW5kfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeVxyXG4gKiBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhlIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50IGV4dGVuZHMgQXBwbGlhYmxlQ29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cclxuICAgIHR5cGUsIF9xdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHMgPSBfcXVlcnlDb25zdHJhaW50cztcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9xdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQodHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkRmlsdGVycyA9IHRoaXMuX3F1ZXJ5Q29uc3RyYWludHNcclxuICAgICAgICAgICAgLm1hcChxdWVyeUNvbnN0cmFpbnQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnlDb25zdHJhaW50Ll9wYXJzZShxdWVyeSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihwYXJzZWRGaWx0ZXIgPT4gcGFyc2VkRmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPiAwKTtcclxuICAgICAgICBpZiAocGFyc2VkRmlsdGVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEZpbHRlcnNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHBhcnNlZEZpbHRlcnMsIHRoaXMuX2dldE9wZXJhdG9yKCkpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkRmlsdGVyID0gdGhpcy5fcGFyc2UocXVlcnkpO1xyXG4gICAgICAgIGlmIChwYXJzZWRGaWx0ZXIuZ2V0RmlsdGVycygpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGV4aXN0aW5nIHF1ZXJ5IGlmIG5vdCBhZGRpbmcgYW55IG1vcmUgZmlsdGVycyAoZS5nLiBhbiBlbXB0eVxyXG4gICAgICAgICAgICAvLyBjb21wb3NpdGUgZmlsdGVyKS5cclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeS5fcXVlcnksIHBhcnNlZEZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBwYXJzZWRGaWx0ZXIpKTtcclxuICAgIH1cclxuICAgIF9nZXRRdWVyeUNvbnN0cmFpbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeUNvbnN0cmFpbnRzO1xyXG4gICAgfVxyXG4gICAgX2dldE9wZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdhbmQnID8gXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8gOiBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi87XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBpcyBhIGRpc2p1bmN0aW9uIG9mXHJcbiAqIHRoZSBnaXZlbiBmaWx0ZXIgY29uc3RyYWludHMuIEEgZGlzanVuY3Rpb24gZmlsdGVyIGluY2x1ZGVzIGEgZG9jdW1lbnQgaWYgaXRcclxuICogc2F0aXNmaWVzIGFueSBvZiB0aGUgZ2l2ZW4gZmlsdGVycy5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBPcHRpb25hbC4gVGhlIGxpc3Qgb2ZcclxuICoge0BsaW5rIFF1ZXJ5RmlsdGVyQ29uc3RyYWludH1zIHRvIHBlcmZvcm0gYSBkaXNqdW5jdGlvbiBmb3IuIFRoZXNlIG11c3QgYmVcclxuICogY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sIHtAbGluayBvcn0sIG9yIHtAbGluayBhbmR9LlxyXG4gKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIG9yKC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXHJcbiAgICBxdWVyeUNvbnN0cmFpbnRzLmZvckVhY2gocXVlcnlDb25zdHJhaW50ID0+IHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KCdvcicsIHF1ZXJ5Q29uc3RyYWludCkpO1xyXG4gICAgcmV0dXJuIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludC5fY3JlYXRlKFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLywgcXVlcnlDb25zdHJhaW50cyk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBpcyBhIGNvbmp1bmN0aW9uIG9mXHJcbiAqIHRoZSBnaXZlbiBmaWx0ZXIgY29uc3RyYWludHMuIEEgY29uanVuY3Rpb24gZmlsdGVyIGluY2x1ZGVzIGEgZG9jdW1lbnQgaWYgaXRcclxuICogc2F0aXNmaWVzIGFsbCBvZiB0aGUgZ2l2ZW4gZmlsdGVycy5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBPcHRpb25hbC4gVGhlIGxpc3Qgb2ZcclxuICoge0BsaW5rIFF1ZXJ5RmlsdGVyQ29uc3RyYWludH1zIHRvIHBlcmZvcm0gYSBjb25qdW5jdGlvbiBmb3IuIFRoZXNlIG11c3QgYmVcclxuICogY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sIHtAbGluayBvcn0sIG9yIHtAbGluayBhbmR9LlxyXG4gKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIGFuZCguLi5xdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICAvLyBPbmx5IHN1cHBvcnQgUXVlcnlGaWx0ZXJDb25zdHJhaW50c1xyXG4gICAgcXVlcnlDb25zdHJhaW50cy5mb3JFYWNoKHF1ZXJ5Q29uc3RyYWludCA9PiB2YWxpZGF0ZVF1ZXJ5RmlsdGVyQ29uc3RyYWludCgnYW5kJywgcXVlcnlDb25zdHJhaW50KSk7XHJcbiAgICByZXR1cm4gUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8sIHF1ZXJ5Q29uc3RyYWludHMpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIHNvcnQgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYVxyXG4gKiBGaXJlc3RvcmUgcXVlcnkuIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmdcclxuICoge0BsaW5rIG9yZGVyQnl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5XHJcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YC5cclxuICpcclxuICogTm90ZTogRG9jdW1lbnRzIHRoYXQgZG8gbm90IGNvbnRhaW4gdGhlIG9yZGVyQnkgZmllbGQgd2lsbCBub3QgYmUgcHJlc2VudCBpblxyXG4gKiB0aGUgcXVlcnkgcmVzdWx0LlxyXG4gKi9cclxuY2xhc3MgUXVlcnlPcmRlckJ5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9kaXJlY3Rpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2ZpZWxkID0gX2ZpZWxkO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdvcmRlckJ5JztcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY3JlYXRlKF9maWVsZCwgX2RpcmVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5Q29uc3RyYWludChfZmllbGQsIF9kaXJlY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3Qgb3JkZXJCeSA9IG5ld1F1ZXJ5T3JkZXJCeShxdWVyeS5fcXVlcnksIHRoaXMuX2ZpZWxkLCB0aGlzLl9kaXJlY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeS5fcXVlcnksIG9yZGVyQnkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeU9yZGVyQnlDb25zdHJhaW50fSB0aGF0IHNvcnRzIHRoZSBxdWVyeSByZXN1bHQgYnkgdGhlXHJcbiAqIHNwZWNpZmllZCBmaWVsZCwgb3B0aW9uYWxseSBpbiBkZXNjZW5kaW5nIG9yZGVyIGluc3RlYWQgb2YgYXNjZW5kaW5nLlxyXG4gKlxyXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIHdpbGwgbm90IGJlIHByZXNlbnRcclxuICogaW4gdGhlIHF1ZXJ5IHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBmaWVsZCB0byBzb3J0IGJ5LlxyXG4gKiBAcGFyYW0gZGlyZWN0aW9uU3RyIC0gT3B0aW9uYWwgZGlyZWN0aW9uIHRvIHNvcnQgYnkgKCdhc2MnIG9yICdkZXNjJykuIElmXHJcbiAqIG5vdCBzcGVjaWZpZWQsIG9yZGVyIHdpbGwgYmUgYXNjZW5kaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlPcmRlckJ5Q29uc3RyYWludH0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uU3RyID0gJ2FzYycpIHtcclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cjtcclxuICAgIGNvbnN0IHBhdGggPSBmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ29yZGVyQnknLCBmaWVsZFBhdGgpO1xyXG4gICAgcmV0dXJuIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQuX2NyZWF0ZShwYXRoLCBkaXJlY3Rpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUxpbWl0Q29uc3RyYWludGAgaXMgdXNlZCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyByZXR1cm5lZCBieVxyXG4gKiBhIEZpcmVzdG9yZSBxdWVyeS5cclxuICogYFF1ZXJ5TGltaXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIGxpbWl0fSBvclxyXG4gKiB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3XHJcbiAqIHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUxpbWl0Q29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUxpbWl0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cclxuICAgIHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcclxuICAgICAgICB0aGlzLl9saW1pdFR5cGUgPSBfbGltaXRUeXBlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0Q29uc3RyYWludCh0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoTGltaXQocXVlcnkuX3F1ZXJ5LCB0aGlzLl9saW1pdCwgdGhpcy5fbGltaXRUeXBlKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9IHRoYXQgb25seSByZXR1cm5zIHRoZSBmaXJzdCBtYXRjaGluZ1xyXG4gKiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4uXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0uXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdChsaW1pdCkge1xyXG4gICAgdmFsaWRhdGVQb3NpdGl2ZU51bWJlcignbGltaXQnLCBsaW1pdCk7XHJcbiAgICByZXR1cm4gUXVlcnlMaW1pdENvbnN0cmFpbnQuX2NyZWF0ZSgnbGltaXQnLCBsaW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGxhc3QgbWF0Y2hpbmdcclxuICogZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBZb3UgbXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBgb3JkZXJCeWAgY2xhdXNlIGZvciBgbGltaXRUb0xhc3RgIHF1ZXJpZXMsXHJcbiAqIG90aGVyd2lzZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gZHVyaW5nIGV4ZWN1dGlvbi5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9MYXN0KGxpbWl0KSB7XHJcbiAgICB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKCdsaW1pdFRvTGFzdCcsIGxpbWl0KTtcclxuICAgIHJldHVybiBRdWVyeUxpbWl0Q29uc3RyYWludC5fY3JlYXRlKCdsaW1pdFRvTGFzdCcsIGxpbWl0LCBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyk7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gZXhjbHVkZSBkb2N1bWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYVxyXG4gKiByZXN1bHQgc2V0IHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5LlxyXG4gKiBgUXVlcnlTdGFydEF0Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayAoc3RhcnRBdDoxKX0gb3JcclxuICoge0BsaW5rIChzdGFydEFmdGVyOjEpfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhXHJcbiAqIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlTdGFydEF0Q29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xyXG4gICAgICAgIHRoaXMuX2luY2x1c2l2ZSA9IF9pbmNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kID0gbmV3UXVlcnlCb3VuZEZyb21Eb2NPckZpZWxkcyhxdWVyeSwgdGhpcy50eXBlLCB0aGlzLl9kb2NPckZpZWxkcywgdGhpcy5faW5jbHVzaXZlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhTdGFydEF0KHF1ZXJ5Ll9xdWVyeSwgYm91bmQpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzdGFydEF0KC4uLmRvY09yRmllbGRzKSB7XHJcbiAgICByZXR1cm4gUXVlcnlTdGFydEF0Q29uc3RyYWludC5fY3JlYXRlKCdzdGFydEF0JywgZG9jT3JGaWVsZHMsIFxyXG4gICAgLyppbmNsdXNpdmU9Ki8gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRBZnRlciguLi5kb2NPckZpZWxkcykge1xyXG4gICAgcmV0dXJuIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQuX2NyZWF0ZSgnc3RhcnRBZnRlcicsIGRvY09yRmllbGRzLCBcclxuICAgIC8qaW5jbHVzaXZlPSovIGZhbHNlKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlFbmRBdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gZXhjbHVkZSBkb2N1bWVudHMgZnJvbSB0aGUgZW5kIG9mIGFcclxuICogcmVzdWx0IHNldCByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeS5cclxuICogYFF1ZXJ5RW5kQXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChlbmRBdDoxKX0gb3JcclxuICoge0BsaW5rIChlbmRCZWZvcmU6MSl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3XHJcbiAqIHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUVuZEF0Q29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUVuZEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cclxuICAgIHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9kb2NPckZpZWxkcyA9IF9kb2NPckZpZWxkcztcclxuICAgICAgICB0aGlzLl9pbmNsdXNpdmUgPSBfaW5jbHVzaXZlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUVuZEF0Q29uc3RyYWludCh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEVuZEF0KHF1ZXJ5Ll9xdWVyeSwgYm91bmQpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRCZWZvcmUoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBRdWVyeUVuZEF0Q29uc3RyYWludC5fY3JlYXRlKCdlbmRCZWZvcmUnLCBkb2NPckZpZWxkcywgXHJcbiAgICAvKmluY2x1c2l2ZT0qLyBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gZW5kQXQoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBRdWVyeUVuZEF0Q29uc3RyYWludC5fY3JlYXRlKCdlbmRBdCcsIGRvY09yRmllbGRzLCBcclxuICAgIC8qaW5jbHVzaXZlPSovIHRydWUpO1xyXG59XHJcbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYm91bmQgZnJvbSBhIGRvY3VtZW50IG9yIGZpZWxkcyAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCBtZXRob2ROYW1lLCBkb2NPckZpZWxkcywgaW5jbHVzaXZlKSB7XHJcbiAgICBkb2NPckZpZWxkc1swXSA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2NPckZpZWxkc1swXSk7XHJcbiAgICBpZiAoZG9jT3JGaWVsZHNbMF0gaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90JDEpIHtcclxuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21Eb2N1bWVudChxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHNbMF0uX2RvY3VtZW50LCBpbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcclxuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21GaWVsZHMocXVlcnkuX3F1ZXJ5LCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIHJlYWRlciwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHMsIGluY2x1c2l2ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3UXVlcnlGaWx0ZXIocXVlcnksIG1ldGhvZE5hbWUsIGRhdGFSZWFkZXIsIGRhdGFiYXNlSWQsIGZpZWxkUGF0aCwgb3AsIHZhbHVlKSB7XHJcbiAgICBsZXQgZmllbGRWYWx1ZTtcclxuICAgIGlmIChmaWVsZFBhdGguaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHwgb3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIFF1ZXJ5LiBZb3UgY2FuJ3QgcGVyZm9ybSAnJHtvcH0nIHF1ZXJpZXMgb24gZG9jdW1lbnRJZCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcclxuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUxpc3QucHVzaChwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgYXJyYXlWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiByZWZlcmVuY2VMaXN0IH0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8XHJcbiAgICAgICAgICAgIG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyB8fFxyXG4gICAgICAgICAgICBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZVF1ZXJ5VmFsdWUoZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWUsIFxyXG4gICAgICAgIC8qIGFsbG93QXJyYXlzPSAqLyBvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWx0ZXIgPSBGaWVsZEZpbHRlci5jcmVhdGUoZmllbGRQYXRoLCBvcCwgZmllbGRWYWx1ZSk7XHJcbiAgICByZXR1cm4gZmlsdGVyO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5T3JkZXJCeShxdWVyeSwgZmllbGRQYXRoLCBkaXJlY3Rpb24pIHtcclxuICAgIGlmIChxdWVyeS5zdGFydEF0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBtdXN0IG5vdCBjYWxsIHN0YXJ0QXQoKSBvciBzdGFydEFmdGVyKCkgYmVmb3JlICcgK1xyXG4gICAgICAgICAgICAnY2FsbGluZyBvcmRlckJ5KCkuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnkuZW5kQXQgIT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IG11c3Qgbm90IGNhbGwgZW5kQXQoKSBvciBlbmRCZWZvcmUoKSBiZWZvcmUgJyArXHJcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9yZGVyQnkgPSBuZXcgT3JkZXJCeShmaWVsZFBhdGgsIGRpcmVjdGlvbik7XHJcbiAgICByZXR1cm4gb3JkZXJCeTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYEJvdW5kYCBmcm9tIGEgcXVlcnkgYW5kIGEgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgYEJvdW5kYCB3aWxsIGFsd2F5cyBpbmNsdWRlIHRoZSBrZXkgb2YgdGhlIGRvY3VtZW50XHJcbiAqIGFuZCBzbyBvbmx5IHRoZSBwcm92aWRlZCBkb2N1bWVudCB3aWxsIGNvbXBhcmUgZXF1YWwgdG8gdGhlIHJldHVybmVkXHJcbiAqIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBXaWxsIHRocm93IGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFsbCBmaWVsZHMgb2YgdGhlIG9yZGVyIGJ5XHJcbiAqIG9mIHRoZSBxdWVyeSBvciBpZiBhbnkgb2YgdGhlIGZpZWxkcyBpbiB0aGUgb3JkZXIgYnkgYXJlIGFuIHVuY29tbWl0dGVkXHJcbiAqIHNlcnZlciB0aW1lc3RhbXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50KHF1ZXJ5LCBkYXRhYmFzZUlkLCBtZXRob2ROYW1lLCBkb2MsIGluY2x1c2l2ZSkge1xyXG4gICAgaWYgKCFkb2MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5OT1RfRk9VTkQsIGBDYW4ndCB1c2UgYSBEb2N1bWVudFNuYXBzaG90IHRoYXQgZG9lc24ndCBleGlzdCBmb3IgYCArXHJcbiAgICAgICAgICAgIGAke21ldGhvZE5hbWV9KCkuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XHJcbiAgICAvLyBCZWNhdXNlIHBlb3BsZSBleHBlY3QgdG8gY29udGludWUvZW5kIGEgcXVlcnkgYXQgdGhlIGV4YWN0IGRvY3VtZW50XHJcbiAgICAvLyBwcm92aWRlZCwgd2UgbmVlZCB0byB1c2UgdGhlIGltcGxpY2l0IHNvcnQgb3JkZXIgcmF0aGVyIHRoYW4gdGhlIGV4cGxpY2l0XHJcbiAgICAvLyBzb3J0IG9yZGVyLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBjb250YWluIHRoZSBkb2N1bWVudCBrZXkuIFRoYXQgd2F5XHJcbiAgICAvLyB0aGUgcG9zaXRpb24gYmVjb21lcyB1bmFtYmlndW91cyBhbmQgdGhlIHF1ZXJ5IGNvbnRpbnVlcy9lbmRzIGV4YWN0bHkgYXRcclxuICAgIC8vIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gV2l0aG91dCB0aGUga2V5IChieSB1c2luZyB0aGUgZXhwbGljaXQgc29ydFxyXG4gICAgLy8gb3JkZXJzKSwgbXVsdGlwbGUgZG9jdW1lbnRzIGNvdWxkIG1hdGNoIHRoZSBwb3NpdGlvbiwgeWllbGRpbmcgZHVwbGljYXRlXHJcbiAgICAvLyByZXN1bHRzLlxyXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XHJcbiAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChyZWZWYWx1ZShkYXRhYmFzZUlkLCBkb2Mua2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvYy5kYXRhLmZpZWxkKG9yZGVyQnkuZmllbGQpO1xyXG4gICAgICAgICAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCBcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyQnkuZmllbGQgK1xyXG4gICAgICAgICAgICAgICAgICAgICdcIiBpcyBhbiB1bmNvbW1pdHRlZCBzZXJ2ZXIgdGltZXN0YW1wLiAoU2luY2UgdGhlIHZhbHVlIG9mICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd0aGlzIGZpZWxkIGlzIHVua25vd24sIHlvdSBjYW5ub3Qgc3RhcnQvZW5kIGEgcXVlcnkgd2l0aCBpdC4pJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCAnJHtmaWVsZH0nICh1c2VkIGFzIHRoZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgb3JkZXJCeSkgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKGNvbXBvbmVudHMsIGluY2x1c2l2ZSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBmaWVsZCB2YWx1ZXMgdG8gYSBgQm91bmRgIGZvciB0aGUgZ2l2ZW4gcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbUZpZWxkcyhxdWVyeSwgZGF0YWJhc2VJZCwgZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWVzLCBpbmNsdXNpdmUpIHtcclxuICAgIC8vIFVzZSBleHBsaWNpdCBvcmRlciBieSdzIGJlY2F1c2UgaXQgaGFzIHRvIG1hdGNoIHRoZSBxdWVyeSB0aGUgdXNlciBtYWRlXHJcbiAgICBjb25zdCBvcmRlckJ5ID0gcXVlcnkuZXhwbGljaXRPcmRlckJ5O1xyXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiBvcmRlckJ5Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBUb28gbWFueSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gJHttZXRob2ROYW1lfSgpLiBgICtcclxuICAgICAgICAgICAgYFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBgICtcclxuICAgICAgICAgICAgYG51bWJlciBvZiBvcmRlckJ5KCkgY2xhdXNlc2ApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgICBjb25zdCBvcmRlckJ5Q29tcG9uZW50ID0gb3JkZXJCeVtpXTtcclxuICAgICAgICBpZiAob3JkZXJCeUNvbXBvbmVudC5maWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByYXdWYWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBFeHBlY3RlZCBhIHN0cmluZyBmb3IgZG9jdW1lbnQgSUQgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7bWV0aG9kTmFtZX0oKSwgYnV0IGdvdCBhICR7dHlwZW9mIHJhd1ZhbHVlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkgJiYgcmF3VmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGFuZCBvcmRlcmluZyBieSBkb2N1bWVudElkKCksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB0aGUgdmFsdWUgcGFzc2VkIHRvICR7bWV0aG9kTmFtZX0oKSBtdXN0IGJlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJyR7cmF3VmFsdWV9JyBjb250YWlucyBhIHNsYXNoLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHJhd1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGdyb3VwIGFuZCBvcmRlcmluZyBieSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcGFzc2VkIHRvICR7bWV0aG9kTmFtZX0oKSBtdXN0IHJlc3VsdCBpbiBhIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB2YWxpZCBkb2N1bWVudCBwYXRoLCBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGNvbnRhaW5zIGFuIG9kZCBudW1iZXIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYG9mIHNlZ21lbnRzLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShwYXRoKTtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHJlZlZhbHVlKGRhdGFiYXNlSWQsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHBhcnNlUXVlcnlWYWx1ZShkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCByYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh3cmFwcGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKGNvbXBvbmVudHMsIGluY2x1c2l2ZSk7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gYGRvY3VtZW50SWRWYWx1ZWAgaW50byBhIGBSZWZlcmVuY2VWYWx1ZWAsIHRocm93aW5nXHJcbiAqIGFwcHJvcHJpYXRlIGVycm9ycyBpZiB0aGUgdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIGBEb2N1bWVudFJlZmVyZW5jZWBcclxuICogb3IgYHN0cmluZ2AsIG9yIGlmIHRoZSBzdHJpbmcgaXMgbWFsZm9ybWVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudElkVmFsdWUoZGF0YWJhc2VJZCwgcXVlcnksIGRvY3VtZW50SWRWYWx1ZSkge1xyXG4gICAgZG9jdW1lbnRJZFZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY3VtZW50SWRWYWx1ZSk7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50SWRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnRJZFZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91ICcgK1xyXG4gICAgICAgICAgICAgICAgJ211c3QgcHJvdmlkZSBhIHZhbGlkIGRvY3VtZW50IElELCBidXQgaXQgd2FzIGFuIGVtcHR5IHN0cmluZy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSAmJiBkb2N1bWVudElkVmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gYnkgYCArXHJcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB5b3UgbXVzdCBwcm92aWRlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGAnJHtkb2N1bWVudElkVmFsdWV9JyBjb250YWlucyBhICcvJyBjaGFyYWN0ZXIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGRvY3VtZW50SWRWYWx1ZSkpO1xyXG4gICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYnkgYCArXHJcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcHJvdmlkZWQgbXVzdCByZXN1bHQgaW4gYSB2YWxpZCBkb2N1bWVudCBwYXRoLCBgICtcclxuICAgICAgICAgICAgICAgIGBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGhhcyBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzICgke3BhdGgubGVuZ3RofSkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBuZXcgRG9jdW1lbnRLZXkocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZG9jdW1lbnRJZFZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcclxuICAgICAgICByZXR1cm4gcmVmVmFsdWUoZGF0YWJhc2VJZCwgZG9jdW1lbnRJZFZhbHVlLl9rZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgd2l0aCBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBgICtcclxuICAgICAgICAgICAgYHN0cmluZyBvciBhIERvY3VtZW50UmVmZXJlbmNlLCBidXQgaXQgd2FzOiBgICtcclxuICAgICAgICAgICAgYCR7dmFsdWVEZXNjcmlwdGlvbihkb2N1bWVudElkVmFsdWUpfS5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbnRvIGEgZGlzanVuY3RpdmUgZmlsdGVyIHNhdGlzZmllcyBhbGxcclxuICogYXJyYXkgcmVxdWlyZW1lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcGVyYXRvcikge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBRdWVyeS4gQSBub24tZW1wdHkgYXJyYXkgaXMgcmVxdWlyZWQgZm9yICcgK1xyXG4gICAgICAgICAgICBgJyR7b3BlcmF0b3IudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIG9wZXJhdG9yLCByZXR1cm5zIHRoZSBzZXQgb2Ygb3BlcmF0b3JzIHRoYXQgY2Fubm90IGJlIHVzZWQgd2l0aCBpdC5cclxuICpcclxuICogVGhpcyBpcyBub3QgYSBjb21wcmVoZW5zaXZlIGNoZWNrLCBhbmQgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGVcclxuICogbG9uZyB0ZXJtLiBWYWxpZGF0aW9ucyBzaG91bGQgb2NjdXIgaW4gdGhlIEZpcmVzdG9yZSBiYWNrZW5kLlxyXG4gKlxyXG4gKiBPcGVyYXRvcnMgaW4gYSBxdWVyeSBtdXN0IGFkaGVyZSB0byB0aGUgZm9sbG93aW5nIHNldCBvZiBydWxlczpcclxuICogMS4gT25seSBvbmUgaW5lcXVhbGl0eSBwZXIgcXVlcnkuXHJcbiAqIDIuIGBOT1RfSU5gIGNhbm5vdCBiZSB1c2VkIHdpdGggYXJyYXksIGRpc2p1bmN0aXZlLCBvciBgTk9UX0VRVUFMYCBvcGVyYXRvcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25mbGljdGluZ09wcyhvcCkge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL107XHJcbiAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLzpcclxuICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL107XHJcbiAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovLFxyXG4gICAgICAgICAgICAgICAgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLFxyXG4gICAgICAgICAgICAgICAgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sXHJcbiAgICAgICAgICAgICAgICBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTmV3RmllbGRGaWx0ZXIocXVlcnksIGZpZWxkRmlsdGVyKSB7XHJcbiAgICBjb25zdCBjb25mbGljdGluZ09wID0gZmluZE9wSW5zaWRlRmlsdGVycyhxdWVyeS5maWx0ZXJzLCBjb25mbGljdGluZ09wcyhmaWVsZEZpbHRlci5vcCkpO1xyXG4gICAgaWYgKGNvbmZsaWN0aW5nT3AgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBpdCdzIGEgZHVwbGljYXRlIG9wIHRvIGdpdmUgYSBzbGlnaHRseSBjbGVhcmVyIGVycm9yIG1lc3NhZ2UuXHJcbiAgICAgICAgaWYgKGNvbmZsaWN0aW5nT3AgPT09IGZpZWxkRmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSBtb3JlIHRoYW4gb25lICcgK1xyXG4gICAgICAgICAgICAgICAgYCcke2ZpZWxkRmlsdGVyLm9wLnRvU3RyaW5nKCl9JyBmaWx0ZXIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gWW91IGNhbm5vdCB1c2UgJyR7ZmllbGRGaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlcnMgYCArXHJcbiAgICAgICAgICAgICAgICBgd2l0aCAnJHtjb25mbGljdGluZ09wLnRvU3RyaW5nKCl9JyBmaWx0ZXJzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeSwgZmlsdGVyKSB7XHJcbiAgICBsZXQgdGVzdFF1ZXJ5ID0gcXVlcnk7XHJcbiAgICBjb25zdCBzdWJGaWx0ZXJzID0gZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKTtcclxuICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIHN1YkZpbHRlcnMpIHtcclxuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHRlc3RRdWVyeSwgc3ViRmlsdGVyKTtcclxuICAgICAgICB0ZXN0UXVlcnkgPSBxdWVyeVdpdGhBZGRlZEZpbHRlcih0ZXN0UXVlcnksIHN1YkZpbHRlcik7XHJcbiAgICB9XHJcbn1cclxuLy8gQ2hlY2tzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgZmlsdGVyIG9wZXJhdG9ycyBhcmUgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgZmlsdGVycyBhbmRcclxuLy8gcmV0dXJucyB0aGUgZmlyc3Qgb25lIHRoYXQgaXMsIG9yIG51bGwgaWYgbm9uZSBhcmUuXHJcbmZ1bmN0aW9uIGZpbmRPcEluc2lkZUZpbHRlcnMoZmlsdGVycywgb3BlcmF0b3JzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihmaWVsZEZpbHRlci5vcCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyLm9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoZnVuY3Rpb25OYW1lLCBxdWVyeUNvbnN0cmFpbnQpIHtcclxuICAgIGlmICghKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KSAmJlxyXG4gICAgICAgICEocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oKSByZXF1aXJlcyBBcHBsaWFibGVDb25zdHJhaW50cyBjcmVhdGVkIHdpdGggYSBjYWxsIHRvICd3aGVyZSguLi4pJywgJ29yKC4uLiknLCBvciAnYW5kKC4uLiknLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50KSB7XHJcbiAgICBjb25zdCBjb21wb3NpdGVGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCkubGVuZ3RoO1xyXG4gICAgY29uc3QgZmllbGRGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KS5sZW5ndGg7XHJcbiAgICBpZiAoY29tcG9zaXRlRmlsdGVyQ291bnQgPiAxIHx8XHJcbiAgICAgICAgKGNvbXBvc2l0ZUZpbHRlckNvdW50ID4gMCAmJiBmaWVsZEZpbHRlckNvdW50ID4gMCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZFF1ZXJ5LiBXaGVuIHVzaW5nIGNvbXBvc2l0ZSBmaWx0ZXJzLCB5b3UgY2Fubm90IHVzZSAnICtcclxuICAgICAgICAgICAgJ21vcmUgdGhhbiBvbmUgZmlsdGVyIGF0IHRoZSB0b3AgbGV2ZWwuIENvbnNpZGVyIG5lc3RpbmcgdGhlIG11bHRpcGxlICcgK1xyXG4gICAgICAgICAgICAnZmlsdGVycyB3aXRoaW4gYW4gYGFuZCguLi4pYCBzdGF0ZW1lbnQuIEZvciBleGFtcGxlOiAnICtcclxuICAgICAgICAgICAgJ2NoYW5nZSBgcXVlcnkocXVlcnksIHdoZXJlKC4uLiksIG9yKC4uLikpYCB0byAnICtcclxuICAgICAgICAgICAgJ2BxdWVyeShxdWVyeSwgYW5kKHdoZXJlKC4uLiksIG9yKC4uLikpKWAuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbnZlcnRzIEZpcmVzdG9yZSdzIGludGVybmFsIHR5cGVzIHRvIHRoZSBKYXZhU2NyaXB0IHR5cGVzIHRoYXQgd2UgZXhwb3NlXHJcbiAqIHRvIHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xyXG4gICAgY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xyXG4gICAgICAgIHN3aXRjaCAodHlwZU9yZGVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ib29sZWFuVmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplTnVtYmVyKHZhbHVlLmludGVnZXJWYWx1ZSB8fCB2YWx1ZS5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgICAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmdWYWx1ZTtcclxuICAgICAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0Qnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0UmVmZXJlbmNlKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEdlb1BvaW50KHZhbHVlLmdlb1BvaW50VmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QXJyYXkodmFsdWUuYXJyYXlWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3QodmFsdWUubWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0T2JqZWN0KG1hcFZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3RNYXAobWFwVmFsdWUuZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0T2JqZWN0TWFwKGZpZWxkcywgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IgPSAnbm9uZScpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3JFYWNoKGZpZWxkcywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0R2VvUG9pbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sb25naXR1ZGUpKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRBcnJheShhcnJheVZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLm1hcCh2YWx1ZSA9PiB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XHJcbiAgICAgICAgc3dpdGNoIChzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUocHJldmlvdXNWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlICdlc3RpbWF0ZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKGdldExvY2FsV3JpdGVUaW1lKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0VGltZXN0YW1wKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChub3JtYWxpemVkVmFsdWUuc2Vjb25kcywgbm9ybWFsaXplZFZhbHVlLm5hbm9zKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnREb2N1bWVudEtleShuYW1lLCBleHBlY3RlZERhdGFiYXNlSWQpIHtcclxuICAgICAgICBjb25zdCByZXNvdXJjZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcclxuICAgICAgICBoYXJkQXNzZXJ0KGlzVmFsaWRSZXNvdXJjZU5hbWUocmVzb3VyY2VQYXRoKSk7XHJcbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IG5ldyBEYXRhYmFzZUlkKHJlc291cmNlUGF0aC5nZXQoMSksIHJlc291cmNlUGF0aC5nZXQoMykpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShyZXNvdXJjZVBhdGgucG9wRmlyc3QoNSkpO1xyXG4gICAgICAgIGlmICghZGF0YWJhc2VJZC5pc0VxdWFsKGV4cGVjdGVkRGF0YWJhc2VJZCkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyhiLzY0MTMwMjAyKTogU29tZWhvdyBzdXBwb3J0IGZvcmVpZ24gcmVmZXJlbmNlcy5cclxuICAgICAgICAgICAgbG9nRXJyb3IoYERvY3VtZW50ICR7a2V5fSBjb250YWlucyBhIGRvY3VtZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYHJlZmVyZW5jZSB3aXRoaW4gYSBkaWZmZXJlbnQgZGF0YWJhc2UgKGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7ZGF0YWJhc2VJZC5wcm9qZWN0SWR9LyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0pIHdoaWNoIGlzIG5vdCBgICtcclxuICAgICAgICAgICAgICAgIGBzdXBwb3J0ZWQuIEl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZmVyZW5jZSBpbiB0aGUgY3VycmVudCBgICtcclxuICAgICAgICAgICAgICAgIGBkYXRhYmFzZSAoJHtleHBlY3RlZERhdGFiYXNlSWQucHJvamVjdElkfS8ke2V4cGVjdGVkRGF0YWJhc2VJZC5kYXRhYmFzZX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgYGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbnZlcnRzIGN1c3RvbSBtb2RlbCBvYmplY3Qgb2YgdHlwZSBUIGludG8gYERvY3VtZW50RGF0YWAgYnkgYXBwbHlpbmcgdGhlXHJcbiAqIGNvbnZlcnRlciBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIGNvbnZlcnRpbmcgdXNlciBvYmplY3RzIHRvIGBEb2N1bWVudERhdGFgXHJcbiAqIGJlY2F1c2Ugd2Ugd2FudCB0byBwcm92aWRlIHRoZSB1c2VyIHdpdGggYSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgaWZcclxuICogdGhlaXIgYHNldCgpYCBvciBmYWlscyBkdWUgdG8gaW52YWxpZCBkYXRhIG9yaWdpbmF0aW5nIGZyb20gYSBgdG9GaXJlc3RvcmUoKWBcclxuICogY2FsbC5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihjb252ZXJ0ZXIsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgY29udmVydGVkVmFsdWU7XHJcbiAgICBpZiAoY29udmVydGVyKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMubWVyZ2UgfHwgb3B0aW9ucy5tZXJnZUZpZWxkcykpIHtcclxuICAgICAgICAgICAgLy8gQ2FzdCB0byBgYW55YCBpbiBvcmRlciB0byBzYXRpc2Z5IHRoZSB1bmlvbiB0eXBlIGNvbnN0cmFpbnQgb25cclxuICAgICAgICAgICAgLy8gdG9GaXJlc3RvcmUoKS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIudG9GaXJlc3RvcmUodmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIudG9GaXJlc3RvcmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnZlcnRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XHJcbn1cclxuY2xhc3MgTGl0ZVVzZXJEYXRhV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xyXG4gICAgfVxyXG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleShuYW1lLCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgLyogY29udmVydGVyPSAqLyBudWxsLCBrZXkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgc3VtIG9mXHJcbiAqIGEgc3BlY2lmaWVkIGZpZWxkIG92ZXIgYSByYW5nZSBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cclxuICogQHBhcmFtIGZpZWxkIFNwZWNpZmllcyB0aGUgZmllbGQgdG8gc3VtIGFjcm9zcyB0aGUgcmVzdWx0IHNldC5cclxuICovXHJcbmZ1bmN0aW9uIHN1bShmaWVsZCkge1xyXG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnc3VtJywgZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEoJ3N1bScsIGZpZWxkKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBBZ2dyZWdhdGVGaWVsZCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhdmVyYWdlIG9mXHJcbiAqIGEgc3BlY2lmaWVkIGZpZWxkIG92ZXIgYSByYW5nZSBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cclxuICogQHBhcmFtIGZpZWxkIFNwZWNpZmllcyB0aGUgZmllbGQgdG8gYXZlcmFnZSBhY3Jvc3MgdGhlIHJlc3VsdCBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhdmVyYWdlKGZpZWxkKSB7XHJcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdhdmcnLCBmaWVsZFBhdGhGcm9tQXJndW1lbnQkMSgnYXZlcmFnZScsIGZpZWxkKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBBZ2dyZWdhdGVGaWVsZCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb3VudCBvZlxyXG4gKiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGNvdW50KCkge1xyXG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnY291bnQnKTtcclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgdHdvICdBZ2dyZWdhdGVGaWVsZGAgaW5zdGFuY2VzIGZvciBlcXVhbGl0eS5cclxuICpcclxuICogQHBhcmFtIGxlZnQgQ29tcGFyZSB0aGlzIEFnZ3JlZ2F0ZUZpZWxkIHRvIHRoZSBgcmlnaHRgLlxyXG4gKiBAcGFyYW0gcmlnaHQgQ29tcGFyZSB0aGlzIEFnZ3JlZ2F0ZUZpZWxkIHRvIHRoZSBgbGVmdGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZ2dyZWdhdGVGaWVsZEVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgQWdncmVnYXRlRmllbGQgJiZcclxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUZpZWxkICYmXHJcbiAgICAgICAgbGVmdC5hZ2dyZWdhdGVUeXBlID09PSByaWdodC5hZ2dyZWdhdGVUeXBlICYmXHJcbiAgICAgICAgKChfYSA9IGxlZnQuX2ludGVybmFsRmllbGRQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2Fub25pY2FsU3RyaW5nKCkpID09PVxyXG4gICAgICAgICAgICAoKF9iID0gcmlnaHQuX2ludGVybmFsRmllbGRQYXRoKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2Fub25pY2FsU3RyaW5nKCkpKTtcclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCBpbnN0YW5jZXMgZm9yIGVxdWFsaXR5LlxyXG4gKlxyXG4gKiBUd28gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIGluc3RhbmNlcyBhcmUgY29uc2lkZXJlZCBcImVxdWFsXCIgaWYgdGhleSBoYXZlXHJcbiAqIHVuZGVybHlpbmcgcXVlcmllcyB0aGF0IGNvbXBhcmUgZXF1YWwsIGFuZCB0aGUgc2FtZSBkYXRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVmdCAtIFRoZSBmaXJzdCBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHJpZ2h0IC0gVGhlIHNlY29uZCBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gY29tcGFyZS5cclxuICpcclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBcImVxdWFsXCIsIGFzIGRlZmluZWQgYWJvdmUsIG9yIGBmYWxzZWBcclxuICogb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gKHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmIGRlZXBFcXVhbChsZWZ0LmRhdGEoKSwgcmlnaHQuZGF0YSgpKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQYXJ0aWFsT2JzZXJ2ZXIob2JqKSB7XHJcbiAgICByZXR1cm4gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBbJ25leHQnLCAnZXJyb3InLCAnY29tcGxldGUnXSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYW4gb2JqZWN0IGFuZCBjb250YWlucyBhdCBsZWFzdCBvbmUgb2YgdGhlIHNwZWNpZmllZFxyXG4gKiBtZXRob2RzLlxyXG4gKi9cclxuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xyXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xyXG4gICAgICAgIGlmIChtZXRob2QgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE1ldGFkYXRhIGFib3V0IGEgc25hcHNob3QsIGRlc2NyaWJpbmcgdGhlIHN0YXRlIG9mIHRoZSBzbmFwc2hvdC5cclxuICovXHJcbmNsYXNzIFNuYXBzaG90TWV0YWRhdGEge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKGhhc1BlbmRpbmdXcml0ZXMsIGZyb21DYWNoZSkge1xyXG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ1dyaXRlcyA9IGhhc1BlbmRpbmdXcml0ZXM7XHJcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBTbmFwc2hvdE1ldGFkYXRhYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgU25hcHNob3RNZXRhZGF0YWAgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBTbmFwc2hvdE1ldGFkYXRhYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc1BlbmRpbmdXcml0ZXMgPT09IG90aGVyLmhhc1BlbmRpbmdXcml0ZXMgJiZcclxuICAgICAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPT09IG90aGVyLmZyb21DYWNoZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91ciBGaXJlc3RvcmVcclxuICogZGF0YWJhc2UuIFRoZSBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvXHJcbiAqIGdldCBhIHNwZWNpZmljIGZpZWxkLlxyXG4gKlxyXG4gKiBGb3IgYSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwb2ludHMgdG8gYSBub24tZXhpc3RpbmcgZG9jdW1lbnQsIGFueSBkYXRhXHJcbiAqIGFjY2VzcyB3aWxsIHJldHVybiAndW5kZWZpbmVkJy4gWW91IGNhbiB1c2UgdGhlIGBleGlzdHMoKWAgbWV0aG9kIHRvXHJcbiAqIGV4cGxpY2l0bHkgdmVyaWZ5IGEgZG9jdW1lbnQncyBleGlzdGVuY2UuXHJcbiAqL1xyXG5jbGFzcyBEb2N1bWVudFNuYXBzaG90IGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCQxIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGtleSwgZG9jdW1lbnQsIG1ldGFkYXRhLCBjb252ZXJ0ZXIpIHtcclxuICAgICAgICBzdXBlcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgY29udmVydGVyKTtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZUltcGwgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZGF0YSBleGlzdHMuIFRydWUgaWYgdGhlIGRvY3VtZW50IGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgZXhpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5leGlzdHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmXHJcbiAgICAgKiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBgc2VydmVyVGltZXN0YW1wKClgIHZhbHVlcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuXHJcbiAgICAgKiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBhcyBgbnVsbGAuIFlvdSBjYW4gb3ZlcnJpZGVcclxuICAgICAqIHRoaXMgYnkgcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgZGF0YSBpcyByZXRyaWV2ZWQgZnJvbVxyXG4gICAgICogdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHMgdGhhdFxyXG4gICAgICogaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGAgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBkYXRhKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcclxuICAgICAgICAgICAgLy8gaWYgYSBjb252ZXJ0ZXIgaGFzIGJlZW4gcHJvdmlkZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCB0aGlzLl9rZXksIHRoaXMuX2RvY3VtZW50LCB0aGlzLm1ldGFkYXRhLCBcclxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRlci5mcm9tRmlyZXN0b3JlKHNuYXBzaG90LCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodGhpcy5fZG9jdW1lbnQuZGF0YS52YWx1ZSwgb3B0aW9ucy5zZXJ2ZXJUaW1lc3RhbXBzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxyXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBhIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdGhhdCBoYXMgbm90IHlldCBiZWVuIHNldCB0b1xyXG4gICAgICogaXRzIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYnlcclxuICAgICAqIHBhc3NpbmcgYW4gb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIChmb3IgZXhhbXBsZSAnZm9vJyBvciAnZm9vLmJhcicpIHRvIGEgc3BlY2lmaWNcclxuICAgICAqIGZpZWxkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgaG93IHRoZSBmaWVsZCBpcyByZXRyaWV2ZWRcclxuICAgICAqIGZyb20gdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHNcclxuICAgICAqIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgZmllbGQgbG9jYXRpb24gb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcclxuICAgICAqIGZpZWxkIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIC8vIFdlIGFyZSB1c2luZyBgYW55YCBoZXJlIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGNhc3QgYnkgb3VyIHVzZXJzLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGdldChmaWVsZFBhdGgsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RvY3VtZW50LmRhdGEuZmllbGQoZmllbGRQYXRoRnJvbUFyZ3VtZW50KCdEb2N1bWVudFNuYXBzaG90LmdldCcsIGZpZWxkUGF0aCkpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodmFsdWUsIG9wdGlvbnMuc2VydmVyVGltZXN0YW1wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcclxuICogRmlyZXN0b3JlIGRhdGFiYXNlIGFzIHBhcnQgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50IGlzIGd1YXJhbnRlZWQgdG8gZXhpc3RcclxuICogYW5kIGl0cyBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvIGdldCBhXHJcbiAqIHNwZWNpZmljIGZpZWxkLlxyXG4gKlxyXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIG9mZmVycyB0aGUgc2FtZSBBUEkgc3VyZmFjZSBhcyBhXHJcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcclxuICogYGV4aXN0c2AgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgdHJ1ZSBhbmQgYGRhdGEoKWAgd2lsbCBuZXZlciByZXR1cm5cclxuICogJ3VuZGVmaW5lZCcuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeURvY3VtZW50U25hcHNob3QgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90IHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdmFsdWVzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cclxuICAgICAqIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZVxyXG4gICAgICogdGhpcyBieSBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgaG93IGRhdGEgaXMgcmV0cmlldmVkIGZyb21cclxuICAgICAqIHRoZSBzbmFwc2hvdCAoZm9yIGV4YW1wbGUgdGhlIGRlc2lyZWQgYmVoYXZpb3IgZm9yIHNlcnZlciB0aW1lc3RhbXBzIHRoYXRcclxuICAgICAqIGhhdmUgbm90IHlldCBiZWVuIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSkuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBgT2JqZWN0YCBjb250YWluaW5nIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICBkYXRhKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5kYXRhKG9wdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeVNuYXBzaG90YCBjb250YWlucyB6ZXJvIG9yIG1vcmUgYERvY3VtZW50U25hcHNob3RgIG9iamVjdHNcclxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudHMgY2FuIGJlIGFjY2Vzc2VkIGFzIGFuXHJcbiAqIGFycmF5IHZpYSB0aGUgYGRvY3NgIHByb3BlcnR5IG9yIGVudW1lcmF0ZWQgdXNpbmcgdGhlIGBmb3JFYWNoYCBtZXRob2QuIFRoZVxyXG4gKiBudW1iZXIgb2YgZG9jdW1lbnRzIGNhbiBiZSBkZXRlcm1pbmVkIHZpYSB0aGUgYGVtcHR5YCBhbmQgYHNpemVgXHJcbiAqIHByb3BlcnRpZXMuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeVNuYXBzaG90IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBfc25hcHNob3QpIHtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xyXG4gICAgICAgIHRoaXMuX3NuYXBzaG90ID0gX3NuYXBzaG90O1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgU25hcHNob3RNZXRhZGF0YShfc25hcHNob3QuaGFzUGVuZGluZ1dyaXRlcywgX3NuYXBzaG90LmZyb21DYWNoZSk7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgLyoqIEFuIGFycmF5IG9mIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXHJcbiAgICBnZXQgZG9jcygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZG9jID0+IHJlc3VsdC5wdXNoKGRvYykpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zbmFwc2hvdC5kb2NzLnNpemU7XHJcbiAgICB9XHJcbiAgICAvKiogVHJ1ZSBpZiB0aGVyZSBhcmUgbm8gZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXHJcbiAgICBnZXQgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRlcyBhbGwgb2YgdGhlIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggYSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBmb3JcclxuICAgICAqIGVhY2ggZG9jdW1lbnQgaW4gdGhlIHNuYXBzaG90LlxyXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBUaGUgYHRoaXNgIGJpbmRpbmcgZm9yIHRoZSBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIHRoaXMuX3NuYXBzaG90LmRvY3MuZm9yRWFjaChkb2MgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIG5ldyBRdWVyeURvY3VtZW50U25hcHNob3QodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgZG9jLmtleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YSh0aGlzLl9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoZG9jLmtleSksIHRoaXMuX3NuYXBzaG90LmZyb21DYWNoZSksIHRoaXMucXVlcnkuY29udmVydGVyKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGRvY3VtZW50cyBjaGFuZ2VzIHNpbmNlIHRoZSBsYXN0IHNuYXBzaG90LiBJZiB0aGlzXHJcbiAgICAgKiBpcyB0aGUgZmlyc3Qgc25hcHNob3QsIGFsbCBkb2N1bWVudHMgd2lsbCBiZSBpbiB0aGUgbGlzdCBhcyAnYWRkZWQnXHJcbiAgICAgKiBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gYFNuYXBzaG90TGlzdGVuT3B0aW9uc2AgdGhhdCBjb250cm9sIHdoZXRoZXIgbWV0YWRhdGEtb25seVxyXG4gICAgICogY2hhbmdlcyAoaS5lLiBvbmx5IGBEb2N1bWVudFNuYXBzaG90Lm1ldGFkYXRhYCBjaGFuZ2VkKSBzaG91bGQgdHJpZ2dlclxyXG4gICAgICogc25hcHNob3QgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBkb2NDaGFuZ2VzKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPSAhIW9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcztcclxuICAgICAgICBpZiAoaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyAmJiB0aGlzLl9zbmFwc2hvdC5leGNsdWRlc01ldGFkYXRhQ2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVG8gaW5jbHVkZSBtZXRhZGF0YSBjaGFuZ2VzIHdpdGggeW91ciBkb2N1bWVudCBjaGFuZ2VzLCB5b3UgbXVzdCAnICtcclxuICAgICAgICAgICAgICAgICdhbHNvIHBhc3MgeyBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOnRydWUgfSB0byBvblNuYXBzaG90KCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkQ2hhbmdlcyB8fFxyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzSW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyAhPT0gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzID0gY2hhbmdlc0Zyb21TbmFwc2hvdCh0aGlzLCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlc0luY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPSBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ2hhbmdlcztcclxuICAgIH1cclxufVxyXG4vKiogQ2FsY3VsYXRlcyB0aGUgYXJyYXkgb2YgYERvY3VtZW50Q2hhbmdlYHMgZm9yIGEgZ2l2ZW4gYFZpZXdTbmFwc2hvdGAuICovXHJcbmZ1bmN0aW9uIGNoYW5nZXNGcm9tU25hcHNob3QocXVlcnlTbmFwc2hvdCwgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcykge1xyXG4gICAgaWYgKHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm9sZERvY3MuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZG9jQ2hhbmdlcy5tYXAoY2hhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeVNuYXBzaG90Ll9maXJlc3RvcmUsIHF1ZXJ5U25hcHNob3QuX3VzZXJEYXRhV3JpdGVyLCBjaGFuZ2UuZG9jLmtleSwgY2hhbmdlLmRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEocXVlcnlTbmFwc2hvdC5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGNoYW5nZS5kb2Mua2V5KSwgcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZnJvbUNhY2hlKSwgcXVlcnlTbmFwc2hvdC5xdWVyeS5jb252ZXJ0ZXIpO1xyXG4gICAgICAgICAgICBjaGFuZ2UuZG9jO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZGVkJyxcclxuICAgICAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgICAgIG9sZEluZGV4OiAtMSxcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4OiBpbmRleCsrXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBBIGBEb2N1bWVudFNldGAgdGhhdCBpcyB1cGRhdGVkIGluY3JlbWVudGFsbHkgYXMgY2hhbmdlcyBhcmUgYXBwbGllZCB0byB1c2VcclxuICAgICAgICAvLyB0byBsb29rdXAgdGhlIGluZGV4IG9mIGEgZG9jdW1lbnQuXHJcbiAgICAgICAgbGV0IGluZGV4VHJhY2tlciA9IHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm9sZERvY3M7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90LmRvY0NoYW5nZXNcclxuICAgICAgICAgICAgLmZpbHRlcihjaGFuZ2UgPT4gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyB8fCBjaGFuZ2UudHlwZSAhPT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKVxyXG4gICAgICAgICAgICAubWFwKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBRdWVyeURvY3VtZW50U25hcHNob3QocXVlcnlTbmFwc2hvdC5fZmlyZXN0b3JlLCBxdWVyeVNuYXBzaG90Ll91c2VyRGF0YVdyaXRlciwgY2hhbmdlLmRvYy5rZXksIGNoYW5nZS5kb2MsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm11dGF0ZWRLZXlzLmhhcyhjaGFuZ2UuZG9jLmtleSksIHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90LmZyb21DYWNoZSksIHF1ZXJ5U25hcHNob3QucXVlcnkuY29udmVydGVyKTtcclxuICAgICAgICAgICAgbGV0IG9sZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGxldCBuZXdJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLykge1xyXG4gICAgICAgICAgICAgICAgb2xkSW5kZXggPSBpbmRleFRyYWNrZXIuaW5kZXhPZihjaGFuZ2UuZG9jLmtleSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleFRyYWNrZXIgPSBpbmRleFRyYWNrZXIuZGVsZXRlKGNoYW5nZS5kb2Mua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleFRyYWNrZXIgPSBpbmRleFRyYWNrZXIuYWRkKGNoYW5nZS5kb2MpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleFRyYWNrZXIuaW5kZXhPZihjaGFuZ2UuZG9jLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHJlc3VsdENoYW5nZVR5cGUoY2hhbmdlLnR5cGUpLFxyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgb2xkSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc3VsdENoYW5nZVR5cGUodHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnYWRkZWQnO1xyXG4gICAgICAgIGNhc2UgMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ21vZGlmaWVkJztcclxuICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3JlbW92ZWQnO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLy8gVE9ETyhmaXJlc3RvcmVleHApOiBBZGQgdGVzdHMgZm9yIHNuYXBzaG90RXF1YWwgd2l0aCBkaWZmZXJlbnQgc25hcHNob3RcclxuLy8gbWV0YWRhdGFcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgc25hcHNob3RzIGFyZSBlcXVhbC5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSByaWdodCAtIEEgc25hcHNob3QgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc25hcHNob3RzIGFyZSBlcXVhbC5cclxuICovXHJcbmZ1bmN0aW9uIHNuYXBzaG90RXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCAmJiByaWdodCBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QpIHtcclxuICAgICAgICByZXR1cm4gKGxlZnQuX2ZpcmVzdG9yZSA9PT0gcmlnaHQuX2ZpcmVzdG9yZSAmJlxyXG4gICAgICAgICAgICBsZWZ0Ll9rZXkuaXNFcXVhbChyaWdodC5fa2V5KSAmJlxyXG4gICAgICAgICAgICAobGVmdC5fZG9jdW1lbnQgPT09IG51bGxcclxuICAgICAgICAgICAgICAgID8gcmlnaHQuX2RvY3VtZW50ID09PSBudWxsXHJcbiAgICAgICAgICAgICAgICA6IGxlZnQuX2RvY3VtZW50LmlzRXF1YWwocmlnaHQuX2RvY3VtZW50KSkgJiZcclxuICAgICAgICAgICAgbGVmdC5fY29udmVydGVyID09PSByaWdodC5fY29udmVydGVyKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeVNuYXBzaG90ICYmIHJpZ2h0IGluc3RhbmNlb2YgUXVlcnlTbmFwc2hvdCkge1xyXG4gICAgICAgIHJldHVybiAobGVmdC5fZmlyZXN0b3JlID09PSByaWdodC5fZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmXHJcbiAgICAgICAgICAgIGxlZnQubWV0YWRhdGEuaXNFcXVhbChyaWdodC5tZXRhZGF0YSkgJiZcclxuICAgICAgICAgICAgbGVmdC5fc25hcHNob3QuaXNFcXVhbChyaWdodC5fc25hcHNob3QpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoaXMgYERvY3VtZW50UmVmZXJlbmNlYC5cclxuICpcclxuICogTm90ZTogYGdldERvYygpYCBhdHRlbXB0cyB0byBwcm92aWRlIHVwLXRvLWRhdGUgZGF0YSB3aGVuIHBvc3NpYmxlIGJ5IHdhaXRpbmdcclxuICogZm9yIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQgbWF5IHJldHVybiBjYWNoZWQgZGF0YSBvciBmYWlsIGlmIHlvdSBhcmVcclxuICogb2ZmbGluZSBhbmQgdGhlIHNlcnZlciBjYW5ub3QgYmUgcmVhY2hlZC4gVG8gc3BlY2lmeSB0aGlzIGJlaGF2aW9yLCBpbnZva2VcclxuICoge0BsaW5rIGdldERvY0Zyb21DYWNoZX0gb3Ige0BsaW5rIGdldERvY0Zyb21TZXJ2ZXJ9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBvZiB0aGUgZG9jdW1lbnQgdG8gZmV0Y2guXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXHJcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2MocmVmZXJlbmNlKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHJlZmVyZW5jZS5fa2V5KS50aGVuKHNuYXBzaG90ID0+IGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xyXG59XHJcbmNsYXNzIEV4cFVzZXJEYXRhV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xyXG4gICAgfVxyXG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleShuYW1lLCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgLyogY29udmVydGVyPSAqLyBudWxsLCBrZXkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGZyb20gY2FjaGUuXHJcbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgY2FjaGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXHJcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2NGcm9tQ2FjaGUocmVmZXJlbmNlKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudEZyb21Mb2NhbENhY2hlKGNsaWVudCwgcmVmZXJlbmNlLl9rZXkpLnRoZW4oZG9jID0+IG5ldyBEb2N1bWVudFNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHJlZmVyZW5jZS5fa2V5LCBkb2MsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKGRvYyAhPT0gbnVsbCAmJiBkb2MuaGFzTG9jYWxNdXRhdGlvbnMsIFxyXG4gICAgLyogZnJvbUNhY2hlPSAqLyB0cnVlKSwgcmVmZXJlbmNlLmNvbnZlcnRlcikpO1xyXG59XHJcbi8qKlxyXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGZyb20gdGhlIHNlcnZlci5cclxuICogUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgbmV0d29yayBpcyBub3QgYXZhaWxhYmxlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXHJcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2NGcm9tU2VydmVyKHJlZmVyZW5jZSkge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCByZWZlcmVuY2UuX2tleSwge1xyXG4gICAgICAgIHNvdXJjZTogJ3NlcnZlcidcclxuICAgIH0pLnRoZW4oc25hcHNob3QgPT4gY29udmVydFRvRG9jU25hcHNob3QoZmlyZXN0b3JlLCByZWZlcmVuY2UsIHNuYXBzaG90KSk7XHJcbn1cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YC5cclxuICpcclxuICogTm90ZTogYGdldERvY3MoKWAgYXR0ZW1wdHMgdG8gcHJvdmlkZSB1cC10by1kYXRlIGRhdGEgd2hlbiBwb3NzaWJsZSBieVxyXG4gKiB3YWl0aW5nIGZvciBkYXRhIGZyb20gdGhlIHNlcnZlciwgYnV0IGl0IG1heSByZXR1cm4gY2FjaGVkIGRhdGEgb3IgZmFpbCBpZlxyXG4gKiB5b3UgYXJlIG9mZmxpbmUgYW5kIHRoZSBzZXJ2ZXIgY2Fubm90IGJlIHJlYWNoZWQuIFRvIHNwZWNpZnkgdGhpcyBiZWhhdmlvcixcclxuICogaW52b2tlIHtAbGluayBnZXREb2NzRnJvbUNhY2hlfSBvciB7QGxpbmsgZ2V0RG9jc0Zyb21TZXJ2ZXJ9LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2NzKHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIHZhbGlkYXRlSGFzRXhwbGljaXRPcmRlckJ5Rm9yTGltaXRUb0xhc3QocXVlcnkuX3F1ZXJ5KTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnkuX3F1ZXJ5KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMgYSBgUXVlcnlTbmFwc2hvdGAgZnJvbSBjYWNoZS5cclxuICogUmV0dXJucyBhbiBlbXB0eSByZXN1bHQgc2V0IGlmIG5vIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgcXVlcnkgYXJlIGN1cnJlbnRseVxyXG4gKiBjYWNoZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvY3NGcm9tQ2FjaGUocXVlcnkpIHtcclxuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c0Zyb21Mb2NhbENhY2hlKGNsaWVudCwgcXVlcnkuX3F1ZXJ5KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMgYSBgUXVlcnlTbmFwc2hvdGAgZnJvbSB0aGVcclxuICogc2VydmVyLiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvY3NGcm9tU2VydmVyKHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnkuX3F1ZXJ5LCB7XHJcbiAgICAgICAgc291cmNlOiAnc2VydmVyJ1xyXG4gICAgfSkudGhlbihzbmFwc2hvdCA9PiBuZXcgUXVlcnlTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBxdWVyeSwgc25hcHNob3QpKTtcclxufVxyXG5mdW5jdGlvbiBzZXREb2MocmVmZXJlbmNlLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmZXJlbmNlLmNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICBjb25zdCBkYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnc2V0RG9jJywgcmVmZXJlbmNlLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWZlcmVuY2UuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xyXG4gICAgcmV0dXJuIGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIFttdXRhdGlvbl0pO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZURvYyhyZWZlcmVuY2UsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpO1xyXG4gICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcclxuICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcclxuICAgIGxldCBwYXJzZWQ7XHJcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XHJcbiAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVWYXJhcmdzKGRhdGFSZWFkZXIsICd1cGRhdGVEb2MnLCByZWZlcmVuY2UuX2tleSwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlRGF0YShkYXRhUmVhZGVyLCAndXBkYXRlRG9jJywgcmVmZXJlbmNlLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpO1xyXG4gICAgcmV0dXJuIGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIFttdXRhdGlvbl0pO1xyXG59XHJcbi8qKlxyXG4gKiBEZWxldGVzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGUgc3BlY2lmaWVkIGBEb2N1bWVudFJlZmVyZW5jZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gZGVsZXRlLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5XHJcbiAqIGRlbGV0ZWQgZnJvbSB0aGUgYmFja2VuZCAobm90ZSB0aGF0IGl0IHdvbid0IHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlRG9jKHJlZmVyZW5jZSkge1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgbXV0YXRpb25zID0gW25ldyBEZWxldGVNdXRhdGlvbihyZWZlcmVuY2UuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSldO1xyXG4gICAgcmV0dXJuIGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIG11dGF0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZCBhIG5ldyBkb2N1bWVudCB0byBzcGVjaWZpZWQgYENvbGxlY3Rpb25SZWZlcmVuY2VgIHdpdGggdGhlIGdpdmVuIGRhdGEsXHJcbiAqIGFzc2lnbmluZyBpdCBhIGRvY3VtZW50IElEIGF1dG9tYXRpY2FsbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgY29sbGVjdGlvbiB0byBhZGQgdGhpcyBkb2N1bWVudCB0by5cclxuICogQHBhcmFtIGRhdGEgLSBBbiBPYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIG5ldyBkb2N1bWVudC5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlXHJcbiAqIG5ld2x5IGNyZWF0ZWQgZG9jdW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gd3JpdHRlbiB0byB0aGUgYmFja2VuZCAoTm90ZSB0aGF0IGl0XHJcbiAqIHdvbid0IHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkRG9jKHJlZmVyZW5jZSwgZGF0YSkge1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgZG9jUmVmID0gZG9jKHJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWZlcmVuY2UuY29udmVydGVyLCBkYXRhKTtcclxuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihyZWZlcmVuY2UuZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnYWRkRG9jJywgZG9jUmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWZlcmVuY2UuY29udmVydGVyICE9PSBudWxsLCB7fSk7XHJcbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKGRvY1JlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKGZhbHNlKSk7XHJcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSkudGhlbigoKSA9PiBkb2NSZWYpO1xyXG59XHJcbmZ1bmN0aW9uIG9uU25hcHNob3QocmVmZXJlbmNlLCAuLi5hcmdzKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIHJlZmVyZW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWZlcmVuY2UpO1xyXG4gICAgbGV0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogZmFsc2UsXHJcbiAgICAgICAgc291cmNlOiAnZGVmYXVsdCdcclxuICAgIH07XHJcbiAgICBsZXQgY3VyckFyZyA9IDA7XHJcbiAgICBpZiAodHlwZW9mIGFyZ3NbY3VyckFyZ10gPT09ICdvYmplY3QnICYmICFpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1cnJBcmddKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBhcmdzW2N1cnJBcmddO1xyXG4gICAgICAgIGN1cnJBcmcrKztcclxuICAgIH1cclxuICAgIGNvbnN0IGludGVybmFsT3B0aW9ucyA9IHtcclxuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiBvcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMsXHJcbiAgICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZVxyXG4gICAgfTtcclxuICAgIGlmIChpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1cnJBcmddKSkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJPYnNlcnZlciA9IGFyZ3NbY3VyckFyZ107XHJcbiAgICAgICAgYXJnc1tjdXJyQXJnXSA9IChfYSA9IHVzZXJPYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZCh1c2VyT2JzZXJ2ZXIpO1xyXG4gICAgICAgIGFyZ3NbY3VyckFyZyArIDFdID0gKF9iID0gdXNlck9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmluZCh1c2VyT2JzZXJ2ZXIpO1xyXG4gICAgICAgIGFyZ3NbY3VyckFyZyArIDJdID0gKF9jID0gdXNlck9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZCh1c2VyT2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgbGV0IG9ic2VydmVyO1xyXG4gICAgbGV0IGZpcmVzdG9yZTtcclxuICAgIGxldCBpbnRlcm5hbFF1ZXJ5O1xyXG4gICAgaWYgKHJlZmVyZW5jZSBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgICAgIGludGVybmFsUXVlcnkgPSBuZXdRdWVyeUZvclBhdGgocmVmZXJlbmNlLl9rZXkucGF0aCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIgPSB7XHJcbiAgICAgICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdzW2N1cnJBcmddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tjdXJyQXJnXShjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3I6IGFyZ3NbY3VyckFyZyArIDFdLFxyXG4gICAgICAgICAgICBjb21wbGV0ZTogYXJnc1tjdXJyQXJnICsgMl1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjYXN0KHJlZmVyZW5jZSwgUXVlcnkpO1xyXG4gICAgICAgIGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgICAgIGludGVybmFsUXVlcnkgPSBxdWVyeS5fcXVlcnk7XHJcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgICAgICBvYnNlcnZlciA9IHtcclxuICAgICAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbY3VyckFyZ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXHJcbiAgICAgICAgICAgIGNvbXBsZXRlOiBhcmdzW2N1cnJBcmcgKyAyXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChyZWZlcmVuY2UuX3F1ZXJ5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBpbnRlcm5hbFF1ZXJ5LCBpbnRlcm5hbE9wdGlvbnMsIG9ic2VydmVyKTtcclxufVxyXG5mdW5jdGlvbiBvblNuYXBzaG90c0luU3luYyhmaXJlc3RvcmUsIGFyZykge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBvYnNlcnZlciA9IGlzUGFydGlhbE9ic2VydmVyKGFyZylcclxuICAgICAgICA/IGFyZ1xyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICBuZXh0OiBhcmdcclxuICAgICAgICB9O1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGNsaWVudCwgb2JzZXJ2ZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBMb2NhbGx5IHdyaXRlcyBgbXV0YXRpb25zYCBvbiB0aGUgYXN5bmMgcXVldWUuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50V3JpdGUoY2xpZW50LCBtdXRhdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHtAbGluayBWaWV3U25hcHNob3R9IHRoYXQgY29udGFpbnMgdGhlIHNpbmdsZSBkb2N1bWVudCBzcGVjaWZpZWQgYnkgYHJlZmBcclxuICogdG8gYSB7QGxpbmsgRG9jdW1lbnRTbmFwc2hvdH0uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZiwgc25hcHNob3QpIHtcclxuICAgIGNvbnN0IGRvYyA9IHNuYXBzaG90LmRvY3MuZ2V0KHJlZi5fa2V5KTtcclxuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEoc25hcHNob3QuaGFzUGVuZGluZ1dyaXRlcywgc25hcHNob3QuZnJvbUNhY2hlKSwgcmVmLmNvbnZlcnRlcik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgdGhlIGdpdmVuIHF1ZXJ5XHJcbiAqIHdpdGhvdXQgYWN0dWFsbHkgZG93bmxvYWRpbmcgdGhlIGRvY3VtZW50cy5cclxuICpcclxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjb3VudCB0aGUgZG9jdW1lbnRzIGlzIGVmZmljaWVudCBiZWNhdXNlIG9ubHkgdGhlXHJcbiAqIGZpbmFsIGNvdW50LCBub3QgdGhlIGRvY3VtZW50cycgZGF0YSwgaXMgZG93bmxvYWRlZC4gVGhpcyBmdW5jdGlvbiBjYW5cclxuICogY291bnQgdGhlIGRvY3VtZW50cyBpbiBjYXNlcyB3aGVyZSB0aGUgcmVzdWx0IHNldCBpcyBwcm9oaWJpdGl2ZWx5IGxhcmdlIHRvXHJcbiAqIGRvd25sb2FkIGVudGlyZWx5ICh0aG91c2FuZHMgb2YgZG9jdW1lbnRzKS5cclxuICpcclxuICogVGhlIHJlc3VsdCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgcHJlc2VudGVkLCB1bmFsdGVyZWQsIHdpdGhvdXRcclxuICogY29uc2lkZXJpbmcgYW55IGxvY2FsIHN0YXRlLiBUaGF0IGlzLCBkb2N1bWVudHMgaW4gdGhlIGxvY2FsIGNhY2hlIGFyZSBub3RcclxuICogdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLCBuZWl0aGVyIGFyZSBsb2NhbCBtb2RpZmljYXRpb25zIG5vdCB5ZXRcclxuICogc3luY2hyb25pemVkIHdpdGggdGhlIHNlcnZlci4gUHJldmlvdXNseS1kb3dubG9hZGVkIHJlc3VsdHMsIGlmIGFueSwgYXJlIG5vdFxyXG4gKiB1c2VkLiBFdmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24gbmVjZXNzYXJpbHkgaW52b2x2ZXMgYSByb3VuZCB0cmlwIHRvXHJcbiAqIHRoZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSBUaGUgcXVlcnkgd2hvc2UgcmVzdWx0IHNldCBzaXplIGlzIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY291bnQ7IHRoZSBjb3VudCBjYW4gYmVcclxuICogcmV0cmlldmVkIGZyb20gYHNuYXBzaG90LmRhdGEoKS5jb3VudGAsIHdoZXJlIGBzbmFwc2hvdGAgaXMgdGhlXHJcbiAqIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byB3aGljaCB0aGUgcmV0dXJuZWQgUHJvbWlzZSByZXNvbHZlcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldENvdW50RnJvbVNlcnZlcihxdWVyeSkge1xyXG4gICAgY29uc3QgY291bnRRdWVyeVNwZWMgPSB7XHJcbiAgICAgICAgY291bnQ6IGNvdW50KClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZ2V0QWdncmVnYXRlRnJvbVNlcnZlcihxdWVyeSwgY291bnRRdWVyeVNwZWMpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcGVjaWZpZWQgYWdncmVnYXRpb25zIG92ZXIgdGhlIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0XHJcbiAqIHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnkgd2l0aG91dCBhY3R1YWxseSBkb3dubG9hZGluZyB0aGUgZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIHBlcmZvcm0gYWdncmVnYXRpb25zIGlzIGVmZmljaWVudCBiZWNhdXNlIG9ubHkgdGhlXHJcbiAqIGZpbmFsIGFnZ3JlZ2F0aW9uIHZhbHVlcywgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGFyZSBkb3dubG9hZGVkLiBUaGlzXHJcbiAqIGZ1bmN0aW9uIGNhbiBwZXJmb3JtIGFnZ3JlZ2F0aW9ucyBvZiB0aGUgZG9jdW1lbnRzIGluIGNhc2VzIHdoZXJlIHRoZSByZXN1bHRcclxuICogc2V0IGlzIHByb2hpYml0aXZlbHkgbGFyZ2UgdG8gZG93bmxvYWQgZW50aXJlbHkgKHRob3VzYW5kcyBvZiBkb2N1bWVudHMpLlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0IHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBwcmVzZW50ZWQsIHVuYWx0ZXJlZCwgd2l0aG91dFxyXG4gKiBjb25zaWRlcmluZyBhbnkgbG9jYWwgc3RhdGUuIFRoYXQgaXMsIGRvY3VtZW50cyBpbiB0aGUgbG9jYWwgY2FjaGUgYXJlIG5vdFxyXG4gKiB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIG5laXRoZXIgYXJlIGxvY2FsIG1vZGlmaWNhdGlvbnMgbm90IHlldFxyXG4gKiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc2VydmVyLiBQcmV2aW91c2x5LWRvd25sb2FkZWQgcmVzdWx0cywgaWYgYW55LCBhcmUgbm90XHJcbiAqIHVzZWQuIEV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvbiBuZWNlc3NhcmlseSBpbnZvbHZlcyBhIHJvdW5kIHRyaXAgdG9cclxuICogdGhlIHNlcnZlci5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IFRoZSBxdWVyeSB3aG9zZSByZXN1bHQgc2V0IGlzIGFnZ3JlZ2F0ZWQgb3Zlci5cclxuICogQHBhcmFtIGFnZ3JlZ2F0ZVNwZWMgQW4gYEFnZ3JlZ2F0ZVNwZWNgIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgYWdncmVnYXRlc1xyXG4gKiB0byBwZXJmb3JtIG92ZXIgdGhlIHJlc3VsdCBzZXQuIFRoZSBBZ2dyZWdhdGVTcGVjIHNwZWNpZmllcyBhbGlhc2VzIGZvciBlYWNoXHJcbiAqIGFnZ3JlZ2F0ZSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGFnZ3JlZ2F0ZSByZXN1bHQuXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgYWdncmVnYXRlU25hcHNob3QgPSBhd2FpdCBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCB7XHJcbiAqICAgY291bnRPZkRvY3M6IGNvdW50KCksXHJcbiAqICAgdG90YWxIb3Vyczogc3VtKCdob3VycycpLFxyXG4gKiAgIGF2ZXJhZ2VTY29yZTogYXZlcmFnZSgnc2NvcmUnKVxyXG4gKiB9KTtcclxuICpcclxuICogY29uc3QgY291bnRPZkRvY3M6IG51bWJlciA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS5jb3VudE9mRG9jcztcclxuICogY29uc3QgdG90YWxIb3VyczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLnRvdGFsSG91cnM7XHJcbiAqIGNvbnN0IGF2ZXJhZ2VTY29yZTogbnVtYmVyIHwgbnVsbCA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS5hdmVyYWdlU2NvcmU7XHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWdncmVnYXRlRnJvbVNlcnZlcihxdWVyeSwgYWdncmVnYXRlU3BlYykge1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBpbnRlcm5hbEFnZ3JlZ2F0ZXMgPSBtYXBUb0FycmF5KGFnZ3JlZ2F0ZVNwZWMsIChhZ2dyZWdhdGUsIGFsaWFzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVJbXBsKGFsaWFzLCBhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSwgYWdncmVnYXRlLl9pbnRlcm5hbEZpZWxkUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIC8vIFJ1biB0aGUgYWdncmVnYXRpb24gYW5kIGNvbnZlcnQgdGhlIHJlc3VsdHNcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRSdW5BZ2dyZWdhdGVRdWVyeShjbGllbnQsIHF1ZXJ5Ll9xdWVyeSwgaW50ZXJuYWxBZ2dyZWdhdGVzKS50aGVuKGFnZ3JlZ2F0ZVJlc3VsdCA9PiBjb252ZXJ0VG9BZ2dyZWdhdGVRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZVJlc3VsdCkpO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgY29yZSBhZ2dyZWdyYXRpb24gcmVzdWx0IHRvIGFuIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YFxyXG4gKiB0aGF0IGNhbiBiZSByZXR1cm5lZCB0byB0aGUgY29uc3VtZXIuXHJcbiAqIEBwYXJhbSBxdWVyeVxyXG4gKiBAcGFyYW0gYWdncmVnYXRlUmVzdWx0IENvcmUgYWdncmVnYXRpb24gcmVzdWx0XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFRvQWdncmVnYXRlUXVlcnlTbmFwc2hvdChmaXJlc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVSZXN1bHQpIHtcclxuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gbmV3IEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QocXVlcnksIHVzZXJEYXRhV3JpdGVyLCBhZ2dyZWdhdGVSZXN1bHQpO1xyXG4gICAgcmV0dXJuIHF1ZXJ5U25hcHNob3Q7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5TG9jYWxDYWNoZUltcGwge1xyXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLmtpbmQgPSAnbWVtb3J5JztcclxuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuZ2FyYmFnZUNvbGxlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPVxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2FyYmFnZUNvbGxlY3Rvci5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBQZXJzaXN0ZW50TG9jYWxDYWNoZUltcGwge1xyXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudCc7XHJcbiAgICAgICAgbGV0IHRhYk1hbmFnZXI7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy50YWJNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnRhYk1hbmFnZXIuX2luaXRpYWxpemUoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB0YWJNYW5hZ2VyID0gc2V0dGluZ3MudGFiTWFuYWdlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhYk1hbmFnZXIgPSBwZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcih1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSB0YWJNYW5hZ2VyLl9vbmxpbmVDb21wb25lbnRQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB0YWJNYW5hZ2VyLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTWVtb3J5RWFnZXJHYWJhZ2VDb2xsZWN0b3JJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlFYWdlcic7XHJcbiAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE1lbW9yeUxydUdhYmFnZUNvbGxlY3RvckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY2FjaGVTaXplKSB7XHJcbiAgICAgICAgdGhpcy5raW5kID0gJ21lbW9yeUxydSc7XHJcbiAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNhY2hlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvcmAuIFRoaXMgaXMgYWxzbyB0aGVcclxuICogZGVmYXVsdCBnYXJiYWdlIGNvbGxlY3RvciB1bmxlc3MgaXQgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlFYWdlckdhYmFnZUNvbGxlY3RvckltcGwoKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgTWVtb3J5THJ1R2FyYmFnZUNvbGxlY3RvcmAuXHJcbiAqXHJcbiAqIEEgdGFyZ2V0IHNpemUgY2FuIGJlIHNwZWNpZmllZCBhcyBwYXJ0IG9mIHRoZSBzZXR0aW5nIHBhcmFtZXRlci4gVGhlXHJcbiAqIGNvbGxlY3RvciB3aWxsIHN0YXJ0IGRlbGV0aW5nIGRvY3VtZW50cyBvbmNlIHRoZSBjYWNoZSBzaXplIGV4Y2VlZHNcclxuICogdGhlIGdpdmVuIHNpemUuIFRoZSBkZWZhdWx0IGNhY2hlIHNpemUgaXMgNDBNQiAoNDAgKiAxMDI0ICogMTAyNCBieXRlcykuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IE1lbW9yeUxydUdhYmFnZUNvbGxlY3RvckltcGwoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgTWVtb3J5TG9jYWxDYWNoZWAuIFRoZSBpbnN0YW5jZSBjYW4gYmUgc2V0IHRvXHJcbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgdG8gdGVsbCB0aGUgU0RLIHdoaWNoIGNhY2hlIGxheWVyIHRvIHVzZS5cclxuICovXHJcbmZ1bmN0aW9uIG1lbW9yeUxvY2FsQ2FjaGUoc2V0dGluZ3MpIHtcclxuICAgIHJldHVybiBuZXcgTWVtb3J5TG9jYWxDYWNoZUltcGwoc2V0dGluZ3MpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TG9jYWxDYWNoZWAuIFRoZSBpbnN0YW5jZSBjYW4gYmUgc2V0IHRvXHJcbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgdG8gdGVsbCB0aGUgU0RLIHdoaWNoIGNhY2hlIGxheWVyIHRvIHVzZS5cclxuICpcclxuICogUGVyc2lzdGVudCBjYWNoZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwZXJzaXN0ZW50TG9jYWxDYWNoZShzZXR0aW5ncykge1xyXG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50TG9jYWxDYWNoZUltcGwoc2V0dGluZ3MpO1xyXG59XHJcbmNsYXNzIFNpbmdsZVRhYk1hbmFnZXJJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZvcmNlT3duZXJzaGlwKSB7XHJcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xyXG4gICAgICAgIHRoaXMua2luZCA9ICdwZXJzaXN0ZW50U2luZ2xlVGFiJztcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKTtcclxuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMsIHRoaXMuZm9yY2VPd25lcnNoaXApO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE11bHRpVGFiTWFuYWdlckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5raW5kID0gJ1BlcnNpc3RlbnRNdWx0aXBsZVRhYic7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfaW5pdGlhbGl6ZShzZXR0aW5ncykge1xyXG4gICAgICAgIHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBzZXR0aW5ncyBDb25maWd1cmVzIHRoZSBjcmVhdGVkIHRhYiBtYW5hZ2VyLlxyXG4gKi9cclxuZnVuY3Rpb24gcGVyc2lzdGVudFNpbmdsZVRhYk1hbmFnZXIoc2V0dGluZ3MpIHtcclxuICAgIHJldHVybiBuZXcgU2luZ2xlVGFiTWFuYWdlckltcGwoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmZvcmNlT3duZXJzaGlwKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgUGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlcmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwZXJzaXN0ZW50TXVsdGlwbGVUYWJNYW5hZ2VyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNdWx0aVRhYk1hbmFnZXJJbXBsKCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9UUkFOU0FDVElPTl9PUFRJT05TID0ge1xyXG4gICAgbWF4QXR0ZW1wdHM6IDVcclxufTtcclxuZnVuY3Rpb24gdmFsaWRhdGVUcmFuc2FjdGlvbk9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMubWF4QXR0ZW1wdHMgPCAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01heCBhdHRlbXB0cyBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB3cml0ZSBiYXRjaCwgdXNlZCB0byBwZXJmb3JtIG11bHRpcGxlIHdyaXRlcyBhcyBhIHNpbmdsZSBhdG9taWMgdW5pdC5cclxuICpcclxuICogQSBgV3JpdGVCYXRjaGAgb2JqZWN0IGNhbiBiZSBhY3F1aXJlZCBieSBjYWxsaW5nIHtAbGluayB3cml0ZUJhdGNofS4gSXRcclxuICogcHJvdmlkZXMgbWV0aG9kcyBmb3IgYWRkaW5nIHdyaXRlcyB0byB0aGUgd3JpdGUgYmF0Y2guIE5vbmUgb2YgdGhlIHdyaXRlc1xyXG4gKiB3aWxsIGJlIGNvbW1pdHRlZCAob3IgdmlzaWJsZSBsb2NhbGx5KSB1bnRpbCB7QGxpbmsgV3JpdGVCYXRjaC5jb21taXR9IGlzXHJcbiAqIGNhbGxlZC5cclxuICovXHJcbmNsYXNzIFdyaXRlQmF0Y2gge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF9jb21taXRIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcclxuICAgICAgICB0aGlzLl9jb21taXRIYW5kbGVyID0gX2NvbW1pdEhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5fY29tbWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgc2V0KGRvY3VtZW50UmVmLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmLmNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zLnB1c2gocGFyc2VkLnRvTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHVwZGF0ZShkb2N1bWVudFJlZiwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCAuLi5tb3JlRmllbGRzQW5kVmFsdWVzKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcclxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXHJcbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xyXG4gICAgICAgIGxldCBwYXJzZWQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZE9yVXBkYXRlRGF0YSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVWYXJhcmdzKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgVGhpcyBgV3JpdGVCYXRjaGAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zLmNvbmNhdChuZXcgRGVsZXRlTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0cyBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGlzIHdyaXRlIGJhdGNoIGFzIGEgc2luZ2xlIGF0b21pYyB1bml0LlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXN1bHQgb2YgdGhlc2Ugd3JpdGVzIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdFxyXG4gICAgICogb2NjdXIgYWZ0ZXIgdGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMuIElmIHRoZSBjbGllbnQgaXMgb2ZmbGluZSwgdGhlXHJcbiAgICAgKiB3cml0ZSBmYWlscy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGxvY2FsIG1vZGlmaWNhdGlvbnMgb3IgYnVmZmVyIHdyaXRlc1xyXG4gICAgICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIG9uY2UgYWxsIG9mIHRoZSB3cml0ZXMgaW4gdGhlIGJhdGNoIGhhdmUgYmVlblxyXG4gICAgICogc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgYXMgYW4gYXRvbWljIHVuaXQgKG5vdGUgdGhhdCBpdCB3b24ndFxyXG4gICAgICogcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXHJcbiAgICAgKi9cclxuICAgIGNvbW1pdCgpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWl0SGFuZGxlcih0aGlzLl9tdXRhdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBfdmVyaWZ5Tm90Q29tbWl0dGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb21taXR0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0Egd3JpdGUgYmF0Y2ggY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIGNvbW1pdCgpICcgK1xyXG4gICAgICAgICAgICAgICAgJ2hhcyBiZWVuIGNhbGxlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIGZpcmVzdG9yZSkge1xyXG4gICAgZG9jdW1lbnRSZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UoZG9jdW1lbnRSZWYpO1xyXG4gICAgaWYgKGRvY3VtZW50UmVmLmZpcmVzdG9yZSAhPT0gZmlyZXN0b3JlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1Byb3ZpZGVkIGRvY3VtZW50IHJlZmVyZW5jZSBpcyBmcm9tIGEgZGlmZmVyZW50IEZpcmVzdG9yZSBpbnN0YW5jZS4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudFJlZjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUT0RPKG1yc2NobWlkdCkgQ29uc2lkZXIgdXNpbmcgYEJhc2VUcmFuc2FjdGlvbmAgYXMgdGhlIGJhc2UgY2xhc3MgaW4gdGhlXHJcbi8vIGxlZ2FjeSBTREsuXHJcbi8qKlxyXG4gKiBBIHJlZmVyZW5jZSB0byBhIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgYFRyYW5zYWN0aW9uYCBvYmplY3QgcGFzc2VkIHRvIGEgdHJhbnNhY3Rpb24ncyBgdXBkYXRlRnVuY3Rpb25gIHByb3ZpZGVzXHJcbiAqIHRoZSBtZXRob2RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjb250ZXh0LiBTZWVcclxuICoge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uJDEge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBfdHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZC5cclxuICAgICAqIEByZXR1cm5zIEEgYERvY3VtZW50U25hcHNob3RgIHdpdGggdGhlIHJlYWQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0KGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmxvb2t1cChbcmVmLl9rZXldKS50aGVuKGRvY3MgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRvY3MgfHwgZG9jcy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZG9jID0gZG9jc1swXTtcclxuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgZG9jLmtleSwgZG9jLCByZWYuY29udmVydGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHJlZi5fa2V5LCBudWxsLCByZWYuY29udmVydGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0KGRvY3VtZW50UmVmLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZi5jb252ZXJ0ZXIsIHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uc2V0KHJlZi5fa2V5LCBwYXJzZWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgbGV0IHBhcnNlZDtcclxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3ModGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdUcmFuc2FjdGlvbi51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi51cGRhdGUocmVmLl9rZXksIHBhcnNlZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgVGhpcyBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZShkb2N1bWVudFJlZikge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLmRlbGV0ZShyZWYuX2tleSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgcmVmZXJlbmNlIHRvIGEgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcclxuICogdGhlIG1ldGhvZHMgdG8gcmVhZCBhbmQgd3JpdGUgZGF0YSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNvbnRleHQuIFNlZVxyXG4gKiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBUcmFuc2FjdGlvbiQxIHtcclxuICAgIC8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgc2FtZSBsb2dpYyBhcyB0aGUgVHJhbnNhY3Rpb24gQVBJIGluIHRoZSBMaXRlIFNES1xyXG4gICAgLy8gYnV0IGlzIHN1YmNsYXNzZWQgaW4gb3JkZXIgdG8gcmV0dXJuIGl0cyBvd24gRG9jdW1lbnRTbmFwc2hvdCB0eXBlcy5cclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBzdXBlcihfZmlyZXN0b3JlLCBfdHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSByZWFkLlxyXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQoZG9jdW1lbnRSZWYpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcih0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBzdXBlclxyXG4gICAgICAgICAgICAuZ2V0KGRvY3VtZW50UmVmKVxyXG4gICAgICAgICAgICAudGhlbihsaXRlRG9jdW1lbnRTbmFwc2hvdCA9PiBuZXcgRG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgbGl0ZURvY3VtZW50U25hcHNob3QuX2RvY3VtZW50LCBuZXcgU25hcHNob3RNZXRhZGF0YShcclxuICAgICAgICAvKiBoYXNQZW5kaW5nV3JpdGVzPSAqLyBmYWxzZSwgXHJcbiAgICAgICAgLyogZnJvbUNhY2hlPSAqLyBmYWxzZSksIHJlZi5jb252ZXJ0ZXIpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXhlY3V0ZXMgdGhlIGdpdmVuIGB1cGRhdGVGdW5jdGlvbmAgYW5kIHRoZW4gYXR0ZW1wdHMgdG8gY29tbWl0IHRoZSBjaGFuZ2VzXHJcbiAqIGFwcGxpZWQgd2l0aGluIHRoZSB0cmFuc2FjdGlvbi4gSWYgYW55IGRvY3VtZW50IHJlYWQgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBoYXMgY2hhbmdlZCwgQ2xvdWQgRmlyZXN0b3JlIHJldHJpZXMgdGhlIGB1cGRhdGVGdW5jdGlvbmAuIElmIGl0IGZhaWxzIHRvXHJcbiAqIGNvbW1pdCBhZnRlciA1IGF0dGVtcHRzLCB0aGUgdHJhbnNhY3Rpb24gZmFpbHMuXHJcbiAqXHJcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBpcyA1MDAuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBBIHJlZmVyZW5jZSB0byB0aGUgRmlyZXN0b3JlIGRhdGFiYXNlIHRvIHJ1biB0aGlzXHJcbiAqIHRyYW5zYWN0aW9uIGFnYWluc3QuXHJcbiAqIEBwYXJhbSB1cGRhdGVGdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb25cclxuICogY29udGV4dC5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMgdG9cclxuICogY29tbWl0LlxyXG4gKiBAcmV0dXJucyBJZiB0aGUgdHJhbnNhY3Rpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBvciB3YXMgZXhwbGljaXRseSBhYm9ydGVkXHJcbiAqICh0aGUgYHVwZGF0ZUZ1bmN0aW9uYCByZXR1cm5lZCBhIGZhaWxlZCBwcm9taXNlKSwgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlXHJcbiAqIGB1cGRhdGVGdW5jdGlvbiBgaXMgcmV0dXJuZWQgaGVyZS4gT3RoZXJ3aXNlLCBpZiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkLCBhXHJcbiAqIHJlamVjdGVkIHByb21pc2Ugd2l0aCB0aGUgY29ycmVzcG9uZGluZyBmYWlsdXJlIGVycm9yIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCB1cGRhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1RSQU5TQUNUSU9OX09QVElPTlMpLCBvcHRpb25zKTtcclxuICAgIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFRyYW5zYWN0aW9uKGNsaWVudCwgaW50ZXJuYWxUcmFuc2FjdGlvbiA9PiB1cGRhdGVGdW5jdGlvbihuZXcgVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCBpbnRlcm5hbFRyYW5zYWN0aW9uKSksIG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgZm9yIHVzZSB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gb3JcclxuICoge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSB3aXRoIGB7bWVyZ2U6IHRydWV9YCB0byBtYXJrIGEgZmllbGQgZm9yIGRlbGV0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlRmllbGQoKSB7XHJcbiAgICByZXR1cm4gbmV3IERlbGV0ZUZpZWxkVmFsdWVJbXBsKCdkZWxldGVGaWVsZCcpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSB0b1xyXG4gKiBpbmNsdWRlIGEgc2VydmVyLWdlbmVyYXRlZCB0aW1lc3RhbXAgaW4gdGhlIHdyaXR0ZW4gZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCgpIHtcclxuICAgIHJldHVybiBuZXcgU2VydmVyVGltZXN0YW1wRmllbGRWYWx1ZUltcGwoJ3NlcnZlclRpbWVzdGFtcCcpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmtcclxuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byB1bmlvbiB0aGUgZ2l2ZW4gZWxlbWVudHMgd2l0aCBhbnkgYXJyYXlcclxuICogdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBFYWNoIHNwZWNpZmllZCBlbGVtZW50IHRoYXQgZG9lc24ndFxyXG4gKiBhbHJlYWR5IGV4aXN0IGluIHRoZSBhcnJheSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQuIElmIHRoZSBmaWVsZCBiZWluZ1xyXG4gKiBtb2RpZmllZCBpcyBub3QgYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gYXJyYXlcclxuICogY29udGFpbmluZyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byB1bmlvbiBpbnRvIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXHJcbiAqIGB1cGRhdGVEb2MoKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheVVuaW9uKC4uLmVsZW1lbnRzKSB7XHJcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBhY3R1YWxseSBwYXJzZSB0aGUgZGF0YSB1bnRpbCBpdCdzIHVzZWQgaW4gc2V0KCkgb3JcclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXHJcbiAgICByZXR1cm4gbmV3IEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCgnYXJyYXlVbmlvbicsIGVsZW1lbnRzKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayAoc2V0RG9jOjEpfSBvciB7QGxpbmtcclxuICogdXBkYXRlRG9jOjF9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byByZW1vdmUgdGhlIGdpdmVuIGVsZW1lbnRzIGZyb20gYW55XHJcbiAqIGFycmF5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIHNlcnZlci4gQWxsIGluc3RhbmNlcyBvZiBlYWNoIGVsZW1lbnRcclxuICogc3BlY2lmaWVkIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS4gSWYgdGhlIGZpZWxkIGJlaW5nIG1vZGlmaWVkIGlzIG5vdFxyXG4gKiBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBlbXB0eSBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXHJcbiAqIGB1cGRhdGVEb2MoKWBcclxuICovXHJcbmZ1bmN0aW9uIGFycmF5UmVtb3ZlKC4uLmVsZW1lbnRzKSB7XHJcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBhY3R1YWxseSBwYXJzZSB0aGUgZGF0YSB1bnRpbCBpdCdzIHVzZWQgaW4gc2V0KCkgb3JcclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXHJcbiAgICByZXR1cm4gbmV3IEFycmF5UmVtb3ZlRmllbGRWYWx1ZUltcGwoJ2FycmF5UmVtb3ZlJywgZWxlbWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmtcclxuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byBpbmNyZW1lbnQgdGhlIGZpZWxkJ3MgY3VycmVudCB2YWx1ZSBieVxyXG4gKiB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqXHJcbiAqIElmIGVpdGhlciB0aGUgb3BlcmFuZCBvciB0aGUgY3VycmVudCBmaWVsZCB2YWx1ZSB1c2VzIGZsb2F0aW5nIHBvaW50XHJcbiAqIHByZWNpc2lvbiwgYWxsIGFyaXRobWV0aWMgZm9sbG93cyBJRUVFIDc1NCBzZW1hbnRpY3MuIElmIGJvdGggdmFsdWVzIGFyZVxyXG4gKiBpbnRlZ2VycywgdmFsdWVzIG91dHNpZGUgb2YgSmF2YVNjcmlwdCdzIHNhZmUgbnVtYmVyIHJhbmdlXHJcbiAqIChgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJgIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmApIGFyZSBhbHNvIHN1YmplY3QgdG9cclxuICogcHJlY2lzaW9uIGxvc3MuIEZ1cnRoZXJtb3JlLCBvbmNlIHByb2Nlc3NlZCBieSB0aGUgRmlyZXN0b3JlIGJhY2tlbmQsIGFsbFxyXG4gKiBpbnRlZ2VyIG9wZXJhdGlvbnMgYXJlIGNhcHBlZCBiZXR3ZWVuIC0yXjYzIGFuZCAyXjYzLTEuXHJcbiAqXHJcbiAqIElmIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIGBudW1iZXJgLCBvciBpZiB0aGUgZmllbGQgZG9lcyBub3RcclxuICogeWV0IGV4aXN0LCB0aGUgdHJhbnNmb3JtYXRpb24gc2V0cyB0aGUgZmllbGQgdG8gdGhlIGdpdmVuIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbiAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgYnkuXHJcbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxyXG4gKiBgdXBkYXRlRG9jKClgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmNyZW1lbnQobikge1xyXG4gICAgcmV0dXJuIG5ldyBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwoJ2luY3JlbWVudCcsIG4pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JpdGUgYmF0Y2gsIHVzZWQgZm9yIHBlcmZvcm1pbmcgbXVsdGlwbGUgd3JpdGVzIGFzIGEgc2luZ2xlXHJcbiAqIGF0b21pYyBvcGVyYXRpb24uIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSB7QGxpbmsgV3JpdGVCYXRjaH1cclxuICogaXMgNTAwLlxyXG4gKlxyXG4gKiBVbmxpa2UgdHJhbnNhY3Rpb25zLCB3cml0ZSBiYXRjaGVzIGFyZSBwZXJzaXN0ZWQgb2ZmbGluZSBhbmQgdGhlcmVmb3JlIGFyZVxyXG4gKiBwcmVmZXJhYmxlIHdoZW4geW91IGRvbid0IG5lZWQgdG8gY29uZGl0aW9uIHlvdXIgd3JpdGVzIG9uIHJlYWQgZGF0YS5cclxuICpcclxuICogQHJldHVybnMgQSB7QGxpbmsgV3JpdGVCYXRjaH0gdGhhdCBjYW4gYmUgdXNlZCB0byBhdG9taWNhbGx5IGV4ZWN1dGUgbXVsdGlwbGVcclxuICogd3JpdGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVCYXRjaChmaXJlc3RvcmUpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIG5ldyBXcml0ZUJhdGNoKGZpcmVzdG9yZSwgbXV0YXRpb25zID0+IGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIG11dGF0aW9ucykpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldEluZGV4Q29uZmlndXJhdGlvbihmaXJlc3RvcmUsIGpzb25PckNvbmZpZ3VyYXRpb24pIHtcclxuICAgIHZhciBfYTtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgaWYgKCFjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIgfHxcclxuICAgICAgICAoKF9hID0gY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX29mZmxpbmVLaW5kKSA9PT0gJ21lbW9yeScpIHtcclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFdlIGRvbid0IHJldHVybiBhbiBlcnJvciBpZiB0aGUgdXNlciBoYXMgbm90IGVuYWJsZWRcclxuICAgICAgICAvLyBwZXJzaXN0ZW5jZSBzaW5jZSBgZW5hYmxlSW5kZXhlZGRiUGVyc2lzdGVuY2UoKWAgY2FuIGZhaWwgb24gdGhlIFdlYi5cclxuICAgICAgICBsb2dXYXJuKCdDYW5ub3QgZW5hYmxlIGluZGV4ZXMgd2hlbiBwZXJzaXN0ZW5jZSBpcyBkaXNhYmxlZCcpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcnNlZEluZGV4ZXMgPSBwYXJzZUluZGV4ZXMoanNvbk9yQ29uZmlndXJhdGlvbik7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50U2V0SW5kZXhDb25maWd1cmF0aW9uKGNsaWVudCwgcGFyc2VkSW5kZXhlcyk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VJbmRleGVzKGpzb25PckNvbmZpZ3VyYXRpb24pIHtcclxuICAgIGNvbnN0IGluZGV4Q29uZmlndXJhdGlvbiA9IHR5cGVvZiBqc29uT3JDb25maWd1cmF0aW9uID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gdHJ5UGFyc2VKc29uKGpzb25PckNvbmZpZ3VyYXRpb24pXHJcbiAgICAgICAgOiBqc29uT3JDb25maWd1cmF0aW9uO1xyXG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IFtdO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXhDb25maWd1cmF0aW9uLmluZGV4ZXMpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleENvbmZpZ3VyYXRpb24uaW5kZXhlcykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXAgPSB0cnlHZXRTdHJpbmcoaW5kZXgsICdjb2xsZWN0aW9uR3JvdXAnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXguZmllbGRzKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFBhdGhTdHJpbmcgPSB0cnlHZXRTdHJpbmcoZmllbGQsICdmaWVsZFBhdGgnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFBhdGggPSBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKCdzZXRJbmRleENvbmZpZ3VyYXRpb24nLCBmaWVsZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5hcnJheUNvbmZpZyA9PT0gJ0NPTlRBSU5TJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmllbGRQYXRoLCAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5vcmRlciA9PT0gJ0FTQ0VORElORycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9yZGVyID09PSAnREVTQ0VORElORycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMSAvKiBJbmRleEtpbmQuREVTQ0VORElORyAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJzZWRJbmRleGVzLnB1c2gobmV3IEZpZWxkSW5kZXgoRmllbGRJbmRleC5VTktOT1dOX0lELCBjb2xsZWN0aW9uR3JvdXAsIHNlZ21lbnRzLCBJbmRleFN0YXRlLmVtcHR5KCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyc2VkSW5kZXhlcztcclxufVxyXG5mdW5jdGlvbiB0cnlQYXJzZUpzb24oanNvbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZhaWxlZCB0byBwYXJzZSBKU09OOiAnICsgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJ5R2V0U3RyaW5nKGRhdGEsIHByb3BlcnR5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRhdGFbcHJvcGVydHldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdNaXNzaW5nIHN0cmluZyB2YWx1ZSBmb3I6ICcgKyBwcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVtwcm9wZXJ0eV07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgZm9yIGNvbmZpZ3VyaW5nIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyB1c2VkXHJcbiAqIGZvciBsb2NhbCBxdWVyeSBleGVjdXRpb24uXHJcbiAqXHJcbiAqIFRvIHVzZSwgY2FsbCBgZ2V0UGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyKClgIHRvIGdldCBhbiBpbnN0YW5jZS5cclxuICovXHJcbmNsYXNzIFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCkge1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IF9jbGllbnQ7XHJcbiAgICAgICAgLyoqIEEgdHlwZSBzdHJpbmcgdG8gdW5pcXVlbHkgaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ1BlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcic7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIFBlcnNpc3RlbnRDYWNoZSBJbmRleCBNYW5hZ2VyIHVzZWQgYnkgdGhlIGdpdmVuIGBGaXJlc3RvcmVgXHJcbiAqIG9iamVjdC5cclxuICpcclxuICogQHJldHVybiBUaGUgYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgaW5zdGFuY2UsIG9yIGBudWxsYCBpZiBsb2NhbFxyXG4gKiBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgbm90IGluIHVzZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcihmaXJlc3RvcmUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2FjaGVkSW5zdGFuY2UgPSBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZS5nZXQoZmlyZXN0b3JlKTtcclxuICAgIGlmIChjYWNoZWRJbnN0YW5jZSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRJbnN0YW5jZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGlmICgoKF9hID0gY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX29mZmxpbmVLaW5kKSAhPT0gJ3BlcnNpc3RlbnQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIoY2xpZW50KTtcclxuICAgIHBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlckJ5RmlyZXN0b3JlLnNldChmaXJlc3RvcmUsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG4vKipcclxuICogRW5hYmxlcyB0aGUgU0RLIHRvIGNyZWF0ZSBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgYXV0b21hdGljYWxseSBmb3IgbG9jYWxcclxuICogcXVlcnkgZXhlY3V0aW9uIHdoZW4gdGhlIFNESyBiZWxpZXZlcyBjYWNoZSBpbmRleGVzIGNhbiBoZWxwIGltcHJvdmVcclxuICogcGVyZm9ybWFuY2UuXHJcbiAqXHJcbiAqIFRoaXMgZmVhdHVyZSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5hYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24oaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCB0cnVlKTtcclxufVxyXG4vKipcclxuICogU3RvcHMgY3JlYXRpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIGF1dG9tYXRpY2FsbHkgZm9yIGxvY2FsIHF1ZXJ5XHJcbiAqIGV4ZWN1dGlvbi4gVGhlIGluZGV4ZXMgd2hpY2ggaGF2ZSBiZWVuIGNyZWF0ZWQgYnkgY2FsbGluZ1xyXG4gKiBgZW5hYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24oKWAgc3RpbGwgdGFrZSBlZmZlY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkaXNhYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24oaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCBmYWxzZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcy5cclxuICpcclxuICogUGxlYXNlIG5vdGUgdGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gZGVsZXRlcyBpbmRleGVzIGdlbmVyYXRlZCBieVxyXG4gKiBgc2V0SW5kZXhDb25maWd1cmF0aW9uKClgLCB3aGljaCBpcyBkZXByZWNhdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlQWxsUGVyc2lzdGVudENhY2hlSW5kZXhlcyhpbmRleE1hbmFnZXIpIHtcclxuICAgIGluZGV4TWFuYWdlci5fY2xpZW50LnZlcmlmeU5vdFRlcm1pbmF0ZWQoKTtcclxuICAgIGNvbnN0IHByb21pc2UgPSBmaXJlc3RvcmVDbGllbnREZWxldGVBbGxGaWVsZEluZGV4ZXMoaW5kZXhNYW5hZ2VyLl9jbGllbnQpO1xyXG4gICAgcHJvbWlzZVxyXG4gICAgICAgIC50aGVuKF8gPT4gbG9nRGVidWcoJ2RlbGV0aW5nIGFsbCBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgc3VjY2VlZGVkJykpXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGxvZ1dhcm4oJ2RlbGV0aW5nIGFsbCBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgZmFpbGVkJywgZXJyb3IpKTtcclxufVxyXG5mdW5jdGlvbiBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCBpc0VuYWJsZWQpIHtcclxuICAgIGluZGV4TWFuYWdlci5fY2xpZW50LnZlcmlmeU5vdFRlcm1pbmF0ZWQoKTtcclxuICAgIGNvbnN0IHByb21pc2UgPSBmaXJlc3RvcmVDbGllbnRTZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLl9jbGllbnQsIGlzRW5hYmxlZCk7XHJcbiAgICBwcm9taXNlXHJcbiAgICAgICAgLnRoZW4oXyA9PiBsb2dEZWJ1Zyhgc2V0dGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4IGF1dG8gY3JlYXRpb24gYCArXHJcbiAgICAgICAgYGlzRW5hYmxlZD0ke2lzRW5hYmxlZH0gc3VjY2VlZGVkYCkpXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGxvZ1dhcm4oYHNldHRpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleCBhdXRvIGNyZWF0aW9uIGAgK1xyXG4gICAgICAgIGBpc0VuYWJsZWQ9JHtpc0VuYWJsZWR9IGZhaWxlZGAsIGVycm9yKSk7XHJcbn1cclxuLyoqXHJcbiAqIE1hcHMgYEZpcmVzdG9yZWAgaW5zdGFuY2VzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcclxuICogYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBVc2UgYSBgV2Vha01hcGAgc28gdGhhdCB0aGUgbWFwcGluZyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZHJvcHBlZCB3aGVuIHRoZVxyXG4gKiBgRmlyZXN0b3JlYCBpbnN0YW5jZSBpcyBnYXJiYWdlIGNvbGxlY3RlZC4gVGhpcyBlbXVsYXRlcyBhIHByaXZhdGUgbWVtYmVyXHJcbiAqIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL2dvby5nbGUvNDU0eXZ1Zy5cclxuICovXHJcbmNvbnN0IHBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlckJ5RmlyZXN0b3JlID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cclxuICpcclxuICogUmV0dXJucyB0aGUgYFF1ZXJ5VGFyZ2V0YCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gcXVlcnkuIFJldHVybnMgYG51bGxgXHJcbiAqIGlmIHRoZSBGaXJlc3RvcmUgY2xpZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkgaGFzIG5vdCBiZWVuXHJcbiAqIGluaXRpYWxpemVkIG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSB0byBjb252ZXJ0IHRvIHByb3RvIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuZnVuY3Rpb24gX2ludGVybmFsUXVlcnlUb1Byb3RvUXVlcnlUYXJnZXQocXVlcnkpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3Qgc2VyaWFsaXplciA9IChfYSA9IGNsaWVudC5fb25saW5lQ29tcG9uZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGFzdG9yZS5zZXJpYWxpemVyO1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgcXVlcnlUb1RhcmdldChxdWVyeS5fcXVlcnkpKS5xdWVyeVRhcmdldDtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LlxyXG4gKlxyXG4gKiBSZXR1cm5zIGBSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdGAgd2hpY2ggY29udGFpbnMgdGhlIHByb3RvIHJlcHJlc2VudGF0aW9uXHJcbiAqIG9mIHRoZSBnaXZlbiBhZ2dyZWdhdGlvbiBxdWVyeSByZXF1ZXN0LiBSZXR1cm5zIG51bGwgaWYgdGhlIEZpcmVzdG9yZSBjbGllbnRcclxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgb3IgaGFzIGJlZW5cclxuICogdGVybWluYXRlZC5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIFF1ZXJ5IHRvIGNvbnZlcnQgdG8gcHJvdG8gcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSBhZ2dyZWdhdGVTcGVjIC0gVGhlIHNldCBvZiBhZ2dyZWdhdGlvbnMgYW5kIHRoZWlyIGFsaWFzZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBfaW50ZXJuYWxBZ2dyZWdhdGlvblF1ZXJ5VG9Qcm90b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBhZ2dyZWdhdGVzID0gbWFwVG9BcnJheShhZ2dyZWdhdGVTcGVjLCAoYWdncmVnYXRlLCBhbGlhcykgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgQWdncmVnYXRlSW1wbChhbGlhcywgYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUsIGFnZ3JlZ2F0ZS5faW50ZXJuYWxGaWVsZFBhdGgpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSAoX2EgPSBjbGllbnQuX29ubGluZUNvbXBvbmVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhc3RvcmUuc2VyaWFsaXplcjtcclxuICAgIGlmIChzZXJpYWxpemVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KHNlcmlhbGl6ZXIsIHF1ZXJ5VG9BZ2dyZWdhdGVUYXJnZXQocXVlcnkuX3F1ZXJ5KSwgYWdncmVnYXRlcywgXHJcbiAgICAvKiBza2lwQWxpYXNpbmc9ICovIHRydWUpLnJlcXVlc3Q7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRlc3RpbmcgaG9va3MgZm9yIHVzZSBieSBGaXJlc3RvcmUncyBpbnRlZ3JhdGlvbiB0ZXN0IHN1aXRlIHRvIHJlYWNoIGludG8gdGhlXHJcbiAqIFNESyBpbnRlcm5hbHMgdG8gdmFsaWRhdGUgbG9naWMgYW5kIGJlaGF2aW9yIHRoYXQgaXMgbm90IHZpc2libGUgZnJvbSB0aGVcclxuICogcHVibGljIEFQSSBzdXJmYWNlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFRlc3RpbmdIb29rcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY3JlYXRlZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBub3RpZmllZCB3aGVuIGFuIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hcclxuICAgICAqIG9jY3VycyBpbiB0aGUgV2F0Y2ggbGlzdGVuIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcmVsYXRpdmUgb3JkZXIgaW4gd2hpY2ggY2FsbGJhY2tzIGFyZSBub3RpZmllZCBpcyB1bnNwZWNpZmllZDsgZG8gbm90XHJcbiAgICAgKiByZWx5IG9uIGFueSBwYXJ0aWN1bGFyIG9yZGVyaW5nLiBJZiBhIGdpdmVuIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQgbXVsdGlwbGVcclxuICAgICAqIHRpbWVzIHRoZW4gaXQgd2lsbCBiZSBub3RpZmllZCBtdWx0aXBsZSB0aW1lcywgb25jZSBwZXIgcmVnaXN0cmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHVucmVnaXN0ZXJzIHRoZSBnaXZlbiBjYWxsYmFjazsgb25seVxyXG4gICAgICogdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGRvZXMgYW55dGhpbmc7IGFsbCBzdWJzZXF1ZW50XHJcbiAgICAgKiBpbnZvY2F0aW9ucyBkbyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiBUZXN0aW5nSG9va3NTcGlJbXBsLmluc3RhbmNlLm9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgYFRlc3RpbmdIb29rc1NwaWAuXHJcbiAqL1xyXG5jbGFzcyBUZXN0aW5nSG9va3NTcGlJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hDYWxsYmFja3NCeUlkID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcclxuICAgICAgICBpZiAoIXRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UgPSBuZXcgVGVzdGluZ0hvb2tzU3BpSW1wbCgpO1xyXG4gICAgICAgICAgICBzZXRUZXN0aW5nSG9va3NTcGkodGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZTtcclxuICAgIH1cclxuICAgIG5vdGlmeU9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goaW5mbykge1xyXG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hDYWxsYmFja3NCeUlkLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soaW5mbykpO1xyXG4gICAgfVxyXG4gICAgb25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGlkID0gU3ltYm9sKCk7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5leGlzdGVuY2VGaWx0ZXJNaXNtYXRjaENhbGxiYWNrc0J5SWQ7XHJcbiAgICAgICAgY2FsbGJhY2tzLnNldChpZCwgY2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBjYWxsYmFja3MuZGVsZXRlKGlkKTtcclxuICAgIH1cclxufVxyXG5sZXQgdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlID0gbnVsbDtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxucmVnaXN0ZXJGaXJlc3RvcmUoJ25vZGUnKTtcblxuZXhwb3J0IHsgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciwgQWdncmVnYXRlRmllbGQsIEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QsIEJ5dGVzLCBDQUNIRV9TSVpFX1VOTElNSVRFRCwgQ29sbGVjdGlvblJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UsIERvY3VtZW50U25hcHNob3QsIEZpZWxkUGF0aCwgRmllbGRWYWx1ZSwgRmlyZXN0b3JlLCBGaXJlc3RvcmVFcnJvciwgR2VvUG9pbnQsIExvYWRCdW5kbGVUYXNrLCBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIsIFF1ZXJ5LCBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQsIFF1ZXJ5Q29uc3RyYWludCwgUXVlcnlEb2N1bWVudFNuYXBzaG90LCBRdWVyeUVuZEF0Q29uc3RyYWludCwgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQsIFF1ZXJ5TGltaXRDb25zdHJhaW50LCBRdWVyeU9yZGVyQnlDb25zdHJhaW50LCBRdWVyeVNuYXBzaG90LCBRdWVyeVN0YXJ0QXRDb25zdHJhaW50LCBTbmFwc2hvdE1ldGFkYXRhLCBUaW1lc3RhbXAsIFRyYW5zYWN0aW9uLCBXcml0ZUJhdGNoLCBBdXRvSWQgYXMgX0F1dG9JZCwgQnl0ZVN0cmluZyBhcyBfQnl0ZVN0cmluZywgRGF0YWJhc2VJZCBhcyBfRGF0YWJhc2VJZCwgRG9jdW1lbnRLZXkgYXMgX0RvY3VtZW50S2V5LCBFbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciBhcyBfRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIsIEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgYXMgX0VtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIEZpZWxkUGF0aCQxIGFzIF9GaWVsZFBhdGgsIFRlc3RpbmdIb29rcyBhcyBfVGVzdGluZ0hvb2tzLCBjYXN0IGFzIF9jYXN0LCBkZWJ1Z0Fzc2VydCBhcyBfZGVidWdBc3NlcnQsIF9pbnRlcm5hbEFnZ3JlZ2F0aW9uUXVlcnlUb1Byb3RvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QsIF9pbnRlcm5hbFF1ZXJ5VG9Qcm90b1F1ZXJ5VGFyZ2V0LCBpc0Jhc2U2NEF2YWlsYWJsZSBhcyBfaXNCYXNlNjRBdmFpbGFibGUsIGxvZ1dhcm4gYXMgX2xvZ1dhcm4sIHZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIgYXMgX3ZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIsIGFkZERvYywgYWdncmVnYXRlRmllbGRFcXVhbCwgYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsLCBhbmQsIGFycmF5UmVtb3ZlLCBhcnJheVVuaW9uLCBhdmVyYWdlLCBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlLCBjb2xsZWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvciwgY291bnQsIGRlbGV0ZUFsbFBlcnNpc3RlbnRDYWNoZUluZGV4ZXMsIGRlbGV0ZURvYywgZGVsZXRlRmllbGQsIGRpc2FibGVOZXR3b3JrLCBkaXNhYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24sIGRvYywgZG9jdW1lbnRJZCwgZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UsIGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UsIGVuYWJsZU5ldHdvcmssIGVuYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBlbmRBdCwgZW5kQmVmb3JlLCBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkLCBleGVjdXRlV3JpdGUsIGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIsIGdldENvdW50RnJvbVNlcnZlciwgZ2V0RG9jLCBnZXREb2NGcm9tQ2FjaGUsIGdldERvY0Zyb21TZXJ2ZXIsIGdldERvY3MsIGdldERvY3NGcm9tQ2FjaGUsIGdldERvY3NGcm9tU2VydmVyLCBnZXRGaXJlc3RvcmUsIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciwgaW5jcmVtZW50LCBpbml0aWFsaXplRmlyZXN0b3JlLCBsaW1pdCwgbGltaXRUb0xhc3QsIGxvYWRCdW5kbGUsIG1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvciwgbWVtb3J5TG9jYWxDYWNoZSwgbWVtb3J5THJ1R2FyYmFnZUNvbGxlY3RvciwgbmFtZWRRdWVyeSwgb25TbmFwc2hvdCwgb25TbmFwc2hvdHNJblN5bmMsIG9yLCBvcmRlckJ5LCBwZXJzaXN0ZW50TG9jYWxDYWNoZSwgcGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlciwgcGVyc2lzdGVudFNpbmdsZVRhYk1hbmFnZXIsIHF1ZXJ5LCBxdWVyeUVxdWFsLCByZWZFcXVhbCwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgc2V0RG9jLCBzZXRJbmRleENvbmZpZ3VyYXRpb24sIHNldExvZ0xldmVsLCBzbmFwc2hvdEVxdWFsLCBzdGFydEFmdGVyLCBzdGFydEF0LCBzdW0sIHRlcm1pbmF0ZSwgdXBkYXRlRG9jLCB3YWl0Rm9yUGVuZGluZ1dyaXRlcywgd2hlcmUsIHdyaXRlQmF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/installations/dist/esm/index.esm2017.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteInstallations: () => (/* binding */ deleteInstallations),\n/* harmony export */   getId: () => (/* binding */ getId),\n/* harmony export */   getInstallations: () => (/* binding */ getInstallations),\n/* harmony export */   getToken: () => (/* binding */ getToken),\n/* harmony export */   onIdChange: () => (/* binding */ onIdChange)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.8\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PENDING_TIMEOUT_MS = 10000;\r\nconst PACKAGE_VERSION = `w:${version}`;\r\nconst INTERNAL_AUTH_VERSION = 'FIS_v2';\r\nconst INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\r\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\r\nconst SERVICE = 'installations';\r\nconst SERVICE_NAME = 'Installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERROR_DESCRIPTION_MAP = {\r\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: \"{$valueName}\"',\r\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */]: 'Firebase Installation is not registered.',\r\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',\r\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\r\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */]: 'Could not process request. Application offline.',\r\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */]: \"Can't delete installation while there is a pending registration request.\"\r\n};\r\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\r\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\r\nfunction isServerError(error) {\r\n    return (error instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError &&\r\n        error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getInstallationsEndpoint({ projectId }) {\r\n    return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\r\n}\r\nfunction extractAuthTokenInfoFromResponse(response) {\r\n    return {\r\n        token: response.token,\r\n        requestStatus: 2 /* RequestStatus.COMPLETED */,\r\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\r\n        creationTime: Date.now()\r\n    };\r\n}\r\nasync function getErrorFromResponse(requestName, response) {\r\n    const responseJson = await response.json();\r\n    const errorData = responseJson.error;\r\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */, {\r\n        requestName,\r\n        serverCode: errorData.code,\r\n        serverMessage: errorData.message,\r\n        serverStatus: errorData.status\r\n    });\r\n}\r\nfunction getHeaders({ apiKey }) {\r\n    return new Headers({\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\nfunction getHeadersWithAuth(appConfig, { refreshToken }) {\r\n    const headers = getHeaders(appConfig);\r\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\r\n    return headers;\r\n}\r\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */\r\nasync function retryIfServerError(fn) {\r\n    const result = await fn();\r\n    if (result.status >= 500 && result.status < 600) {\r\n        // Internal Server Error. Retry request.\r\n        return fn();\r\n    }\r\n    return result;\r\n}\r\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\r\n    // This works because the server will never respond with fractions of a second.\r\n    return Number(responseExpiresIn.replace('s', '000'));\r\n}\r\nfunction getAuthorizationHeader(refreshToken) {\r\n    return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {\r\n    const endpoint = getInstallationsEndpoint(appConfig);\r\n    const headers = getHeaders(appConfig);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        fid,\r\n        authVersion: INTERNAL_AUTH_VERSION,\r\n        appId: appConfig.appId,\r\n        sdkVersion: PACKAGE_VERSION\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const registeredInstallationEntry = {\r\n            fid: responseValue.fid || fid,\r\n            registrationStatus: 2 /* RequestStatus.COMPLETED */,\r\n            refreshToken: responseValue.refreshToken,\r\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\r\n        };\r\n        return registeredInstallationEntry;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Create Installation', response);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a promise that resolves after given time passes. */\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction bufferToBase64UrlSafe(array) {\r\n    const b64 = btoa(String.fromCharCode(...array));\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\r\nconst INVALID_FID = '';\r\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */\r\nfunction generateFid() {\r\n    try {\r\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\r\n        // bytes. our implementation generates a 17 byte array instead.\r\n        const fidByteArray = new Uint8Array(17);\r\n        const crypto = self.crypto || self.msCrypto;\r\n        crypto.getRandomValues(fidByteArray);\r\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\r\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\r\n        const fid = encode(fidByteArray);\r\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\r\n    }\r\n    catch (_a) {\r\n        // FID generation errored\r\n        return INVALID_FID;\r\n    }\r\n}\r\n/** Converts a FID Uint8Array to a base64 string representation. */\r\nfunction encode(fidByteArray) {\r\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\r\n    // Remove the 23rd character that was added because of the extra 4 bits at the\r\n    // end of our 17 byte array, and the '=' padding.\r\n    return b64String.substr(0, 22);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a string key that can be used to identify the app. */\r\nfunction getKey(appConfig) {\r\n    return `${appConfig.appName}!${appConfig.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst fidChangeCallbacks = new Map();\r\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */\r\nfunction fidChanged(appConfig, fid) {\r\n    const key = getKey(appConfig);\r\n    callFidChangeCallbacks(key, fid);\r\n    broadcastFidChange(key, fid);\r\n}\r\nfunction addCallback(appConfig, callback) {\r\n    // Open the broadcast channel if it's not already open,\r\n    // to be able to listen to change events from other tabs.\r\n    getBroadcastChannel();\r\n    const key = getKey(appConfig);\r\n    let callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        callbackSet = new Set();\r\n        fidChangeCallbacks.set(key, callbackSet);\r\n    }\r\n    callbackSet.add(callback);\r\n}\r\nfunction removeCallback(appConfig, callback) {\r\n    const key = getKey(appConfig);\r\n    const callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        return;\r\n    }\r\n    callbackSet.delete(callback);\r\n    if (callbackSet.size === 0) {\r\n        fidChangeCallbacks.delete(key);\r\n    }\r\n    // Close broadcast channel if there are no more callbacks.\r\n    closeBroadcastChannel();\r\n}\r\nfunction callFidChangeCallbacks(key, fid) {\r\n    const callbacks = fidChangeCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    for (const callback of callbacks) {\r\n        callback(fid);\r\n    }\r\n}\r\nfunction broadcastFidChange(key, fid) {\r\n    const channel = getBroadcastChannel();\r\n    if (channel) {\r\n        channel.postMessage({ key, fid });\r\n    }\r\n    closeBroadcastChannel();\r\n}\r\nlet broadcastChannel = null;\r\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\r\nfunction getBroadcastChannel() {\r\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\r\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\r\n        broadcastChannel.onmessage = e => {\r\n            callFidChangeCallbacks(e.data.key, e.data.fid);\r\n        };\r\n    }\r\n    return broadcastChannel;\r\n}\r\nfunction closeBroadcastChannel() {\r\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\r\n        broadcastChannel.close();\r\n        broadcastChannel = null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DATABASE_NAME = 'firebase-installations-database';\r\nconst DATABASE_VERSION = 1;\r\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DATABASE_NAME, DATABASE_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(OBJECT_STORE_NAME);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\n/** Assigns or overwrites the record for the given key with the given value. */\r\nasync function set(appConfig, value) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await objectStore.get(key));\r\n    await objectStore.put(value, key);\r\n    await tx.done;\r\n    if (!oldValue || oldValue.fid !== value.fid) {\r\n        fidChanged(appConfig, value.fid);\r\n    }\r\n    return value;\r\n}\r\n/** Removes record(s) from the objectStore that match the given key. */\r\nasync function remove(appConfig) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\r\n    await tx.done;\r\n}\r\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */\r\nasync function update(appConfig, updateFn) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await store.get(key));\r\n    const newValue = updateFn(oldValue);\r\n    if (newValue === undefined) {\r\n        await store.delete(key);\r\n    }\r\n    else {\r\n        await store.put(newValue, key);\r\n    }\r\n    await tx.done;\r\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\r\n        fidChanged(appConfig, newValue.fid);\r\n    }\r\n    return newValue;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */\r\nasync function getInstallationEntry(installations) {\r\n    let registrationPromise;\r\n    const installationEntry = await update(installations.appConfig, oldEntry => {\r\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\r\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\r\n        registrationPromise = entryWithPromise.registrationPromise;\r\n        return entryWithPromise.installationEntry;\r\n    });\r\n    if (installationEntry.fid === INVALID_FID) {\r\n        // FID generation failed. Waiting for the FID from the server.\r\n        return { installationEntry: await registrationPromise };\r\n    }\r\n    return {\r\n        installationEntry,\r\n        registrationPromise\r\n    };\r\n}\r\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */\r\nfunction updateOrCreateInstallationEntry(oldEntry) {\r\n    const entry = oldEntry || {\r\n        fid: generateFid(),\r\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n    };\r\n    return clearTimedOutRequest(entry);\r\n}\r\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */\r\nfunction triggerRegistrationIfNecessary(installations, installationEntry) {\r\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        if (!navigator.onLine) {\r\n            // Registration required but app is offline.\r\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */));\r\n            return {\r\n                installationEntry,\r\n                registrationPromise: registrationPromiseWithError\r\n            };\r\n        }\r\n        // Try registering. Change status to IN_PROGRESS.\r\n        const inProgressEntry = {\r\n            fid: installationEntry.fid,\r\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n            registrationTime: Date.now()\r\n        };\r\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\r\n        return { installationEntry: inProgressEntry, registrationPromise };\r\n    }\r\n    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        return {\r\n            installationEntry,\r\n            registrationPromise: waitUntilFidRegistration(installations)\r\n        };\r\n    }\r\n    else {\r\n        return { installationEntry };\r\n    }\r\n}\r\n/** This will be executed only once for each new Firebase Installation. */\r\nasync function registerInstallation(installations, installationEntry) {\r\n    try {\r\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\r\n        return set(installations.appConfig, registeredInstallationEntry);\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) && e.customData.serverCode === 409) {\r\n            // Server returned a \"FID can not be used\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            // Registration failed. Set FID as not registered.\r\n            await set(installations.appConfig, {\r\n                fid: installationEntry.fid,\r\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n            });\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n/** Call if FID registration is pending in another request. */\r\nasync function waitUntilFidRegistration(installations) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateInstallationRequest(installations.appConfig);\r\n    while (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // createInstallation request still in progress.\r\n        await sleep(100);\r\n        entry = await updateInstallationRequest(installations.appConfig);\r\n    }\r\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\r\n        if (registrationPromise) {\r\n            return registrationPromise;\r\n        }\r\n        else {\r\n            // if there is no registrationPromise, entry is registered.\r\n            return installationEntry;\r\n        }\r\n    }\r\n    return entry;\r\n}\r\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateInstallationRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!oldEntry) {\r\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */);\r\n        }\r\n        return clearTimedOutRequest(oldEntry);\r\n    });\r\n}\r\nfunction clearTimedOutRequest(entry) {\r\n    if (hasInstallationRequestTimedOut(entry)) {\r\n        return {\r\n            fid: entry.fid,\r\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n        };\r\n    }\r\n    return entry;\r\n}\r\nfunction hasInstallationRequestTimedOut(installationEntry) {\r\n    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {\r\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        installation: {\r\n            sdkVersion: PACKAGE_VERSION,\r\n            appId: appConfig.appId\r\n        }\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\r\n        return completedAuthToken;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Generate Auth Token', response);\r\n    }\r\n}\r\nfunction getGenerateAuthTokenEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */\r\nasync function refreshAuthToken(installations, forceRefresh = false) {\r\n    let tokenPromise;\r\n    const entry = await update(installations.appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\r\n            // There is a valid token in the DB.\r\n            return oldEntry;\r\n        }\r\n        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // There already is a token request in progress.\r\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\r\n            return oldEntry;\r\n        }\r\n        else {\r\n            // No token or token expired.\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\r\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\r\n            return inProgressEntry;\r\n        }\r\n    });\r\n    const authToken = tokenPromise\r\n        ? await tokenPromise\r\n        : entry.authToken;\r\n    return authToken;\r\n}\r\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */\r\nasync function waitUntilAuthTokenRequest(installations, forceRefresh) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateAuthTokenRequest(installations.appConfig);\r\n    while (entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // generateAuthToken still in progress.\r\n        await sleep(100);\r\n        entry = await updateAuthTokenRequest(installations.appConfig);\r\n    }\r\n    const authToken = entry.authToken;\r\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        return refreshAuthToken(installations, forceRefresh);\r\n    }\r\n    else {\r\n        return authToken;\r\n    }\r\n}\r\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateAuthTokenRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\r\n            return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n        }\r\n        return oldEntry;\r\n    });\r\n}\r\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\r\n    try {\r\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\r\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });\r\n        await set(installations.appConfig, updatedInstallationEntry);\r\n        return authToken;\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) &&\r\n            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\r\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n            await set(installations.appConfig, updatedInstallationEntry);\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nfunction isEntryRegistered(installationEntry) {\r\n    return (installationEntry !== undefined &&\r\n        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);\r\n}\r\nfunction isAuthTokenValid(authToken) {\r\n    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&\r\n        !isAuthTokenExpired(authToken));\r\n}\r\nfunction isAuthTokenExpired(authToken) {\r\n    const now = Date.now();\r\n    return (now < authToken.creationTime ||\r\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\r\n}\r\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\r\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\r\n    const inProgressAuthToken = {\r\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n        requestTime: Date.now()\r\n    };\r\n    return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });\r\n}\r\nfunction hasAuthTokenRequestTimedOut(authToken) {\r\n    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a Firebase Installation if there isn't one for the app and\r\n * returns the Installation ID.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function getId(installations) {\r\n    const installationsImpl = installations;\r\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\r\n    if (registrationPromise) {\r\n        registrationPromise.catch(console.error);\r\n    }\r\n    else {\r\n        // If the installation is already registered, update the authentication\r\n        // token if needed.\r\n        refreshAuthToken(installationsImpl).catch(console.error);\r\n    }\r\n    return installationEntry.fid;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a Firebase Installations auth token, identifying the current\r\n * Firebase Installation.\r\n * @param installations - The `Installations` instance.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nasync function getToken(installations, forceRefresh = false) {\r\n    const installationsImpl = installations;\r\n    await completeInstallationRegistration(installationsImpl);\r\n    // At this point we either have a Registered Installation in the DB, or we've\r\n    // already thrown an error.\r\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\r\n    return authToken.token;\r\n}\r\nasync function completeInstallationRegistration(installations) {\r\n    const { registrationPromise } = await getInstallationEntry(installations);\r\n    if (registrationPromise) {\r\n        // A createInstallation request is in progress. Wait until it finishes.\r\n        await registrationPromise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function deleteInstallationRequest(appConfig, installationEntry) {\r\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    const request = {\r\n        method: 'DELETE',\r\n        headers\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (!response.ok) {\r\n        throw await getErrorFromResponse('Delete Installation', response);\r\n    }\r\n}\r\nfunction getDeleteEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Deletes the Firebase Installation and all associated data.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function deleteInstallations(installations) {\r\n    const { appConfig } = installations;\r\n    const entry = await update(appConfig, oldEntry => {\r\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n            // Delete the unregistered entry without sending a deleteInstallation request.\r\n            return undefined;\r\n        }\r\n        return oldEntry;\r\n    });\r\n    if (entry) {\r\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // Can't delete while trying to register.\r\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */);\r\n        }\r\n        else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */) {\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            else {\r\n                await deleteInstallationRequest(appConfig, entry);\r\n                await remove(appConfig);\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n * @param installations - The `Installations` instance.\r\n * @param callback - The callback function that is invoked when FID changes.\r\n * @returns A function that can be called to unsubscribe.\r\n *\r\n * @public\r\n */\r\nfunction onIdChange(installations, callback) {\r\n    const { appConfig } = installations;\r\n    addCallback(appConfig, callback);\r\n    return () => {\r\n        removeCallback(appConfig, callback);\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an instance of {@link Installations} associated with the given\r\n * {@link @firebase/app#FirebaseApp} instance.\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * @public\r\n */\r\nfunction getInstallations(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\r\n    const installationsImpl = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'installations').getImmediate();\r\n    return installationsImpl;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction extractAppConfig(app) {\r\n    if (!app || !app.options) {\r\n        throw getMissingValueError('App Configuration');\r\n    }\r\n    if (!app.name) {\r\n        throw getMissingValueError('App Name');\r\n    }\r\n    // Required app config keys\r\n    const configKeys = [\r\n        'projectId',\r\n        'apiKey',\r\n        'appId'\r\n    ];\r\n    for (const keyName of configKeys) {\r\n        if (!app.options[keyName]) {\r\n            throw getMissingValueError(keyName);\r\n        }\r\n    }\r\n    return {\r\n        appName: app.name,\r\n        projectId: app.options.projectId,\r\n        apiKey: app.options.apiKey,\r\n        appId: app.options.appId\r\n    };\r\n}\r\nfunction getMissingValueError(valueName) {\r\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, {\r\n        valueName\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INSTALLATIONS_NAME = 'installations';\r\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\r\nconst publicFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Throws if app isn't configured properly.\r\n    const appConfig = extractAppConfig(app);\r\n    const heartbeatServiceProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'heartbeat');\r\n    const installationsImpl = {\r\n        app,\r\n        appConfig,\r\n        heartbeatServiceProvider,\r\n        _delete: () => Promise.resolve()\r\n    };\r\n    return installationsImpl;\r\n};\r\nconst internalFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Internal FIS instance relies on public FIS instance.\r\n    const installations = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, INSTALLATIONS_NAME).getImmediate();\r\n    const installationsInternal = {\r\n        getId: () => getId(installations),\r\n        getToken: (forceRefresh) => getToken(installations, forceRefresh)\r\n    };\r\n    return installationsInternal;\r\n};\r\nfunction registerInstallations() {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n}\n\n/**\r\n * The Firebase Installations Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterInstallations();\r\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\r\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2luc3RhbGxhdGlvbnMvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEY7QUFDMUM7QUFDYTtBQUNoQzs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsV0FBVztBQUM1SDtBQUNBO0FBQ0EseURBQXlELGNBQWMsNEJBQTRCLGNBQWMsY0FBYyxHQUFHLGVBQWU7QUFDako7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFZO0FBQ3RDO0FBQ0E7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DLGNBQWMsc0JBQXNCLFlBQVksVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLEVBQUUsYUFBYTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQ0FBcUMsSUFBSSxLQUFLO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQ0FBcUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RCxjQUFjLG9DQUFvQyxHQUFHLElBQUk7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZSxhQUFhLG9EQUFvRDtBQUNqSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QixXQUFXO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsd0JBQXdCLGFBQWEsb0RBQW9EO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlLGdDQUFnQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDLGNBQWMsb0NBQW9DLEdBQUcsSUFBSTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQsSUFBSSxpQ0FBaUM7QUFDckMscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQU07QUFDdEMsOEJBQThCLDJEQUFZO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBa0IsS0FBSywwREFBUztBQUNwQyxJQUFJLGlFQUFrQixLQUFLLDBEQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQWU7QUFDZjtBQUNBLDhEQUFlOztBQUUrRDtBQUM5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVudG9yeV9tYW5hZ21lbnQvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2luc3RhbGxhdGlvbnMvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz83YjRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC42LjhcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUEVORElOR19USU1FT1VUX01TID0gMTAwMDA7XHJcbmNvbnN0IFBBQ0tBR0VfVkVSU0lPTiA9IGB3OiR7dmVyc2lvbn1gO1xyXG5jb25zdCBJTlRFUk5BTF9BVVRIX1ZFUlNJT04gPSAnRklTX3YyJztcclxuY29uc3QgSU5TVEFMTEFUSU9OU19BUElfVVJMID0gJ2h0dHBzOi8vZmlyZWJhc2VpbnN0YWxsYXRpb25zLmdvb2dsZWFwaXMuY29tL3YxJztcclxuY29uc3QgVE9LRU5fRVhQSVJBVElPTl9CVUZGRVIgPSA2MCAqIDYwICogMTAwMDsgLy8gT25lIGhvdXJcclxuY29uc3QgU0VSVklDRSA9ICdpbnN0YWxsYXRpb25zJztcclxuY29uc3QgU0VSVklDRV9OQU1FID0gJ0luc3RhbGxhdGlvbnMnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBFUlJPUl9ERVNDUklQVElPTl9NQVAgPSB7XHJcbiAgICBbXCJtaXNzaW5nLWFwcC1jb25maWctdmFsdWVzXCIgLyogRXJyb3JDb2RlLk1JU1NJTkdfQVBQX0NPTkZJR19WQUxVRVMgKi9dOiAnTWlzc2luZyBBcHAgY29uZmlndXJhdGlvbiB2YWx1ZTogXCJ7JHZhbHVlTmFtZX1cIicsXHJcbiAgICBbXCJub3QtcmVnaXN0ZXJlZFwiIC8qIEVycm9yQ29kZS5OT1RfUkVHSVNURVJFRCAqL106ICdGaXJlYmFzZSBJbnN0YWxsYXRpb24gaXMgbm90IHJlZ2lzdGVyZWQuJyxcclxuICAgIFtcImluc3RhbGxhdGlvbi1ub3QtZm91bmRcIiAvKiBFcnJvckNvZGUuSU5TVEFMTEFUSU9OX05PVF9GT1VORCAqL106ICdGaXJlYmFzZSBJbnN0YWxsYXRpb24gbm90IGZvdW5kLicsXHJcbiAgICBbXCJyZXF1ZXN0LWZhaWxlZFwiIC8qIEVycm9yQ29kZS5SRVFVRVNUX0ZBSUxFRCAqL106ICd7JHJlcXVlc3ROYW1lfSByZXF1ZXN0IGZhaWxlZCB3aXRoIGVycm9yIFwieyRzZXJ2ZXJDb2RlfSB7JHNlcnZlclN0YXR1c306IHskc2VydmVyTWVzc2FnZX1cIicsXHJcbiAgICBbXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqL106ICdDb3VsZCBub3QgcHJvY2VzcyByZXF1ZXN0LiBBcHBsaWNhdGlvbiBvZmZsaW5lLicsXHJcbiAgICBbXCJkZWxldGUtcGVuZGluZy1yZWdpc3RyYXRpb25cIiAvKiBFcnJvckNvZGUuREVMRVRFX1BFTkRJTkdfUkVHSVNUUkFUSU9OICovXTogXCJDYW4ndCBkZWxldGUgaW5zdGFsbGF0aW9uIHdoaWxlIHRoZXJlIGlzIGEgcGVuZGluZyByZWdpc3RyYXRpb24gcmVxdWVzdC5cIlxyXG59O1xyXG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeShTRVJWSUNFLCBTRVJWSUNFX05BTUUsIEVSUk9SX0RFU0NSSVBUSU9OX01BUCk7XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgZXJyb3IgaXMgYSBGaXJlYmFzZUVycm9yIHRoYXQgaXMgYmFzZWQgb24gYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyLiAqL1xyXG5mdW5jdGlvbiBpc1NlcnZlckVycm9yKGVycm9yKSB7XHJcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvciAmJlxyXG4gICAgICAgIGVycm9yLmNvZGUuaW5jbHVkZXMoXCJyZXF1ZXN0LWZhaWxlZFwiIC8qIEVycm9yQ29kZS5SRVFVRVNUX0ZBSUxFRCAqLykpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldEluc3RhbGxhdGlvbnNFbmRwb2ludCh7IHByb2plY3RJZCB9KSB7XHJcbiAgICByZXR1cm4gYCR7SU5TVEFMTEFUSU9OU19BUElfVVJMfS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vaW5zdGFsbGF0aW9uc2A7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9rZW46IHJlc3BvbnNlLnRva2VuLFxyXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IDIgLyogUmVxdWVzdFN0YXR1cy5DT01QTEVURUQgKi8sXHJcbiAgICAgICAgZXhwaXJlc0luOiBnZXRFeHBpcmVzSW5Gcm9tUmVzcG9uc2VFeHBpcmVzSW4ocmVzcG9uc2UuZXhwaXJlc0luKSxcclxuICAgICAgICBjcmVhdGlvblRpbWU6IERhdGUubm93KClcclxuICAgIH07XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0RXJyb3JGcm9tUmVzcG9uc2UocmVxdWVzdE5hbWUsIHJlc3BvbnNlKSB7XHJcbiAgICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBlcnJvckRhdGEgPSByZXNwb25zZUpzb24uZXJyb3I7XHJcbiAgICByZXR1cm4gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJyZXF1ZXN0LWZhaWxlZFwiIC8qIEVycm9yQ29kZS5SRVFVRVNUX0ZBSUxFRCAqLywge1xyXG4gICAgICAgIHJlcXVlc3ROYW1lLFxyXG4gICAgICAgIHNlcnZlckNvZGU6IGVycm9yRGF0YS5jb2RlLFxyXG4gICAgICAgIHNlcnZlck1lc3NhZ2U6IGVycm9yRGF0YS5tZXNzYWdlLFxyXG4gICAgICAgIHNlcnZlclN0YXR1czogZXJyb3JEYXRhLnN0YXR1c1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SGVhZGVycyh7IGFwaUtleSB9KSB7XHJcbiAgICByZXR1cm4gbmV3IEhlYWRlcnMoe1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgJ3gtZ29vZy1hcGkta2V5JzogYXBpS2V5XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRIZWFkZXJzV2l0aEF1dGgoYXBwQ29uZmlnLCB7IHJlZnJlc2hUb2tlbiB9KSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVycyhhcHBDb25maWcpO1xyXG4gICAgaGVhZGVycy5hcHBlbmQoJ0F1dGhvcml6YXRpb24nLCBnZXRBdXRob3JpemF0aW9uSGVhZGVyKHJlZnJlc2hUb2tlbikpO1xyXG4gICAgcmV0dXJuIGhlYWRlcnM7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIHRoZSBwYXNzZWQgaW4gZmV0Y2ggd3JhcHBlciBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXHJcbiAqIElmIHRoZSByZXR1cm5lZCByZXNwb25zZSBoYXMgYSBzdGF0dXMgb2YgNXh4LCByZS1ydW5zIHRoZSBmdW5jdGlvbiBvbmNlIGFuZFxyXG4gKiByZXR1cm5zIHRoZSByZXNwb25zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJldHJ5SWZTZXJ2ZXJFcnJvcihmbikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oKTtcclxuICAgIGlmIChyZXN1bHQuc3RhdHVzID49IDUwMCAmJiByZXN1bHQuc3RhdHVzIDwgNjAwKSB7XHJcbiAgICAgICAgLy8gSW50ZXJuYWwgU2VydmVyIEVycm9yLiBSZXRyeSByZXF1ZXN0LlxyXG4gICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRFeHBpcmVzSW5Gcm9tUmVzcG9uc2VFeHBpcmVzSW4ocmVzcG9uc2VFeHBpcmVzSW4pIHtcclxuICAgIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgc2VydmVyIHdpbGwgbmV2ZXIgcmVzcG9uZCB3aXRoIGZyYWN0aW9ucyBvZiBhIHNlY29uZC5cclxuICAgIHJldHVybiBOdW1iZXIocmVzcG9uc2VFeHBpcmVzSW4ucmVwbGFjZSgncycsICcwMDAnKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QXV0aG9yaXphdGlvbkhlYWRlcihyZWZyZXNoVG9rZW4pIHtcclxuICAgIHJldHVybiBgJHtJTlRFUk5BTF9BVVRIX1ZFUlNJT059ICR7cmVmcmVzaFRva2VufWA7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW5zdGFsbGF0aW9uUmVxdWVzdCh7IGFwcENvbmZpZywgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyIH0sIHsgZmlkIH0pIHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50KGFwcENvbmZpZyk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVycyhhcHBDb25maWcpO1xyXG4gICAgLy8gSWYgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgIGNvbnN0IGhlYXJ0YmVhdFNlcnZpY2UgPSBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcclxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0U2VydmljZSkge1xyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdHNIZWFkZXIgPSBhd2FpdCBoZWFydGJlYXRTZXJ2aWNlLmdldEhlYXJ0YmVhdHNIZWFkZXIoKTtcclxuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xyXG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZCgneC1maXJlYmFzZS1jbGllbnQnLCBoZWFydGJlYXRzSGVhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBib2R5ID0ge1xyXG4gICAgICAgIGZpZCxcclxuICAgICAgICBhdXRoVmVyc2lvbjogSU5URVJOQUxfQVVUSF9WRVJTSU9OLFxyXG4gICAgICAgIGFwcElkOiBhcHBDb25maWcuYXBwSWQsXHJcbiAgICAgICAgc2RrVmVyc2lvbjogUEFDS0FHRV9WRVJTSU9OXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXRyeUlmU2VydmVyRXJyb3IoKCkgPT4gZmV0Y2goZW5kcG9pbnQsIHJlcXVlc3QpKTtcclxuICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsdWUgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZEluc3RhbGxhdGlvbkVudHJ5ID0ge1xyXG4gICAgICAgICAgICBmaWQ6IHJlc3BvbnNlVmFsdWUuZmlkIHx8IGZpZCxcclxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uU3RhdHVzOiAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovLFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IHJlc3BvbnNlVmFsdWUucmVmcmVzaFRva2VuLFxyXG4gICAgICAgICAgICBhdXRoVG9rZW46IGV4dHJhY3RBdXRoVG9rZW5JbmZvRnJvbVJlc3BvbnNlKHJlc3BvbnNlVmFsdWUuYXV0aFRva2VuKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGF3YWl0IGdldEVycm9yRnJvbVJlc3BvbnNlKCdDcmVhdGUgSW5zdGFsbGF0aW9uJywgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIGdpdmVuIHRpbWUgcGFzc2VzLiAqL1xyXG5mdW5jdGlvbiBzbGVlcChtcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjRVcmxTYWZlKGFycmF5KSB7XHJcbiAgICBjb25zdCBiNjQgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYXJyYXkpKTtcclxuICAgIHJldHVybiBiNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgVkFMSURfRklEX1BBVFRFUk4gPSAvXltjZGVmXVtcXHctXXsyMX0kLztcclxuY29uc3QgSU5WQUxJRF9GSUQgPSAnJztcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG5ldyBGSUQgdXNpbmcgcmFuZG9tIHZhbHVlcyBmcm9tIFdlYiBDcnlwdG8gQVBJLlxyXG4gKiBSZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiBGSUQgZ2VuZXJhdGlvbiBmYWlscyBmb3IgYW55IHJlYXNvbi5cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlRmlkKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBBIHZhbGlkIEZJRCBoYXMgZXhhY3RseSAyMiBiYXNlNjQgY2hhcmFjdGVycywgd2hpY2ggaXMgMTMyIGJpdHMsIG9yIDE2LjVcclxuICAgICAgICAvLyBieXRlcy4gb3VyIGltcGxlbWVudGF0aW9uIGdlbmVyYXRlcyBhIDE3IGJ5dGUgYXJyYXkgaW5zdGVhZC5cclxuICAgICAgICBjb25zdCBmaWRCeXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgxNyk7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvID0gc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0bztcclxuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGZpZEJ5dGVBcnJheSk7XHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZmlyc3QgNCByYW5kb20gYml0cyB3aXRoIHRoZSBjb25zdGFudCBGSUQgaGVhZGVyIG9mIDBiMDExMS5cclxuICAgICAgICBmaWRCeXRlQXJyYXlbMF0gPSAwYjAxMTEwMDAwICsgKGZpZEJ5dGVBcnJheVswXSAlIDBiMDAwMTAwMDApO1xyXG4gICAgICAgIGNvbnN0IGZpZCA9IGVuY29kZShmaWRCeXRlQXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBWQUxJRF9GSURfUEFUVEVSTi50ZXN0KGZpZCkgPyBmaWQgOiBJTlZBTElEX0ZJRDtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIC8vIEZJRCBnZW5lcmF0aW9uIGVycm9yZWRcclxuICAgICAgICByZXR1cm4gSU5WQUxJRF9GSUQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIENvbnZlcnRzIGEgRklEIFVpbnQ4QXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xyXG5mdW5jdGlvbiBlbmNvZGUoZmlkQnl0ZUFycmF5KSB7XHJcbiAgICBjb25zdCBiNjRTdHJpbmcgPSBidWZmZXJUb0Jhc2U2NFVybFNhZmUoZmlkQnl0ZUFycmF5KTtcclxuICAgIC8vIFJlbW92ZSB0aGUgMjNyZCBjaGFyYWN0ZXIgdGhhdCB3YXMgYWRkZWQgYmVjYXVzZSBvZiB0aGUgZXh0cmEgNCBiaXRzIGF0IHRoZVxyXG4gICAgLy8gZW5kIG9mIG91ciAxNyBieXRlIGFycmF5LCBhbmQgdGhlICc9JyBwYWRkaW5nLlxyXG4gICAgcmV0dXJuIGI2NFN0cmluZy5zdWJzdHIoMCwgMjIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBSZXR1cm5zIGEgc3RyaW5nIGtleSB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBhcHAuICovXHJcbmZ1bmN0aW9uIGdldEtleShhcHBDb25maWcpIHtcclxuICAgIHJldHVybiBgJHthcHBDb25maWcuYXBwTmFtZX0hJHthcHBDb25maWcuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBmaWRDaGFuZ2VDYWxsYmFja3MgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBDYWxscyB0aGUgb25JZENoYW5nZSBjYWxsYmFja3Mgd2l0aCB0aGUgbmV3IEZJRCB2YWx1ZSwgYW5kIGJyb2FkY2FzdHMgdGhlXHJcbiAqIGNoYW5nZSB0byBvdGhlciB0YWJzLlxyXG4gKi9cclxuZnVuY3Rpb24gZmlkQ2hhbmdlZChhcHBDb25maWcsIGZpZCkge1xyXG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFwcENvbmZpZyk7XHJcbiAgICBjYWxsRmlkQ2hhbmdlQ2FsbGJhY2tzKGtleSwgZmlkKTtcclxuICAgIGJyb2FkY2FzdEZpZENoYW5nZShrZXksIGZpZCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjaykge1xyXG4gICAgLy8gT3BlbiB0aGUgYnJvYWRjYXN0IGNoYW5uZWwgaWYgaXQncyBub3QgYWxyZWFkeSBvcGVuLFxyXG4gICAgLy8gdG8gYmUgYWJsZSB0byBsaXN0ZW4gdG8gY2hhbmdlIGV2ZW50cyBmcm9tIG90aGVyIHRhYnMuXHJcbiAgICBnZXRCcm9hZGNhc3RDaGFubmVsKCk7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcclxuICAgIGxldCBjYWxsYmFja1NldCA9IGZpZENoYW5nZUNhbGxiYWNrcy5nZXQoa2V5KTtcclxuICAgIGlmICghY2FsbGJhY2tTZXQpIHtcclxuICAgICAgICBjYWxsYmFja1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICBmaWRDaGFuZ2VDYWxsYmFja3Muc2V0KGtleSwgY2FsbGJhY2tTZXQpO1xyXG4gICAgfVxyXG4gICAgY2FsbGJhY2tTZXQuYWRkKGNhbGxiYWNrKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVDYWxsYmFjayhhcHBDb25maWcsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcclxuICAgIGNvbnN0IGNhbGxiYWNrU2V0ID0gZmlkQ2hhbmdlQ2FsbGJhY2tzLmdldChrZXkpO1xyXG4gICAgaWYgKCFjYWxsYmFja1NldCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrU2V0LmRlbGV0ZShjYWxsYmFjayk7XHJcbiAgICBpZiAoY2FsbGJhY2tTZXQuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIGZpZENoYW5nZUNhbGxiYWNrcy5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuICAgIC8vIENsb3NlIGJyb2FkY2FzdCBjaGFubmVsIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNhbGxiYWNrcy5cclxuICAgIGNsb3NlQnJvYWRjYXN0Q2hhbm5lbCgpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxGaWRDaGFuZ2VDYWxsYmFja3Moa2V5LCBmaWQpIHtcclxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGZpZENoYW5nZUNhbGxiYWNrcy5nZXQoa2V5KTtcclxuICAgIGlmICghY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcclxuICAgICAgICBjYWxsYmFjayhmaWQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJyb2FkY2FzdEZpZENoYW5nZShrZXksIGZpZCkge1xyXG4gICAgY29uc3QgY2hhbm5lbCA9IGdldEJyb2FkY2FzdENoYW5uZWwoKTtcclxuICAgIGlmIChjaGFubmVsKSB7XHJcbiAgICAgICAgY2hhbm5lbC5wb3N0TWVzc2FnZSh7IGtleSwgZmlkIH0pO1xyXG4gICAgfVxyXG4gICAgY2xvc2VCcm9hZGNhc3RDaGFubmVsKCk7XHJcbn1cclxubGV0IGJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xyXG4vKiogT3BlbnMgYW5kIHJldHVybnMgYSBCcm9hZGNhc3RDaGFubmVsIGlmIGl0IGlzIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gKi9cclxuZnVuY3Rpb24gZ2V0QnJvYWRjYXN0Q2hhbm5lbCgpIHtcclxuICAgIGlmICghYnJvYWRjYXN0Q2hhbm5lbCAmJiAnQnJvYWRjYXN0Q2hhbm5lbCcgaW4gc2VsZikge1xyXG4gICAgICAgIGJyb2FkY2FzdENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCgnW0ZpcmViYXNlXSBGSUQgQ2hhbmdlJyk7XHJcbiAgICAgICAgYnJvYWRjYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSBlID0+IHtcclxuICAgICAgICAgICAgY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhlLmRhdGEua2V5LCBlLmRhdGEuZmlkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWw7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCcm9hZGNhc3RDaGFubmVsKCkge1xyXG4gICAgaWYgKGZpZENoYW5nZUNhbGxiYWNrcy5zaXplID09PSAwICYmIGJyb2FkY2FzdENoYW5uZWwpIHtcclxuICAgICAgICBicm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XHJcbiAgICAgICAgYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREFUQUJBU0VfTkFNRSA9ICdmaXJlYmFzZS1pbnN0YWxsYXRpb25zLWRhdGFiYXNlJztcclxuY29uc3QgREFUQUJBU0VfVkVSU0lPTiA9IDE7XHJcbmNvbnN0IE9CSkVDVF9TVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWluc3RhbGxhdGlvbnMtc3RvcmUnO1xyXG5sZXQgZGJQcm9taXNlID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xyXG4gICAgaWYgKCFkYlByb21pc2UpIHtcclxuICAgICAgICBkYlByb21pc2UgPSBvcGVuREIoREFUQUJBU0VfTkFNRSwgREFUQUJBU0VfVkVSU0lPTiwge1xyXG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiUHJvbWlzZTtcclxufVxyXG4vKiogQXNzaWducyBvciBvdmVyd3JpdGVzIHRoZSByZWNvcmQgZm9yIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNldChhcHBDb25maWcsIHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcclxuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gKGF3YWl0IG9iamVjdFN0b3JlLmdldChrZXkpKTtcclxuICAgIGF3YWl0IG9iamVjdFN0b3JlLnB1dCh2YWx1ZSwga2V5KTtcclxuICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICBpZiAoIW9sZFZhbHVlIHx8IG9sZFZhbHVlLmZpZCAhPT0gdmFsdWUuZmlkKSB7XHJcbiAgICAgICAgZmlkQ2hhbmdlZChhcHBDb25maWcsIHZhbHVlLmZpZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLyoqIFJlbW92ZXMgcmVjb3JkKHMpIGZyb20gdGhlIG9iamVjdFN0b3JlIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGtleS4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlKGFwcENvbmZpZykge1xyXG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFwcENvbmZpZyk7XHJcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgYXdhaXQgdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpLmRlbGV0ZShrZXkpO1xyXG4gICAgYXdhaXQgdHguZG9uZTtcclxufVxyXG4vKipcclxuICogQXRvbWljYWxseSB1cGRhdGVzIGEgcmVjb3JkIHdpdGggdGhlIHJlc3VsdCBvZiB1cGRhdGVGbiwgd2hpY2ggZ2V0c1xyXG4gKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZS4gSWYgbmV3VmFsdWUgaXMgdW5kZWZpbmVkLCB0aGUgcmVjb3JkIGlzXHJcbiAqIGRlbGV0ZWQgaW5zdGVhZC5cclxuICogQHJldHVybiBVcGRhdGVkIHZhbHVlXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB1cGRhdGUoYXBwQ29uZmlnLCB1cGRhdGVGbikge1xyXG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFwcENvbmZpZyk7XHJcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfTkFNRSk7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IChhd2FpdCBzdG9yZS5nZXQoa2V5KSk7XHJcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHVwZGF0ZUZuKG9sZFZhbHVlKTtcclxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYXdhaXQgc3RvcmUuZGVsZXRlKGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhd2FpdCBzdG9yZS5wdXQobmV3VmFsdWUsIGtleSk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgaWYgKG5ld1ZhbHVlICYmICghb2xkVmFsdWUgfHwgb2xkVmFsdWUuZmlkICE9PSBuZXdWYWx1ZS5maWQpKSB7XHJcbiAgICAgICAgZmlkQ2hhbmdlZChhcHBDb25maWcsIG5ld1ZhbHVlLmZpZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3VmFsdWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYW5kIHJldHVybnMgdGhlIEluc3RhbGxhdGlvbkVudHJ5IGZyb20gdGhlIGRhdGFiYXNlLlxyXG4gKiBBbHNvIHRyaWdnZXJzIGEgcmVnaXN0cmF0aW9uIHJlcXVlc3QgaWYgaXQgaXMgbmVjZXNzYXJ5IGFuZCBwb3NzaWJsZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEluc3RhbGxhdGlvbkVudHJ5KGluc3RhbGxhdGlvbnMpIHtcclxuICAgIGxldCByZWdpc3RyYXRpb25Qcm9taXNlO1xyXG4gICAgY29uc3QgaW5zdGFsbGF0aW9uRW50cnkgPSBhd2FpdCB1cGRhdGUoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIG9sZEVudHJ5ID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YWxsYXRpb25FbnRyeSA9IHVwZGF0ZU9yQ3JlYXRlSW5zdGFsbGF0aW9uRW50cnkob2xkRW50cnkpO1xyXG4gICAgICAgIGNvbnN0IGVudHJ5V2l0aFByb21pc2UgPSB0cmlnZ2VyUmVnaXN0cmF0aW9uSWZOZWNlc3NhcnkoaW5zdGFsbGF0aW9ucywgaW5zdGFsbGF0aW9uRW50cnkpO1xyXG4gICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2UgPSBlbnRyeVdpdGhQcm9taXNlLnJlZ2lzdHJhdGlvblByb21pc2U7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5V2l0aFByb21pc2UuaW5zdGFsbGF0aW9uRW50cnk7XHJcbiAgICB9KTtcclxuICAgIGlmIChpbnN0YWxsYXRpb25FbnRyeS5maWQgPT09IElOVkFMSURfRklEKSB7XHJcbiAgICAgICAgLy8gRklEIGdlbmVyYXRpb24gZmFpbGVkLiBXYWl0aW5nIGZvciB0aGUgRklEIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAgICByZXR1cm4geyBpbnN0YWxsYXRpb25FbnRyeTogYXdhaXQgcmVnaXN0cmF0aW9uUHJvbWlzZSB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnN0YWxsYXRpb25FbnRyeSxcclxuICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IEluc3RhbGxhdGlvbiBFbnRyeSBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXHJcbiAqIEFsc28gY2xlYXJzIHRpbWVkIG91dCBwZW5kaW5nIHJlcXVlc3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlT3JDcmVhdGVJbnN0YWxsYXRpb25FbnRyeShvbGRFbnRyeSkge1xyXG4gICAgY29uc3QgZW50cnkgPSBvbGRFbnRyeSB8fCB7XHJcbiAgICAgICAgZmlkOiBnZW5lcmF0ZUZpZCgpLFxyXG4gICAgICAgIHJlZ2lzdHJhdGlvblN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNsZWFyVGltZWRPdXRSZXF1ZXN0KGVudHJ5KTtcclxufVxyXG4vKipcclxuICogSWYgdGhlIEZpcmViYXNlIEluc3RhbGxhdGlvbiBpcyBub3QgcmVnaXN0ZXJlZCB5ZXQsIHRoaXMgd2lsbCB0cmlnZ2VyIHRoZVxyXG4gKiByZWdpc3RyYXRpb24gYW5kIHJldHVybiBhbiBJblByb2dyZXNzSW5zdGFsbGF0aW9uRW50cnkuXHJcbiAqXHJcbiAqIElmIHJlZ2lzdHJhdGlvblByb21pc2UgZG9lcyBub3QgZXhpc3QsIHRoZSBpbnN0YWxsYXRpb25FbnRyeSBpcyBndWFyYW50ZWVkXHJcbiAqIHRvIGJlIHJlZ2lzdGVyZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmlnZ2VyUmVnaXN0cmF0aW9uSWZOZWNlc3NhcnkoaW5zdGFsbGF0aW9ucywgaW5zdGFsbGF0aW9uRW50cnkpIHtcclxuICAgIGlmIChpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqLykge1xyXG4gICAgICAgIGlmICghbmF2aWdhdG9yLm9uTGluZSkge1xyXG4gICAgICAgICAgICAvLyBSZWdpc3RyYXRpb24gcmVxdWlyZWQgYnV0IGFwcCBpcyBvZmZsaW5lLlxyXG4gICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb25Qcm9taXNlV2l0aEVycm9yID0gUHJvbWlzZS5yZWplY3QoRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLykpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFsbGF0aW9uRW50cnksXHJcbiAgICAgICAgICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlOiByZWdpc3RyYXRpb25Qcm9taXNlV2l0aEVycm9yXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSByZWdpc3RlcmluZy4gQ2hhbmdlIHN0YXR1cyB0byBJTl9QUk9HUkVTUy5cclxuICAgICAgICBjb25zdCBpblByb2dyZXNzRW50cnkgPSB7XHJcbiAgICAgICAgICAgIGZpZDogaW5zdGFsbGF0aW9uRW50cnkuZmlkLFxyXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLyxcclxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uVGltZTogRGF0ZS5ub3coKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IHJlZ2lzdGVySW5zdGFsbGF0aW9uKGluc3RhbGxhdGlvbnMsIGluUHJvZ3Jlc3NFbnRyeSk7XHJcbiAgICAgICAgcmV0dXJuIHsgaW5zdGFsbGF0aW9uRW50cnk6IGluUHJvZ3Jlc3NFbnRyeSwgcmVnaXN0cmF0aW9uUHJvbWlzZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5zdGFsbGF0aW9uRW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnN0YWxsYXRpb25FbnRyeSxcclxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZTogd2FpdFVudGlsRmlkUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IGluc3RhbGxhdGlvbkVudHJ5IH07XHJcbiAgICB9XHJcbn1cclxuLyoqIFRoaXMgd2lsbCBiZSBleGVjdXRlZCBvbmx5IG9uY2UgZm9yIGVhY2ggbmV3IEZpcmViYXNlIEluc3RhbGxhdGlvbi4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJJbnN0YWxsYXRpb24oaW5zdGFsbGF0aW9ucywgaW5zdGFsbGF0aW9uRW50cnkpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZEluc3RhbGxhdGlvbkVudHJ5ID0gYXdhaXQgY3JlYXRlSW5zdGFsbGF0aW9uUmVxdWVzdChpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICAgICAgcmV0dXJuIHNldChpbnN0YWxsYXRpb25zLmFwcENvbmZpZywgcmVnaXN0ZXJlZEluc3RhbGxhdGlvbkVudHJ5KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGlzU2VydmVyRXJyb3IoZSkgJiYgZS5jdXN0b21EYXRhLnNlcnZlckNvZGUgPT09IDQwOSkge1xyXG4gICAgICAgICAgICAvLyBTZXJ2ZXIgcmV0dXJuZWQgYSBcIkZJRCBjYW4gbm90IGJlIHVzZWRcIiBlcnJvci5cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgSUQgbmV4dCB0aW1lLlxyXG4gICAgICAgICAgICBhd2FpdCByZW1vdmUoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVnaXN0cmF0aW9uIGZhaWxlZC4gU2V0IEZJRCBhcyBub3QgcmVnaXN0ZXJlZC5cclxuICAgICAgICAgICAgYXdhaXQgc2V0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCB7XHJcbiAgICAgICAgICAgICAgICBmaWQ6IGluc3RhbGxhdGlvbkVudHJ5LmZpZCxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvblN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDYWxsIGlmIEZJRCByZWdpc3RyYXRpb24gaXMgcGVuZGluZyBpbiBhbm90aGVyIHJlcXVlc3QuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbEZpZFJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zKSB7XHJcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSBpcyBubyB3YXkgb2YgcmVsaWFibHkgb2JzZXJ2aW5nIHdoZW4gYSB2YWx1ZSBpblxyXG4gICAgLy8gSW5kZXhlZERCIGNoYW5nZXMgKHlldCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2luZGV4ZWQtZGItb2JzZXJ2ZXJzKSxcclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9sbC5cclxuICAgIGxldCBlbnRyeSA9IGF3YWl0IHVwZGF0ZUluc3RhbGxhdGlvblJlcXVlc3QoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xyXG4gICAgd2hpbGUgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlSW5zdGFsbGF0aW9uIHJlcXVlc3Qgc3RpbGwgaW4gcHJvZ3Jlc3MuXHJcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcclxuICAgICAgICBlbnRyeSA9IGF3YWl0IHVwZGF0ZUluc3RhbGxhdGlvblJlcXVlc3QoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XHJcbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgdGltZWQgb3V0IG9yIGZhaWxlZCBpbiBhIGRpZmZlcmVudCBjYWxsLiBUcnkgYWdhaW4uXHJcbiAgICAgICAgY29uc3QgeyBpbnN0YWxsYXRpb25FbnRyeSwgcmVnaXN0cmF0aW9uUHJvbWlzZSB9ID0gYXdhaXQgZ2V0SW5zdGFsbGF0aW9uRW50cnkoaW5zdGFsbGF0aW9ucyk7XHJcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvblByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvblByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyByZWdpc3RyYXRpb25Qcm9taXNlLCBlbnRyeSBpcyByZWdpc3RlcmVkLlxyXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFsbGF0aW9uRW50cnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgb25seSBpZiB0aGVyZSBpcyBhIENyZWF0ZUluc3RhbGxhdGlvbiByZXF1ZXN0IGluIHByb2dyZXNzLlxyXG4gKlxyXG4gKiBVcGRhdGVzIHRoZSBJbnN0YWxsYXRpb25FbnRyeSBpbiB0aGUgREIgYmFzZWQgb24gdGhlIHN0YXR1cyBvZiB0aGVcclxuICogQ3JlYXRlSW5zdGFsbGF0aW9uIHJlcXVlc3QuXHJcbiAqXHJcbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgSW5zdGFsbGF0aW9uRW50cnkuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZykge1xyXG4gICAgcmV0dXJuIHVwZGF0ZShhcHBDb25maWcsIG9sZEVudHJ5ID0+IHtcclxuICAgICAgICBpZiAoIW9sZEVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5zdGFsbGF0aW9uLW5vdC1mb3VuZFwiIC8qIEVycm9yQ29kZS5JTlNUQUxMQVRJT05fTk9UX0ZPVU5EICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZWRPdXRSZXF1ZXN0KG9sZEVudHJ5KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyVGltZWRPdXRSZXF1ZXN0KGVudHJ5KSB7XHJcbiAgICBpZiAoaGFzSW5zdGFsbGF0aW9uUmVxdWVzdFRpbWVkT3V0KGVudHJ5KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpZDogZW50cnkuZmlkLFxyXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqL1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50cnk7XHJcbn1cclxuZnVuY3Rpb24gaGFzSW5zdGFsbGF0aW9uUmVxdWVzdFRpbWVkT3V0KGluc3RhbGxhdGlvbkVudHJ5KSB7XHJcbiAgICByZXR1cm4gKGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovICYmXHJcbiAgICAgICAgaW5zdGFsbGF0aW9uRW50cnkucmVnaXN0cmF0aW9uVGltZSArIFBFTkRJTkdfVElNRU9VVF9NUyA8IERhdGUubm93KCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQXV0aFRva2VuUmVxdWVzdCh7IGFwcENvbmZpZywgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyIH0sIGluc3RhbGxhdGlvbkVudHJ5KSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGdldEdlbmVyYXRlQXV0aFRva2VuRW5kcG9pbnQoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVyc1dpdGhBdXRoKGFwcENvbmZpZywgaW5zdGFsbGF0aW9uRW50cnkpO1xyXG4gICAgLy8gSWYgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgIGNvbnN0IGhlYXJ0YmVhdFNlcnZpY2UgPSBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcclxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0U2VydmljZSkge1xyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdHNIZWFkZXIgPSBhd2FpdCBoZWFydGJlYXRTZXJ2aWNlLmdldEhlYXJ0YmVhdHNIZWFkZXIoKTtcclxuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xyXG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZCgneC1maXJlYmFzZS1jbGllbnQnLCBoZWFydGJlYXRzSGVhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBib2R5ID0ge1xyXG4gICAgICAgIGluc3RhbGxhdGlvbjoge1xyXG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBQQUNLQUdFX1ZFUlNJT04sXHJcbiAgICAgICAgICAgIGFwcElkOiBhcHBDb25maWcuYXBwSWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXRyeUlmU2VydmVyRXJyb3IoKCkgPT4gZmV0Y2goZW5kcG9pbnQsIHJlcXVlc3QpKTtcclxuICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsdWUgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc3QgY29tcGxldGVkQXV0aFRva2VuID0gZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2VWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZEF1dGhUb2tlbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGF3YWl0IGdldEVycm9yRnJvbVJlc3BvbnNlKCdHZW5lcmF0ZSBBdXRoIFRva2VuJywgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEdlbmVyYXRlQXV0aFRva2VuRW5kcG9pbnQoYXBwQ29uZmlnLCB7IGZpZCB9KSB7XHJcbiAgICByZXR1cm4gYCR7Z2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50KGFwcENvbmZpZyl9LyR7ZmlkfS9hdXRoVG9rZW5zOmdlbmVyYXRlYDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHRva2VuIGZvciB0aGUgaW5zdGFsbGF0aW9uLiBHZW5lcmF0ZXMgYSBuZXdcclxuICogdG9rZW4gaWYgb25lIGRvZXNuJ3QgZXhpc3QsIGlzIGV4cGlyZWQgb3IgYWJvdXQgdG8gZXhwaXJlLlxyXG4gKlxyXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIEZpcmViYXNlIEluc3RhbGxhdGlvbiBpcyByZWdpc3RlcmVkLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEF1dGhUb2tlbihpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgbGV0IHRva2VuUHJvbWlzZTtcclxuICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdXBkYXRlKGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCBvbGRFbnRyeSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc0VudHJ5UmVnaXN0ZXJlZChvbGRFbnRyeSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJub3QtcmVnaXN0ZXJlZFwiIC8qIEVycm9yQ29kZS5OT1RfUkVHSVNURVJFRCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEF1dGhUb2tlbiA9IG9sZEVudHJ5LmF1dGhUb2tlbjtcclxuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0F1dGhUb2tlblZhbGlkKG9sZEF1dGhUb2tlbikpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB2YWxpZCB0b2tlbiBpbiB0aGUgREIuXHJcbiAgICAgICAgICAgIHJldHVybiBvbGRFbnRyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2xkQXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhbHJlYWR5IGlzIGEgdG9rZW4gcmVxdWVzdCBpbiBwcm9ncmVzcy5cclxuICAgICAgICAgICAgdG9rZW5Qcm9taXNlID0gd2FpdFVudGlsQXV0aFRva2VuUmVxdWVzdChpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2gpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2xkRW50cnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyB0b2tlbiBvciB0b2tlbiBleHBpcmVkLlxyXG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5vbkxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLW9mZmxpbmVcIiAvKiBFcnJvckNvZGUuQVBQX09GRkxJTkUgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGluUHJvZ3Jlc3NFbnRyeSA9IG1ha2VBdXRoVG9rZW5SZXF1ZXN0SW5Qcm9ncmVzc0VudHJ5KG9sZEVudHJ5KTtcclxuICAgICAgICAgICAgdG9rZW5Qcm9taXNlID0gZmV0Y2hBdXRoVG9rZW5Gcm9tU2VydmVyKGluc3RhbGxhdGlvbnMsIGluUHJvZ3Jlc3NFbnRyeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpblByb2dyZXNzRW50cnk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhdXRoVG9rZW4gPSB0b2tlblByb21pc2VcclxuICAgICAgICA/IGF3YWl0IHRva2VuUHJvbWlzZVxyXG4gICAgICAgIDogZW50cnkuYXV0aFRva2VuO1xyXG4gICAgcmV0dXJuIGF1dGhUb2tlbjtcclxufVxyXG4vKipcclxuICogQ2FsbCBvbmx5IGlmIEZJRCBpcyByZWdpc3RlcmVkIGFuZCBBdXRoIFRva2VuIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MuXHJcbiAqXHJcbiAqIFdhaXRzIHVudGlsIHRoZSBjdXJyZW50IHBlbmRpbmcgcmVxdWVzdCBmaW5pc2hlcy4gSWYgdGhlIHJlcXVlc3QgdGltZXMgb3V0LFxyXG4gKiB0cmllcyBvbmNlIGluIHRoaXMgdGhyZWFkIGFzIHdlbGwuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB3YWl0VW50aWxBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCkge1xyXG4gICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUgaXMgbm8gd2F5IG9mIHJlbGlhYmx5IG9ic2VydmluZyB3aGVuIGEgdmFsdWUgaW5cclxuICAgIC8vIEluZGV4ZWREQiBjaGFuZ2VzICh5ZXQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9pbmRleGVkLWRiLW9ic2VydmVycyksXHJcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHBvbGwuXHJcbiAgICBsZXQgZW50cnkgPSBhd2FpdCB1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcclxuICAgIHdoaWxlIChlbnRyeS5hdXRoVG9rZW4ucmVxdWVzdFN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovKSB7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGVBdXRoVG9rZW4gc3RpbGwgaW4gcHJvZ3Jlc3MuXHJcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcclxuICAgICAgICBlbnRyeSA9IGF3YWl0IHVwZGF0ZUF1dGhUb2tlblJlcXVlc3QoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aFRva2VuID0gZW50cnkuYXV0aFRva2VuO1xyXG4gICAgaWYgKGF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAwIC8qIFJlcXVlc3RTdGF0dXMuTk9UX1NUQVJURUQgKi8pIHtcclxuICAgICAgICAvLyBUaGUgcmVxdWVzdCB0aW1lZCBvdXQgb3IgZmFpbGVkIGluIGEgZGlmZmVyZW50IGNhbGwuIFRyeSBhZ2Fpbi5cclxuICAgICAgICByZXR1cm4gcmVmcmVzaEF1dGhUb2tlbihpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGF1dGhUb2tlbjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsbGVkIG9ubHkgaWYgdGhlcmUgaXMgYSBHZW5lcmF0ZUF1dGhUb2tlbiByZXF1ZXN0IGluIHByb2dyZXNzLlxyXG4gKlxyXG4gKiBVcGRhdGVzIHRoZSBJbnN0YWxsYXRpb25FbnRyeSBpbiB0aGUgREIgYmFzZWQgb24gdGhlIHN0YXR1cyBvZiB0aGVcclxuICogR2VuZXJhdGVBdXRoVG9rZW4gcmVxdWVzdC5cclxuICpcclxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBJbnN0YWxsYXRpb25FbnRyeS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZUF1dGhUb2tlblJlcXVlc3QoYXBwQ29uZmlnKSB7XHJcbiAgICByZXR1cm4gdXBkYXRlKGFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xyXG4gICAgICAgIGlmICghaXNFbnRyeVJlZ2lzdGVyZWQob2xkRW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm90LXJlZ2lzdGVyZWRcIiAvKiBFcnJvckNvZGUuTk9UX1JFR0lTVEVSRUQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRBdXRoVG9rZW4gPSBvbGRFbnRyeS5hdXRoVG9rZW47XHJcbiAgICAgICAgaWYgKGhhc0F1dGhUb2tlblJlcXVlc3RUaW1lZE91dChvbGRBdXRoVG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZEVudHJ5KSwgeyBhdXRoVG9rZW46IHsgcmVxdWVzdFN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovIH0gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvbGRFbnRyeTtcclxuICAgIH0pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aFRva2VuRnJvbVNlcnZlcihpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBhdXRoVG9rZW4gPSBhd2FpdCBnZW5lcmF0ZUF1dGhUb2tlblJlcXVlc3QoaW5zdGFsbGF0aW9ucywgaW5zdGFsbGF0aW9uRW50cnkpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFsbGF0aW9uRW50cnkpLCB7IGF1dGhUb2tlbiB9KTtcclxuICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICAgICAgcmV0dXJuIGF1dGhUb2tlbjtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGlzU2VydmVyRXJyb3IoZSkgJiZcclxuICAgICAgICAgICAgKGUuY3VzdG9tRGF0YS5zZXJ2ZXJDb2RlID09PSA0MDEgfHwgZS5jdXN0b21EYXRhLnNlcnZlckNvZGUgPT09IDQwNCkpIHtcclxuICAgICAgICAgICAgLy8gU2VydmVyIHJldHVybmVkIGEgXCJGSUQgbm90IGZvdW5kXCIgb3IgYSBcIkludmFsaWQgYXV0aGVudGljYXRpb25cIiBlcnJvci5cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgSUQgbmV4dCB0aW1lLlxyXG4gICAgICAgICAgICBhd2FpdCByZW1vdmUoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YWxsYXRpb25FbnRyeSksIHsgYXV0aFRva2VuOiB7IHJlcXVlc3RTdGF0dXM6IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqLyB9IH0pO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNFbnRyeVJlZ2lzdGVyZWQoaW5zdGFsbGF0aW9uRW50cnkpIHtcclxuICAgIHJldHVybiAoaW5zdGFsbGF0aW9uRW50cnkgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLyk7XHJcbn1cclxuZnVuY3Rpb24gaXNBdXRoVG9rZW5WYWxpZChhdXRoVG9rZW4pIHtcclxuICAgIHJldHVybiAoYXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDIgLyogUmVxdWVzdFN0YXR1cy5DT01QTEVURUQgKi8gJiZcclxuICAgICAgICAhaXNBdXRoVG9rZW5FeHBpcmVkKGF1dGhUb2tlbikpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXV0aFRva2VuRXhwaXJlZChhdXRoVG9rZW4pIHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4gKG5vdyA8IGF1dGhUb2tlbi5jcmVhdGlvblRpbWUgfHxcclxuICAgICAgICBhdXRoVG9rZW4uY3JlYXRpb25UaW1lICsgYXV0aFRva2VuLmV4cGlyZXNJbiA8IG5vdyArIFRPS0VOX0VYUElSQVRJT05fQlVGRkVSKTtcclxufVxyXG4vKiogUmV0dXJucyBhbiB1cGRhdGVkIEluc3RhbGxhdGlvbkVudHJ5IHdpdGggYW4gSW5Qcm9ncmVzc0F1dGhUb2tlbi4gKi9cclxuZnVuY3Rpb24gbWFrZUF1dGhUb2tlblJlcXVlc3RJblByb2dyZXNzRW50cnkob2xkRW50cnkpIHtcclxuICAgIGNvbnN0IGluUHJvZ3Jlc3NBdXRoVG9rZW4gPSB7XHJcbiAgICAgICAgcmVxdWVzdFN0YXR1czogMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovLFxyXG4gICAgICAgIHJlcXVlc3RUaW1lOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkRW50cnkpLCB7IGF1dGhUb2tlbjogaW5Qcm9ncmVzc0F1dGhUb2tlbiB9KTtcclxufVxyXG5mdW5jdGlvbiBoYXNBdXRoVG9rZW5SZXF1ZXN0VGltZWRPdXQoYXV0aFRva2VuKSB7XHJcbiAgICByZXR1cm4gKGF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8gJiZcclxuICAgICAgICBhdXRoVG9rZW4ucmVxdWVzdFRpbWUgKyBQRU5ESU5HX1RJTUVPVVRfTVMgPCBEYXRlLm5vdygpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlcyBhIEZpcmViYXNlIEluc3RhbGxhdGlvbiBpZiB0aGVyZSBpc24ndCBvbmUgZm9yIHRoZSBhcHAgYW5kXHJcbiAqIHJldHVybnMgdGhlIEluc3RhbGxhdGlvbiBJRC5cclxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRJZChpbnN0YWxsYXRpb25zKSB7XHJcbiAgICBjb25zdCBpbnN0YWxsYXRpb25zSW1wbCA9IGluc3RhbGxhdGlvbnM7XHJcbiAgICBjb25zdCB7IGluc3RhbGxhdGlvbkVudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zSW1wbCk7XHJcbiAgICBpZiAocmVnaXN0cmF0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2UuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBJZiB0aGUgaW5zdGFsbGF0aW9uIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCwgdXBkYXRlIHRoZSBhdXRoZW50aWNhdGlvblxyXG4gICAgICAgIC8vIHRva2VuIGlmIG5lZWRlZC5cclxuICAgICAgICByZWZyZXNoQXV0aFRva2VuKGluc3RhbGxhdGlvbnNJbXBsKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0YWxsYXRpb25FbnRyeS5maWQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBGaXJlYmFzZSBJbnN0YWxsYXRpb25zIGF1dGggdG9rZW4sIGlkZW50aWZ5aW5nIHRoZSBjdXJyZW50XHJcbiAqIEZpcmViYXNlIEluc3RhbGxhdGlvbi5cclxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YWxsYXRpb25zSW1wbCA9IGluc3RhbGxhdGlvbnM7XHJcbiAgICBhd2FpdCBjb21wbGV0ZUluc3RhbGxhdGlvblJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zSW1wbCk7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGVpdGhlciBoYXZlIGEgUmVnaXN0ZXJlZCBJbnN0YWxsYXRpb24gaW4gdGhlIERCLCBvciB3ZSd2ZVxyXG4gICAgLy8gYWxyZWFkeSB0aHJvd24gYW4gZXJyb3IuXHJcbiAgICBjb25zdCBhdXRoVG9rZW4gPSBhd2FpdCByZWZyZXNoQXV0aFRva2VuKGluc3RhbGxhdGlvbnNJbXBsLCBmb3JjZVJlZnJlc2gpO1xyXG4gICAgcmV0dXJuIGF1dGhUb2tlbi50b2tlbjtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZUluc3RhbGxhdGlvblJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zKSB7XHJcbiAgICBjb25zdCB7IHJlZ2lzdHJhdGlvblByb21pc2UgfSA9IGF3YWl0IGdldEluc3RhbGxhdGlvbkVudHJ5KGluc3RhbGxhdGlvbnMpO1xyXG4gICAgaWYgKHJlZ2lzdHJhdGlvblByb21pc2UpIHtcclxuICAgICAgICAvLyBBIGNyZWF0ZUluc3RhbGxhdGlvbiByZXF1ZXN0IGlzIGluIHByb2dyZXNzLiBXYWl0IHVudGlsIGl0IGZpbmlzaGVzLlxyXG4gICAgICAgIGF3YWl0IHJlZ2lzdHJhdGlvblByb21pc2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlSW5zdGFsbGF0aW9uUmVxdWVzdChhcHBDb25maWcsIGluc3RhbGxhdGlvbkVudHJ5KSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGdldERlbGV0ZUVuZHBvaW50KGFwcENvbmZpZywgaW5zdGFsbGF0aW9uRW50cnkpO1xyXG4gICAgY29uc3QgaGVhZGVycyA9IGdldEhlYWRlcnNXaXRoQXV0aChhcHBDb25maWcsIGluc3RhbGxhdGlvbkVudHJ5KTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICBoZWFkZXJzXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXRyeUlmU2VydmVyRXJyb3IoKCkgPT4gZmV0Y2goZW5kcG9pbnQsIHJlcXVlc3QpKTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBhd2FpdCBnZXRFcnJvckZyb21SZXNwb25zZSgnRGVsZXRlIEluc3RhbGxhdGlvbicsIHJlc3BvbnNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXREZWxldGVFbmRwb2ludChhcHBDb25maWcsIHsgZmlkIH0pIHtcclxuICAgIHJldHVybiBgJHtnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKX0vJHtmaWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVsZXRlcyB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGFuZCBhbGwgYXNzb2NpYXRlZCBkYXRhLlxyXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluc3RhbGxhdGlvbnMoaW5zdGFsbGF0aW9ucykge1xyXG4gICAgY29uc3QgeyBhcHBDb25maWcgfSA9IGluc3RhbGxhdGlvbnM7XHJcbiAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHVwZGF0ZShhcHBDb25maWcsIG9sZEVudHJ5ID0+IHtcclxuICAgICAgICBpZiAob2xkRW50cnkgJiYgb2xkRW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAwIC8qIFJlcXVlc3RTdGF0dXMuTk9UX1NUQVJURUQgKi8pIHtcclxuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSB1bnJlZ2lzdGVyZWQgZW50cnkgd2l0aG91dCBzZW5kaW5nIGEgZGVsZXRlSW5zdGFsbGF0aW9uIHJlcXVlc3QuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvbGRFbnRyeTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovKSB7XHJcbiAgICAgICAgICAgIC8vIENhbid0IGRlbGV0ZSB3aGlsZSB0cnlpbmcgdG8gcmVnaXN0ZXIuXHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZGVsZXRlLXBlbmRpbmctcmVnaXN0cmF0aW9uXCIgLyogRXJyb3JDb2RlLkRFTEVURV9QRU5ESU5HX1JFR0lTVFJBVElPTiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLykge1xyXG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5vbkxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLW9mZmxpbmVcIiAvKiBFcnJvckNvZGUuQVBQX09GRkxJTkUgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsZXRlSW5zdGFsbGF0aW9uUmVxdWVzdChhcHBDb25maWcsIGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZShhcHBDb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTZXRzIGEgbmV3IGNhbGxiYWNrIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW4gSW5zdGFsbGF0aW9uIElEIGNoYW5nZXMuXHJcbiAqIFJldHVybnMgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgY2FsbGJhY2sgd2hlbiBjYWxsZWQuXHJcbiAqIEBwYXJhbSBpbnN0YWxsYXRpb25zIC0gVGhlIGBJbnN0YWxsYXRpb25zYCBpbnN0YW5jZS5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIEZJRCBjaGFuZ2VzLlxyXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byB1bnN1YnNjcmliZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gb25JZENoYW5nZShpbnN0YWxsYXRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgeyBhcHBDb25maWcgfSA9IGluc3RhbGxhdGlvbnM7XHJcbiAgICBhZGRDYWxsYmFjayhhcHBDb25maWcsIGNhbGxiYWNrKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHtAbGluayBJbnN0YWxsYXRpb25zfSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEluc3RhbGxhdGlvbnMoYXBwID0gZ2V0QXBwKCkpIHtcclxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gX2dldFByb3ZpZGVyKGFwcCwgJ2luc3RhbGxhdGlvbnMnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgIHJldHVybiBpbnN0YWxsYXRpb25zSW1wbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0QXBwQ29uZmlnKGFwcCkge1xyXG4gICAgaWYgKCFhcHAgfHwgIWFwcC5vcHRpb25zKSB7XHJcbiAgICAgICAgdGhyb3cgZ2V0TWlzc2luZ1ZhbHVlRXJyb3IoJ0FwcCBDb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwcC5uYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgZ2V0TWlzc2luZ1ZhbHVlRXJyb3IoJ0FwcCBOYW1lJyk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXF1aXJlZCBhcHAgY29uZmlnIGtleXNcclxuICAgIGNvbnN0IGNvbmZpZ0tleXMgPSBbXHJcbiAgICAgICAgJ3Byb2plY3RJZCcsXHJcbiAgICAgICAgJ2FwaUtleScsXHJcbiAgICAgICAgJ2FwcElkJ1xyXG4gICAgXTtcclxuICAgIGZvciAoY29uc3Qga2V5TmFtZSBvZiBjb25maWdLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFhcHAub3B0aW9uc1trZXlOYW1lXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBnZXRNaXNzaW5nVmFsdWVFcnJvcihrZXlOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFwcE5hbWU6IGFwcC5uYW1lLFxyXG4gICAgICAgIHByb2plY3RJZDogYXBwLm9wdGlvbnMucHJvamVjdElkLFxyXG4gICAgICAgIGFwaUtleTogYXBwLm9wdGlvbnMuYXBpS2V5LFxyXG4gICAgICAgIGFwcElkOiBhcHAub3B0aW9ucy5hcHBJZFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRNaXNzaW5nVmFsdWVFcnJvcih2YWx1ZU5hbWUpIHtcclxuICAgIHJldHVybiBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm1pc3NpbmctYXBwLWNvbmZpZy12YWx1ZXNcIiAvKiBFcnJvckNvZGUuTUlTU0lOR19BUFBfQ09ORklHX1ZBTFVFUyAqLywge1xyXG4gICAgICAgIHZhbHVlTmFtZVxyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgSU5TVEFMTEFUSU9OU19OQU1FID0gJ2luc3RhbGxhdGlvbnMnO1xyXG5jb25zdCBJTlNUQUxMQVRJT05TX05BTUVfSU5URVJOQUwgPSAnaW5zdGFsbGF0aW9ucy1pbnRlcm5hbCc7XHJcbmNvbnN0IHB1YmxpY0ZhY3RvcnkgPSAoY29udGFpbmVyKSA9PiB7XHJcbiAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgLy8gVGhyb3dzIGlmIGFwcCBpc24ndCBjb25maWd1cmVkIHByb3Blcmx5LlxyXG4gICAgY29uc3QgYXBwQ29uZmlnID0gZXh0cmFjdEFwcENvbmZpZyhhcHApO1xyXG4gICAgY29uc3QgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2hlYXJ0YmVhdCcpO1xyXG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ltcGwgPSB7XHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGFwcENvbmZpZyxcclxuICAgICAgICBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsXHJcbiAgICAgICAgX2RlbGV0ZTogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKClcclxuICAgIH07XHJcbiAgICByZXR1cm4gaW5zdGFsbGF0aW9uc0ltcGw7XHJcbn07XHJcbmNvbnN0IGludGVybmFsRmFjdG9yeSA9IChjb250YWluZXIpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAvLyBJbnRlcm5hbCBGSVMgaW5zdGFuY2UgcmVsaWVzIG9uIHB1YmxpYyBGSVMgaW5zdGFuY2UuXHJcbiAgICBjb25zdCBpbnN0YWxsYXRpb25zID0gX2dldFByb3ZpZGVyKGFwcCwgSU5TVEFMTEFUSU9OU19OQU1FKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbnRlcm5hbCA9IHtcclxuICAgICAgICBnZXRJZDogKCkgPT4gZ2V0SWQoaW5zdGFsbGF0aW9ucyksXHJcbiAgICAgICAgZ2V0VG9rZW46IChmb3JjZVJlZnJlc2gpID0+IGdldFRva2VuKGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaClcclxuICAgIH07XHJcbiAgICByZXR1cm4gaW5zdGFsbGF0aW9uc0ludGVybmFsO1xyXG59O1xyXG5mdW5jdGlvbiByZWdpc3Rlckluc3RhbGxhdGlvbnMoKSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChJTlNUQUxMQVRJT05TX05BTUUsIHB1YmxpY0ZhY3RvcnksIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KElOU1RBTExBVElPTlNfTkFNRV9JTlRFUk5BTCwgaW50ZXJuYWxGYWN0b3J5LCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxufVxuXG4vKipcclxuICogVGhlIEZpcmViYXNlIEluc3RhbGxhdGlvbnMgV2ViIFNESy5cclxuICogVGhpcyBTREsgZG9lcyBub3Qgd29yayBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXHJcbiAqXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJJbnN0YWxsYXRpb25zKCk7XHJcbnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcclxuLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XG5cbmV4cG9ydCB7IGRlbGV0ZUluc3RhbGxhdGlvbnMsIGdldElkLCBnZXRJbnN0YWxsYXRpb25zLCBnZXRUb2tlbiwgb25JZENoYW5nZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A container for all of the Logger instances\r\n */\r\nconst instances = [];\r\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\r\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\r\n})(LogLevel || (LogLevel = {}));\r\nconst levelStringToEnum = {\r\n    'debug': LogLevel.DEBUG,\r\n    'verbose': LogLevel.VERBOSE,\r\n    'info': LogLevel.INFO,\r\n    'warn': LogLevel.WARN,\r\n    'error': LogLevel.ERROR,\r\n    'silent': LogLevel.SILENT\r\n};\r\n/**\r\n * The default log level\r\n */\r\nconst defaultLogLevel = LogLevel.INFO;\r\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\r\nconst ConsoleMethod = {\r\n    [LogLevel.DEBUG]: 'log',\r\n    [LogLevel.VERBOSE]: 'log',\r\n    [LogLevel.INFO]: 'info',\r\n    [LogLevel.WARN]: 'warn',\r\n    [LogLevel.ERROR]: 'error'\r\n};\r\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\r\nconst defaultLogHandler = (instance, logType, ...args) => {\r\n    if (logType < instance.logLevel) {\r\n        return;\r\n    }\r\n    const now = new Date().toISOString();\r\n    const method = ConsoleMethod[logType];\r\n    if (method) {\r\n        console[method](`[${now}]  ${instance.name}:`, ...args);\r\n    }\r\n    else {\r\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\r\n    }\r\n};\r\nclass Logger {\r\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */\r\n    constructor(name) {\r\n        this.name = name;\r\n        /**\r\n         * The log level of the given Logger instance.\r\n         */\r\n        this._logLevel = defaultLogLevel;\r\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */\r\n        this._logHandler = defaultLogHandler;\r\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */\r\n        this._userLogHandler = null;\r\n        /**\r\n         * Capture the current instance for later use\r\n         */\r\n        instances.push(this);\r\n    }\r\n    get logLevel() {\r\n        return this._logLevel;\r\n    }\r\n    set logLevel(val) {\r\n        if (!(val in LogLevel)) {\r\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\r\n        }\r\n        this._logLevel = val;\r\n    }\r\n    // Workaround for setter/getter having to be the same type.\r\n    setLogLevel(val) {\r\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\r\n    }\r\n    get logHandler() {\r\n        return this._logHandler;\r\n    }\r\n    set logHandler(val) {\r\n        if (typeof val !== 'function') {\r\n            throw new TypeError('Value assigned to `logHandler` must be a function');\r\n        }\r\n        this._logHandler = val;\r\n    }\r\n    get userLogHandler() {\r\n        return this._userLogHandler;\r\n    }\r\n    set userLogHandler(val) {\r\n        this._userLogHandler = val;\r\n    }\r\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\r\n    debug(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\r\n        this._logHandler(this, LogLevel.DEBUG, ...args);\r\n    }\r\n    log(...args) {\r\n        this._userLogHandler &&\r\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\r\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\r\n    }\r\n    info(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\r\n        this._logHandler(this, LogLevel.INFO, ...args);\r\n    }\r\n    warn(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\r\n        this._logHandler(this, LogLevel.WARN, ...args);\r\n    }\r\n    error(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\r\n        this._logHandler(this, LogLevel.ERROR, ...args);\r\n    }\r\n}\r\nfunction setLogLevel(level) {\r\n    instances.forEach(inst => {\r\n        inst.setLogLevel(level);\r\n    });\r\n}\r\nfunction setUserLogHandler(logCallback, options) {\r\n    for (const instance of instances) {\r\n        let customLogLevel = null;\r\n        if (options && options.level) {\r\n            customLogLevel = levelStringToEnum[options.level];\r\n        }\r\n        if (logCallback === null) {\r\n            instance.userLogHandler = null;\r\n        }\r\n        else {\r\n            instance.userLogHandler = (instance, level, ...args) => {\r\n                const message = args\r\n                    .map(arg => {\r\n                    if (arg == null) {\r\n                        return null;\r\n                    }\r\n                    else if (typeof arg === 'string') {\r\n                        return arg;\r\n                    }\r\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\r\n                        return arg.toString();\r\n                    }\r\n                    else if (arg instanceof Error) {\r\n                        return arg.message;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            return JSON.stringify(arg);\r\n                        }\r\n                        catch (ignored) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                })\r\n                    .filter(arg => arg)\r\n                    .join(' ');\r\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\r\n                    logCallback({\r\n                        level: LogLevel[level].toLowerCase(),\r\n                        message,\r\n                        args,\r\n                        type: instance.name\r\n                    });\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZlbnRvcnlfbWFuYWdtZW50Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz9jMzUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\r\nconst CONSTANTS = {\r\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */\r\n    NODE_CLIENT: false,\r\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */\r\n    NODE_ADMIN: false,\r\n    /**\r\n     * Firebase SDK Version\r\n     */\r\n    SDK_VERSION: '${JSCORE_VERSION}'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\r\nconst assert = function (assertion, message) {\r\n    if (!assertion) {\r\n        throw assertionError(message);\r\n    }\r\n};\r\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\r\nconst assertionError = function (message) {\r\n    return new Error('Firebase Database (' +\r\n        CONSTANTS.SDK_VERSION +\r\n        ') INTERNAL ASSERT FAILED: ' +\r\n        message);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst stringToByteArray$1 = function (str) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if ((c & 0xfc00) === 0xd800 &&\r\n            i + 1 < str.length &&\r\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\r\n            // Surrogate Pair\r\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\r\nconst byteArrayToString = function (bytes) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let pos = 0, c = 0;\r\n    while (pos < bytes.length) {\r\n        const c1 = bytes[pos++];\r\n        if (c1 < 128) {\r\n            out[c++] = String.fromCharCode(c1);\r\n        }\r\n        else if (c1 > 191 && c1 < 224) {\r\n            const c2 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\r\n        }\r\n        else if (c1 > 239 && c1 < 365) {\r\n            // Surrogate Pair\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            const c4 = bytes[pos++];\r\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\r\n                0x10000;\r\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\r\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\r\n        }\r\n        else {\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n        }\r\n    }\r\n    return out.join('');\r\n};\r\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\r\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\r\n// Static lookup maps, lazily populated by init_()\r\nconst base64 = {\r\n    /**\r\n     * Maps bytes to characters.\r\n     */\r\n    byteToCharMap_: null,\r\n    /**\r\n     * Maps characters to bytes.\r\n     */\r\n    charToByteMap_: null,\r\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */\r\n    byteToCharMapWebSafe_: null,\r\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */\r\n    charToByteMapWebSafe_: null,\r\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */\r\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\r\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */\r\n    get ENCODED_VALS() {\r\n        return this.ENCODED_VALS_BASE + '+/=';\r\n    },\r\n    /**\r\n     * Our websafe alphabet.\r\n     */\r\n    get ENCODED_VALS_WEBSAFE() {\r\n        return this.ENCODED_VALS_BASE + '-_.';\r\n    },\r\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */\r\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\r\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeByteArray(input, webSafe) {\r\n        if (!Array.isArray(input)) {\r\n            throw Error('encodeByteArray takes an array as a parameter');\r\n        }\r\n        this.init_();\r\n        const byteToCharMap = webSafe\r\n            ? this.byteToCharMapWebSafe_\r\n            : this.byteToCharMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length; i += 3) {\r\n            const byte1 = input[i];\r\n            const haveByte2 = i + 1 < input.length;\r\n            const byte2 = haveByte2 ? input[i + 1] : 0;\r\n            const haveByte3 = i + 2 < input.length;\r\n            const byte3 = haveByte3 ? input[i + 2] : 0;\r\n            const outByte1 = byte1 >> 2;\r\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\r\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\r\n            let outByte4 = byte3 & 0x3f;\r\n            if (!haveByte3) {\r\n                outByte4 = 64;\r\n                if (!haveByte2) {\r\n                    outByte3 = 64;\r\n                }\r\n            }\r\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\r\n        }\r\n        return output.join('');\r\n    },\r\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return btoa(input);\r\n        }\r\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */\r\n    decodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return atob(input);\r\n        }\r\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */\r\n    decodeStringToByteArray(input, webSafe) {\r\n        this.init_();\r\n        const charToByteMap = webSafe\r\n            ? this.charToByteMapWebSafe_\r\n            : this.charToByteMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length;) {\r\n            const byte1 = charToByteMap[input.charAt(i++)];\r\n            const haveByte2 = i < input.length;\r\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\r\n            ++i;\r\n            const haveByte3 = i < input.length;\r\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            const haveByte4 = i < input.length;\r\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\r\n                throw new DecodeBase64StringError();\r\n            }\r\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\r\n            output.push(outByte1);\r\n            if (byte3 !== 64) {\r\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\r\n                output.push(outByte2);\r\n                if (byte4 !== 64) {\r\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\r\n                    output.push(outByte3);\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    },\r\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */\r\n    init_() {\r\n        if (!this.byteToCharMap_) {\r\n            this.byteToCharMap_ = {};\r\n            this.charToByteMap_ = {};\r\n            this.byteToCharMapWebSafe_ = {};\r\n            this.charToByteMapWebSafe_ = {};\r\n            // We want quick mappings back and forth, so we precompute two maps.\r\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\r\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\r\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\r\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\r\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\r\n                // Be forgiving when decoding and correctly decode both encodings.\r\n                if (i >= this.ENCODED_VALS_BASE.length) {\r\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\r\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n/**\r\n * An error encountered while decoding base64 string.\r\n */\r\nclass DecodeBase64StringError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'DecodeBase64StringError';\r\n    }\r\n}\r\n/**\r\n * URL-safe base64 encoding\r\n */\r\nconst base64Encode = function (str) {\r\n    const utf8Bytes = stringToByteArray$1(str);\r\n    return base64.encodeByteArray(utf8Bytes, true);\r\n};\r\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */\r\nconst base64urlEncodeWithoutPadding = function (str) {\r\n    // Use base64url encoding and remove padding in the end (dot characters).\r\n    return base64Encode(str).replace(/\\./g, '');\r\n};\r\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\r\nconst base64Decode = function (str) {\r\n    try {\r\n        return base64.decodeString(str, true);\r\n    }\r\n    catch (e) {\r\n        console.error('base64Decode failed: ', e);\r\n    }\r\n    return null;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\r\nfunction deepCopy(value) {\r\n    return deepExtend(undefined, value);\r\n}\r\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */\r\nfunction deepExtend(target, source) {\r\n    if (!(source instanceof Object)) {\r\n        return source;\r\n    }\r\n    switch (source.constructor) {\r\n        case Date:\r\n            // Treat Dates like scalars; if the target date object had any child\r\n            // properties - they will be lost!\r\n            const dateValue = source;\r\n            return new Date(dateValue.getTime());\r\n        case Object:\r\n            if (target === undefined) {\r\n                target = {};\r\n            }\r\n            break;\r\n        case Array:\r\n            // Always copy the array source and overwrite the target.\r\n            target = [];\r\n            break;\r\n        default:\r\n            // Not a plain Object - treat it as a scalar.\r\n            return source;\r\n    }\r\n    for (const prop in source) {\r\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\r\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\r\n            continue;\r\n        }\r\n        target[prop] = deepExtend(target[prop], source[prop]);\r\n    }\r\n    return target;\r\n}\r\nfunction isValidKey(key) {\r\n    return key !== '__proto__';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */\r\nfunction getGlobal() {\r\n    if (typeof self !== 'undefined') {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        return window;\r\n    }\r\n    if (typeof global !== 'undefined') {\r\n        return global;\r\n    }\r\n    throw new Error('Unable to locate global object.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\r\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */\r\nconst getDefaultsFromEnvVariable = () => {\r\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\r\n        return;\r\n    }\r\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\r\n    if (defaultsJsonString) {\r\n        return JSON.parse(defaultsJsonString);\r\n    }\r\n};\r\nconst getDefaultsFromCookie = () => {\r\n    if (typeof document === 'undefined') {\r\n        return;\r\n    }\r\n    let match;\r\n    try {\r\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\r\n    }\r\n    catch (e) {\r\n        // Some environments such as Angular Universal SSR have a\r\n        // `document` object but error on accessing `document.cookie`.\r\n        return;\r\n    }\r\n    const decoded = match && base64Decode(match[1]);\r\n    return decoded && JSON.parse(decoded);\r\n};\r\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */\r\nconst getDefaults = () => {\r\n    try {\r\n        return (getDefaultsFromGlobal() ||\r\n            getDefaultsFromEnvVariable() ||\r\n            getDefaultsFromCookie());\r\n    }\r\n    catch (e) {\r\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */\r\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\r\n        return;\r\n    }\r\n};\r\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\r\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\r\n    const host = getDefaultEmulatorHost(productName);\r\n    if (!host) {\r\n        return undefined;\r\n    }\r\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\r\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\r\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\r\n    }\r\n    // eslint-disable-next-line no-restricted-globals\r\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\r\n    if (host[0] === '[') {\r\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\r\n        return [host.substring(1, separatorIndex - 1), port];\r\n    }\r\n    else {\r\n        return [host.substring(0, separatorIndex), port];\r\n    }\r\n};\r\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */\r\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\r\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */\r\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.reject = () => { };\r\n        this.resolve = () => { };\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */\r\n    wrapCallback(callback) {\r\n        return (error, value) => {\r\n            if (error) {\r\n                this.reject(error);\r\n            }\r\n            else {\r\n                this.resolve(value);\r\n            }\r\n            if (typeof callback === 'function') {\r\n                // Attaching noop handler just in case developer wasn't expecting\r\n                // promises\r\n                this.promise.catch(() => { });\r\n                // Some of our callbacks don't expect a value and our own tests\r\n                // assert that the parameter length is 1\r\n                if (callback.length === 1) {\r\n                    callback(error);\r\n                }\r\n                else {\r\n                    callback(error, value);\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction createMockUserToken(token, projectId) {\r\n    if (token.uid) {\r\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\r\n    }\r\n    // Unsecured JWTs use \"none\" as the algorithm.\r\n    const header = {\r\n        alg: 'none',\r\n        type: 'JWT'\r\n    };\r\n    const project = projectId || 'demo-project';\r\n    const iat = token.iat || 0;\r\n    const sub = token.sub || token.user_id;\r\n    if (!sub) {\r\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n    }\r\n    const payload = Object.assign({ \r\n        // Set all required fields to decent defaults\r\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\r\n            sign_in_provider: 'custom',\r\n            identities: {}\r\n        } }, token);\r\n    // Unsecured JWTs use the empty string as a signature.\r\n    const signature = '';\r\n    return [\r\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\r\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\r\n        signature\r\n    ].join('.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\r\nfunction getUA() {\r\n    if (typeof navigator !== 'undefined' &&\r\n        typeof navigator['userAgent'] === 'string') {\r\n        return navigator['userAgent'];\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\r\nfunction isMobileCordova() {\r\n    return (typeof window !== 'undefined' &&\r\n        // @ts-ignore Setting up an broadly applicable index signature for Window\r\n        // just to deal with this case would probably be a bad idea.\r\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\r\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\r\n}\r\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */\r\n// Node detection logic from: https://github.com/iliakan/detect-node/\r\nfunction isNode() {\r\n    var _a;\r\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\r\n    if (forceEnvironment === 'node') {\r\n        return true;\r\n    }\r\n    else if (forceEnvironment === 'browser') {\r\n        return false;\r\n    }\r\n    try {\r\n        return (Object.prototype.toString.call(global.process) === '[object process]');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Detect Browser Environment\r\n */\r\nfunction isBrowser() {\r\n    return typeof window !== 'undefined' || isWebWorker();\r\n}\r\n/**\r\n * Detect Web Worker context\r\n */\r\nfunction isWebWorker() {\r\n    return (typeof WorkerGlobalScope !== 'undefined' &&\r\n        typeof self !== 'undefined' &&\r\n        self instanceof WorkerGlobalScope);\r\n}\r\nfunction isBrowserExtension() {\r\n    const runtime = typeof chrome === 'object'\r\n        ? chrome.runtime\r\n        : typeof browser === 'object'\r\n            ? browser.runtime\r\n            : undefined;\r\n    return typeof runtime === 'object' && runtime.id !== undefined;\r\n}\r\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\r\nfunction isReactNative() {\r\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\r\n}\r\n/** Detects Electron apps. */\r\nfunction isElectron() {\r\n    return getUA().indexOf('Electron/') >= 0;\r\n}\r\n/** Detects Internet Explorer. */\r\nfunction isIE() {\r\n    const ua = getUA();\r\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\r\n}\r\n/** Detects Universal Windows Platform apps. */\r\nfunction isUWP() {\r\n    return getUA().indexOf('MSAppHost/') >= 0;\r\n}\r\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\r\nfunction isNodeSdk() {\r\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\r\n}\r\n/** Returns true if we are running in Safari. */\r\nfunction isSafari() {\r\n    return (!isNode() &&\r\n        !!navigator.userAgent &&\r\n        navigator.userAgent.includes('Safari') &&\r\n        !navigator.userAgent.includes('Chrome'));\r\n}\r\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\r\nfunction isIndexedDBAvailable() {\r\n    try {\r\n        return typeof indexedDB === 'object';\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */\r\nfunction validateIndexedDBOpenable() {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            let preExist = true;\r\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\r\n            const request = self.indexedDB.open(DB_CHECK_NAME);\r\n            request.onsuccess = () => {\r\n                request.result.close();\r\n                // delete database only when it doesn't pre-exist\r\n                if (!preExist) {\r\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\r\n                }\r\n                resolve(true);\r\n            };\r\n            request.onupgradeneeded = () => {\r\n                preExist = false;\r\n            };\r\n            request.onerror = () => {\r\n                var _a;\r\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\r\n            };\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\r\nfunction areCookiesEnabled() {\r\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */\r\nconst ERROR_NAME = 'FirebaseError';\r\n// Based on code from:\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\r\nclass FirebaseError extends Error {\r\n    constructor(\r\n    /** The error code for this error. */\r\n    code, message, \r\n    /** Custom data for this error. */\r\n    customData) {\r\n        super(message);\r\n        this.code = code;\r\n        this.customData = customData;\r\n        /** The custom name for all FirebaseErrors. */\r\n        this.name = ERROR_NAME;\r\n        // Fix For ES5\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, FirebaseError.prototype);\r\n        // Maintains proper stack trace for where our error was thrown.\r\n        // Only available on V8.\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\r\n        }\r\n    }\r\n}\r\nclass ErrorFactory {\r\n    constructor(service, serviceName, errors) {\r\n        this.service = service;\r\n        this.serviceName = serviceName;\r\n        this.errors = errors;\r\n    }\r\n    create(code, ...data) {\r\n        const customData = data[0] || {};\r\n        const fullCode = `${this.service}/${code}`;\r\n        const template = this.errors[code];\r\n        const message = template ? replaceTemplate(template, customData) : 'Error';\r\n        // Service Name: Error message (service/code).\r\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\r\n        const error = new FirebaseError(fullCode, fullMessage, customData);\r\n        return error;\r\n    }\r\n}\r\nfunction replaceTemplate(template, data) {\r\n    return template.replace(PATTERN, (_, key) => {\r\n        const value = data[key];\r\n        return value != null ? String(value) : `<${key}?>`;\r\n    });\r\n}\r\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\r\nfunction jsonEval(str) {\r\n    return JSON.parse(str);\r\n}\r\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\r\nfunction stringify(data) {\r\n    return JSON.stringify(data);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst decode = function (token) {\r\n    let header = {}, claims = {}, data = {}, signature = '';\r\n    try {\r\n        const parts = token.split('.');\r\n        header = jsonEval(base64Decode(parts[0]) || '');\r\n        claims = jsonEval(base64Decode(parts[1]) || '');\r\n        signature = parts[2];\r\n        data = claims['d'] || {};\r\n        delete claims['d'];\r\n    }\r\n    catch (e) { }\r\n    return {\r\n        header,\r\n        claims,\r\n        data,\r\n        signature\r\n    };\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidTimestamp = function (token) {\r\n    const claims = decode(token).claims;\r\n    const now = Math.floor(new Date().getTime() / 1000);\r\n    let validSince = 0, validUntil = 0;\r\n    if (typeof claims === 'object') {\r\n        if (claims.hasOwnProperty('nbf')) {\r\n            validSince = claims['nbf'];\r\n        }\r\n        else if (claims.hasOwnProperty('iat')) {\r\n            validSince = claims['iat'];\r\n        }\r\n        if (claims.hasOwnProperty('exp')) {\r\n            validUntil = claims['exp'];\r\n        }\r\n        else {\r\n            // token will expire after 24h by default\r\n            validUntil = validSince + 86400;\r\n        }\r\n    }\r\n    return (!!now &&\r\n        !!validSince &&\r\n        !!validUntil &&\r\n        now >= validSince &&\r\n        now <= validUntil);\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst issuedAtTime = function (token) {\r\n    const claims = decode(token).claims;\r\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\r\n        return claims['iat'];\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidFormat = function (token) {\r\n    const decoded = decode(token), claims = decoded.claims;\r\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\r\n};\r\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isAdmin = function (token) {\r\n    const claims = decode(token).claims;\r\n    return typeof claims === 'object' && claims['admin'] === true;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction contains(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\nfunction safeGet(obj, key) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction map(obj, fn, contextObj) {\r\n    const res = {};\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            res[key] = fn.call(contextObj, obj[key], key, obj);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */\r\nfunction deepEqual(a, b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    for (const k of aKeys) {\r\n        if (!bKeys.includes(k)) {\r\n            return false;\r\n        }\r\n        const aProp = a[k];\r\n        const bProp = b[k];\r\n        if (isObject(aProp) && isObject(bProp)) {\r\n            if (!deepEqual(aProp, bProp)) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (aProp !== bProp) {\r\n            return false;\r\n        }\r\n    }\r\n    for (const k of bKeys) {\r\n        if (!aKeys.includes(k)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isObject(thing) {\r\n    return thing !== null && typeof thing === 'object';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */\r\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\r\n    const deferredPromise = new Deferred();\r\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\r\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\r\n    return deferredPromise.promise;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\r\nfunction querystring(querystringParams) {\r\n    const params = [];\r\n    for (const [key, value] of Object.entries(querystringParams)) {\r\n        if (Array.isArray(value)) {\r\n            value.forEach(arrayVal => {\r\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\r\n            });\r\n        }\r\n        else {\r\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n        }\r\n    }\r\n    return params.length ? '&' + params.join('&') : '';\r\n}\r\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\r\nfunction querystringDecode(querystring) {\r\n    const obj = {};\r\n    const tokens = querystring.replace(/^\\?/, '').split('&');\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            const [key, value] = token.split('=');\r\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */\r\nfunction extractQuerystring(url) {\r\n    const queryStart = url.indexOf('?');\r\n    if (!queryStart) {\r\n        return '';\r\n    }\r\n    const fragmentStart = url.indexOf('#', queryStart);\r\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\r\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\nclass Sha1 {\r\n    constructor() {\r\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */\r\n        this.chain_ = [];\r\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */\r\n        this.buf_ = [];\r\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */\r\n        this.W_ = [];\r\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */\r\n        this.pad_ = [];\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.inbuf_ = 0;\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.total_ = 0;\r\n        this.blockSize = 512 / 8;\r\n        this.pad_[0] = 128;\r\n        for (let i = 1; i < this.blockSize; ++i) {\r\n            this.pad_[i] = 0;\r\n        }\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        this.chain_[0] = 0x67452301;\r\n        this.chain_[1] = 0xefcdab89;\r\n        this.chain_[2] = 0x98badcfe;\r\n        this.chain_[3] = 0x10325476;\r\n        this.chain_[4] = 0xc3d2e1f0;\r\n        this.inbuf_ = 0;\r\n        this.total_ = 0;\r\n    }\r\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */\r\n    compress_(buf, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        const W = this.W_;\r\n        // get 16 big endian words\r\n        if (typeof buf === 'string') {\r\n            for (let i = 0; i < 16; i++) {\r\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\r\n                // have a bug that turns the post-increment ++ operator into pre-increment\r\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\r\n                // correctness and which is affected by this bug, so I've removed all uses\r\n                // of post-increment ++ in which the result value is used.  We can revert\r\n                // this change once the Safari bug\r\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\r\n                // most clients have been updated.\r\n                W[i] =\r\n                    (buf.charCodeAt(offset) << 24) |\r\n                        (buf.charCodeAt(offset + 1) << 16) |\r\n                        (buf.charCodeAt(offset + 2) << 8) |\r\n                        buf.charCodeAt(offset + 3);\r\n                offset += 4;\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < 16; i++) {\r\n                W[i] =\r\n                    (buf[offset] << 24) |\r\n                        (buf[offset + 1] << 16) |\r\n                        (buf[offset + 2] << 8) |\r\n                        buf[offset + 3];\r\n                offset += 4;\r\n            }\r\n        }\r\n        // expand to 80 words\r\n        for (let i = 16; i < 80; i++) {\r\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\r\n        }\r\n        let a = this.chain_[0];\r\n        let b = this.chain_[1];\r\n        let c = this.chain_[2];\r\n        let d = this.chain_[3];\r\n        let e = this.chain_[4];\r\n        let f, k;\r\n        // TODO(user): Try to unroll this loop to speed up the computation.\r\n        for (let i = 0; i < 80; i++) {\r\n            if (i < 40) {\r\n                if (i < 20) {\r\n                    f = d ^ (b & (c ^ d));\r\n                    k = 0x5a827999;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0x6ed9eba1;\r\n                }\r\n            }\r\n            else {\r\n                if (i < 60) {\r\n                    f = (b & c) | (d & (b | c));\r\n                    k = 0x8f1bbcdc;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0xca62c1d6;\r\n                }\r\n            }\r\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\r\n            b = a;\r\n            a = t;\r\n        }\r\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\r\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\r\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\r\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\r\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\r\n    }\r\n    update(bytes, length) {\r\n        // TODO(johnlenz): tighten the function signature and remove this check\r\n        if (bytes == null) {\r\n            return;\r\n        }\r\n        if (length === undefined) {\r\n            length = bytes.length;\r\n        }\r\n        const lengthMinusBlock = length - this.blockSize;\r\n        let n = 0;\r\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\r\n        const buf = this.buf_;\r\n        let inbuf = this.inbuf_;\r\n        // The outer while loop should execute at most twice.\r\n        while (n < length) {\r\n            // When we have no data in the block to top up, we can directly process the\r\n            // input buffer (assuming it contains sufficient data). This gives ~25%\r\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\r\n            // the data is provided in large chunks (or in multiples of 64 bytes).\r\n            if (inbuf === 0) {\r\n                while (n <= lengthMinusBlock) {\r\n                    this.compress_(bytes, n);\r\n                    n += this.blockSize;\r\n                }\r\n            }\r\n            if (typeof bytes === 'string') {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes.charCodeAt(n);\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes[n];\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inbuf_ = inbuf;\r\n        this.total_ += length;\r\n    }\r\n    /** @override */\r\n    digest() {\r\n        const digest = [];\r\n        let totalBits = this.total_ * 8;\r\n        // Add pad 0x80 0x00*.\r\n        if (this.inbuf_ < 56) {\r\n            this.update(this.pad_, 56 - this.inbuf_);\r\n        }\r\n        else {\r\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\r\n        }\r\n        // Add # bits.\r\n        for (let i = this.blockSize - 1; i >= 56; i--) {\r\n            this.buf_[i] = totalBits & 255;\r\n            totalBits /= 256; // Don't use bit-shifting here!\r\n        }\r\n        this.compress_(this.buf_);\r\n        let n = 0;\r\n        for (let i = 0; i < 5; i++) {\r\n            for (let j = 24; j >= 0; j -= 8) {\r\n                digest[n] = (this.chain_[i] >> j) & 255;\r\n                ++n;\r\n            }\r\n        }\r\n        return digest;\r\n    }\r\n}\n\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\r\nfunction createSubscribe(executor, onNoObservers) {\r\n    const proxy = new ObserverProxy(executor, onNoObservers);\r\n    return proxy.subscribe.bind(proxy);\r\n}\r\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\r\nclass ObserverProxy {\r\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */\r\n    constructor(executor, onNoObservers) {\r\n        this.observers = [];\r\n        this.unsubscribes = [];\r\n        this.observerCount = 0;\r\n        // Micro-task scheduling by calling task.then().\r\n        this.task = Promise.resolve();\r\n        this.finalized = false;\r\n        this.onNoObservers = onNoObservers;\r\n        // Call the executor asynchronously so subscribers that are called\r\n        // synchronously after the creation of the subscribe function\r\n        // can still receive the very first value generated in the executor.\r\n        this.task\r\n            .then(() => {\r\n            executor(this);\r\n        })\r\n            .catch(e => {\r\n            this.error(e);\r\n        });\r\n    }\r\n    next(value) {\r\n        this.forEachObserver((observer) => {\r\n            observer.next(value);\r\n        });\r\n    }\r\n    error(error) {\r\n        this.forEachObserver((observer) => {\r\n            observer.error(error);\r\n        });\r\n        this.close(error);\r\n    }\r\n    complete() {\r\n        this.forEachObserver((observer) => {\r\n            observer.complete();\r\n        });\r\n        this.close();\r\n    }\r\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\r\n    subscribe(nextOrObserver, error, complete) {\r\n        let observer;\r\n        if (nextOrObserver === undefined &&\r\n            error === undefined &&\r\n            complete === undefined) {\r\n            throw new Error('Missing Observer.');\r\n        }\r\n        // Assemble an Observer object when passed as callback functions.\r\n        if (implementsAnyMethods(nextOrObserver, [\r\n            'next',\r\n            'error',\r\n            'complete'\r\n        ])) {\r\n            observer = nextOrObserver;\r\n        }\r\n        else {\r\n            observer = {\r\n                next: nextOrObserver,\r\n                error,\r\n                complete\r\n            };\r\n        }\r\n        if (observer.next === undefined) {\r\n            observer.next = noop;\r\n        }\r\n        if (observer.error === undefined) {\r\n            observer.error = noop;\r\n        }\r\n        if (observer.complete === undefined) {\r\n            observer.complete = noop;\r\n        }\r\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\r\n        // Attempt to subscribe to a terminated Observable - we\r\n        // just respond to the Observer with the final error or complete\r\n        // event.\r\n        if (this.finalized) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.task.then(() => {\r\n                try {\r\n                    if (this.finalError) {\r\n                        observer.error(this.finalError);\r\n                    }\r\n                    else {\r\n                        observer.complete();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // nothing\r\n                }\r\n                return;\r\n            });\r\n        }\r\n        this.observers.push(observer);\r\n        return unsub;\r\n    }\r\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\r\n    // any unsubscribed Observer.\r\n    unsubscribeOne(i) {\r\n        if (this.observers === undefined || this.observers[i] === undefined) {\r\n            return;\r\n        }\r\n        delete this.observers[i];\r\n        this.observerCount -= 1;\r\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\r\n            this.onNoObservers(this);\r\n        }\r\n    }\r\n    forEachObserver(fn) {\r\n        if (this.finalized) {\r\n            // Already closed by previous event....just eat the additional values.\r\n            return;\r\n        }\r\n        // Since sendOne calls asynchronously - there is no chance that\r\n        // this.observers will become undefined.\r\n        for (let i = 0; i < this.observers.length; i++) {\r\n            this.sendOne(i, fn);\r\n        }\r\n    }\r\n    // Call the Observer via one of it's callback function. We are careful to\r\n    // confirm that the observe has not been unsubscribed since this asynchronous\r\n    // function had been queued.\r\n    sendOne(i, fn) {\r\n        // Execute the callback asynchronously\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\r\n                try {\r\n                    fn(this.observers[i]);\r\n                }\r\n                catch (e) {\r\n                    // Ignore exceptions raised in Observers or missing methods of an\r\n                    // Observer.\r\n                    // Log error to console. b/31404806\r\n                    if (typeof console !== 'undefined' && console.error) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    close(err) {\r\n        if (this.finalized) {\r\n            return;\r\n        }\r\n        this.finalized = true;\r\n        if (err !== undefined) {\r\n            this.finalError = err;\r\n        }\r\n        // Proxy is no longer needed - garbage collect references\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            this.observers = undefined;\r\n            this.onNoObservers = undefined;\r\n        });\r\n    }\r\n}\r\n/** Turn synchronous function into one called asynchronously. */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction async(fn, onError) {\r\n    return (...args) => {\r\n        Promise.resolve(true)\r\n            .then(() => {\r\n            fn(...args);\r\n        })\r\n            .catch((error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        });\r\n    };\r\n}\r\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    for (const method of methods) {\r\n        if (method in obj && typeof obj[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction noop() {\r\n    // do nothing\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\r\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\r\n    let argError;\r\n    if (argCount < minCount) {\r\n        argError = 'at least ' + minCount;\r\n    }\r\n    else if (argCount > maxCount) {\r\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\r\n    }\r\n    if (argError) {\r\n        const error = fnName +\r\n            ' failed: Was called with ' +\r\n            argCount +\r\n            (argCount === 1 ? ' argument.' : ' arguments.') +\r\n            ' Expects ' +\r\n            argError +\r\n            '.';\r\n        throw new Error(error);\r\n    }\r\n};\r\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */\r\nfunction errorPrefix(fnName, argName) {\r\n    return `${fnName} failed: ${argName} argument `;\r\n}\r\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\r\nfunction validateNamespace(fnName, namespace, optional) {\r\n    if (optional && !namespace) {\r\n        return;\r\n    }\r\n    if (typeof namespace !== 'string') {\r\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\r\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\r\n    }\r\n}\r\nfunction validateCallback(fnName, argumentName, \r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\ncallback, optional) {\r\n    if (optional && !callback) {\r\n        return;\r\n    }\r\n    if (typeof callback !== 'function') {\r\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\r\n    }\r\n}\r\nfunction validateContextObject(fnName, argumentName, context, optional) {\r\n    if (optional && !context) {\r\n        return;\r\n    }\r\n    if (typeof context !== 'object' || context === null) {\r\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\r\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\r\n// so it's been modified.\r\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\r\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\r\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\r\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\r\n// pair).\r\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\r\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\r\nconst stringToByteArray = function (str) {\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        // Is this the lead surrogate in a surrogate pair?\r\n        if (c >= 0xd800 && c <= 0xdbff) {\r\n            const high = c - 0xd800; // the high 10 bits.\r\n            i++;\r\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\r\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\r\n            c = 0x10000 + (high << 10) + low;\r\n        }\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if (c < 65536) {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\r\nconst stringLength = function (str) {\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            p++;\r\n        }\r\n        else if (c < 2048) {\r\n            p += 2;\r\n        }\r\n        else if (c >= 0xd800 && c <= 0xdbff) {\r\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\r\n            p += 4;\r\n            i++; // skip trail surrogate.\r\n        }\r\n        else {\r\n            p += 3;\r\n        }\r\n    }\r\n    return p;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */\r\nconst uuidv4 = function () {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\r\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\r\nconst DEFAULT_INTERVAL_MILLIS = 1000;\r\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\r\nconst DEFAULT_BACKOFF_FACTOR = 2;\r\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\r\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst RANDOM_FACTOR = 0.5;\r\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\r\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\r\n    // Calculates an exponentially increasing value.\r\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\r\n    // and count to restore state.\r\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\r\n    // A random \"fuzz\" to avoid waves of retries.\r\n    // Deviation: randomFactor is required.\r\n    const randomWait = Math.round(\r\n    // A fraction of the backoff value to add/subtract.\r\n    // Deviation: changes multiplication order to improve readability.\r\n    RANDOM_FACTOR *\r\n        currBaseValue *\r\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\r\n        // if we add or subtract.\r\n        (Math.random() - 0.5) *\r\n        2);\r\n    // Limits backoff to max to avoid effectively permanent backoff.\r\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provide English ordinal letters after a number\r\n */\r\nfunction ordinal(i) {\r\n    if (!Number.isFinite(i)) {\r\n        return `${i}`;\r\n    }\r\n    return i + indicator(i);\r\n}\r\nfunction indicator(i) {\r\n    i = Math.abs(i);\r\n    const cent = i % 100;\r\n    if (cent >= 10 && cent <= 20) {\r\n        return 'th';\r\n    }\r\n    const dec = i % 10;\r\n    if (dec === 1) {\r\n        return 'st';\r\n    }\r\n    if (dec === 2) {\r\n        return 'nd';\r\n    }\r\n    if (dec === 3) {\r\n        return 'rd';\r\n    }\r\n    return 'th';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getModularInstance(service) {\r\n    if (service && service._delegate) {\r\n        return service._delegate;\r\n    }\r\n    else {\r\n        return service;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Overriding the constant (we should be the only ones doing this)\r\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSx3RUFBd0UsS0FBSzs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixJQUFJLFNBQVMsR0FBRyxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxVQUFVLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeStCO0FBQ3orQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVudG9yeV9tYW5hZ21lbnQvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcz9mNDM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXHJcbiAqL1xyXG5jb25zdCBDT05TVEFOVFMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgQWRtaW4gTm9kZS5qcyBTREsuXHJcbiAgICAgKi9cclxuICAgIE5PREVfQURNSU46IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBTREtfVkVSU0lPTjogJyR7SlNDT1JFX1ZFUlNJT059J1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcclxuICovXHJcbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXHJcbiAqL1xyXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXHJcbiAgICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcclxuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcclxuICAgICAgICBtZXNzYWdlKTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXHJcbiAgICAgICAgICAgIGkgKyAxIDwgc3RyLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNmZik7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcbi8qKlxyXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcclxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxyXG4gKiBAcGFyYW0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cclxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuY29uc3QgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwb3MgPSAwLCBjID0gMDtcclxuICAgIHdoaWxlIChwb3MgPCBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgdSA9ICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXHJcbiAgICAgICAgICAgICAgICAweDEwMDAwO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG59O1xyXG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxyXG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxyXG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxyXG5jb25zdCBiYXNlNjQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqL1xyXG4gICAgY2hhclRvQnl0ZU1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXHJcbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXHJcbiAgICAgKi9cclxuICAgIEVOQ09ERURfVkFMU19CQVNFOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcclxuICAgICAqL1xyXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxyXG4gICAgICogc3RhcnRlZCBhdCBNb3ppbGxhIGJ1dCBpcyBub3cgaW1wbGVtZW50ZWQgYnkgbWFueSBicm93c2Vycy4gV2UgdXNlIHRoZVxyXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XHJcbiAgICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcclxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUJ5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRfKCk7XHJcbiAgICAgICAgY29uc3QgYnl0ZVRvQ2hhck1hcCA9IHdlYlNhZmVcclxuICAgICAgICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1xyXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTMgPSAoKGJ5dGUyICYgMHgwZikgPDwgMikgfCAoYnl0ZTMgPj4gNik7XHJcbiAgICAgICAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcclxuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcclxuICAgICAgICAgICAgICAgIG91dEJ5dGU0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidG9hKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcclxuICAgICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcclxuICAgICAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXHJcbiAgICAgKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xyXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTMgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweGYwKSB8IChieXRlMyA+PiAyKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlNCAhPT0gNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweGMwKSB8IGJ5dGU0O1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcclxuICAgICAqIGFjY2Vzc2luZyBhbnkgb2YgdGhlIHN0YXRpYyBtYXAgdmFyaWFibGVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgaW5pdF8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xyXG4gICAgICAgICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxyXG4gKi9cclxuY2xhc3MgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcic7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xyXG4gKi9cclxuY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyAod2l0aG91dCBcIi5cIiBwYWRkaW5nIGluIHRoZSBlbmQpLlxyXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXHJcbiAqL1xyXG5jb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cclxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xyXG59O1xyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXHJcbiAqXHJcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxyXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cclxuICpcclxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXHJcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXHJcbiAqL1xyXG5jb25zdCBiYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0ciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcclxuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXHJcbiAqIG9mIE9iamVjdHMgYW5kIEFycmF5cykuICBTY2FsYXIgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJlIG92ZXItd3JpdHRlbi5cclxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxyXG4gKiAoYW5kIHJldHVybmVkKS5cclxuICpcclxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXHJcbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxyXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY2FzZSBEYXRlOlxyXG4gICAgICAgICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGNhc2UgT2JqZWN0OlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQXJyYXk6XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjb3B5IHRoZSBhcnJheSBzb3VyY2UgYW5kIG92ZXJ3cml0ZSB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgLy8gdXNlIGlzVmFsaWRLZXkgdG8gZ3VhcmQgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uLiBTZWUgaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1MT0RBU0gtNDUwMjAyXHJcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgIWlzVmFsaWRLZXkocHJvcCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXyc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBvbHlmaWxsIGZvciBgZ2xvYmFsVGhpc2Agb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB0aGUgYGdsb2JhbFRoaXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUdsb2JhbCA9ICgpID0+IGdldEdsb2JhbCgpLl9fRklSRUJBU0VfREVGQVVMVFNfXztcclxuLyoqXHJcbiAqIEF0dGVtcHQgdG8gcmVhZCBkZWZhdWx0cyBmcm9tIGEgSlNPTiBzdHJpbmcgcHJvdmlkZWQgdG9cclxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfXyBvciBhIEpTT04gZmlsZSB3aG9zZSBwYXRoIGlzIGluXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xyXG4gKiBUaGUgZG90cyBhcmUgaW4gcGFyZW5zIGJlY2F1c2UgY2VydGFpbiBjb21waWxlcnMgKFZpdGU/KSBjYW5ub3RcclxuICogaGFuZGxlIHNlZWluZyB0aGF0IHZhcmlhYmxlIGluIGNvbW1lbnRzLlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbiAgICBpZiAoZGVmYXVsdHNKc29uU3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVmYXVsdHNKc29uU3RyaW5nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tQ29va2llID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbWF0Y2g7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9fX0ZJUkVCQVNFX0RFRkFVTFRTX189KFteO10rKS8pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBTb21lIGVudmlyb25tZW50cyBzdWNoIGFzIEFuZ3VsYXIgVW5pdmVyc2FsIFNTUiBoYXZlIGFcclxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xyXG4gICAgcmV0dXJuIGRlY29kZWQgJiYgSlNPTi5wYXJzZShkZWNvZGVkKTtcclxufTtcclxuLyoqXHJcbiAqIEdldCB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC4gSXQgY2hlY2tzIGluIG9yZGVyOlxyXG4gKiAoMSkgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGFzIGEgcHJvcGVydHkgb2YgYGdsb2JhbFRoaXNgXHJcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxyXG4gKiAoMykgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGluIGEgY29va2llXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzID0gKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlKCkgfHxcclxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tQ29va2llKCkpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxyXG4gICAgICAgICAqIHRvIGFueSBlbnZpcm9ubWVudCBjYXNlIHdlIGhhdmUgbm90IGFjY291bnRlZCBmb3IuIExvZyB0b1xyXG4gICAgICAgICAqIGluZm8gaW5zdGVhZCBvZiBzd2FsbG93aW5nIHNvIHdlIGNhbiBmaW5kIHRoZXNlIHVua25vd24gY2FzZXNcclxuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zb2xlLmluZm8oYFVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZSB0bzogJHtlfWApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcclxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxyXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdG5hbWUgYW5kIHBvcnQgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBwYWlyIG9mIGhvc3RuYW1lIGFuZCBwb3J0IGxpa2UgYFtcIjo6MVwiLCA0MDAwXWAgaWYgYXZhaWxhYmxlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCA9IChwcm9kdWN0TmFtZSkgPT4ge1xyXG4gICAgY29uc3QgaG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QocHJvZHVjdE5hbWUpO1xyXG4gICAgaWYgKCFob3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXHJcbiAgICBpZiAoc2VwYXJhdG9ySW5kZXggPD0gMCB8fCBzZXBhcmF0b3JJbmRleCArIDEgPT09IGhvc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvc3QgJHtob3N0fSB3aXRoIG5vIHNlcGFyYXRlIGhvc3RuYW1lIGFuZCBwb3J0IWApO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xyXG4gICAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKHNlcGFyYXRvckluZGV4ICsgMSksIDEwKTtcclxuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcclxuICAgICAgICAvLyBCcmFja2V0LXF1b3RlZCBgW2lwdjZhZGRyXTpwb3J0YCA9PiByZXR1cm4gXCJpcHY2YWRkclwiICh3aXRob3V0IGJyYWNrZXRzKS5cclxuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDEsIHNlcGFyYXRvckluZGV4IC0gMSksIHBvcnRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCksIHBvcnRdO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXhwZXJpbWVudGFsIHNldHRpbmcgb24gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QgKHByb3BlcnRpZXNcclxuICogcHJlZml4ZWQgYnkgXCJfXCIpXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERlZmVycmVkIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgQVBJIGludGVybmFscyBhcmUgbm90IHByb21pc2VpZmllZCBhbmQgY2Fubm90IGJlY2F1c2Ugb3VyIGNhbGxiYWNrIEFQSXMgaGF2ZSBzdWJ0bGUgZXhwZWN0YXRpb25zIGFyb3VuZFxyXG4gICAgICogaW52b2tpbmcgcHJvbWlzZXMgaW5saW5lLCB3aGljaCBQcm9taXNlcyBhcmUgZm9yYmlkZGVuIHRvIGRvLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIG5vZGUtc3R5bGUgY2FsbGJhY2tcclxuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXHJcbiAgICAgKi9cclxuICAgIHdyYXBDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZSBvZiBvdXIgY2FsbGJhY2tzIGRvbid0IGV4cGVjdCBhIHZhbHVlIGFuZCBvdXIgb3duIHRlc3RzXHJcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTW9ja1VzZXJUb2tlbih0b2tlbiwgcHJvamVjdElkKSB7XHJcbiAgICBpZiAodG9rZW4udWlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJ1aWRcIiBmaWVsZCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGJ5IG1vY2tVc2VyVG9rZW4uIFBsZWFzZSB1c2UgXCJzdWJcIiBpbnN0ZWFkIGZvciBGaXJlYmFzZSBBdXRoIFVzZXIgSUQuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cclxuICAgIGNvbnN0IGhlYWRlciA9IHtcclxuICAgICAgICBhbGc6ICdub25lJyxcclxuICAgICAgICB0eXBlOiAnSldUJ1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2plY3QgPSBwcm9qZWN0SWQgfHwgJ2RlbW8tcHJvamVjdCc7XHJcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcclxuICAgIGNvbnN0IHN1YiA9IHRva2VuLnN1YiB8fCB0b2tlbi51c2VyX2lkO1xyXG4gICAgaWYgKCFzdWIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyBcclxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcclxuICAgICAgICBpc3M6IGBodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vJHtwcm9qZWN0fWAsIGF1ZDogcHJvamVjdCwgaWF0LCBleHA6IGlhdCArIDM2MDAsIGF1dGhfdGltZTogaWF0LCBzdWIsIHVzZXJfaWQ6IHN1YiwgZmlyZWJhc2U6IHtcclxuICAgICAgICAgICAgc2lnbl9pbl9wcm92aWRlcjogJ2N1c3RvbScsXHJcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XHJcbiAgICAgICAgfSB9LCB0b2tlbik7XHJcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhIHNpZ25hdHVyZS5cclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShoZWFkZXIpKSxcclxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICBdLmpvaW4oJy4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBuYXZpZ2F0b3IudXNlckFnZW50IHN0cmluZyBvciAnJyBpZiBpdCdzIG5vdCBkZWZpbmVkLlxyXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRVQSgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAqXHJcbiAqIERlbGliZXJhdGVseSBkb2VzIG5vdCByZWx5IG9uIGNoZWNraW5nIGBmaWxlOi8vYCBVUkxzIChhcyB0aGlzIGZhaWxzIFBob25lR2FwXHJcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcclxuICogd2FpdCBmb3IgYSBjYWxsYmFjay5cclxuICovXHJcbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIFNldHRpbmcgdXAgYW4gYnJvYWRseSBhcHBsaWNhYmxlIGluZGV4IHNpZ25hdHVyZSBmb3IgV2luZG93XHJcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXHJcbiAgICAgICAgISEod2luZG93Wydjb3Jkb3ZhJ10gfHwgd2luZG93WydwaG9uZWdhcCddIHx8IHdpbmRvd1snUGhvbmVHYXAnXSkgJiZcclxuICAgICAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChnZXRVQSgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBOb2RlLmpzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgTm9kZS5qcyBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZCBvciBzcGVjaWZpZWQuXHJcbiAqL1xyXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cclxuZnVuY3Rpb24gaXNOb2RlKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xyXG4gICAgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdub2RlJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ2Jyb3dzZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyB8fCBpc1dlYldvcmtlcigpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgV2ViIFdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcclxuICAgIHJldHVybiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCcm93c2VyRXh0ZW5zaW9uKCkge1xyXG4gICAgY29uc3QgcnVudGltZSA9IHR5cGVvZiBjaHJvbWUgPT09ICdvYmplY3QnXHJcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxyXG4gICAgICAgIDogdHlwZW9mIGJyb3dzZXIgPT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgID8gYnJvd3Nlci5ydW50aW1lXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBydW50aW1lID09PSAnb2JqZWN0JyAmJiBydW50aW1lLmlkICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcclxufVxyXG4vKiogRGV0ZWN0cyBFbGVjdHJvbiBhcHBzLiAqL1xyXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignRWxlY3Ryb24vJykgPj0gMDtcclxufVxyXG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cclxuZnVuY3Rpb24gaXNJRSgpIHtcclxuICAgIGNvbnN0IHVhID0gZ2V0VUEoKTtcclxuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIFVuaXZlcnNhbCBXaW5kb3dzIFBsYXRmb3JtIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzVVdQKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignTVNBcHBIb3N0LycpID49IDA7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc05vZGVTZGsoKSB7XHJcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gU2FmYXJpLiAqL1xyXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcclxuICAgIHJldHVybiAoIWlzTm9kZSgpICYmXHJcbiAgICAgICAgISFuYXZpZ2F0b3IudXNlckFnZW50ICYmXHJcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcclxuICAgICAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnQ2hyb21lJykpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmRleGVkREJBdmFpbGFibGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB2YWxpZGF0ZXMgYnJvd3Nlci9zdyBjb250ZXh0IGZvciBpbmRleGVkREIgYnkgb3BlbmluZyBhIGR1bW15IGluZGV4ZWREQiBkYXRhYmFzZSBhbmQgcmVqZWN0XHJcbiAqIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIGRhdGFiYXNlIG9wZW4gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAdGhyb3dzIGV4Y2VwdGlvbiBpZiBjdXJyZW50IGJyb3dzZXIvc3cgY29udGV4dCBjYW4ndCBydW4gaWRiLm9wZW4gKGV4OiBTYWZhcmkgaWZyYW1lLCBGaXJlZm94XHJcbiAqIHByaXZhdGUgYnJvd3NpbmcpXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcHJlRXhpc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBEQl9DSEVDS19OQU1FID0gJ3ZhbGlkYXRlLWJyb3dzZXItY29udGV4dC1mb3ItaW5kZXhlZGRiLWFuYWx5dGljcy1tb2R1bGUnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmVFeGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcmVFeGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKChfYSA9IHJlcXVlc3QuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiAgIC8vIFR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcclxuICogICB0eXBlIEVyciA9XHJcbiAqICAgICAndW5rbm93bicgfFxyXG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXHJcbiAqICAgICA7XHJcbiAqXHJcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcclxuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XHJcbiAqICAgdmFyIEVyciA9IHtcclxuICogICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcclxuICogICB9XHJcbiAqXHJcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcclxuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXHJcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcclxuICogICB9O1xyXG4gKlxyXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXHJcbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xyXG4gKlxyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcclxuICogICAuLi5cclxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cclxuICpcclxuICogICBjYXRjaCAoZSkge1xyXG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcclxuICogICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ3NlcnZpY2UvZmlsZS1ub3QtZm91bmQnKSB7XHJcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICovXHJcbmNvbnN0IEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XHJcbi8vIEJhc2VkIG9uIGNvZGUgZnJvbTpcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXHJcbmNsYXNzIEZpcmViYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGNvZGUsIG1lc3NhZ2UsIFxyXG4gICAgLyoqIEN1c3RvbSBkYXRhIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY3VzdG9tRGF0YSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcclxuICAgICAgICAvKiogVGhlIGN1c3RvbSBuYW1lIGZvciBhbGwgRmlyZWJhc2VFcnJvcnMuICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gRVJST1JfTkFNRTtcclxuICAgICAgICAvLyBGaXggRm9yIEVTNVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93bi5cclxuICAgICAgICAvLyBPbmx5IGF2YWlsYWJsZSBvbiBWOC5cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBFcnJvckZhY3Rvcnkge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xyXG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlKGNvZGUsIC4uLmRhdGEpIHtcclxuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcclxuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IGAke3RoaXMuc2VydmljZX0vJHtjb2RlfWA7XHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmVycm9yc1tjb2RlXTtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcclxuICAgICAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXHJcbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xyXG4gICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpIHtcclxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFBBVFRFUk4sIChfLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBgPCR7a2V5fT8+YDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFBBVFRFUk4gPSAvXFx7XFwkKFtefV0rKX0vZztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXHJcbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxyXG4gKi9cclxuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSBKYXZhc2NyaXB0IG9iamVjdCB0byBiZSBzdHJpbmdpZmllZC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcclxuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcclxuICAgICAgICBjbGFpbXMgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKTtcclxuICAgICAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcclxuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XHJcbiAgICAgICAgZGVsZXRlIGNsYWltc1snZCddO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFkZXIsXHJcbiAgICAgICAgY2xhaW1zLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcclxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICBsZXQgdmFsaWRTaW5jZSA9IDAsIHZhbGlkVW50aWwgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IHZhbGlkU2luY2UgKyA4NjQwMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCEhbm93ICYmXHJcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgISF2YWxpZFVudGlsICYmXHJcbiAgICAgICAgbm93ID49IHZhbGlkU2luY2UgJiZcclxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRGb3JtYXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcclxuICAgIHJldHVybiAhIWNsYWltcyAmJiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnMob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVHZXQob2JqLCBrZXkpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gZm4uY2FsbChjb250ZXh0T2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIERlZXAgZXF1YWwgdHdvIG9iamVjdHMuIFN1cHBvcnQgQXJyYXlzIGFuZCBPYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xyXG4gICAgICAgIGlmICghYktleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhUHJvcCA9IGFba107XHJcbiAgICAgICAgY29uc3QgYlByb3AgPSBiW2tdO1xyXG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFQcm9wLCBiUHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhUHJvcCAhPT0gYlByb3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xyXG4gICAgICAgIGlmICghYUtleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVqZWN0cyBpZiB0aGUgZ2l2ZW4gcHJvbWlzZSBkb2Vzbid0IHJlc29sdmUgaW4gdGltZUluTVMgbWlsbGlzZWNvbmRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dChwcm9taXNlLCB0aW1lSW5NUyA9IDIwMDApIHtcclxuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiBkZWZlcnJlZFByb21pc2UucmVqZWN0KCd0aW1lb3V0IScpLCB0aW1lSW5NUyk7XHJcbiAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWRQcm9taXNlLnJlc29sdmUsIGRlZmVycmVkUHJvbWlzZS5yZWplY3QpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxyXG4gKiBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxyXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5c3RyaW5nUGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGFycmF5VmFsID0+IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcclxufVxyXG4vKipcclxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3RcclxuICogKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZ0RlY29kZShxdWVyeXN0cmluZykge1xyXG4gICAgY29uc3Qgb2JqID0ge307XHJcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XHJcbiAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG4vKipcclxuICogRXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIHBhcnQgb2YgYSBVUkwsIGluY2x1ZGluZyB0aGUgbGVhZGluZyBxdWVzdGlvbiBtYXJrIChpZiBwcmVzZW50KS5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcclxuICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xyXG4gICAgaWYgKCFxdWVyeVN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnJhZ21lbnRTdGFydCA9IHVybC5pbmRleE9mKCcjJywgcXVlcnlTdGFydCk7XHJcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cclxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcclxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcclxuICogICBzaGExLnVwZGF0ZShieXRlcyk7XHJcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xyXG4gKlxyXG4gKiBQZXJmb3JtYW5jZTpcclxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcclxuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcclxuICpcclxuICovXHJcbi8qKlxyXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGZpbmFsXHJcbiAqIEBzdHJ1Y3RcclxuICovXHJcbmNsYXNzIFNoYTEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cclxuICAgICAgICAgKiBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhaW5fID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5idWZfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXHJcbiAgICAgICAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLldfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcclxuICAgICAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29tcHJlc3NfKGJ1Ziwgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgVyA9IHRoaXMuV187XHJcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcclxuICAgICAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgYnVnIHRoYXQgdHVybnMgdGhlIHBvc3QtaW5jcmVtZW50ICsrIG9wZXJhdG9yIGludG8gcHJlLWluY3JlbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBwb3N0LWluY3JlbWVudCArKyBpbiB3aGljaCB0aGUgcmVzdWx0IHZhbHVlIGlzIHVzZWQuICBXZSBjYW4gcmV2ZXJ0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXHJcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGNsaWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldF0gPDwgMjQpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcclxuICAgICAgICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNoYWluX1swXTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuY2hhaW5fWzFdO1xyXG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNoYWluX1szXTtcclxuICAgICAgICBsZXQgZSA9IHRoaXMuY2hhaW5fWzRdO1xyXG4gICAgICAgIGxldCBmLCBrO1xyXG4gICAgICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NmVkOWViYTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHhjYTYyYzFkNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICBlID0gZDtcclxuICAgICAgICAgICAgZCA9IGM7XHJcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGIgPSBhO1xyXG4gICAgICAgICAgICBhID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXHJcbiAgICAgICAgaWYgKGJ5dGVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcclxuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcclxuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxyXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxyXG4gICAgICAgICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxyXG4gICAgICAgICAgICAvLyBzcGVlZHVwIG9uIENocm9tZSAyMyBhbmQgfjE1JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYsIGJ1dCByZXF1aXJlcyB0aGF0XHJcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cclxuICAgICAgICAgICAgaWYgKGluYnVmID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gKz0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqIEBvdmVycmlkZSAqL1xyXG4gICAgZGlnZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xyXG4gICAgICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XHJcbiAgICAgICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxyXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkICMgYml0cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xyXG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcclxuICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlnZXN0O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXHJcbiAqIFRoZW5hYmxlKS5cclxuICpcclxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXHJcbiAqICAgICBhcyBhIHByb3h5LlxyXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmUoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xyXG4gICAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcclxufVxyXG4vKipcclxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxyXG4gKiBmdW5jdGlvbi5cclxuICovXHJcbmNsYXNzIE9ic2VydmVyUHJveHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICAgICAqICAgICBhcyBhIHByb3h5LlxyXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgPSAwO1xyXG4gICAgICAgIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxyXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcclxuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcclxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cclxuICAgICAgICB0aGlzLnRhc2tcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBleGVjdXRvcih0aGlzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeWNocm9ub3VzbHkgdG8gdGhlaXJcclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICBsZXQgb2JzZXJ2ZXI7XHJcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cclxuICAgICAgICBpZiAoaW1wbGVtZW50c0FueU1ldGhvZHMobmV4dE9yT2JzZXJ2ZXIsIFtcclxuICAgICAgICAgICAgJ25leHQnLFxyXG4gICAgICAgICAgICAnZXJyb3InLFxyXG4gICAgICAgICAgICAnY29tcGxldGUnXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcclxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXHJcbiAgICAgICAgLy8gZXZlbnQuXHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cclxuICAgIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXHJcbiAgICB1bnN1YnNjcmliZU9uZShpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBjbG9zZWQgYnkgcHJldmlvdXMgZXZlbnQuLi4uanVzdCBlYXQgdGhlIGFkZGl0aW9uYWwgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpbmNlIHNlbmRPbmUgY2FsbHMgYXN5bmNocm9ub3VzbHkgLSB0aGVyZSBpcyBubyBjaGFuY2UgdGhhdFxyXG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xyXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcclxuICAgIC8vIGZ1bmN0aW9uIGhhZCBiZWVuIHF1ZXVlZC5cclxuICAgIHNlbmRPbmUoaSwgZm4pIHtcclxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZShlcnIpIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJveHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIGdhcmJhZ2UgY29sbGVjdCByZWZlcmVuY2VzXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XHJcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gICAgLy8gZG8gbm90aGluZ1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIGZvciBhIHB1YmxpYyBmdW5jdGlvbi5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcclxuICAgIGxldCBhcmdFcnJvcjtcclxuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xyXG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcclxuICAgIH1cclxuICAgIGlmIChhcmdFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcclxuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgYXJnQ291bnQgK1xyXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXHJcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcclxuICAgICAgICAgICAgYXJnRXJyb3IgK1xyXG4gICAgICAgICAgICAnLic7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBhcmdOYW1lIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxyXG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWUsIGFyZ05hbWUpIHtcclxuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZm5OYW1lXHJcbiAqIEBwYXJhbSBhcmd1bWVudE51bWJlclxyXG4gKiBAcGFyYW0gbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSBvcHRpb25hbFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBuYW1lc3BhY2UsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICduYW1lc3BhY2UnKSArICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCBhcmd1bWVudE5hbWUsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5jYWxsYmFjaywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XHJcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXHJcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cclxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXHJcbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xyXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XHJcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxyXG4vLyBwYWlyKS5cclxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XHJcbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgNjU1MzYpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBwKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIHAgKz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cclxuICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcCArPSAzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcclxuICogR2VuZXJhdGVzIGEgbmV3IHV1aWQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IHV1aWR2NCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xyXG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xyXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcclxuICAgIH0pO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcclxuLyoqXHJcbiAqIFRoZSBmYWN0b3IgdG8gYmFja29mZiBieS5cclxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXHJcbiAqXHJcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcclxuICovXHJcbmNvbnN0IE1BWF9WQUxVRV9NSUxMSVMgPSA0ICogNjAgKiA2MCAqIDEwMDA7IC8vIEZvdXIgaG91cnMsIGxpa2UgaU9TIGFuZCBBbmRyb2lkLlxyXG4vKipcclxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cclxuICogU2VlXHJcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xyXG4gKiBmb3IgY29udGV4dC5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgUkFORE9NX0ZBQ1RPUiA9IDAuNTtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2V4cG9uZW50aWFsYmFja29mZi5qcy5cclxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhiYWNrb2ZmQ291bnQsIGludGVydmFsTWlsbGlzID0gREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMsIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SKSB7XHJcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cclxuICAgIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxyXG4gICAgLy8gYW5kIGNvdW50IHRvIHJlc3RvcmUgc3RhdGUuXHJcbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xyXG4gICAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cclxuICAgIC8vIERldmlhdGlvbjogcmFuZG9tRmFjdG9yIGlzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXHJcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cclxuICAgIC8vIERldmlhdGlvbjogY2hhbmdlcyBtdWx0aXBsaWNhdGlvbiBvcmRlciB0byBpbXByb3ZlIHJlYWRhYmlsaXR5LlxyXG4gICAgUkFORE9NX0ZBQ1RPUiAqXHJcbiAgICAgICAgY3VyckJhc2VWYWx1ZSAqXHJcbiAgICAgICAgLy8gQSByYW5kb20gZmxvYXQgKHJvdW5kZWQgdG8gaW50IGJ5IE1hdGgucm91bmQgYWJvdmUpIGluIHRoZSByYW5nZSBbLTEsIDFdLiBEZXRlcm1pbmVzXHJcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXHJcbiAgICAgICAgMik7XHJcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXHJcbiAgICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2l9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xyXG59XHJcbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XHJcbiAgICBpID0gTWF0aC5hYnMoaSk7XHJcbiAgICBjb25zdCBjZW50ID0gaSAlIDEwMDtcclxuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcclxuICAgICAgICByZXR1cm4gJ3RoJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcclxuICAgIGlmIChkZWMgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gJ3N0JztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDIpIHtcclxuICAgICAgICByZXR1cm4gJ25kJztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDMpIHtcclxuICAgICAgICByZXR1cm4gJ3JkJztcclxuICAgIH1cclxuICAgIHJldHVybiAndGgnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XHJcbiAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLl9kZWxlZ2F0ZSkge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9kZWxlZ2F0ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIE92ZXJyaWRpbmcgdGhlIGNvbnN0YW50ICh3ZSBzaG91bGQgYmUgdGhlIG9ubHkgb25lcyBkb2luZyB0aGlzKVxyXG5DT05TVEFOVFMuTk9ERV9DTElFTlQgPSB0cnVlO1xuXG5leHBvcnQgeyBDT05TVEFOVFMsIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yLCBEZWZlcnJlZCwgRXJyb3JGYWN0b3J5LCBGaXJlYmFzZUVycm9yLCBNQVhfVkFMVUVfTUlMTElTLCBSQU5ET01fRkFDVE9SLCBTaGExLCBhcmVDb29raWVzRW5hYmxlZCwgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciwgYXN5bmMsIGJhc2U2NCwgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzLCBjb250YWlucywgY3JlYXRlTW9ja1VzZXJUb2tlbiwgY3JlYXRlU3Vic2NyaWJlLCBkZWNvZGUsIGRlZXBDb3B5LCBkZWVwRXF1YWwsIGRlZXBFeHRlbmQsIGVycm9yUHJlZml4LCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldERlZmF1bHRBcHBDb25maWcsIGdldERlZmF1bHRFbXVsYXRvckhvc3QsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgZ2V0RGVmYXVsdHMsIGdldEV4cGVyaW1lbnRhbFNldHRpbmcsIGdldEdsb2JhbCwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXRVQSwgaXNBZG1pbiwgaXNCcm93c2VyLCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzRWxlY3Ryb24sIGlzRW1wdHksIGlzSUUsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCBpc01vYmlsZUNvcmRvdmEsIGlzTm9kZSwgaXNOb2RlU2RrLCBpc1JlYWN0TmF0aXZlLCBpc1NhZmFyaSwgaXNVV1AsIGlzVmFsaWRGb3JtYXQsIGlzVmFsaWRUaW1lc3RhbXAsIGlzV2ViV29ya2VyLCBpc3N1ZWRBdFRpbWUsIGpzb25FdmFsLCBtYXAsIG9yZGluYWwsIHByb21pc2VXaXRoVGltZW91dCwgcXVlcnlzdHJpbmcsIHF1ZXJ5c3RyaW5nRGVjb2RlLCBzYWZlR2V0LCBzdHJpbmdMZW5ndGgsIHN0cmluZ1RvQnl0ZUFycmF5LCBzdHJpbmdpZnksIHV1aWR2NCwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0LCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCB2YWxpZGF0ZU5hbWVzcGFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   Md5: () => (/* binding */ Md5),\n/* harmony export */   \"default\": () => (/* binding */ bloom_blob_es2018)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar bloom_blob_es2018 = {};\n\n/** @license\nCopyright The Closure Library Authors.\nSPDX-License-Identifier: Apache-2.0\n*/\n\nvar Integer;\nvar Md5;\n(function() {var h;/** @license\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\nfunction k(f,a){function c(){}c.prototype=a.prototype;f.D=a.prototype;f.prototype=new c;f.prototype.constructor=f;f.C=function(d,e,g){for(var b=Array(arguments.length-2),r=2;r<arguments.length;r++)b[r-2]=arguments[r];return a.prototype[e].apply(d,b)};}function l(){this.blockSize=-1;}function m(){this.blockSize=-1;this.blockSize=64;this.g=Array(4);this.B=Array(this.blockSize);this.o=this.h=0;this.s();}k(m,l);m.prototype.s=function(){this.g[0]=1732584193;this.g[1]=4023233417;this.g[2]=2562383102;this.g[3]=271733878;this.o=this.h=0;};\nfunction n(f,a,c){c||(c=0);var d=Array(16);if(\"string\"===typeof a)for(var e=0;16>e;++e)d[e]=a.charCodeAt(c++)|a.charCodeAt(c++)<<8|a.charCodeAt(c++)<<16|a.charCodeAt(c++)<<24;else for(e=0;16>e;++e)d[e]=a[c++]|a[c++]<<8|a[c++]<<16|a[c++]<<24;a=f.g[0];c=f.g[1];e=f.g[2];var g=f.g[3];var b=a+(g^c&(e^g))+d[0]+3614090360&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[1]+3905402710&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[2]+606105819&4294967295;e=g+(b<<17&4294967295|b>>>15);\nb=c+(a^e&(g^a))+d[3]+3250441966&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[4]+4118548399&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[5]+1200080426&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[6]+2821735955&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[7]+4249261313&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[8]+1770035416&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[9]+2336552879&4294967295;g=a+(b<<12&4294967295|\nb>>>20);b=e+(c^g&(a^c))+d[10]+4294925233&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[11]+2304563134&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[12]+1804603682&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[13]+4254626195&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[14]+2792965006&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[15]+1236535329&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(e^g&(c^e))+d[1]+4129170786&4294967295;a=c+(b<<\n5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[6]+3225465664&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[11]+643717713&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[0]+3921069994&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[5]+3593408605&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[10]+38016083&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[15]+3634488961&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[4]+3889429448&4294967295;c=\ne+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[9]+568446438&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[14]+3275163606&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[3]+4107603335&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[8]+1163531501&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[13]+2850285829&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[2]+4243563512&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[7]+1735328473&4294967295;\ne=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[12]+2368359562&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(c^e^g)+d[5]+4294588738&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[8]+2272392833&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[11]+1839030562&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[14]+4259657740&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[1]+2763975236&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[4]+1272893353&4294967295;g=a+(b<<11&4294967295|\nb>>>21);b=e+(g^a^c)+d[7]+4139469664&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[10]+3200236656&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[13]+681279174&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[0]+3936430074&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[3]+3572445317&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[6]+76029189&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[9]+3654602809&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[12]+\n3873151461&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[15]+530742520&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[2]+3299628645&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(e^(c|~g))+d[0]+4096336452&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[7]+1126891415&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[14]+2878612391&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[5]+4237533241&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[12]+1700485571&\n4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[3]+2399980690&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[10]+4293915773&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[1]+2240044497&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[8]+1873313359&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[15]+4264355552&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[6]+2734768916&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[13]+1309151649&\n4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[4]+4149444226&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[11]+3174756917&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[2]+718787259&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[9]+3951481745&4294967295;f.g[0]=f.g[0]+a&4294967295;f.g[1]=f.g[1]+(e+(b<<21&4294967295|b>>>11))&4294967295;f.g[2]=f.g[2]+e&4294967295;f.g[3]=f.g[3]+g&4294967295;}\nm.prototype.u=function(f,a){void 0===a&&(a=f.length);for(var c=a-this.blockSize,d=this.B,e=this.h,g=0;g<a;){if(0==e)for(;g<=c;)n(this,f,g),g+=this.blockSize;if(\"string\"===typeof f)for(;g<a;){if(d[e++]=f.charCodeAt(g++),e==this.blockSize){n(this,d);e=0;break}}else for(;g<a;)if(d[e++]=f[g++],e==this.blockSize){n(this,d);e=0;break}}this.h=e;this.o+=a;};\nm.prototype.v=function(){var f=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);f[0]=128;for(var a=1;a<f.length-8;++a)f[a]=0;var c=8*this.o;for(a=f.length-8;a<f.length;++a)f[a]=c&255,c/=256;this.u(f);f=Array(16);for(a=c=0;4>a;++a)for(var d=0;32>d;d+=8)f[c++]=this.g[a]>>>d&255;return f};function p(f,a){var c=q;return Object.prototype.hasOwnProperty.call(c,f)?c[f]:c[f]=a(f)}function t(f,a){this.h=a;for(var c=[],d=!0,e=f.length-1;0<=e;e--){var g=f[e]|0;d&&g==a||(c[e]=g,d=!1);}this.g=c;}var q={};function u(f){return -128<=f&&128>f?p(f,function(a){return new t([a|0],0>a?-1:0)}):new t([f|0],0>f?-1:0)}function v(f){if(isNaN(f)||!isFinite(f))return w;if(0>f)return x(v(-f));for(var a=[],c=1,d=0;f>=c;d++)a[d]=f/c|0,c*=4294967296;return new t(a,0)}\nfunction y(f,a){if(0==f.length)throw Error(\"number format error: empty string\");a=a||10;if(2>a||36<a)throw Error(\"radix out of range: \"+a);if(\"-\"==f.charAt(0))return x(y(f.substring(1),a));if(0<=f.indexOf(\"-\"))throw Error('number format error: interior \"-\" character');for(var c=v(Math.pow(a,8)),d=w,e=0;e<f.length;e+=8){var g=Math.min(8,f.length-e),b=parseInt(f.substring(e,e+g),a);8>g?(g=v(Math.pow(a,g)),d=d.j(g).add(v(b))):(d=d.j(c),d=d.add(v(b)));}return d}var w=u(0),z=u(1),A=u(16777216);h=t.prototype;\nh.m=function(){if(B(this))return -x(this).m();for(var f=0,a=1,c=0;c<this.g.length;c++){var d=this.i(c);f+=(0<=d?d:4294967296+d)*a;a*=4294967296;}return f};h.toString=function(f){f=f||10;if(2>f||36<f)throw Error(\"radix out of range: \"+f);if(C(this))return \"0\";if(B(this))return \"-\"+x(this).toString(f);for(var a=v(Math.pow(f,6)),c=this,d=\"\";;){var e=D(c,a).g;c=F(c,e.j(a));var g=((0<c.g.length?c.g[0]:c.h)>>>0).toString(f);c=e;if(C(c))return g+d;for(;6>g.length;)g=\"0\"+g;d=g+d;}};\nh.i=function(f){return 0>f?0:f<this.g.length?this.g[f]:this.h};function C(f){if(0!=f.h)return !1;for(var a=0;a<f.g.length;a++)if(0!=f.g[a])return !1;return !0}function B(f){return -1==f.h}h.l=function(f){f=F(this,f);return B(f)?-1:C(f)?0:1};function x(f){for(var a=f.g.length,c=[],d=0;d<a;d++)c[d]=~f.g[d];return (new t(c,~f.h)).add(z)}h.abs=function(){return B(this)?x(this):this};\nh.add=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0,e=0;e<=a;e++){var g=d+(this.i(e)&65535)+(f.i(e)&65535),b=(g>>>16)+(this.i(e)>>>16)+(f.i(e)>>>16);d=b>>>16;g&=65535;b&=65535;c[e]=b<<16|g;}return new t(c,c[c.length-1]&-2147483648?-1:0)};function F(f,a){return f.add(x(a))}\nh.j=function(f){if(C(this)||C(f))return w;if(B(this))return B(f)?x(this).j(x(f)):x(x(this).j(f));if(B(f))return x(this.j(x(f)));if(0>this.l(A)&&0>f.l(A))return v(this.m()*f.m());for(var a=this.g.length+f.g.length,c=[],d=0;d<2*a;d++)c[d]=0;for(d=0;d<this.g.length;d++)for(var e=0;e<f.g.length;e++){var g=this.i(d)>>>16,b=this.i(d)&65535,r=f.i(e)>>>16,E=f.i(e)&65535;c[2*d+2*e]+=b*E;G(c,2*d+2*e);c[2*d+2*e+1]+=g*E;G(c,2*d+2*e+1);c[2*d+2*e+1]+=b*r;G(c,2*d+2*e+1);c[2*d+2*e+2]+=g*r;G(c,2*d+2*e+2);}for(d=0;d<\na;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=a;d<2*a;d++)c[d]=0;return new t(c,0)};function G(f,a){for(;(f[a]&65535)!=f[a];)f[a+1]+=f[a]>>>16,f[a]&=65535,a++;}function H(f,a){this.g=f;this.h=a;}\nfunction D(f,a){if(C(a))throw Error(\"division by zero\");if(C(f))return new H(w,w);if(B(f))return a=D(x(f),a),new H(x(a.g),x(a.h));if(B(a))return a=D(f,x(a)),new H(x(a.g),a.h);if(30<f.g.length){if(B(f)||B(a))throw Error(\"slowDivide_ only works with positive integers.\");for(var c=z,d=a;0>=d.l(f);)c=I(c),d=I(d);var e=J(c,1),g=J(d,1);d=J(d,2);for(c=J(c,2);!C(d);){var b=g.add(d);0>=b.l(f)&&(e=e.add(c),g=b);d=J(d,1);c=J(c,1);}a=F(f,e.j(a));return new H(e,a)}for(e=w;0<=f.l(a);){c=Math.max(1,Math.floor(f.m()/\na.m()));d=Math.ceil(Math.log(c)/Math.LN2);d=48>=d?1:Math.pow(2,d-48);g=v(c);for(b=g.j(a);B(b)||0<b.l(f);)c-=d,g=v(c),b=g.j(a);C(g)&&(g=z);e=e.add(g);f=F(f,b);}return new H(e,f)}h.A=function(f){return D(this,f).h};h.and=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)&f.i(d);return new t(c,this.h&f.h)};h.or=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)|f.i(d);return new t(c,this.h|f.h)};\nh.xor=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)^f.i(d);return new t(c,this.h^f.h)};function I(f){for(var a=f.g.length+1,c=[],d=0;d<a;d++)c[d]=f.i(d)<<1|f.i(d-1)>>>31;return new t(c,f.h)}function J(f,a){var c=a>>5;a%=32;for(var d=f.g.length-c,e=[],g=0;g<d;g++)e[g]=0<a?f.i(g+c)>>>a|f.i(g+c+1)<<32-a:f.i(g+c);return new t(e,f.h)}m.prototype.digest=m.prototype.v;m.prototype.reset=m.prototype.s;m.prototype.update=m.prototype.u;Md5 = bloom_blob_es2018.Md5=m;t.prototype.add=t.prototype.add;t.prototype.multiply=t.prototype.j;t.prototype.modulo=t.prototype.A;t.prototype.compare=t.prototype.l;t.prototype.toNumber=t.prototype.m;t.prototype.toString=t.prototype.toString;t.prototype.getBits=t.prototype.i;t.fromNumber=v;t.fromString=y;Integer = bloom_blob_es2018.Integer=t;}).apply( typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self  : typeof window !== 'undefined' ? window  : {});\n\n\n//# sourceMappingURL=bloom_blob_es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9kaXN0L2Jsb29tLWJsb2IvZXNtL2Jsb29tX2Jsb2JfZXMyMDE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLHdCQUF3QixnQkFBZ0Isa0JBQWtCLDBCQUEwQixvQkFBb0Isd0NBQXdDLG1CQUFtQix3QkFBd0IsbUNBQW1DLGFBQWEsbUJBQW1CLGFBQWEsa0JBQWtCLGtCQUFrQixnQkFBZ0IsNkJBQTZCLGdCQUFnQixVQUFVLE9BQU8seUJBQXlCLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQjtBQUN2Z0Isa0JBQWtCLFNBQVMsZ0JBQWdCLG1DQUFtQyxLQUFLLDRGQUE0RixhQUFhLEtBQUssZ0RBQWdELFNBQVMsU0FBUyxTQUFTLGFBQWEsK0NBQStDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDBDQUEwQztBQUN4ZCwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDZCQUE2QiwyQ0FBMkM7QUFDL2QsUUFBUSw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsNENBQTRDLDZCQUE2Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsNENBQTRDLDhCQUE4QiwyQ0FBMkM7QUFDOWUscUJBQXFCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMENBQTBDLDZCQUE2Qiw0Q0FBNEMsOEJBQThCLDJDQUEyQztBQUNuZiw0QkFBNEIsMENBQTBDLDZCQUE2Qiw0Q0FBNEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4Qiw0Q0FBNEMsNkJBQTZCLDJDQUEyQyw2QkFBNkI7QUFDL2MsOEJBQThCLDRDQUE0Qyw4QkFBOEIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMsOEJBQThCLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCLHVDQUF1QztBQUN2ZSxRQUFRLHVDQUF1Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCLHVDQUF1Qyw4QkFBOEIsdUNBQXVDLDhCQUE4QixxQ0FBcUMsNkJBQTZCLHVDQUF1Qyw2QkFBNkI7QUFDdGUsc0JBQXNCLDhCQUE4Qix1Q0FBdUMsOEJBQThCLHVDQUF1Qyw2QkFBNkIsMENBQTBDLDZCQUE2QiwwQ0FBMEMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QjtBQUM3ZCxXQUFXLDZCQUE2QiwwQ0FBMEMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QjtBQUN6ZCxXQUFXLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIseUNBQXlDLDhCQUE4QiwwQ0FBMEMsMkJBQTJCLHVEQUF1RCwyQkFBMkI7QUFDdlosNEJBQTRCLHlCQUF5QixpREFBaUQsSUFBSSxFQUFFLGFBQWEsS0FBSywrQkFBK0IsNEJBQTRCLElBQUksRUFBRSwrQ0FBK0MsVUFBVSxJQUFJLE9BQU8sVUFBVSxJQUFJLHFDQUFxQyxVQUFVLElBQUksT0FBTyxTQUFTO0FBQ3BWLHlCQUF5QixnRUFBZ0UsU0FBUyxZQUFZLGFBQWEsV0FBVyxlQUFlLGlCQUFpQixXQUFXLHNCQUFzQixVQUFVLFlBQVksVUFBVSxJQUFJLGdCQUFnQixLQUFLLDhCQUE4QixVQUFVLGdCQUFnQixRQUFRLGdFQUFnRSxnQkFBZ0IsU0FBUywrQkFBK0IsS0FBSyxLQUFLLGFBQWEsd0JBQXdCLFVBQVUsU0FBUyxjQUFjLHNDQUFzQyw2QkFBNkIsd0JBQXdCLGNBQWMsbUNBQW1DLHVCQUF1QixxQkFBcUIsS0FBSyw2QkFBNkI7QUFDbHVCLGdCQUFnQixnRUFBZ0UsUUFBUSxtREFBbUQsa0RBQWtELGdGQUFnRixtQ0FBbUMsV0FBVyxNQUFNLDhEQUE4RCxzRUFBc0UsU0FBUyxnQ0FBZ0M7QUFDOWUsZUFBZSwrQkFBK0Isb0JBQW9CLGdCQUFnQixLQUFLLGdCQUFnQiwyQkFBMkIsZUFBZSxVQUFVLHVCQUF1QixRQUFRLG1EQUFtRCxzQkFBc0IsMENBQTBDLHdDQUF3QyxFQUFFLGVBQWUsY0FBYyxrREFBa0QsSUFBSSxtQkFBbUIsS0FBSyxXQUFXLFNBQVM7QUFDdGQsZ0JBQWdCLCtDQUErQyxjQUFjLG9CQUFvQixZQUFZLGFBQWEsMkJBQTJCLFVBQVUsY0FBYyxlQUFlLGdCQUFnQixZQUFZLHlCQUF5QixjQUFjLDhCQUE4QixJQUFJLGlCQUFpQiw4QkFBOEIsaUJBQWlCO0FBQ2pXLGtCQUFrQiwwREFBMEQsS0FBSyxLQUFLLG1GQUFtRixTQUFTLFNBQVMsU0FBUyxjQUFjLGdEQUFnRCxnQkFBZ0I7QUFDbFIsZ0JBQWdCLDBCQUEwQix1REFBdUQsK0JBQStCLGtEQUFrRCw0Q0FBNEMsTUFBTSxXQUFXLFFBQVEsZ0JBQWdCLGdCQUFnQixhQUFhLEtBQUssb0VBQW9FLGdCQUFnQixhQUFhLGtCQUFrQixlQUFlLGtCQUFrQixlQUFlLGtCQUFrQixnQkFBZ0IsUUFBUTtBQUN0ZixFQUFFLDZCQUE2QixRQUFRLE1BQU0sV0FBVyxtQkFBbUIsZ0JBQWdCLEtBQUssbUJBQW1CLG9DQUFvQyxnQkFBZ0IsU0FBUztBQUNoTCxnQkFBZ0Isd0NBQXdDLDBCQUEwQixnREFBZ0QsNkNBQTZDLGtCQUFrQiw0RUFBNEUsZ0JBQWdCLFVBQVUsZUFBZSxzQkFBc0IsU0FBUyxhQUFhLE1BQU0sRUFBRSxlQUFlLDRCQUE0QixTQUFTLFVBQVUsY0FBYyxrQkFBa0IsUUFBUSxVQUFVLEVBQUU7QUFDNWQsUUFBUSxrQ0FBa0MsMkJBQTJCLE9BQU8sYUFBYSxlQUFlLHNCQUFzQixZQUFZLFdBQVcsVUFBVSxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0Isc0RBQXNELElBQUksMEJBQTBCLDRCQUE0QixpQkFBaUIsc0RBQXNELElBQUksMEJBQTBCO0FBQzViLGtCQUFrQixzREFBc0QsSUFBSSwwQkFBMEIsNEJBQTRCLGNBQWMsZ0NBQWdDLElBQUksaUNBQWlDLG9CQUFvQixnQkFBZ0IsV0FBVyxNQUFNLGdDQUFnQyxJQUFJLG9EQUFvRCxvQkFBb0IsaUNBQWlDLGdDQUFnQyxpQ0FBaUMsOEJBQThCLGdDQUFnQyxtQ0FBbUMsaUNBQWlDLGtDQUFrQyxtQ0FBbUMsMENBQTBDLGtDQUFrQyxlQUFlLGVBQWUsdUNBQXVDLG9KQUFvSjs7QUFFOTRCO0FBQ3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52ZW50b3J5X21hbmFnbWVudC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvd2ViY2hhbm5lbC13cmFwcGVyL2Rpc3QvYmxvb20tYmxvYi9lc20vYmxvb21fYmxvYl9lczIwMTguanM/YzNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGJsb29tX2Jsb2JfZXMyMDE4ID0ge307XG5cbi8qKiBAbGljZW5zZVxuQ29weXJpZ2h0IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy5cblNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4qL1xuXG52YXIgSW50ZWdlcjtcbnZhciBNZDU7XG4oZnVuY3Rpb24oKSB7dmFyIGg7LyoqIEBsaWNlbnNlXG5cbiBDb3B5cmlnaHQgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLlxuIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4qL1xuZnVuY3Rpb24gayhmLGEpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9YS5wcm90b3R5cGU7Zi5EPWEucHJvdG90eXBlO2YucHJvdG90eXBlPW5ldyBjO2YucHJvdG90eXBlLmNvbnN0cnVjdG9yPWY7Zi5DPWZ1bmN0aW9uKGQsZSxnKXtmb3IodmFyIGI9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0yKSxyPTI7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyliW3ItMl09YXJndW1lbnRzW3JdO3JldHVybiBhLnByb3RvdHlwZVtlXS5hcHBseShkLGIpfTt9ZnVuY3Rpb24gbCgpe3RoaXMuYmxvY2tTaXplPS0xO31mdW5jdGlvbiBtKCl7dGhpcy5ibG9ja1NpemU9LTE7dGhpcy5ibG9ja1NpemU9NjQ7dGhpcy5nPUFycmF5KDQpO3RoaXMuQj1BcnJheSh0aGlzLmJsb2NrU2l6ZSk7dGhpcy5vPXRoaXMuaD0wO3RoaXMucygpO31rKG0sbCk7bS5wcm90b3R5cGUucz1mdW5jdGlvbigpe3RoaXMuZ1swXT0xNzMyNTg0MTkzO3RoaXMuZ1sxXT00MDIzMjMzNDE3O3RoaXMuZ1syXT0yNTYyMzgzMTAyO3RoaXMuZ1szXT0yNzE3MzM4Nzg7dGhpcy5vPXRoaXMuaD0wO307XG5mdW5jdGlvbiBuKGYsYSxjKXtjfHwoYz0wKTt2YXIgZD1BcnJheSgxNik7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWZvcih2YXIgZT0wOzE2PmU7KytlKWRbZV09YS5jaGFyQ29kZUF0KGMrKyl8YS5jaGFyQ29kZUF0KGMrKyk8PDh8YS5jaGFyQ29kZUF0KGMrKyk8PDE2fGEuY2hhckNvZGVBdChjKyspPDwyNDtlbHNlIGZvcihlPTA7MTY+ZTsrK2UpZFtlXT1hW2MrK118YVtjKytdPDw4fGFbYysrXTw8MTZ8YVtjKytdPDwyNDthPWYuZ1swXTtjPWYuZ1sxXTtlPWYuZ1syXTt2YXIgZz1mLmdbM107dmFyIGI9YSsoZ15jJihlXmcpKStkWzBdKzM2MTQwOTAzNjAmNDI5NDk2NzI5NTthPWMrKGI8PDcmNDI5NDk2NzI5NXxiPj4+MjUpO2I9ZysoZV5hJihjXmUpKStkWzFdKzM5MDU0MDI3MTAmNDI5NDk2NzI5NTtnPWErKGI8PDEyJjQyOTQ5NjcyOTV8Yj4+PjIwKTtiPWUrKGNeZyYoYV5jKSkrZFsyXSs2MDYxMDU4MTkmNDI5NDk2NzI5NTtlPWcrKGI8PDE3JjQyOTQ5NjcyOTV8Yj4+PjE1KTtcbmI9YysoYV5lJihnXmEpKStkWzNdKzMyNTA0NDE5NjYmNDI5NDk2NzI5NTtjPWUrKGI8PDIyJjQyOTQ5NjcyOTV8Yj4+PjEwKTtiPWErKGdeYyYoZV5nKSkrZFs0XSs0MTE4NTQ4Mzk5JjQyOTQ5NjcyOTU7YT1jKyhiPDw3JjQyOTQ5NjcyOTV8Yj4+PjI1KTtiPWcrKGVeYSYoY15lKSkrZFs1XSsxMjAwMDgwNDI2JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMiY0Mjk0OTY3Mjk1fGI+Pj4yMCk7Yj1lKyhjXmcmKGFeYykpK2RbNl0rMjgyMTczNTk1NSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTcmNDI5NDk2NzI5NXxiPj4+MTUpO2I9YysoYV5lJihnXmEpKStkWzddKzQyNDkyNjEzMTMmNDI5NDk2NzI5NTtjPWUrKGI8PDIyJjQyOTQ5NjcyOTV8Yj4+PjEwKTtiPWErKGdeYyYoZV5nKSkrZFs4XSsxNzcwMDM1NDE2JjQyOTQ5NjcyOTU7YT1jKyhiPDw3JjQyOTQ5NjcyOTV8Yj4+PjI1KTtiPWcrKGVeYSYoY15lKSkrZFs5XSsyMzM2NTUyODc5JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMiY0Mjk0OTY3Mjk1fFxuYj4+PjIwKTtiPWUrKGNeZyYoYV5jKSkrZFsxMF0rNDI5NDkyNTIzMyY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTcmNDI5NDk2NzI5NXxiPj4+MTUpO2I9YysoYV5lJihnXmEpKStkWzExXSsyMzA0NTYzMTM0JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMiY0Mjk0OTY3Mjk1fGI+Pj4xMCk7Yj1hKyhnXmMmKGVeZykpK2RbMTJdKzE4MDQ2MDM2ODImNDI5NDk2NzI5NTthPWMrKGI8PDcmNDI5NDk2NzI5NXxiPj4+MjUpO2I9ZysoZV5hJihjXmUpKStkWzEzXSs0MjU0NjI2MTk1JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMiY0Mjk0OTY3Mjk1fGI+Pj4yMCk7Yj1lKyhjXmcmKGFeYykpK2RbMTRdKzI3OTI5NjUwMDYmNDI5NDk2NzI5NTtlPWcrKGI8PDE3JjQyOTQ5NjcyOTV8Yj4+PjE1KTtiPWMrKGFeZSYoZ15hKSkrZFsxNV0rMTIzNjUzNTMyOSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjImNDI5NDk2NzI5NXxiPj4+MTApO2I9YSsoZV5nJihjXmUpKStkWzFdKzQxMjkxNzA3ODYmNDI5NDk2NzI5NTthPWMrKGI8PFxuNSY0Mjk0OTY3Mjk1fGI+Pj4yNyk7Yj1nKyhjXmUmKGFeYykpK2RbNl0rMzIyNTQ2NTY2NCY0Mjk0OTY3Mjk1O2c9YSsoYjw8OSY0Mjk0OTY3Mjk1fGI+Pj4yMyk7Yj1lKyhhXmMmKGdeYSkpK2RbMTFdKzY0MzcxNzcxMyY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTQmNDI5NDk2NzI5NXxiPj4+MTgpO2I9YysoZ15hJihlXmcpKStkWzBdKzM5MjEwNjk5OTQmNDI5NDk2NzI5NTtjPWUrKGI8PDIwJjQyOTQ5NjcyOTV8Yj4+PjEyKTtiPWErKGVeZyYoY15lKSkrZFs1XSszNTkzNDA4NjA1JjQyOTQ5NjcyOTU7YT1jKyhiPDw1JjQyOTQ5NjcyOTV8Yj4+PjI3KTtiPWcrKGNeZSYoYV5jKSkrZFsxMF0rMzgwMTYwODMmNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzE1XSszNjM0NDg4OTYxJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNCY0Mjk0OTY3Mjk1fGI+Pj4xOCk7Yj1jKyhnXmEmKGVeZykpK2RbNF0rMzg4OTQyOTQ0OCY0Mjk0OTY3Mjk1O2M9XG5lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhlXmcmKGNeZSkpK2RbOV0rNTY4NDQ2NDM4JjQyOTQ5NjcyOTU7YT1jKyhiPDw1JjQyOTQ5NjcyOTV8Yj4+PjI3KTtiPWcrKGNeZSYoYV5jKSkrZFsxNF0rMzI3NTE2MzYwNiY0Mjk0OTY3Mjk1O2c9YSsoYjw8OSY0Mjk0OTY3Mjk1fGI+Pj4yMyk7Yj1lKyhhXmMmKGdeYSkpK2RbM10rNDEwNzYwMzMzNSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTQmNDI5NDk2NzI5NXxiPj4+MTgpO2I9YysoZ15hJihlXmcpKStkWzhdKzExNjM1MzE1MDEmNDI5NDk2NzI5NTtjPWUrKGI8PDIwJjQyOTQ5NjcyOTV8Yj4+PjEyKTtiPWErKGVeZyYoY15lKSkrZFsxM10rMjg1MDI4NTgyOSY0Mjk0OTY3Mjk1O2E9YysoYjw8NSY0Mjk0OTY3Mjk1fGI+Pj4yNyk7Yj1nKyhjXmUmKGFeYykpK2RbMl0rNDI0MzU2MzUxMiY0Mjk0OTY3Mjk1O2c9YSsoYjw8OSY0Mjk0OTY3Mjk1fGI+Pj4yMyk7Yj1lKyhhXmMmKGdeYSkpK2RbN10rMTczNTMyODQ3MyY0Mjk0OTY3Mjk1O1xuZT1nKyhiPDwxNCY0Mjk0OTY3Mjk1fGI+Pj4xOCk7Yj1jKyhnXmEmKGVeZykpK2RbMTJdKzIzNjgzNTk1NjImNDI5NDk2NzI5NTtjPWUrKGI8PDIwJjQyOTQ5NjcyOTV8Yj4+PjEyKTtiPWErKGNeZV5nKStkWzVdKzQyOTQ1ODg3MzgmNDI5NDk2NzI5NTthPWMrKGI8PDQmNDI5NDk2NzI5NXxiPj4+MjgpO2I9ZysoYV5jXmUpK2RbOF0rMjI3MjM5MjgzMyY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTEmNDI5NDk2NzI5NXxiPj4+MjEpO2I9ZSsoZ15hXmMpK2RbMTFdKzE4MzkwMzA1NjImNDI5NDk2NzI5NTtlPWcrKGI8PDE2JjQyOTQ5NjcyOTV8Yj4+PjE2KTtiPWMrKGVeZ15hKStkWzE0XSs0MjU5NjU3NzQwJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMyY0Mjk0OTY3Mjk1fGI+Pj45KTtiPWErKGNeZV5nKStkWzFdKzI3NjM5NzUyMzYmNDI5NDk2NzI5NTthPWMrKGI8PDQmNDI5NDk2NzI5NXxiPj4+MjgpO2I9ZysoYV5jXmUpK2RbNF0rMTI3Mjg5MzM1MyY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTEmNDI5NDk2NzI5NXxcbmI+Pj4yMSk7Yj1lKyhnXmFeYykrZFs3XSs0MTM5NDY5NjY0JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNiY0Mjk0OTY3Mjk1fGI+Pj4xNik7Yj1jKyhlXmdeYSkrZFsxMF0rMzIwMDIzNjY1NiY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjMmNDI5NDk2NzI5NXxiPj4+OSk7Yj1hKyhjXmVeZykrZFsxM10rNjgxMjc5MTc0JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzBdKzM5MzY0MzAwNzQmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8Yj4+PjIxKTtiPWUrKGdeYV5jKStkWzNdKzM1NzI0NDUzMTcmNDI5NDk2NzI5NTtlPWcrKGI8PDE2JjQyOTQ5NjcyOTV8Yj4+PjE2KTtiPWMrKGVeZ15hKStkWzZdKzc2MDI5MTg5JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMyY0Mjk0OTY3Mjk1fGI+Pj45KTtiPWErKGNeZV5nKStkWzldKzM2NTQ2MDI4MDkmNDI5NDk2NzI5NTthPWMrKGI8PDQmNDI5NDk2NzI5NXxiPj4+MjgpO2I9ZysoYV5jXmUpK2RbMTJdK1xuMzg3MzE1MTQ2MSY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTEmNDI5NDk2NzI5NXxiPj4+MjEpO2I9ZSsoZ15hXmMpK2RbMTVdKzUzMDc0MjUyMCY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTYmNDI5NDk2NzI5NXxiPj4+MTYpO2I9YysoZV5nXmEpK2RbMl0rMzI5OTYyODY0NSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjMmNDI5NDk2NzI5NXxiPj4+OSk7Yj1hKyhlXihjfH5nKSkrZFswXSs0MDk2MzM2NDUyJjQyOTQ5NjcyOTU7YT1jKyhiPDw2JjQyOTQ5NjcyOTV8Yj4+PjI2KTtiPWcrKGNeKGF8fmUpKStkWzddKzExMjY4OTE0MTUmNDI5NDk2NzI5NTtnPWErKGI8PDEwJjQyOTQ5NjcyOTV8Yj4+PjIyKTtiPWUrKGFeKGd8fmMpKStkWzE0XSsyODc4NjEyMzkxJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNSY0Mjk0OTY3Mjk1fGI+Pj4xNyk7Yj1jKyhnXihlfH5hKSkrZFs1XSs0MjM3NTMzMjQxJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMSY0Mjk0OTY3Mjk1fGI+Pj4xMSk7Yj1hKyhlXihjfH5nKSkrZFsxMl0rMTcwMDQ4NTU3MSZcbjQyOTQ5NjcyOTU7YT1jKyhiPDw2JjQyOTQ5NjcyOTV8Yj4+PjI2KTtiPWcrKGNeKGF8fmUpKStkWzNdKzIzOTk5ODA2OTAmNDI5NDk2NzI5NTtnPWErKGI8PDEwJjQyOTQ5NjcyOTV8Yj4+PjIyKTtiPWUrKGFeKGd8fmMpKStkWzEwXSs0MjkzOTE1NzczJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNSY0Mjk0OTY3Mjk1fGI+Pj4xNyk7Yj1jKyhnXihlfH5hKSkrZFsxXSsyMjQwMDQ0NDk3JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMSY0Mjk0OTY3Mjk1fGI+Pj4xMSk7Yj1hKyhlXihjfH5nKSkrZFs4XSsxODczMzEzMzU5JjQyOTQ5NjcyOTU7YT1jKyhiPDw2JjQyOTQ5NjcyOTV8Yj4+PjI2KTtiPWcrKGNeKGF8fmUpKStkWzE1XSs0MjY0MzU1NTUyJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMCY0Mjk0OTY3Mjk1fGI+Pj4yMik7Yj1lKyhhXihnfH5jKSkrZFs2XSsyNzM0NzY4OTE2JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNSY0Mjk0OTY3Mjk1fGI+Pj4xNyk7Yj1jKyhnXihlfH5hKSkrZFsxM10rMTMwOTE1MTY0OSZcbjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMSY0Mjk0OTY3Mjk1fGI+Pj4xMSk7Yj1hKyhlXihjfH5nKSkrZFs0XSs0MTQ5NDQ0MjI2JjQyOTQ5NjcyOTU7YT1jKyhiPDw2JjQyOTQ5NjcyOTV8Yj4+PjI2KTtiPWcrKGNeKGF8fmUpKStkWzExXSszMTc0NzU2OTE3JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMCY0Mjk0OTY3Mjk1fGI+Pj4yMik7Yj1lKyhhXihnfH5jKSkrZFsyXSs3MTg3ODcyNTkmNDI5NDk2NzI5NTtlPWcrKGI8PDE1JjQyOTQ5NjcyOTV8Yj4+PjE3KTtiPWMrKGdeKGV8fmEpKStkWzldKzM5NTE0ODE3NDUmNDI5NDk2NzI5NTtmLmdbMF09Zi5nWzBdK2EmNDI5NDk2NzI5NTtmLmdbMV09Zi5nWzFdKyhlKyhiPDwyMSY0Mjk0OTY3Mjk1fGI+Pj4xMSkpJjQyOTQ5NjcyOTU7Zi5nWzJdPWYuZ1syXStlJjQyOTQ5NjcyOTU7Zi5nWzNdPWYuZ1szXStnJjQyOTQ5NjcyOTU7fVxubS5wcm90b3R5cGUudT1mdW5jdGlvbihmLGEpe3ZvaWQgMD09PWEmJihhPWYubGVuZ3RoKTtmb3IodmFyIGM9YS10aGlzLmJsb2NrU2l6ZSxkPXRoaXMuQixlPXRoaXMuaCxnPTA7ZzxhOyl7aWYoMD09ZSlmb3IoO2c8PWM7KW4odGhpcyxmLGcpLGcrPXRoaXMuYmxvY2tTaXplO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZilmb3IoO2c8YTspe2lmKGRbZSsrXT1mLmNoYXJDb2RlQXQoZysrKSxlPT10aGlzLmJsb2NrU2l6ZSl7bih0aGlzLGQpO2U9MDticmVha319ZWxzZSBmb3IoO2c8YTspaWYoZFtlKytdPWZbZysrXSxlPT10aGlzLmJsb2NrU2l6ZSl7bih0aGlzLGQpO2U9MDticmVha319dGhpcy5oPWU7dGhpcy5vKz1hO307XG5tLnByb3RvdHlwZS52PWZ1bmN0aW9uKCl7dmFyIGY9QXJyYXkoKDU2PnRoaXMuaD90aGlzLmJsb2NrU2l6ZToyKnRoaXMuYmxvY2tTaXplKS10aGlzLmgpO2ZbMF09MTI4O2Zvcih2YXIgYT0xO2E8Zi5sZW5ndGgtODsrK2EpZlthXT0wO3ZhciBjPTgqdGhpcy5vO2ZvcihhPWYubGVuZ3RoLTg7YTxmLmxlbmd0aDsrK2EpZlthXT1jJjI1NSxjLz0yNTY7dGhpcy51KGYpO2Y9QXJyYXkoMTYpO2ZvcihhPWM9MDs0PmE7KythKWZvcih2YXIgZD0wOzMyPmQ7ZCs9OClmW2MrK109dGhpcy5nW2FdPj4+ZCYyNTU7cmV0dXJuIGZ9O2Z1bmN0aW9uIHAoZixhKXt2YXIgYz1xO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYyxmKT9jW2ZdOmNbZl09YShmKX1mdW5jdGlvbiB0KGYsYSl7dGhpcy5oPWE7Zm9yKHZhciBjPVtdLGQ9ITAsZT1mLmxlbmd0aC0xOzA8PWU7ZS0tKXt2YXIgZz1mW2VdfDA7ZCYmZz09YXx8KGNbZV09ZyxkPSExKTt9dGhpcy5nPWM7fXZhciBxPXt9O2Z1bmN0aW9uIHUoZil7cmV0dXJuIC0xMjg8PWYmJjEyOD5mP3AoZixmdW5jdGlvbihhKXtyZXR1cm4gbmV3IHQoW2F8MF0sMD5hPy0xOjApfSk6bmV3IHQoW2Z8MF0sMD5mPy0xOjApfWZ1bmN0aW9uIHYoZil7aWYoaXNOYU4oZil8fCFpc0Zpbml0ZShmKSlyZXR1cm4gdztpZigwPmYpcmV0dXJuIHgodigtZikpO2Zvcih2YXIgYT1bXSxjPTEsZD0wO2Y+PWM7ZCsrKWFbZF09Zi9jfDAsYyo9NDI5NDk2NzI5NjtyZXR1cm4gbmV3IHQoYSwwKX1cbmZ1bmN0aW9uIHkoZixhKXtpZigwPT1mLmxlbmd0aCl0aHJvdyBFcnJvcihcIm51bWJlciBmb3JtYXQgZXJyb3I6IGVtcHR5IHN0cmluZ1wiKTthPWF8fDEwO2lmKDI+YXx8MzY8YSl0aHJvdyBFcnJvcihcInJhZGl4IG91dCBvZiByYW5nZTogXCIrYSk7aWYoXCItXCI9PWYuY2hhckF0KDApKXJldHVybiB4KHkoZi5zdWJzdHJpbmcoMSksYSkpO2lmKDA8PWYuaW5kZXhPZihcIi1cIikpdGhyb3cgRXJyb3IoJ251bWJlciBmb3JtYXQgZXJyb3I6IGludGVyaW9yIFwiLVwiIGNoYXJhY3RlcicpO2Zvcih2YXIgYz12KE1hdGgucG93KGEsOCkpLGQ9dyxlPTA7ZTxmLmxlbmd0aDtlKz04KXt2YXIgZz1NYXRoLm1pbig4LGYubGVuZ3RoLWUpLGI9cGFyc2VJbnQoZi5zdWJzdHJpbmcoZSxlK2cpLGEpOzg+Zz8oZz12KE1hdGgucG93KGEsZykpLGQ9ZC5qKGcpLmFkZCh2KGIpKSk6KGQ9ZC5qKGMpLGQ9ZC5hZGQodihiKSkpO31yZXR1cm4gZH12YXIgdz11KDApLHo9dSgxKSxBPXUoMTY3NzcyMTYpO2g9dC5wcm90b3R5cGU7XG5oLm09ZnVuY3Rpb24oKXtpZihCKHRoaXMpKXJldHVybiAteCh0aGlzKS5tKCk7Zm9yKHZhciBmPTAsYT0xLGM9MDtjPHRoaXMuZy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmkoYyk7Zis9KDA8PWQ/ZDo0Mjk0OTY3Mjk2K2QpKmE7YSo9NDI5NDk2NzI5Njt9cmV0dXJuIGZ9O2gudG9TdHJpbmc9ZnVuY3Rpb24oZil7Zj1mfHwxMDtpZigyPmZ8fDM2PGYpdGhyb3cgRXJyb3IoXCJyYWRpeCBvdXQgb2YgcmFuZ2U6IFwiK2YpO2lmKEModGhpcykpcmV0dXJuIFwiMFwiO2lmKEIodGhpcykpcmV0dXJuIFwiLVwiK3godGhpcykudG9TdHJpbmcoZik7Zm9yKHZhciBhPXYoTWF0aC5wb3coZiw2KSksYz10aGlzLGQ9XCJcIjs7KXt2YXIgZT1EKGMsYSkuZztjPUYoYyxlLmooYSkpO3ZhciBnPSgoMDxjLmcubGVuZ3RoP2MuZ1swXTpjLmgpPj4+MCkudG9TdHJpbmcoZik7Yz1lO2lmKEMoYykpcmV0dXJuIGcrZDtmb3IoOzY+Zy5sZW5ndGg7KWc9XCIwXCIrZztkPWcrZDt9fTtcbmguaT1mdW5jdGlvbihmKXtyZXR1cm4gMD5mPzA6Zjx0aGlzLmcubGVuZ3RoP3RoaXMuZ1tmXTp0aGlzLmh9O2Z1bmN0aW9uIEMoZil7aWYoMCE9Zi5oKXJldHVybiAhMTtmb3IodmFyIGE9MDthPGYuZy5sZW5ndGg7YSsrKWlmKDAhPWYuZ1thXSlyZXR1cm4gITE7cmV0dXJuICEwfWZ1bmN0aW9uIEIoZil7cmV0dXJuIC0xPT1mLmh9aC5sPWZ1bmN0aW9uKGYpe2Y9Rih0aGlzLGYpO3JldHVybiBCKGYpPy0xOkMoZik/MDoxfTtmdW5jdGlvbiB4KGYpe2Zvcih2YXIgYT1mLmcubGVuZ3RoLGM9W10sZD0wO2Q8YTtkKyspY1tkXT1+Zi5nW2RdO3JldHVybiAobmV3IHQoYyx+Zi5oKSkuYWRkKHopfWguYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcyk/eCh0aGlzKTp0aGlzfTtcbmguYWRkPWZ1bmN0aW9uKGYpe2Zvcih2YXIgYT1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGYuZy5sZW5ndGgpLGM9W10sZD0wLGU9MDtlPD1hO2UrKyl7dmFyIGc9ZCsodGhpcy5pKGUpJjY1NTM1KSsoZi5pKGUpJjY1NTM1KSxiPShnPj4+MTYpKyh0aGlzLmkoZSk+Pj4xNikrKGYuaShlKT4+PjE2KTtkPWI+Pj4xNjtnJj02NTUzNTtiJj02NTUzNTtjW2VdPWI8PDE2fGc7fXJldHVybiBuZXcgdChjLGNbYy5sZW5ndGgtMV0mLTIxNDc0ODM2NDg/LTE6MCl9O2Z1bmN0aW9uIEYoZixhKXtyZXR1cm4gZi5hZGQoeChhKSl9XG5oLmo9ZnVuY3Rpb24oZil7aWYoQyh0aGlzKXx8QyhmKSlyZXR1cm4gdztpZihCKHRoaXMpKXJldHVybiBCKGYpP3godGhpcykuaih4KGYpKTp4KHgodGhpcykuaihmKSk7aWYoQihmKSlyZXR1cm4geCh0aGlzLmooeChmKSkpO2lmKDA+dGhpcy5sKEEpJiYwPmYubChBKSlyZXR1cm4gdih0aGlzLm0oKSpmLm0oKSk7Zm9yKHZhciBhPXRoaXMuZy5sZW5ndGgrZi5nLmxlbmd0aCxjPVtdLGQ9MDtkPDIqYTtkKyspY1tkXT0wO2ZvcihkPTA7ZDx0aGlzLmcubGVuZ3RoO2QrKylmb3IodmFyIGU9MDtlPGYuZy5sZW5ndGg7ZSsrKXt2YXIgZz10aGlzLmkoZCk+Pj4xNixiPXRoaXMuaShkKSY2NTUzNSxyPWYuaShlKT4+PjE2LEU9Zi5pKGUpJjY1NTM1O2NbMipkKzIqZV0rPWIqRTtHKGMsMipkKzIqZSk7Y1syKmQrMiplKzFdKz1nKkU7RyhjLDIqZCsyKmUrMSk7Y1syKmQrMiplKzFdKz1iKnI7RyhjLDIqZCsyKmUrMSk7Y1syKmQrMiplKzJdKz1nKnI7RyhjLDIqZCsyKmUrMik7fWZvcihkPTA7ZDxcbmE7ZCsrKWNbZF09Y1syKmQrMV08PDE2fGNbMipkXTtmb3IoZD1hO2Q8MiphO2QrKyljW2RdPTA7cmV0dXJuIG5ldyB0KGMsMCl9O2Z1bmN0aW9uIEcoZixhKXtmb3IoOyhmW2FdJjY1NTM1KSE9ZlthXTspZlthKzFdKz1mW2FdPj4+MTYsZlthXSY9NjU1MzUsYSsrO31mdW5jdGlvbiBIKGYsYSl7dGhpcy5nPWY7dGhpcy5oPWE7fVxuZnVuY3Rpb24gRChmLGEpe2lmKEMoYSkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO2lmKEMoZikpcmV0dXJuIG5ldyBIKHcsdyk7aWYoQihmKSlyZXR1cm4gYT1EKHgoZiksYSksbmV3IEgoeChhLmcpLHgoYS5oKSk7aWYoQihhKSlyZXR1cm4gYT1EKGYseChhKSksbmV3IEgoeChhLmcpLGEuaCk7aWYoMzA8Zi5nLmxlbmd0aCl7aWYoQihmKXx8QihhKSl0aHJvdyBFcnJvcihcInNsb3dEaXZpZGVfIG9ubHkgd29ya3Mgd2l0aCBwb3NpdGl2ZSBpbnRlZ2Vycy5cIik7Zm9yKHZhciBjPXosZD1hOzA+PWQubChmKTspYz1JKGMpLGQ9SShkKTt2YXIgZT1KKGMsMSksZz1KKGQsMSk7ZD1KKGQsMik7Zm9yKGM9SihjLDIpOyFDKGQpOyl7dmFyIGI9Zy5hZGQoZCk7MD49Yi5sKGYpJiYoZT1lLmFkZChjKSxnPWIpO2Q9SihkLDEpO2M9SihjLDEpO31hPUYoZixlLmooYSkpO3JldHVybiBuZXcgSChlLGEpfWZvcihlPXc7MDw9Zi5sKGEpOyl7Yz1NYXRoLm1heCgxLE1hdGguZmxvb3IoZi5tKCkvXG5hLm0oKSkpO2Q9TWF0aC5jZWlsKE1hdGgubG9nKGMpL01hdGguTE4yKTtkPTQ4Pj1kPzE6TWF0aC5wb3coMixkLTQ4KTtnPXYoYyk7Zm9yKGI9Zy5qKGEpO0IoYil8fDA8Yi5sKGYpOyljLT1kLGc9dihjKSxiPWcuaihhKTtDKGcpJiYoZz16KTtlPWUuYWRkKGcpO2Y9RihmLGIpO31yZXR1cm4gbmV3IEgoZSxmKX1oLkE9ZnVuY3Rpb24oZil7cmV0dXJuIEQodGhpcyxmKS5ofTtoLmFuZD1mdW5jdGlvbihmKXtmb3IodmFyIGE9TWF0aC5tYXgodGhpcy5nLmxlbmd0aCxmLmcubGVuZ3RoKSxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09dGhpcy5pKGQpJmYuaShkKTtyZXR1cm4gbmV3IHQoYyx0aGlzLmgmZi5oKX07aC5vcj1mdW5jdGlvbihmKXtmb3IodmFyIGE9TWF0aC5tYXgodGhpcy5nLmxlbmd0aCxmLmcubGVuZ3RoKSxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09dGhpcy5pKGQpfGYuaShkKTtyZXR1cm4gbmV3IHQoYyx0aGlzLmh8Zi5oKX07XG5oLnhvcj1mdW5jdGlvbihmKXtmb3IodmFyIGE9TWF0aC5tYXgodGhpcy5nLmxlbmd0aCxmLmcubGVuZ3RoKSxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09dGhpcy5pKGQpXmYuaShkKTtyZXR1cm4gbmV3IHQoYyx0aGlzLmheZi5oKX07ZnVuY3Rpb24gSShmKXtmb3IodmFyIGE9Zi5nLmxlbmd0aCsxLGM9W10sZD0wO2Q8YTtkKyspY1tkXT1mLmkoZCk8PDF8Zi5pKGQtMSk+Pj4zMTtyZXR1cm4gbmV3IHQoYyxmLmgpfWZ1bmN0aW9uIEooZixhKXt2YXIgYz1hPj41O2ElPTMyO2Zvcih2YXIgZD1mLmcubGVuZ3RoLWMsZT1bXSxnPTA7ZzxkO2crKyllW2ddPTA8YT9mLmkoZytjKT4+PmF8Zi5pKGcrYysxKTw8MzItYTpmLmkoZytjKTtyZXR1cm4gbmV3IHQoZSxmLmgpfW0ucHJvdG90eXBlLmRpZ2VzdD1tLnByb3RvdHlwZS52O20ucHJvdG90eXBlLnJlc2V0PW0ucHJvdG90eXBlLnM7bS5wcm90b3R5cGUudXBkYXRlPW0ucHJvdG90eXBlLnU7TWQ1ID0gYmxvb21fYmxvYl9lczIwMTguTWQ1PW07dC5wcm90b3R5cGUuYWRkPXQucHJvdG90eXBlLmFkZDt0LnByb3RvdHlwZS5tdWx0aXBseT10LnByb3RvdHlwZS5qO3QucHJvdG90eXBlLm1vZHVsbz10LnByb3RvdHlwZS5BO3QucHJvdG90eXBlLmNvbXBhcmU9dC5wcm90b3R5cGUubDt0LnByb3RvdHlwZS50b051bWJlcj10LnByb3RvdHlwZS5tO3QucHJvdG90eXBlLnRvU3RyaW5nPXQucHJvdG90eXBlLnRvU3RyaW5nO3QucHJvdG90eXBlLmdldEJpdHM9dC5wcm90b3R5cGUuaTt0LmZyb21OdW1iZXI9djt0LmZyb21TdHJpbmc9eTtJbnRlZ2VyID0gYmxvb21fYmxvYl9lczIwMTguSW50ZWdlcj10O30pLmFwcGx5KCB0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gY29tbW9uanNHbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93ICA6IHt9KTtcblxuZXhwb3J0IHsgSW50ZWdlciwgTWQ1LCBibG9vbV9ibG9iX2VzMjAxOCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9vbV9ibG9iX2VzMjAxOC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\n");

/***/ })

};
;